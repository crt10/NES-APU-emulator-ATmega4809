
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Tue Jan 26 23:42:01 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
002818                           noise_adjusted_note: .byte 1 //the resultant note index after the arpeggio macro
                                 
002819                           song_frames: .byte 2
00281b                           song_frame_offset: .byte 2
00281d                           song_size: .byte 2
00281f                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002820                           song_fx_Bxx: .byte 1
002821                           song_fx_Cxx: .byte 1
002822                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002823                           pulse1_pattern: .byte 2
002825                           pulse1_pattern_delay_rows: .byte 1
002826                           pulse1_pattern_delay_frames: .byte 1
002827                           pulse1_pattern_offset: .byte 2
                                 
002829                           pulse1_volume_macro: .byte 2
00282b                           pulse1_volume_macro_offset: .byte 1
00282c                           pulse1_volume_macro_loop: .byte 1
00282d                           pulse1_volume_macro_release: .byte 1
                                 
00282e                           pulse1_arpeggio_macro: .byte 2
002830                           pulse1_arpeggio_macro_offset: .byte 1
002831                           pulse1_arpeggio_macro_loop: .byte 1
002832                           pulse1_arpeggio_macro_release: .byte 1
002833                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002834                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002836                           pulse1_pitch_macro: .byte 2
002838                           pulse1_pitch_macro_offset: .byte 1
002839                           pulse1_pitch_macro_loop: .byte 1
00283a                           pulse1_pitch_macro_release: .byte 1
                                 
00283b                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283c                           pulse1_hi_pitch_macro: .byte 2
00283e                           pulse1_hi_pitch_macro_offset: .byte 1
00283f                           pulse1_hi_pitch_macro_loop: .byte 1
002840                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002841                           pulse1_duty_macro: .byte 2
002843                           pulse1_duty_macro_offset: .byte 1
002844                           pulse1_duty_macro_loop: .byte 1
002845                           pulse1_duty_macro_release: .byte 1
                                 
002846                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002848                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00284a                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284c                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284e                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002850                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002852                           pulse1_fx_3xx_target: .byte 2 //target note period
002854                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002856                           pulse1_fx_3xx_total_offset: .byte 2
002858                           pulse1_fx_4xy_speed: .byte 1
002859                           pulse1_fx_4xy_depth: .byte 1
00285a                           pulse1_fx_4xy_phase: .byte 1
00285b                           pulse1_fx_7xy_speed: .byte 1
00285c                           pulse1_fx_7xy_depth: .byte 1
00285d                           pulse1_fx_7xy_phase: .byte 1
00285e                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285f                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002860                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002861                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002862                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002864                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002865                           pulse1_fx_Qxy_target: .byte 2 //target note period
002867                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002869                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286b                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286c                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286e                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002870                           pulse1_fx_Rxy_total_offset: .byte 2
002872                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002873                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002874                           pulse2_pattern: .byte 2
002876                           pulse2_pattern_delay_rows: .byte 1
002877                           pulse2_pattern_delay_frames: .byte 1
002878                           pulse2_pattern_offset: .byte 2
                                 
00287a                           pulse2_volume_macro: .byte 2
00287c                           pulse2_volume_macro_offset: .byte 1
00287d                           pulse2_volume_macro_loop: .byte 1
00287e                           pulse2_volume_macro_release: .byte 1
                                 
00287f                           pulse2_arpeggio_macro: .byte 2
002881                           pulse2_arpeggio_macro_offset: .byte 1
002882                           pulse2_arpeggio_macro_loop: .byte 1
002883                           pulse2_arpeggio_macro_release: .byte 1
002884                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002885                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002887                           pulse2_pitch_macro: .byte 2
002889                           pulse2_pitch_macro_offset: .byte 1
00288a                           pulse2_pitch_macro_loop: .byte 1
00288b                           pulse2_pitch_macro_release: .byte 1
                                 
00288c                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288d                           pulse2_hi_pitch_macro: .byte 2
00288f                           pulse2_hi_pitch_macro_offset: .byte 1
002890                           pulse2_hi_pitch_macro_loop: .byte 1
002891                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002892                           pulse2_duty_macro: .byte 2
002894                           pulse2_duty_macro_offset: .byte 1
002895                           pulse2_duty_macro_loop: .byte 1
002896                           pulse2_duty_macro_release: .byte 1
                                 
002897                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002899                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289b                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289d                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289f                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a1                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a3                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a5                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a7                           pulse2_fx_3xx_total_offset: .byte 2
0028a9                           pulse2_fx_4xy_speed: .byte 1
0028aa                           pulse2_fx_4xy_depth: .byte 1
0028ab                           pulse2_fx_4xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_speed: .byte 1
0028ad                           pulse2_fx_7xy_depth: .byte 1
0028ae                           pulse2_fx_7xy_phase: .byte 1
0028af                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028b0                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b1                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b2                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b3                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b5                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b6                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b8                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028ba                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028bc                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bd                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028bf                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c1                           pulse2_fx_Rxy_total_offset: .byte 2
0028c3                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c4                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c5                           triangle_pattern: .byte 2
0028c7                           triangle_pattern_delay_rows: .byte 1
0028c8                           triangle_pattern_delay_frames: .byte 1
0028c9                           triangle_pattern_offset: .byte 2
                                 
0028cb                           triangle_volume_macro: .byte 2
0028cd                           triangle_volume_macro_offset: .byte 1
0028ce                           triangle_volume_macro_loop: .byte 1
0028cf                           triangle_volume_macro_release: .byte 1
                                 
0028d0                           triangle_arpeggio_macro: .byte 2
0028d2                           triangle_arpeggio_macro_offset: .byte 1
0028d3                           triangle_arpeggio_macro_loop: .byte 1
0028d4                           triangle_arpeggio_macro_release: .byte 1
0028d5                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d6                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d8                           triangle_pitch_macro: .byte 2
0028da                           triangle_pitch_macro_offset: .byte 1
0028db                           triangle_pitch_macro_loop: .byte 1
0028dc                           triangle_pitch_macro_release: .byte 1
                                 
0028dd                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028de                           triangle_hi_pitch_macro: .byte 2
0028e0                           triangle_hi_pitch_macro_offset: .byte 1
0028e1                           triangle_hi_pitch_macro_loop: .byte 1
0028e2                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e3                           triangle_duty_macro: .byte 2
0028e5                           triangle_duty_macro_offset: .byte 1
0028e6                           triangle_duty_macro_loop: .byte 1
0028e7                           triangle_duty_macro_release: .byte 1
                                 
0028e8                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028ea                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028ec                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028ee                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028f0                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f2                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f4                           triangle_fx_3xx_target: .byte 2 //target note period
0028f6                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f8                           triangle_fx_3xx_total_offset: .byte 2
0028fa                           triangle_fx_4xy_speed: .byte 1
0028fb                           triangle_fx_4xy_depth: .byte 1
0028fc                           triangle_fx_4xy_phase: .byte 1
0028fd                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028fe                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028ff                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002901                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002902                           triangle_fx_Qxy_target: .byte 2 //target note period
002904                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002908                           triangle_fx_Rxy_target_note: .byte 1 //target note index
002909                           triangle_fx_Rxy_target: .byte 2 //target note period
00290b                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290d                           triangle_fx_Rxy_total_offset: .byte 2
00290f                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002910                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002911                           noise_pattern: .byte 2
002913                           noise_pattern_delay_rows: .byte 1
002914                           noise_pattern_delay_frames: .byte 1
002915                           noise_pattern_offset: .byte 2
                                 
002917                           noise_volume_macro: .byte 2
002919                           noise_volume_macro_offset: .byte 1
00291a                           noise_volume_macro_loop: .byte 1
00291b                           noise_volume_macro_release: .byte 1
                                 
00291c                           noise_arpeggio_macro: .byte 2
00291e                           noise_arpeggio_macro_offset: .byte 1
00291f                           noise_arpeggio_macro_loop: .byte 1
002920                           noise_arpeggio_macro_release: .byte 1
002921                           noise_arpeggio_macro_mode: .byte 1
                                 
002922                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002924                           noise_pitch_macro: .byte 2
002926                           noise_pitch_macro_offset: .byte 1
002927                           noise_pitch_macro_loop: .byte 1
002928                           noise_pitch_macro_release: .byte 1
                                 
002929                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00292a                           noise_hi_pitch_macro: .byte 2
00292c                           noise_hi_pitch_macro_offset: .byte 1
00292d                           noise_hi_pitch_macro_loop: .byte 1
00292e                           noise_hi_pitch_macro_release: .byte 1
                                 
00292f                           noise_duty_macro: .byte 2
002931                           noise_duty_macro_offset: .byte 1
002932                           noise_duty_macro_loop: .byte 1
002933                           noise_duty_macro_release: .byte 1
                                 
002934                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002936                           noise_fx_1xx: .byte 1 //refers to the rate in which to subtract the pitch from by the 1xx
002937                           noise_fx_1xx_total: .byte 1 //the total pitch offset for 1xx
002938                           noise_fx_2xx: .byte 1 //refers to the rate in which to add to the pitch by the 2xx
002939                           noise_fx_2xx_total: .byte 1 //the total pitch offset for 2xx
00293a                           noise_fx_4xy_speed: .byte 1
00293b                           noise_fx_4xy_depth: .byte 1
00293c                           noise_fx_4xy_phase: .byte 1
00293d                           noise_fx_4xy_offset: .byte 1
00293e                           noise_fx_7xy_speed: .byte 1
00293f                           noise_fx_7xy_depth: .byte 1
002940                           noise_fx_7xy_phase: .byte 1
002941                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002942                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002943                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002944                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002945                           noise_fx_Pxx_total: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002946                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002947                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002948                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 0ec3                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 134a                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1251                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 125c                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1251                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1273                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 12c0                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 130d                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 1318                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(216): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(218): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(219): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(220): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(221): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(223): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(226): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(227): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(231): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(233): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(234): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(235): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(237): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(240): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(246): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(247): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(249): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(250): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(251): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(258): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(259): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(269): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(270): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
000ec3 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
000ec4 93c0 0034                 	sts CPU_CCP, r28
000ec6 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
000ec7 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
000ec9 2422                      	clr zero
                                 
                                 	//MEMORY
000eca e3c0                      	ldi r28, 0b00110000
000ecb 93c0 2800                 	sts pulse1_param, r28
000ecd e8c0                      	ldi r28, 0b10000000
000ece 93c0 2801                 	sts pulse1_sweep_param, r28
000ed0 efcf                      	ldi r28, 0xFF
000ed1 93c0 2802                 	sts pulse1_timerL, r28
000ed3 93c0 2803                 	sts pulse1_timerH, r28
000ed5 93c0 2804                 	sts pulse1_length, r28
                                 
000ed7 e3c0                      	ldi r28, 0b00110000
000ed8 93c0 2808                 	sts pulse2_param, r28
000eda e8c0                      	ldi r28, 0b10000000
000edb 93c0 2809                 	sts pulse2_sweep_param, r28
000edd efcf                      	ldi r28, 0xFF
000ede 93c0 280a                 	sts pulse2_timerL, r28
000ee0 93c0 280b                 	sts pulse2_timerH, r28
000ee2 93c0 280c                 	sts pulse2_length, r28
                                 
000ee4 efcf                      	ldi r28, 0xFF
000ee5 93c0 2810                 	sts triangle_timerL, r28
000ee7 93c0 2811                 	sts triangle_timerH, r28
                                 
000ee9 e3c0                      	ldi r28, 0b00110000
000eea 93c0 2813                 	sts noise_param, r28
000eec e0cf                      	ldi r28, 0b00001111
000eed 93c0 2814                 	sts noise_period, r28
                                 
000eef e0c2                      	ldi r28, 0x02
000ef0 93c0 281b                 	sts song_frame_offset, r28
000ef2 9220 281c                 	sts song_frame_offset+1, zero
000ef4 efcf                      	ldi r28, 0xFF
000ef5 93c0 2820                 	sts song_fx_Bxx, r28
000ef7 9220 2821                 	sts song_fx_Cxx, zero
000ef9 9220 2822                 	sts song_fx_Dxx, zero
000efb e4ee                      	ldi ZL, LOW(song0_frames << 1)
000efc e0f3                      	ldi ZH, HIGH(song0_frames << 1)
000efd 93e0 2819                 	sts song_frames, ZL
000eff 93f0 281a                 	sts song_frames+1, ZH
000f01 91c5                      	lpm r28, Z+ //load the song size
000f02 91d5                      	lpm r29, Z+
000f03 93c0 281d                 	sts song_size, r28
000f05 93d0 281e                 	sts song_size+1, r29
000f07 9220 281f                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
000f09 91c5                      	lpm r28, Z+
000f0a 91d5                      	lpm r29, Z+
000f0b 0fcc                      	lsl r28
000f0c 1fdd                      	rol r29
000f0d 93c0 2823                 	sts pulse1_pattern, r28
000f0f 93d0 2824                 	sts pulse1_pattern+1, r29
000f11 9220 2825                 	sts pulse1_pattern_delay_rows, zero
000f13 9220 2826                 	sts pulse1_pattern_delay_frames, zero
000f15 9220 2827                 	sts pulse1_pattern_offset, zero
000f17 9220 2828                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
000f19 91c5                      	lpm r28, Z+
000f1a 91d5                      	lpm r29, Z+
000f1b 0fcc                      	lsl r28
000f1c 1fdd                      	rol r29
000f1d 93c0 2874                 	sts pulse2_pattern, r28
000f1f 93d0 2875                 	sts pulse2_pattern+1, r29
000f21 9220 2876                 	sts pulse2_pattern_delay_rows, zero
000f23 9220 2877                 	sts pulse2_pattern_delay_frames, zero
000f25 9220 2878                 	sts pulse2_pattern_offset, zero
000f27 9220 2879                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
000f29 91c5                      	lpm r28, Z+
000f2a 91d5                      	lpm r29, Z+
000f2b 0fcc                      	lsl r28
000f2c 1fdd                      	rol r29
000f2d 93c0 28c5                 	sts triangle_pattern, r28
000f2f 93d0 28c6                 	sts triangle_pattern+1, r29
000f31 9220 28c7                 	sts triangle_pattern_delay_rows, zero
000f33 9220 28c8                 	sts triangle_pattern_delay_frames, zero
000f35 9220 28c9                 	sts triangle_pattern_offset, zero
000f37 9220 28ca                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
000f39 91c5                      	lpm r28, Z+
000f3a 91d5                      	lpm r29, Z+
000f3b 0fcc                      	lsl r28
000f3c 1fdd                      	rol r29
000f3d 93c0 2911                 	sts noise_pattern, r28
000f3f 93d0 2912                 	sts noise_pattern+1, r29
000f41 9220 2913                 	sts noise_pattern_delay_rows, zero
000f43 9220 2914                 	sts noise_pattern_delay_frames, zero
000f45 9220 2915                 	sts noise_pattern_offset, zero
000f47 9220 2916                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
000f49 efcf                      	ldi r28, 0xFF
000f4a 9220 282b                 	sts pulse1_volume_macro_offset, zero
000f4c 93c0 282c                 	sts pulse1_volume_macro_loop, r28
000f4e 93c0 282d                 	sts pulse1_volume_macro_release, r28
000f50 9220 2830                 	sts pulse1_arpeggio_macro_offset, zero
000f52 93c0 2831                 	sts pulse1_arpeggio_macro_loop, r28
000f54 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
000f56 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
000f58 9220 2838                 	sts pulse1_pitch_macro_offset, zero
000f5a 93c0 2839                 	sts pulse1_pitch_macro_loop, r28
000f5c 93c0 283a                 	sts pulse1_pitch_macro_release, r28
000f5e 9220 283e                 	sts pulse1_hi_pitch_macro_offset, zero
000f60 93c0 283f                 	sts pulse1_hi_pitch_macro_loop, r28
000f62 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
000f64 9220 2843                 	sts pulse1_duty_macro_offset, zero
000f66 93c0 2844                 	sts pulse1_duty_macro_loop, r28
000f68 93c0 2845                 	sts pulse1_duty_macro_release, r28
                                 
000f6a 9220 2829                 	sts pulse1_volume_macro, zero
000f6c 9220 282a                 	sts pulse1_volume_macro+1, zero
000f6e 9220 282e                 	sts pulse1_arpeggio_macro, zero
000f70 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
000f72 9220 2834                 	sts pulse1_total_pitch_offset, zero
000f74 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
000f76 9220 2836                 	sts pulse1_pitch_macro, zero
000f78 9220 2837                 	sts pulse1_pitch_macro+1, zero
000f7a 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
000f7c 9220 283c                 	sts pulse1_hi_pitch_macro, zero
000f7e 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
000f80 9220 2841                 	sts pulse1_duty_macro, zero
000f82 9220 2842                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
000f84 e00f                      	ldi pulse1_volume_divider, 0x0F
000f85 9110 2800                 	lds pulse1_volume_decay, pulse1_param
000f87 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
000f88 9190 2800                 	lds pulse_channel_flags, pulse1_param
000f8a 7390                      	andi pulse_channel_flags, 0b00110000
000f8b 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
000f8c 9220 2806                 	sts pulse1_output_volume, zero
000f8e 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
000f90 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
000f91 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
000f92 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
000f93 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
000f95 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
000f96 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
000f97 efcf                      	ldi r28, 0xFF
000f98 9220 2846                 	sts pulse1_fx_0xy_sequence, zero
000f9a 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
000f9c 9220 2848                 	sts pulse1_fx_1xx, zero
000f9e 9220 2849                 	sts pulse1_fx_1xx+1, zero
000fa0 9220 284a                 	sts pulse1_fx_1xx_total, zero
000fa2 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
000fa4 9220 284c                 	sts pulse1_fx_2xx, zero
000fa6 9220 284d                 	sts pulse1_fx_2xx+1, zero
000fa8 9220 284e                 	sts pulse1_fx_2xx_total, zero
000faa 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
000fac 9220 2850                 	sts pulse1_fx_3xx_start, zero
000fae 9220 2851                 	sts pulse1_fx_3xx_start+1, zero
000fb0 9220 2852                 	sts pulse1_fx_3xx_target, zero
000fb2 9220 2853                 	sts pulse1_fx_3xx_target+1, zero
000fb4 9220 2854                 	sts pulse1_fx_3xx_speed, zero
000fb6 9220 2855                 	sts pulse1_fx_3xx_speed+1, zero
000fb8 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
000fba 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
000fbc 9220 2858                 	sts pulse1_fx_4xy_speed, zero
000fbe 9220 2859                 	sts pulse1_fx_4xy_depth, zero
000fc0 9220 285a                 	sts pulse1_fx_4xy_phase, zero
000fc2 9220 285b                 	sts pulse1_fx_7xy_speed, zero
000fc4 9220 285c                 	sts pulse1_fx_7xy_depth, zero
000fc6 9220 285d                 	sts pulse1_fx_7xy_phase, zero
000fc8 9220 285e                 	sts pulse1_fx_7xy_value, zero
000fca 9220 285f                 	sts pulse1_fx_Axy, zero
000fcc 93c0 2860                 	sts pulse1_fx_Gxx_pre, r28
000fce 93c0 2861                 	sts pulse1_fx_Gxx_post, r28
000fd0 9220 2862                 	sts pulse1_fx_Pxx_total, zero
000fd2 9220 2863                 	sts pulse1_fx_Pxx_total+1, zero
000fd4 9220 2864                 	sts pulse1_fx_Qxy_target_note, zero
000fd6 9220 2865                 	sts pulse1_fx_Qxy_target, zero
000fd8 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
000fda 9220 2867                 	sts pulse1_fx_Qxy_speed, zero
000fdc 9220 2868                 	sts pulse1_fx_Qxy_speed+1, zero
000fde 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
000fe0 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
000fe2 9220 286b                 	sts pulse1_fx_Rxy_target_note, zero
000fe4 9220 286c                 	sts pulse1_fx_Rxy_target, zero
000fe6 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
000fe8 9220 286e                 	sts pulse1_fx_Rxy_speed, zero
000fea 9220 286f                 	sts pulse1_fx_Rxy_speed+1, zero
000fec 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
000fee 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
000ff0 93c0 2872                 	sts pulse1_fx_Sxx_pre, r28
000ff2 93c0 2873                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
000ff4 efcf                      	ldi r28, 0xFF
000ff5 9220 287c                 	sts pulse2_volume_macro_offset, zero
000ff7 93c0 287d                 	sts pulse2_volume_macro_loop, r28
000ff9 93c0 287e                 	sts pulse2_volume_macro_release, r28
000ffb 9220 2881                 	sts pulse2_arpeggio_macro_offset, zero
000ffd 93c0 2882                 	sts pulse2_arpeggio_macro_loop, r28
000fff 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
001001 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
001003 9220 2889                 	sts pulse2_pitch_macro_offset, zero
001005 93c0 288a                 	sts pulse2_pitch_macro_loop, r28
001007 93c0 288b                 	sts pulse2_pitch_macro_release, r28
001009 9220 288f                 	sts pulse2_hi_pitch_macro_offset, zero
00100b 93c0 2890                 	sts pulse2_hi_pitch_macro_loop, r28
00100d 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
00100f 9220 2894                 	sts pulse2_duty_macro_offset, zero
001011 93c0 2895                 	sts pulse2_duty_macro_loop, r28
001013 93c0 2896                 	sts pulse2_duty_macro_release, r28
                                 
001015 9220 287a                 	sts pulse2_volume_macro, zero
001017 9220 287b                 	sts pulse2_volume_macro+1, zero
001019 9220 287f                 	sts pulse2_arpeggio_macro, zero
00101b 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
00101d 9220 2885                 	sts pulse2_total_pitch_offset, zero
00101f 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001021 9220 2887                 	sts pulse2_pitch_macro, zero
001023 9220 2888                 	sts pulse2_pitch_macro+1, zero
001025 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
001027 9220 288d                 	sts pulse2_hi_pitch_macro, zero
001029 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
00102b 9220 2892                 	sts pulse2_duty_macro, zero
00102d 9220 2893                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
00102f e02f                      	ldi pulse2_volume_divider, 0x0F
001030 9130 2808                 	lds pulse2_volume_decay, pulse2_param
001032 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
001033 91d0 2808                 	lds r29, pulse2_param
001035 73d0                      	andi r29, 0b00110000
001036 62d0                      	sbr r29, 0b0100000 //set start flag
001037 95d2                      	swap r29
001038 2b9d                      	or pulse_channel_flags, r29
001039 9220 280e                 	sts pulse2_output_volume, zero
00103b 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
00103d 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
00103e e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00103f 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
001040 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
001042 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
001043 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001044 efcf                      	ldi r28, 0xFF
001045 9220 2897                 	sts pulse2_fx_0xy_sequence, zero
001047 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001049 9220 2899                 	sts pulse2_fx_1xx, zero
00104b 9220 289a                 	sts pulse2_fx_1xx+1, zero
00104d 9220 289b                 	sts pulse2_fx_1xx_total, zero
00104f 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
001051 9220 289d                 	sts pulse2_fx_2xx, zero
001053 9220 289e                 	sts pulse2_fx_2xx+1, zero
001055 9220 289f                 	sts pulse2_fx_2xx_total, zero
001057 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
001059 9220 28a1                 	sts pulse2_fx_3xx_start, zero
00105b 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero
00105d 9220 28a3                 	sts pulse2_fx_3xx_target, zero
00105f 9220 28a4                 	sts pulse2_fx_3xx_target+1, zero
001061 9220 28a5                 	sts pulse2_fx_3xx_speed, zero
001063 9220 28a6                 	sts pulse2_fx_3xx_speed+1, zero
001065 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
001067 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001069 9220 28a9                 	sts pulse2_fx_4xy_speed, zero
00106b 9220 28aa                 	sts pulse2_fx_4xy_depth, zero
00106d 9220 28ab                 	sts pulse2_fx_4xy_phase, zero
00106f 9220 28ac                 	sts pulse2_fx_7xy_speed, zero
001071 9220 28ad                 	sts pulse2_fx_7xy_depth, zero
001073 9220 28ae                 	sts pulse2_fx_7xy_phase, zero
001075 9220 28af                 	sts pulse2_fx_7xy_value, zero
001077 9220 28b0                 	sts pulse2_fx_Axy, zero
001079 93c0 28b1                 	sts pulse2_fx_Gxx_pre, r28
00107b 93c0 28b2                 	sts pulse2_fx_Gxx_post, r28
00107d 9220 28b3                 	sts pulse2_fx_Pxx_total, zero
00107f 9220 28b4                 	sts pulse2_fx_Pxx_total+1, zero
001081 9220 28b5                 	sts pulse2_fx_Qxy_target_note, zero
001083 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
001085 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001087 9220 28b8                 	sts pulse2_fx_Qxy_speed, zero
001089 9220 28b9                 	sts pulse2_fx_Qxy_speed+1, zero
00108b 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
00108d 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
00108f 9220 28bc                 	sts pulse2_fx_Rxy_target_note, zero
001091 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001093 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001095 9220 28bf                 	sts pulse2_fx_Rxy_speed, zero
001097 9220 28c0                 	sts pulse2_fx_Rxy_speed+1, zero
001099 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
00109b 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
00109d 93c0 28c3                 	sts pulse2_fx_Sxx_pre, r28
00109f 93c0 28c4                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
0010a1 efcf                      	ldi r28, 0xFF
0010a2 9220 28cd                 	sts triangle_volume_macro_offset, zero
0010a4 93c0 28ce                 	sts triangle_volume_macro_loop, r28
0010a6 93c0 28cf                 	sts triangle_volume_macro_release, r28
0010a8 9220 28d2                 	sts triangle_arpeggio_macro_offset, zero
0010aa 93c0 28d3                 	sts triangle_arpeggio_macro_loop, r28
0010ac 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
0010ae 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
0010b0 9220 28da                 	sts triangle_pitch_macro_offset, zero
0010b2 93c0 28db                 	sts triangle_pitch_macro_loop, r28
0010b4 93c0 28dc                 	sts triangle_pitch_macro_release, r28
0010b6 9220 28e0                 	sts triangle_hi_pitch_macro_offset, zero
0010b8 93c0 28e1                 	sts triangle_hi_pitch_macro_loop, r28
0010ba 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
0010bc 9220 28e5                 	sts triangle_duty_macro_offset, zero
0010be 93c0 28e6                 	sts triangle_duty_macro_loop, r28
0010c0 93c0 28e7                 	sts triangle_duty_macro_release, r28
                                 
0010c2 9220 28cb                 	sts triangle_volume_macro, zero
0010c4 9220 28cc                 	sts triangle_volume_macro+1, zero
0010c6 9220 28d0                 	sts triangle_arpeggio_macro, zero
0010c8 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
0010ca 9220 28d6                 	sts triangle_total_pitch_offset, zero
0010cc 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
0010ce 9220 28d8                 	sts triangle_pitch_macro, zero
0010d0 9220 28d9                 	sts triangle_pitch_macro+1, zero
0010d2 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
0010d4 9220 28de                 	sts triangle_hi_pitch_macro, zero
0010d6 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
0010d8 9220 28e3                 	sts triangle_duty_macro, zero
0010da 9220 28e4                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
0010dc e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
0010dd 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
0010de efcf                      	ldi r28, 0xFF
0010df 9220 28e8                 	sts triangle_fx_0xy_sequence, zero
0010e1 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
0010e3 9220 28ea                 	sts triangle_fx_1xx, zero
0010e5 9220 28eb                 	sts triangle_fx_1xx+1, zero
0010e7 9220 28ec                 	sts triangle_fx_1xx_total, zero
0010e9 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
0010eb 9220 28ee                 	sts triangle_fx_2xx, zero
0010ed 9220 28ef                 	sts triangle_fx_2xx+1, zero
0010ef 9220 28f0                 	sts triangle_fx_2xx_total, zero
0010f1 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
0010f3 9220 28f2                 	sts triangle_fx_3xx_start, zero
0010f5 9220 28f3                 	sts triangle_fx_3xx_start+1, zero
0010f7 9220 28f4                 	sts triangle_fx_3xx_target, zero
0010f9 9220 28f5                 	sts triangle_fx_3xx_target+1, zero
0010fb 9220 28f6                 	sts triangle_fx_3xx_speed, zero
0010fd 9220 28f7                 	sts triangle_fx_3xx_speed+1, zero
0010ff 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
001101 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001103 9220 28fa                 	sts triangle_fx_4xy_speed, zero
001105 9220 28fb                 	sts triangle_fx_4xy_depth, zero
001107 9220 28fc                 	sts triangle_fx_4xy_phase, zero
001109 93c0 28fd                 	sts triangle_fx_Gxx_pre, r28
00110b 93c0 28fe                 	sts triangle_fx_Gxx_post, r28
00110d 9220 28ff                 	sts triangle_fx_Pxx_total, zero
00110f 9220 2900                 	sts triangle_fx_Pxx_total+1, zero
001111 9220 2901                 	sts triangle_fx_Qxy_target_note, zero
001113 9220 2902                 	sts triangle_fx_Qxy_target, zero
001115 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
001117 9220 2904                 	sts triangle_fx_Qxy_speed, zero
001119 9220 2905                 	sts triangle_fx_Qxy_speed+1, zero
00111b 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
00111d 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
00111f 9220 2908                 	sts triangle_fx_Rxy_target_note, zero
001121 9220 2909                 	sts triangle_fx_Rxy_target, zero
001123 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
001125 9220 290b                 	sts triangle_fx_Rxy_speed, zero
001127 9220 290c                 	sts triangle_fx_Rxy_speed+1, zero
001129 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
00112b 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
00112d 93c0 290f                 	sts triangle_fx_Sxx_pre, r28
00112f 93c0 2910                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
001131 efcf                      	ldi r28, 0xFF
001132 9220 2919                 	sts noise_volume_macro_offset, zero
001134 93c0 291a                 	sts noise_volume_macro_loop, r28
001136 93c0 291b                 	sts noise_volume_macro_release, r28
001138 9220 291e                 	sts noise_arpeggio_macro_offset, zero
00113a 93c0 291f                 	sts noise_arpeggio_macro_loop, r28
00113c 93c0 2920                 	sts noise_arpeggio_macro_release, r28
00113e 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
001140 9220 2926                 	sts noise_pitch_macro_offset, zero
001142 93c0 2927                 	sts noise_pitch_macro_loop, r28
001144 93c0 2928                 	sts noise_pitch_macro_release, r28
001146 9220 292c                 	sts noise_hi_pitch_macro_offset, zero
001148 93c0 292d                 	sts noise_hi_pitch_macro_loop, r28
00114a 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
00114c 9220 2931                 	sts noise_duty_macro_offset, zero
00114e 93c0 2932                 	sts noise_duty_macro_loop, r28
001150 93c0 2933                 	sts noise_duty_macro_release, r28
                                 
001152 9220 2917                 	sts noise_volume_macro, zero
001154 9220 2918                 	sts noise_volume_macro+1, zero
001156 9220 291c                 	sts noise_arpeggio_macro, zero
001158 9220 291d                 	sts noise_arpeggio_macro+1, zero
00115a 9220 2922                 	sts noise_total_pitch_offset, zero
00115c 9220 2923                 	sts noise_total_pitch_offset+1, zero
00115e 9220 2924                 	sts noise_pitch_macro, zero
001160 9220 2925                 	sts noise_pitch_macro+1, zero
001162 9220 2929                 	sts noise_total_hi_pitch_offset, zero
001164 9220 292a                 	sts noise_hi_pitch_macro, zero
001166 9220 292b                 	sts noise_hi_pitch_macro+1, zero
001168 9220 292f                 	sts noise_duty_macro, zero
00116a 9220 2930                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
00116c 9220 2816                 	sts noise_output_volume, zero
00116e 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001170 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001171 2f5c                      	mov noise_sequence_LOW, r28
001172 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
001173 efcf                      	ldi r28, 0xFF
001174 9220 2934                 	sts noise_fx_0xy_sequence, zero
001176 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
001178 9220 2936                 	sts noise_fx_1xx, zero
00117a 9220 2937                 	sts noise_fx_1xx_total, zero
00117c 9220 2938                 	sts noise_fx_2xx, zero
00117e 9220 2939                 	sts noise_fx_2xx_total, zero
001180 9220 293a                 	sts noise_fx_4xy_speed, zero
001182 9220 293b                 	sts noise_fx_4xy_depth, zero
001184 9220 293c                 	sts noise_fx_4xy_phase, zero
001186 9220 293d                 	sts noise_fx_4xy_offset, zero
001188 9220 293e                 	sts noise_fx_7xy_speed, zero
00118a 9220 293f                 	sts noise_fx_7xy_depth, zero
00118c 9220 2940                 	sts noise_fx_7xy_phase, zero
00118e 9220 2941                 	sts noise_fx_7xy_value, zero
001190 9220 2942                 	sts noise_fx_Axy, zero
001192 93c0 2943                 	sts noise_fx_Gxx_pre, r28
001194 93c0 2944                 	sts noise_fx_Gxx_post, r28
001196 9220 2945                 	sts noise_fx_Pxx_total, zero
001198 93c0 2946                 	sts noise_fx_Sxx_pre, r28
00119a 93c0 2947                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
00119c efcf                      	ldi r28, 0xFF
00119d b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
00119e e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
00119f 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
0011a1 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0011a2 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
0011a4 e1c5                      	ldi r28, 0x15 //set the period for CMP0
0011a5 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
0011a7 e0c5                      	ldi r28, 0x05
0011a8 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
0011aa e2cb                      	ldi r28, 0x2B //set the period for CMP1
0011ab 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
0011ad e0ca                      	ldi r28, 0x0A
0011ae 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
0011b0 e4c1                      	ldi r28, 0x41 //set the period for CMP2
0011b1 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
0011b3 e0cf                      	ldi r28, 0x0F
0011b4 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
0011b6 e5c7                      	ldi r28, 0x57 //set the period for OVF
0011b7 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
0011b9 e1c4                      	ldi r28, 0x14
0011ba 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
0011bc e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0011bd 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0011bf e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
0011c0 93c0 0a81                 	sts TCB0_CTRLB, r28
0011c2 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
0011c3 93c0 0a85                 	sts TCB0_INTCTRL, r28
0011c5 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
0011c7 93c0 0a8c                 	sts TCB0_CCMPL, r28
0011c9 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
0011cb 93c0 0a8d                 	sts TCB0_CCMPH, r28
0011cd e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0011ce 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
0011d0 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0011d1 93b0 0a91                 	sts TCB1_CTRLB, r27
0011d3 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0011d4 93b0 0a95                 	sts TCB1_INTCTRL, r27
0011d6 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0011d8 93b0 0a9c                 	sts TCB1_CCMPL, r27
0011da 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0011dc 93b0 0a9d                 	sts TCB1_CCMPH, r27
0011de e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0011df 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
0011e1 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0011e2 93b0 0aa1                 	sts TCB2_CTRLB, r27
0011e4 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
0011e5 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
0011e7 93b0 0aac                 	sts TCB2_CCMPL, r27
0011e9 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
0011eb 93b0 0aad                 	sts TCB2_CCMPH, r27
0011ed e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
0011ee 93b0 0aa0                 	sts TCB2_CTRLA, r27
0011f0 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
0011f1 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0011f2 93b0 0ab1                 	sts TCB3_CTRLB, r27
0011f4 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0011f5 93b0 0ab5                 	sts TCB3_INTCTRL, r27
0011f7 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0011f9 93b0 0abc                 	sts TCB3_CCMPL, r27
0011fb 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0011fd 93b0 0abd                 	sts TCB3_CCMPH, r27
0011ff e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001200 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
001202 91c0 2806                 	lds r28, pulse1_output_volume
001204 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
001206 fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
001207 c015                      	rjmp volume_mixer_pulse1_off
                                 
001208 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
001209 f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
00120a 91e0 0a8c                 	lds r30, TCB0_CCMPL
00120c e5f9                      	ldi r31, 0x59
00120d 17ef                      	cp r30, r31
00120e 91e0 0a8d                 	lds r30, TCB0_CCMPH
001210 e0f0                      	ldi r31, 0x00
001211 07ef                      	cpc r30, r31
001212 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $595A
001213 91e0 0a8c                 	lds r30, TCB0_CCMPL
001215 e5fa                      	ldi r31, 0x5A
001216 17ef                      	cp r30, r31
001217 91e0 0a8d                 	lds r30, TCB0_CCMPH
001219 e5f9                      	ldi r31, 0x59
00121a 07ef                      	cpc r30, r31
00121b f408                      	brsh volume_mixer_pulse1_off
00121c c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
00121d 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
00121e fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
00121f c015                      	rjmp volume_mixer_pulse2_off
                                 
001220 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
001221 f099                      	breq volume_mixer_pulse2_off
                                 
001222 91e0 0a9c                 	lds r30, TCB1_CCMPL
001224 e5f9                      	ldi r31, 0x59
001225 17ef                      	cp r30, r31
001226 91e0 0a9d                 	lds r30, TCB1_CCMPH
001228 e0f0                      	ldi r31, 0x00
001229 07ef                      	cpc r30, r31
00122a f050                      	brlo volume_mixer_pulse2_off
                                 
00122b 91e0 0a9c                 	lds r30, TCB1_CCMPL
00122d e5fa                      	ldi r31, 0x5A
00122e 17ef                      	cp r30, r31
00122f 91e0 0a9d                 	lds r30, TCB1_CCMPH
001231 e5f9                      	ldi r31, 0x59
001232 07ef                      	cpc r30, r31
001233 f408                      	brsh volume_mixer_pulse2_off
001234 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001235 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
001236 0fcd                      	add r28, r29
001237 e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
001238 e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
001239 0fec                      	add ZL, r28
00123a 1df2                      	adc ZH, zero
00123b 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
00123c 2fd4                      	mov r29, triangle_sequence
00123d fdd4                      	sbrc r29, 4 //check 5th bit
00123e 95d0                      	com r29
00123f 70df                      	andi r29, 0x0F
001240 2fed                      	mov r30, r29
001241 0fde                      	add r29, r30 //multiply the triangle volume by 3
001242 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
001243 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
001244 c004                      	rjmp volume_mixer_tnd_out
001245 91e0 2816                 	lds r30, noise_output_volume
001247 0fee                      	lsl r30 //multiply noise volume by 2
001248 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
001249 e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
00124a e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
00124b 0fed                      	add ZL, r29
00124c 1df2                      	adc ZH, zero
00124d 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
00124e 0fcd                      	add r28, r29
00124f b9c1                      	out VPORTA_OUT, r28
001250 cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001251 b7bf                      	in r27, CPU_SREG
001252 93bf                      	push r27
001253 94f8                      	cli
                                 
                                 	//ENVELOPE
001254 d053                      	rcall pulse1_envelope_routine
001255 d09f                      	rcall pulse2_envelope_routine
                                 
001256 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
001257 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001259 91bf                      	pop r27
00125a bfbf                      	out CPU_SREG, r27
00125b 9518                      	reti
                                 
                                 sequence_1_3:
00125c b7bf                      	in r27, CPU_SREG
00125d 93bf                      	push r27
00125e 94f8                      	cli
                                 
                                 	//ENVELOPE
00125f d048                      	rcall pulse1_envelope_routine
001260 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001261 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001262 d01b                      	rcall pulse1_sweep_routine
001263 fcf3                      	sbrc pulse2_sweep, 3
001264 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001265 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001266 c002                      	rjmp sequence_1_3_pulse2_length
001267 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001268 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001269 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
00126a c002                      	rjmp sequence_1_3_exit
00126b 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
00126c 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
00126d e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
00126e 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001270 91bf                      	pop r27
001271 bfbf                      	out CPU_SREG, r27
001272 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001273 b7bf                      	in r27, CPU_SREG
001274 93bf                      	push r27
001275 94f8                      	cli
                                 
001276 0caa                      	lsl pulse1_sequence //shifts sequence to the left
001277 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001278 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001279 93b0 0a86                 	sts TCB0_INTFLAGS, r27
00127b 91bf                      	pop r27
00127c bfbf                      	out CPU_SREG, r27
00127d 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00127e 2dbc                      	mov r27, pulse1_sweep
00127f 70b7                      	andi r27, 0x07 //mask for period divider bits
001280 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001281 93df                      	push r29
001282 2ddc                      	mov r29, pulse1_sweep
001283 95d2                      	swap r29
001284 70d7                      	andi r29, 0x07 //mask for shift bits
001285 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001286 91df                      	pop r29
001287 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001288 91a0 0a8c                 	lds r26, TCB0_CCMPL
00128a 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
00128c 95b6                      	lsr r27
00128d 95a7                      	ror r26
00128e 95da                      	dec r29
00128f f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001290 fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
001291 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001292 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001293 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001294 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001296 0fad                      	add r26, r29
001297 91d0 0a8d                 	lds r29, TCB0_CCMPH
001299 1fbd                      	adc r27, r29
                                 
00129a 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00129c 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00129e 91df                      	pop r29
00129f c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
0012a0 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
0012a1 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
0012a2 9508                      	ret
                                 
                                 pulse1_sweep_reload:
0012a3 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0012a5 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
0012a6 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
0012a7 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
0012a8 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
0012a9 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
0012aa 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0012ab f011                      	breq PC+3 //if the divider == 0, check loop flag
0012ac 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0012ad 9508                      	ret
                                 
0012ae 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0012b0 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0012b1 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
0012b2 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0012b3 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0012b4 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
0012b5 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0012b6 f409                      	brne PC+2 //if decay != 0, go decrement
0012b7 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0012b8 951a                      	dec pulse1_volume_decay
0012b9 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0012ba 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
0012bb 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0012bd 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0012be e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0012bf 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
0012c0 b7bf                      	in r27, CPU_SREG
0012c1 93bf                      	push r27
0012c2 94f8                      	cli
                                 
0012c3 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
0012c4 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0012c5 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0012c6 93b0 0a96                 	sts TCB1_INTFLAGS, r27
0012c8 91bf                      	pop r27
0012c9 bfbf                      	out CPU_SREG, r27
0012ca 9518                      	reti
                                 
                                 pulse2_sweep_routine:
0012cb 2dbf                      	mov r27, pulse2_sweep
0012cc 70b7                      	andi r27, 0x07 //mask for period divider bits
0012cd f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0012ce 93df                      	push r29
0012cf 2ddf                      	mov r29, pulse2_sweep
0012d0 95d2                      	swap r29
0012d1 70d7                      	andi r29, 0x07 //mask for shift bits
0012d2 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
0012d3 91df                      	pop r29
0012d4 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
0012d5 91a0 0a9c                 	lds r26, TCB1_CCMPL
0012d7 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
0012d9 95b6                      	lsr r27
0012da 95a7                      	ror r26
0012db 95da                      	dec r29
0012dc f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0012dd fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
0012de c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0012df 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
0012e0 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
0012e1 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
0012e3 0fad                      	add r26, r29
0012e4 91d0 0a9d                 	lds r29, TCB1_CCMPH
0012e6 1fbd                      	adc r27, r29
                                 
0012e7 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
0012e9 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0012eb 91df                      	pop r29
0012ec c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
0012ed 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
0012ee ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0012ef 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0012f0 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0012f2 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
0012f3 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0012f4 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0012f5 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0012f6 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0012f7 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0012f8 f011                      	breq PC+3 //if the divider == 0, check loop flag
0012f9 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0012fa 9508                      	ret
                                 
0012fb 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0012fd 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0012fe ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
0012ff c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001300 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001301 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001302 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
001303 f409                      	brne PC+2 //if decay != 0, go decrement
001304 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001305 953a                      	dec pulse2_volume_decay
001306 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
001307 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
001308 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
00130a 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
00130b e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
00130c 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
00130d b7bf                      	in r27, CPU_SREG
00130e 93bf                      	push r27
00130f 94f8                      	cli
                                 
001310 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
001311 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
001312 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001313 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
001315 91bf                      	pop r27
001316 bfbf                      	out CPU_SREG, r27
001317 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
001318 b7bf                      	in r27, CPU_SREG
001319 93bf                      	push r27
00131a 94f8                      	cli
                                 
00131b 2fa5                      	mov r26, noise_sequence_LOW
00131c fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
00131d c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
00131e 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
00131f 27a5                      	eor r26, noise_sequence_LOW
001320 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001321 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
001322 9566                      	lsr noise_sequence_HIGH
001323 9557                      	ror noise_sequence_LOW
001324 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
001325 9566                      	lsr noise_sequence_HIGH
001326 9557                      	ror noise_sequence_LOW
001327 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
001328 c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
001329 0faa                      	lsl r26
00132a 1faa                      	rol r26
00132b 1faa                      	rol r26 //move the 6th bit to the 0th bit place
00132c 27a5                      	eor r26, noise_sequence_LOW
00132d fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
00132e c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
00132f 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
001330 9566                      	lsr noise_sequence_HIGH
001331 9557                      	ror noise_sequence_LOW
001332 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
001333 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
001334 9566                      	lsr noise_sequence_HIGH
001335 9557                      	ror noise_sequence_LOW
001336 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
001337 c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
001338 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001339 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
00133b 91bf                      	pop r27
00133c bfbf                      	out CPU_SREG, r27
00133d 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
00133e efec                      	ldi ZL, LOW(length << 1)
00133f e5f6                      	ldi ZH, HIGH(length << 1)
001340 0fed                      	add ZL, r29
001341 1df2                      	adc ZH, zero
001342 91d4                      	lpm r29, Z
001343 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001344 e1ec                      	ldi ZL, LOW(sequences << 1)
001345 e5f7                      	ldi ZH, HIGH(sequences << 1)
001346 0fed                      	add ZL, r29
001347 1df2                      	adc ZH, zero
001348 91d4                      	lpm r29, Z
001349 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
00134a b7bf                      	in r27, CPU_SREG
00134b 93bf                      	push r27
00134c 94f8                      	cli
00134d 93cf                      	push r28
00134e 93df                      	push r29
00134f 93ef                      	push r30
001350 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001351 91a0 2820                 	lds r26, song_fx_Bxx
001353 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001354 f4a9                      	brne sound_driver_fx_Bxx_routine
001355 91a0 2821                 	lds r26, song_fx_Cxx
001357 11a2                      	cpse r26, zero
001358 c08b                      	rjmp sound_driver_fx_Cxx_routine
001359 91a0 2822                 	lds r26, song_fx_Dxx
00135b 11a2                      	cpse r26, zero
00135c c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
00135d 91a0 281b                 	lds r26, song_frame_offset
00135f 91b0 281c                 	lds r27, song_frame_offset+1
001361 91c0 281d                 	lds r28, song_size
001363 91d0 281e                 	lds r29, song_size+1
001365 17ac                      	cp r26, r28
001366 07bd                      	cpc r27, r29
001367 f408                      	brsh sound_driver_fx_song_loop
001368 c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
001369 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
00136a 91e0 2819                 	lds ZL, song_frames
00136c 91f0 281a                 	lds ZH, song_frames+1
00136e 27cc                      	clr r28 //initialize r29:r28 to 0
00136f 27dd                      	clr r29
001370 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001371 95aa                      	dec r26
001372 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001373 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001374 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
001375 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
001376 93c0 281b                 	sts song_frame_offset, r28
001378 93d0 281c                 	sts song_frame_offset+1, r29
00137a 0fec                      	add ZL, r28
00137b 1ffd                      	adc ZH, r29
                                 
00137c 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
00137d 91b5                      	lpm r27, Z+
00137e 0faa                      	lsl r26
00137f 1fbb                      	rol r27
001380 93a0 2823                 	sts pulse1_pattern, r26
001382 93b0 2824                 	sts pulse1_pattern+1, r27
001384 91a5                      	lpm r26, Z+
001385 91b5                      	lpm r27, Z+
001386 0faa                      	lsl r26
001387 1fbb                      	rol r27
001388 93a0 2874                 	sts pulse2_pattern, r26
00138a 93b0 2875                 	sts pulse2_pattern+1, r27
00138c 91a5                      	lpm r26, Z+
00138d 91b5                      	lpm r27, Z+
00138e 0faa                      	lsl r26
00138f 1fbb                      	rol r27
001390 93a0 28c5                 	sts triangle_pattern, r26
001392 93b0 28c6                 	sts triangle_pattern+1, r27
001394 91a5                      	lpm r26, Z+
001395 91b5                      	lpm r27, Z+
001396 0faa                      	lsl r26
001397 1fbb                      	rol r27
001398 93a0 2911                 	sts noise_pattern, r26
00139a 93b0 2912                 	sts noise_pattern+1, r27
                                 
00139c 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00139e 9220 2828                 	sts pulse1_pattern_offset+1, zero
0013a0 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0013a2 9220 2826                 	sts pulse1_pattern_delay_frames, zero
0013a4 9220 2878                 	sts pulse2_pattern_offset, zero
0013a6 9220 2879                 	sts pulse2_pattern_offset+1, zero
0013a8 9220 2876                 	sts pulse2_pattern_delay_rows, zero
0013aa 9220 2877                 	sts pulse2_pattern_delay_frames, zero
0013ac 9220 28c9                 	sts triangle_pattern_offset, zero
0013ae 9220 28ca                 	sts triangle_pattern_offset+1, zero
0013b0 9220 28c7                 	sts triangle_pattern_delay_rows, zero
0013b2 9220 28c8                 	sts triangle_pattern_delay_frames, zero
0013b4 9220 2915                 	sts noise_pattern_offset, zero
0013b6 9220 2916                 	sts noise_pattern_offset+1, zero
0013b8 9220 2913                 	sts noise_pattern_delay_rows, zero
0013ba 9220 2914                 	sts noise_pattern_delay_frames, zero
                                 
0013bc efaf                      	ldi r26, 0xFF
0013bd 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0013bf 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
0013c1 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
0013c3 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
0013c5 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
0013c7 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
0013c9 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
0013cb 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
0013cd 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
0013cf 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
0013d1 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
0013d3 93a0 2910                 	sts triangle_fx_Sxx_post, r26
0013d5 93a0 2943                 	sts noise_fx_Gxx_pre, r26
0013d7 93a0 2944                 	sts noise_fx_Gxx_post, r26
0013d9 93a0 2946                 	sts noise_fx_Sxx_pre, r26
0013db 93a0 2947                 	sts noise_fx_Sxx_post, r26
                                 
0013dd 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
0013df 9220 2821                 	sts song_fx_Cxx, zero
0013e1 9220 2822                 	sts song_fx_Dxx, zero
0013e3 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0013e4 91ff                      	pop r31
0013e5 91ef                      	pop r30
0013e6 91df                      	pop r29
0013e7 91cf                      	pop r28
0013e8 91bf                      	pop r27
0013e9 bfbf                      	out CPU_SREG, r27
0013ea 94f8                      	cli //disable global interrupts
                                 		
0013eb efaf                      	ldi r26, 0xFF
0013ec 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
0013ee 9220 2821                 	sts song_fx_Cxx, zero
0013f0 9220 2822                 	sts song_fx_Dxx, zero
0013f2 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0013f3 91e0 2819                 	lds ZL, song_frames
0013f5 91f0 281a                 	lds ZH, song_frames+1
0013f7 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0013f9 91b0 281c                 	lds r27, song_frame_offset+1
0013fb 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0013fc 93a0 281b                 	sts song_frame_offset, r26
0013fe 93b0 281c                 	sts song_frame_offset+1, r27
001400 0fea                      	add ZL, r26
001401 1ffb                      	adc ZH, r27
                                 
001402 91a5                      	lpm r26, Z+ //load the address of the next pattern
001403 91b5                      	lpm r27, Z+
001404 0faa                      	lsl r26
001405 1fbb                      	rol r27
001406 93a0 2823                 	sts pulse1_pattern, r26
001408 93b0 2824                 	sts pulse1_pattern+1, r27
00140a 91a5                      	lpm r26, Z+
00140b 91b5                      	lpm r27, Z+
00140c 0faa                      	lsl r26
00140d 1fbb                      	rol r27
00140e 93a0 2874                 	sts pulse2_pattern, r26
001410 93b0 2875                 	sts pulse2_pattern+1, r27
001412 91a5                      	lpm r26, Z+
001413 91b5                      	lpm r27, Z+
001414 0faa                      	lsl r26
001415 1fbb                      	rol r27
001416 93a0 28c5                 	sts triangle_pattern, r26
001418 93b0 28c6                 	sts triangle_pattern+1, r27
00141a 91a5                      	lpm r26, Z+
00141b 91b5                      	lpm r27, Z+
00141c 0faa                      	lsl r26
00141d 1fbb                      	rol r27
00141e 93a0 2911                 	sts noise_pattern, r26
001420 93b0 2912                 	sts noise_pattern+1, r27
                                 
001422 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001424 9220 2828                 	sts pulse1_pattern_offset+1, zero
001426 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001428 9220 2826                 	sts pulse1_pattern_delay_frames, zero
00142a 9220 2878                 	sts pulse2_pattern_offset, zero
00142c 9220 2879                 	sts pulse2_pattern_offset+1, zero
00142e 9220 2876                 	sts pulse2_pattern_delay_rows, zero
001430 9220 2877                 	sts pulse2_pattern_delay_frames, zero
001432 9220 28c9                 	sts triangle_pattern_offset, zero
001434 9220 28ca                 	sts triangle_pattern_offset+1, zero
001436 9220 28c7                 	sts triangle_pattern_delay_rows, zero
001438 9220 28c8                 	sts triangle_pattern_delay_frames, zero
00143a 9220 2915                 	sts noise_pattern_offset, zero
00143c 9220 2916                 	sts noise_pattern_offset+1, zero
00143e 9220 2913                 	sts noise_pattern_delay_rows, zero
001440 9220 2914                 	sts noise_pattern_delay_frames, zero
                                 
001442 efaf                      	ldi r26, 0xFF
001443 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001445 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
001447 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
001449 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
00144b 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
00144d 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
00144f 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
001451 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
001453 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
001455 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
001457 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
001459 93a0 2910                 	sts triangle_fx_Sxx_post, r26
00145b 93a0 2943                 	sts noise_fx_Gxx_pre, r26
00145d 93a0 2944                 	sts noise_fx_Gxx_post, r26
00145f 93a0 2946                 	sts noise_fx_Sxx_pre, r26
001461 93a0 2947                 	sts noise_fx_Sxx_post, r26
                                 
001463 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
001465 9220 2821                 	sts song_fx_Cxx, zero
001467 9220 2822                 	sts song_fx_Dxx, zero
001469 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
00146a 91a0 2825                 	lds r26, pulse1_pattern_delay_rows
00146c 91b0 2826                 	lds r27, pulse1_pattern_delay_frames
00146e 9610                      	adiw r27:r26, 0
00146f f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
001470 c2e4                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001471 91e0 2823                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001473 91f0 2824                 	lds ZH, pulse1_pattern+1
001475 91a0 2827                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001477 91b0 2828                 	lds r27, pulse1_pattern_offset+1
001479 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00147a 1ffb                      	adc ZH, r27
00147b 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00147c 35b7                      	cpi r27, 0x57
00147d f408                      	brsh sound_driver_channel0_check_if_volume
00147e c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
00147f 36b7                      	cpi r27, 0x67
001480 f408                      	brsh sound_driver_channel0_check_if_delay
001481 c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001482 3eb3                      	cpi r27, 0xE3
001483 f408                      	brsh sound_driver_channel0_check_if_instrument
001484 c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001485 f409                      	brne sound_driver_channel0_check_if_release
001486 c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001487 3eb4                      	cpi r27, 0xE4
001488 f409                      	brne sound_driver_channel0_check_if_end
001489 c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
00148a 3fbf                      	cpi r27, 0xFF
00148b f409                      	brne sound_driver_channel0_check_if_fx
00148c c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
00148d 9631                      	adiw Z, 1 //point Z to the byte next to the flag
00148e 91a4                      	lpm r26, Z //load the fx data into r26
00148f d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001490 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001491 e2e0                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001492 e5f7                      	ldi ZH, HIGH(channel0_fx << 1)
001493 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001494 0feb                      	add ZL, r27 //add offset
001495 1df2                      	adc ZH, zero
001496 91c5                      	lpm r28, Z+ //load address bytes
001497 91d4                      	lpm r29, Z
001498 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001499 2ffd                      	mov ZH, r29
00149a 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
00149b 93a0 2846                 	sts pulse1_fx_0xy_sequence, r26
00149d 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
00149f cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
0014a0 9220 284c                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
0014a2 9220 284d                 	sts pulse1_fx_2xx+1, zero
0014a4 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0014a6 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
0014a8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014a9 937f                      	push r23
0014aa 2f6a                      	mov r22, r26 //store the rate into r22
0014ab eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014ac 9f67                      	mul r22, r23
0014ad 917f                      	pop r23
0014ae 916f                      	pop r22
                                 
0014af 9416                      	lsr r1 //shift out the fractional bits
0014b0 9407                      	ror r0
0014b1 9416                      	lsr r1
0014b2 9407                      	ror r0
0014b3 9416                      	lsr r1
0014b4 9407                      	ror r0
0014b5 9416                      	lsr r1
0014b6 9407                      	ror r0
0014b7 9200 2848                 	sts pulse1_fx_1xx, r0
0014b9 9210 2849                 	sts pulse1_fx_1xx+1, r1
0014bb cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0014bc 9220 2848                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0014be 9220 2849                 	sts pulse1_fx_1xx+1, zero
0014c0 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0014c2 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
0014c4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014c5 937f                      	push r23
0014c6 2f6a                      	mov r22, r26 //store the rate into r22
0014c7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014c8 9f67                      	mul r22, r23
0014c9 917f                      	pop r23
0014ca 916f                      	pop r22
                                 
0014cb 9416                      	lsr r1 //shift out the fractional bits
0014cc 9407                      	ror r0
0014cd 9416                      	lsr r1
0014ce 9407                      	ror r0
0014cf 9416                      	lsr r1
0014d0 9407                      	ror r0
0014d1 9416                      	lsr r1
0014d2 9407                      	ror r0
0014d3 9200 284c                 	sts pulse1_fx_2xx, r0
0014d5 9210 284d                 	sts pulse1_fx_2xx+1, r1
0014d7 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0014d8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014d9 937f                      	push r23
0014da 2f6a                      	mov r22, r26 //store the rate into r22
0014db eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014dc 9f67                      	mul r22, r23
0014dd 917f                      	pop r23
0014de 916f                      	pop r22
                                 
0014df 9416                      	lsr r1 //shift out the fractional bits
0014e0 9407                      	ror r0
0014e1 9416                      	lsr r1
0014e2 9407                      	ror r0
0014e3 9416                      	lsr r1
0014e4 9407                      	ror r0
0014e5 9416                      	lsr r1
0014e6 9407                      	ror r0
0014e7 9200 2854                 	sts pulse1_fx_3xx_speed, r0
0014e9 9210 2855                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0014eb 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0014ec c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0014ed cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0014ee 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0014f0 91b0 0a8d                 	lds r27, TCB0_CCMPH
0014f2 93a0 2850                 	sts pulse1_fx_3xx_start, r26
0014f4 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
                                 
0014f6 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
0014f8 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
0014fa cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0014fb 2fba                      	mov r27, r26
0014fc 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0014fd 95a2                      	swap r26
0014fe 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0014ff 93a0 2858                 	sts pulse1_fx_4xy_speed, r26
001501 93b0 2859                 	sts pulse1_fx_4xy_depth, r27
001503 9220 285a                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
001505 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
001506 2fba                      	mov r27, r26
001507 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001508 95a2                      	swap r26
001509 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00150a 93a0 285b                 	sts pulse1_fx_7xy_speed, r26
00150c 93b0 285c                 	sts pulse1_fx_7xy_depth, r27
00150e 9220 285d                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
001510 9220 285e                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001512 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001513 93a0 285f                 	sts pulse1_fx_Axy, r26
001515 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
001516 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001518 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
001519 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00151b cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
00151c 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00151e cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
00151f 91b0 2800                 	lds r27, pulse1_param
001521 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001522 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001523 93b0 2800                 	sts pulse1_param, r27
001525 6096                      	sbr pulse_channel_flags, 6
001526 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
001527 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001529 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
00152a 15a2                      	cp r26, zero
00152b f051                      	breq sound_driver_channel0_fx_Gxx_invalid
00152c 91b0 281f                 	lds r27, song_speed
00152e 17ab                      	cp r26, r27
00152f f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
001530 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001532 e0b1                      	ldi r27, 0x01
001533 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001535 c222                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
001536 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001537 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
001538 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
001539 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
00153a cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
00153b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00153c 937f                      	push r23
00153d 2f6a                      	mov r22, r26
00153e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00153f 0367                      	mulsu r22, r23
001540 917f                      	pop r23
001541 916f                      	pop r22
001542 9416                      	lsr r1 //shift out the fractional bits
001543 9407                      	ror r0
001544 9416                      	lsr r1
001545 9407                      	ror r0
001546 9416                      	lsr r1
001547 9407                      	ror r0
001548 9416                      	lsr r1
001549 9407                      	ror r0
00154a fe13                      	sbrs r1, 3 //check if result was a negative number
00154b c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
00154c efb0                      	ldi r27, 0xF0
00154d 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
00154e 9200 2862                 	sts pulse1_fx_Pxx_total, r0
001550 9210 2863                 	sts pulse1_fx_Pxx_total+1, r1
001552 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001553 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
001555 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
001557 9630                      	adiw Z, 0
001558 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001559 cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00155a 91e0 2836                 	lds ZL, pulse1_pitch_macro
00155c 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
00155e 9630                      	adiw Z, 0
00155f f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001560 cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001561 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
001563 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
001565 9630                      	adiw Z, 0
001566 f009                      	breq sound_driver_channel0_fx_Qxy_process
001567 cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001568 2fba                      	mov r27, r26 //copy fx parameters into r27
001569 70bf                      	andi r27, 0x0F //mask note index offset
00156a 91c0 2864                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
00156c 0fbc                      	add r27, r28
00156d 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00156e f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
00156f e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001570 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
001572 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001573 e0f0                      	ldi ZH, HIGH(note_table << 1)
001574 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001575 0feb                      	add ZL, r27 //add offset
001576 1df2                      	adc ZH, zero
001577 91c5                      	lpm r28, Z+ //load bytes
001578 91d4                      	lpm r29, Z
001579 93c0 2865                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
00157b 93d0 2866                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
00157d 95a2                      	swap r26
00157e 70af                      	andi r26, 0x0F //mask effect speed
00157f 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001580 95a3                      	inc r26 //increment the speed by 1
                                 
001581 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001582 937f                      	push r23
001583 2f6a                      	mov r22, r26 //store the speed data into r27
001584 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001585 9f67                      	mul r22, r23
001586 917f                      	pop r23
001587 916f                      	pop r22
                                 
001588 9416                      	lsr r1 //shift out the fractional bits
001589 9407                      	ror r0
00158a 9416                      	lsr r1
00158b 9407                      	ror r0
00158c 9416                      	lsr r1
00158d 9407                      	ror r0
00158e 9416                      	lsr r1
00158f 9407                      	ror r0
                                 
001590 9200 2867                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001592 9210 2868                 	sts pulse1_fx_Qxy_speed+1, r1
001594 cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001595 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
001597 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
001599 9630                      	adiw Z, 0
00159a f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
00159b ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
00159c 91e0 2836                 	lds ZL, pulse1_pitch_macro
00159e 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
0015a0 9630                      	adiw Z, 0
0015a1 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0015a2 cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0015a3 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
0015a5 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
0015a7 9630                      	adiw Z, 0
0015a8 f009                      	breq sound_driver_channel0_fx_Rxy_process
0015a9 cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0015aa 2fba                      	mov r27, r26 //copy fx parameters into r27
0015ab 70bf                      	andi r27, 0x0F //mask note index offset
0015ac 91c0 286b                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
0015ae 1bcb                      	sub r28, r27
0015af f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0015b0 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0015b1 93c0 286b                 	sts pulse1_fx_Rxy_target_note, r28
0015b3 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0015b4 e0f0                      	ldi ZH, HIGH(note_table << 1)
0015b5 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0015b6 0fec                      	add ZL, r28 //add offset
0015b7 1df2                      	adc ZH, zero
0015b8 91c5                      	lpm r28, Z+ //load bytes
0015b9 91d4                      	lpm r29, Z
0015ba 93c0 286c                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0015bc 93d0 286d                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
0015be 95a2                      	swap r26
0015bf 70af                      	andi r26, 0x0F //mask effect speed
0015c0 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0015c1 95a3                      	inc r26 //increment the speed by 1
                                 
0015c2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015c3 937f                      	push r23
0015c4 2f6a                      	mov r22, r26 //store the speed data into r27
0015c5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015c6 9f67                      	mul r22, r23
0015c7 917f                      	pop r23
0015c8 916f                      	pop r22
                                 
0015c9 9416                      	lsr r1 //shift out the fractional bits
0015ca 9407                      	ror r0
0015cb 9416                      	lsr r1
0015cc 9407                      	ror r0
0015cd 9416                      	lsr r1
0015ce 9407                      	ror r0
0015cf 9416                      	lsr r1
0015d0 9407                      	ror r0
                                 
0015d1 9200 286e                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
0015d3 9210 286f                 	sts pulse1_fx_Rxy_speed+1, r1
0015d5 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
0015d6 15a2                      	cp r26, zero
0015d7 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
0015d8 91b0 281f                 	lds r27, song_speed
0015da 17ab                      	cp r26, r27
0015db f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
0015dc 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0015de e0b1                      	ldi r27, 0x01
0015df 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
0015e1 c176                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
0015e2 ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
0015e3 e1ec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0015e4 e5f7                      	ldi ZH, HIGH(sequences << 1)
0015e5 0fea                      	add ZL, r26 //offset the pointer
0015e6 1df2                      	adc ZH, zero
                                 
0015e7 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0015e8 95a7                      	ror r26
0015e9 95a7                      	ror r26
0015ea 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0015ec 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0015ed 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0015ee 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0015ef c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0015f0 ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0015f1 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0015f2 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0015f3 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0015f4 93c0 2800                 	sts pulse1_param, r28
0015f6 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0015f7 ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
0015f8 ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
0015f9 ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
0015fa ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
0015fb 93b0 2807                 	sts pulse1_note, r27 //store the note index
0015fd 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
0015ff 93b0 286b                 	sts pulse1_fx_Rxy_target_note, r27
001601 e0a3                      	ldi r26, 0x03
001602 e0b2                      	ldi r27, 0x02
001603 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001605 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
001607 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
001609 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
00160b 93b0 2843                 	sts pulse1_duty_macro_offset, r27
00160d 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
00160f 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
001611 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
001613 9220 284a                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001615 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
001617 9220 284e                 	sts pulse1_fx_2xx_total, zero
001619 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
00161b 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
00161d 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
00161f 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001621 91b0 0a8d                 	lds r27, TCB0_CCMPH
001623 93a0 2850                 	sts pulse1_fx_3xx_start, r26
001625 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
001627 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001629 6097                      	sbr pulse_channel_flags, 7 //set reload flag
00162a 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00162c 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
00162e 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
001630 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
001632 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001634 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001636 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
001638 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
00163a d106                      	rcall sound_driver_channel0_increment_offset
00163b ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
00163c 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00163d 91a0 2800                 	lds r26, pulse1_param
00163f 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001640 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001641 93a0 2800                 	sts pulse1_param, r26
001643 6096                      	sbr pulse_channel_flags, 6
001644 d0fc                      	rcall sound_driver_channel0_increment_offset
001645 ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001646 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001647 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001649 d0f7                      	rcall sound_driver_channel0_increment_offset
00164a c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
00164b 9220 2829                 	sts pulse1_volume_macro, zero //reset all macro addresses
00164d 9220 282a                 	sts pulse1_volume_macro+1, zero
00164f 9220 282e                 	sts pulse1_arpeggio_macro, zero
001651 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
001653 9220 2836                 	sts pulse1_pitch_macro, zero
001655 9220 2837                 	sts pulse1_pitch_macro+1, zero
001657 9220 283c                 	sts pulse1_hi_pitch_macro, zero
001659 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
00165b 9220 2841                 	sts pulse1_duty_macro, zero
00165d 9220 2842                 	sts pulse1_duty_macro+1, zero
00165f 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001661 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
001663 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001665 9631                      	adiw Z, 1 //point to the byte next to the flag
001666 91b4                      	lpm r27, Z //store the instrument offset into r27
001667 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001668 e0fd                      	ldi ZH, HIGH(instruments)
001669 0feb                      	add ZL, r27 //point Z to offsetted instrument
00166a 1df2                      	adc ZH, zero
00166b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00166c 1fff                      	rol ZH
00166d 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00166e 91b4                      	lpm r27, Z
                                 
00166f 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001670 1fbb                      	rol r27
001671 2fea                      	mov ZL, r26
001672 2ffb                      	mov ZH, r27
001673 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001674 9632                      	adiw Z, 2 //point Z to the address of the macro
001675 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001676 95aa                      	dec r26
001677 f019                      	breq sound_driver_channel0_instrument_change_exit
001678 95b6                      	lsr r27
001679 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
00167a cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
00167b e0a3                      	ldi r26, 0x03
00167c e0b2                      	ldi r27, 0x02
00167d 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00167f 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
001681 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
001683 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
001685 93b0 2843                 	sts pulse1_duty_macro_offset, r27
001687 d0c3                      	rcall sound_driver_channel0_increment_offset_twice
001688 cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001689 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
00168a 91d5                      	lpm r29, Z+
                                 
00168b 30a5                      	cpi r26, 5
00168c f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
00168d 30a4                      	cpi r26, 4
00168e f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
00168f 30a3                      	cpi r26, 3
001690 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001691 30a2                      	cpi r26, 2
001692 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001693 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001694 93c0 2829                 	sts pulse1_volume_macro, r28
001696 93d0 282a                 	sts pulse1_volume_macro+1, r29
001698 d041                      	rcall sound_driver_channel0_instrument_change_read_header
001699 93c0 282d                 	sts pulse1_volume_macro_release, r28
00169b 93d0 282c                 	sts pulse1_volume_macro_loop, r29
00169d cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
00169e 93c0 282e                 	sts pulse1_arpeggio_macro, r28
0016a0 93d0 282f                 	sts pulse1_arpeggio_macro+1, r29
0016a2 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016a4 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
0016a6 9220 286c                 	sts pulse1_fx_Rxy_target, zero
0016a8 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
0016aa d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0016ab cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0016ac 93c0 2836                 	sts pulse1_pitch_macro, r28
0016ae 93d0 2837                 	sts pulse1_pitch_macro+1, r29
0016b0 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016b2 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
0016b4 9220 286c                 	sts pulse1_fx_Rxy_target, zero
0016b6 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
0016b8 d021                      	rcall sound_driver_channel0_instrument_change_read_header
0016b9 93c0 283a                 	sts pulse1_pitch_macro_release, r28
0016bb 93d0 2839                 	sts pulse1_pitch_macro_loop, r29
0016bd cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0016be 93c0 283c                 	sts pulse1_hi_pitch_macro, r28
0016c0 93d0 283d                 	sts pulse1_hi_pitch_macro+1, r29
0016c2 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016c4 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
0016c6 9220 286c                 	sts pulse1_fx_Rxy_target, zero
0016c8 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
0016ca d00f                      	rcall sound_driver_channel0_instrument_change_read_header
0016cb 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
0016cd 93d0 283f                 	sts pulse1_hi_pitch_macro_loop, r29
0016cf cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
0016d0 93c0 2841                 	sts pulse1_duty_macro, r28
0016d2 93d0 2842                 	sts pulse1_duty_macro+1, r29
0016d4 d005                      	rcall sound_driver_channel0_instrument_change_read_header
0016d5 93c0 2845                 	sts pulse1_duty_macro_release, r28
0016d7 93d0 2844                 	sts pulse1_duty_macro_loop, r29
0016d9 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
0016da 93ef                      	push ZL
0016db 93ff                      	push ZH
0016dc 2fec                      	mov ZL, r28
0016dd 2ffd                      	mov ZH, r29
0016de 0fee                      	lsl ZL
0016df 1fff                      	rol ZH
0016e0 91c5                      	lpm r28, Z+
0016e1 91d4                      	lpm r29, Z
0016e2 91ff                      	pop ZH
0016e3 91ef                      	pop ZL
0016e4 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
0016e5 93ef                      	push ZL
0016e6 93ff                      	push ZH
0016e7 2fec                      	mov ZL, r28
0016e8 2ffd                      	mov ZH, r29
0016e9 0fee                      	lsl ZL
0016ea 1fff                      	rol ZH
0016eb 91c5                      	lpm r28, Z+
0016ec 91d5                      	lpm r29, Z+
0016ed 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
0016ef 93d0 2831                 	sts pulse1_arpeggio_macro_loop, r29
0016f1 91c4                      	lpm r28, Z
0016f2 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
0016f4 91ff                      	pop ZH
0016f5 91ef                      	pop ZL
0016f6 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
0016f7 91b0 282d                 	lds r27, pulse1_volume_macro_release
0016f9 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0016fa f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
0016fb 95b3                      	inc r27
0016fc 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
0016fe 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
001700 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001701 f019                      	breq sound_driver_channel0_release_pitch
001702 95b3                      	inc r27
001703 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001705 91b0 283a                 	lds r27, pulse1_pitch_macro_release
001707 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001708 f019                      	breq sound_driver_channel0_release_hi_pitch
001709 95b3                      	inc r27
00170a 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
00170c 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
00170e 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00170f f019                      	breq sound_driver_channel0_release_duty
001710 95b3                      	inc r27
001711 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001713 91b0 2845                 	lds r27, pulse1_duty_macro_release
001715 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001716 f019                      	breq sound_driver_channel0_release_exit
001717 95b3                      	inc r27
001718 93b0 2843                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
00171a d026                      	rcall sound_driver_channel0_increment_offset
00171b cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
00171c 91e0 2819                 	lds ZL, song_frames
00171e 91f0 281a                 	lds ZH, song_frames+1
001720 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001722 91b0 281c                 	lds r27, song_frame_offset+1
001724 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001725 93a0 281b                 	sts song_frame_offset, r26
001727 93b0 281c                 	sts song_frame_offset+1, r27
                                 
001729 91c0 281d                 	lds r28, song_size
00172b 91d0 281e                 	lds r29, song_size+1
00172d 17ac                      	cp r26, r28
00172e 07bd                      	cpc r27, r29
00172f f010                      	brlo sound_driver_channel0_next_pattern_exists
001730 940c 2b78                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001732 0fea                      	add ZL, r26
001733 1ffb                      	adc ZH, r27
                                 
001734 91a5                      	lpm r26, Z+ //load the address of the next pattern
001735 91b4                      	lpm r27, Z
001736 0faa                      	lsl r26
001737 1fbb                      	rol r27
001738 93a0 2823                 	sts pulse1_pattern, r26
00173a 93b0 2824                 	sts pulse1_pattern+1, r27
                                 
00173c 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00173e 9220 2828                 	sts pulse1_pattern_offset+1, zero
001740 cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001741 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001743 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
001745 9631                      	adiw Z, 1
001746 93e0 2827                 	sts pulse1_pattern_offset, ZL
001748 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
00174a 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00174b 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
00174d 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
00174f 9632                      	adiw Z, 2 //increment the pointer twice
001750 93e0 2827                 	sts pulse1_pattern_offset, ZL
001752 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
001754 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001755 95ba                      	dec r27
001756 93b0 2826                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001758 91a0 2876                 	lds r26, pulse2_pattern_delay_rows
00175a 91b0 2877                 	lds r27, pulse2_pattern_delay_frames
00175c 9610                      	adiw r27:r26, 0
00175d f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
00175e c2d7                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
00175f 91e0 2874                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001761 91f0 2875                 	lds ZH, pulse2_pattern+1
001763 91a0 2878                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001765 91b0 2879                 	lds r27, pulse2_pattern_offset+1
001767 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001768 1ffb                      	adc ZH, r27
001769 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
00176a 35b7                      	cpi r27, 0x57
00176b f408                      	brsh sound_driver_channel1_check_if_volume
00176c c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
00176d 36b7                      	cpi r27, 0x67
00176e f408                      	brsh sound_driver_channel1_check_if_delay
00176f c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001770 3eb3                      	cpi r27, 0xE3
001771 f408                      	brsh sound_driver_channel1_check_if_instrument
001772 c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001773 f409                      	brne sound_driver_channel1_check_if_release
001774 c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001775 3eb4                      	cpi r27, 0xE4
001776 f409                      	brne sound_driver_channel1_check_if_end
001777 c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001778 3fbf                      	cpi r27, 0xFF
001779 f409                      	brne sound_driver_channel1_check_if_fx
00177a c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
00177b 9631                      	adiw Z, 1 //point Z to the byte next to the flag
00177c 91a4                      	lpm r26, Z //load the fx data into r26
00177d d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
00177e 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
00177f e5e4                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001780 e5f7                      	ldi ZH, HIGH(channel1_fx << 1)
001781 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001782 0feb                      	add ZL, r27 //add offset
001783 1df2                      	adc ZH, zero
001784 91c5                      	lpm r28, Z+ //load address bytes
001785 91d4                      	lpm r29, Z
001786 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001787 2ffd                      	mov ZH, r29
001788 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001789 93a0 2897                 	sts pulse2_fx_0xy_sequence, r26
00178b 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
00178d cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
00178e 9220 289d                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001790 9220 289e                 	sts pulse2_fx_2xx+1, zero
001792 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001794 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001796 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001797 937f                      	push r23
001798 2f6a                      	mov r22, r26 //store the rate into r22
001799 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00179a 9f67                      	mul r22, r23
00179b 917f                      	pop r23
00179c 916f                      	pop r22
                                 
00179d 9416                      	lsr r1 //shift out the fractional bits
00179e 9407                      	ror r0
00179f 9416                      	lsr r1
0017a0 9407                      	ror r0
0017a1 9416                      	lsr r1
0017a2 9407                      	ror r0
0017a3 9416                      	lsr r1
0017a4 9407                      	ror r0
0017a5 9200 2899                 	sts pulse2_fx_1xx, r0
0017a7 9210 289a                 	sts pulse2_fx_1xx+1, r1
0017a9 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
0017aa 9220 2899                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
0017ac 9220 289a                 	sts pulse2_fx_1xx+1, zero
0017ae 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
0017b0 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
0017b2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017b3 937f                      	push r23
0017b4 2f6a                      	mov r22, r26 //store the rate into r22
0017b5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017b6 9f67                      	mul r22, r23
0017b7 917f                      	pop r23
0017b8 916f                      	pop r22
                                 
0017b9 9416                      	lsr r1 //shift out the fractional bits
0017ba 9407                      	ror r0
0017bb 9416                      	lsr r1
0017bc 9407                      	ror r0
0017bd 9416                      	lsr r1
0017be 9407                      	ror r0
0017bf 9416                      	lsr r1
0017c0 9407                      	ror r0
0017c1 9200 289d                 	sts pulse2_fx_2xx, r0
0017c3 9210 289e                 	sts pulse2_fx_2xx+1, r1
0017c5 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
0017c6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017c7 937f                      	push r23
0017c8 2f6a                      	mov r22, r26 //store the rate into r22
0017c9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017ca 9f67                      	mul r22, r23
0017cb 917f                      	pop r23
0017cc 916f                      	pop r22
                                 
0017cd 9416                      	lsr r1 //shift out the fractional bits
0017ce 9407                      	ror r0
0017cf 9416                      	lsr r1
0017d0 9407                      	ror r0
0017d1 9416                      	lsr r1
0017d2 9407                      	ror r0
0017d3 9416                      	lsr r1
0017d4 9407                      	ror r0
0017d5 9200 28a5                 	sts pulse2_fx_3xx_speed, r0
0017d7 9210 28a6                 	sts pulse2_fx_3xx_speed+1, r1
                                 
0017d9 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0017da c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
0017db cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
0017dc 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0017de 91b0 0a9d                 	lds r27, TCB1_CCMPH
0017e0 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
0017e2 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
                                 
0017e4 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
0017e6 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
0017e8 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
0017e9 2fba                      	mov r27, r26
0017ea 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0017eb 95a2                      	swap r26
0017ec 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0017ed 93a0 28a9                 	sts pulse2_fx_4xy_speed, r26
0017ef 93b0 28aa                 	sts pulse2_fx_4xy_depth, r27
0017f1 9220 28ab                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
0017f3 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
0017f4 2fba                      	mov r27, r26
0017f5 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0017f6 95a2                      	swap r26
0017f7 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0017f8 93a0 28ac                 	sts pulse2_fx_7xy_speed, r26
0017fa 93b0 28ad                 	sts pulse2_fx_7xy_depth, r27
0017fc 9220 28ae                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
0017fe 9220 28af                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001800 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001801 93a0 28b0                 	sts pulse2_fx_Axy, r26
001803 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001804 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001806 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001807 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001809 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
00180a 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00180c cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
00180d 91b0 2808                 	lds r27, pulse2_param
00180f 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001810 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001811 93b0 2808                 	sts pulse2_param, r27
001813 6092                      	sbr pulse_channel_flags, 2
001814 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001815 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001817 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001818 15a2                      	cp r26, zero
001819 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
00181a 91b0 281f                 	lds r27, song_speed
00181c 17ab                      	cp r26, r27
00181d f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
00181e 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001820 e0b1                      	ldi r27, 0x01
001821 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001823 c215                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001824 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001825 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001826 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001827 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001828 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001829 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00182a 937f                      	push r23
00182b 2f6a                      	mov r22, r26
00182c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00182d 0367                      	mulsu r22, r23
00182e 917f                      	pop r23
00182f 916f                      	pop r22
001830 9416                      	lsr r1 //shift out the fractional bits
001831 9407                      	ror r0
001832 9416                      	lsr r1
001833 9407                      	ror r0
001834 9416                      	lsr r1
001835 9407                      	ror r0
001836 9416                      	lsr r1
001837 9407                      	ror r0
001838 fe13                      	sbrs r1, 3 //check if result was a negative number
001839 c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
00183a efb0                      	ldi r27, 0xF0
00183b 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
00183c 9200 28b3                 	sts pulse2_fx_Pxx_total, r0
00183e 9210 28b4                 	sts pulse2_fx_Pxx_total+1, r1
001840 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001841 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001843 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001845 9630                      	adiw Z, 0
001846 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001847 cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001848 91e0 2887                 	lds ZL, pulse2_pitch_macro
00184a 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
00184c 9630                      	adiw Z, 0
00184d f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
00184e cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
00184f 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001851 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001853 9630                      	adiw Z, 0
001854 f009                      	breq sound_driver_channel1_fx_Qxy_process
001855 cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001856 2fba                      	mov r27, r26 //copy fx parameters into r27
001857 70bf                      	andi r27, 0x0F //mask note index offset
001858 91c0 28b5                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
00185a 0fbc                      	add r27, r28
00185b 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00185c f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
00185d e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
00185e 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001860 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001861 e0f0                      	ldi ZH, HIGH(note_table << 1)
001862 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001863 0feb                      	add ZL, r27 //add offset
001864 1df2                      	adc ZH, zero
001865 91c5                      	lpm r28, Z+ //load bytes
001866 91d4                      	lpm r29, Z
001867 93c0 28b6                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001869 93d0 28b7                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
00186b 95a2                      	swap r26
00186c 70af                      	andi r26, 0x0F //mask effect speed
00186d 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00186e 95a3                      	inc r26 //increment the speed by 1
                                 
00186f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001870 937f                      	push r23
001871 2f6a                      	mov r22, r26 //store the speed data into r27
001872 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001873 9f67                      	mul r22, r23
001874 917f                      	pop r23
001875 916f                      	pop r22
                                 
001876 9416                      	lsr r1 //shift out the fractional bits
001877 9407                      	ror r0
001878 9416                      	lsr r1
001879 9407                      	ror r0
00187a 9416                      	lsr r1
00187b 9407                      	ror r0
00187c 9416                      	lsr r1
00187d 9407                      	ror r0
                                 
00187e 9200 28b8                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001880 9210 28b9                 	sts pulse2_fx_Qxy_speed+1, r1
001882 cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001883 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001885 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001887 9630                      	adiw Z, 0
001888 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001889 ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
00188a 91e0 2887                 	lds ZL, pulse2_pitch_macro
00188c 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
00188e 9630                      	adiw Z, 0
00188f f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001890 cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001891 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001893 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001895 9630                      	adiw Z, 0
001896 f009                      	breq sound_driver_channel1_fx_Rxy_process
001897 cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001898 2fba                      	mov r27, r26 //copy fx parameters into r27
001899 70bf                      	andi r27, 0x0F //mask note index offset
00189a 91c0 28bc                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
00189c 1bcb                      	sub r28, r27
00189d f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
00189e e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
00189f 93c0 28bc                 	sts pulse2_fx_Rxy_target_note, r28
0018a1 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0018a2 e0f0                      	ldi ZH, HIGH(note_table << 1)
0018a3 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0018a4 0fec                      	add ZL, r28 //add offset
0018a5 1df2                      	adc ZH, zero
0018a6 91c5                      	lpm r28, Z+ //load bytes
0018a7 91d4                      	lpm r29, Z
0018a8 93c0 28bd                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
0018aa 93d0 28be                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
0018ac 95a2                      	swap r26
0018ad 70af                      	andi r26, 0x0F //mask effect speed
0018ae 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0018af 95a3                      	inc r26 //increment the speed by 1
                                 
0018b0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018b1 937f                      	push r23
0018b2 2f6a                      	mov r22, r26 //store the speed data into r27
0018b3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018b4 9f67                      	mul r22, r23
0018b5 917f                      	pop r23
0018b6 916f                      	pop r22
                                 
0018b7 9416                      	lsr r1 //shift out the fractional bits
0018b8 9407                      	ror r0
0018b9 9416                      	lsr r1
0018ba 9407                      	ror r0
0018bb 9416                      	lsr r1
0018bc 9407                      	ror r0
0018bd 9416                      	lsr r1
0018be 9407                      	ror r0
                                 
0018bf 9200 28bf                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
0018c1 9210 28c0                 	sts pulse2_fx_Rxy_speed+1, r1
0018c3 ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
0018c4 15a2                      	cp r26, zero
0018c5 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
0018c6 91b0 281f                 	lds r27, song_speed
0018c8 17ab                      	cp r26, r27
0018c9 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
0018ca 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0018cc e0b1                      	ldi r27, 0x01
0018cd 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
0018cf c169                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
0018d0 ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
0018d1 e1ec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0018d2 e5f7                      	ldi ZH, HIGH(sequences << 1)
0018d3 0fea                      	add ZL, r26 //offset the pointer
0018d4 1df2                      	adc ZH, zero
                                 
0018d5 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
0018d6 95a7                      	ror r26
0018d7 95a7                      	ror r26
0018d8 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
0018da 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
0018db 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0018dc 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0018dd c001                      	rjmp sound_driver_channel1_fx_Vxx_store
0018de ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
0018df 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
0018e0 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0018e1 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0018e2 93c0 2808                 	sts pulse2_param, r28
0018e4 ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
0018e5 ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
0018e6 ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
0018e7 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
0018e8 ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
0018e9 93b0 280f                 	sts pulse2_note, r27 //store the note index
0018eb 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
0018ed 93b0 28bc                 	sts pulse2_fx_Rxy_target_note, r27
0018ef e0a3                      	ldi r26, 0x03
0018f0 e0b2                      	ldi r27, 0x02
0018f1 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
0018f3 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
0018f5 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
0018f7 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
0018f9 93b0 2894                 	sts pulse2_duty_macro_offset, r27
0018fb 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
0018fd 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
0018ff 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
001901 9220 289b                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001903 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
001905 9220 289f                 	sts pulse2_fx_2xx_total, zero
001907 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
001909 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
00190b 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
00190d 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00190f 91b0 0a9d                 	lds r27, TCB1_CCMPH
001911 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001913 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
001915 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001917 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001918 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00191a 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
00191c 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
00191e 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
001920 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001922 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001924 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
001926 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
001928 d0f9                      	rcall sound_driver_channel1_increment_offset
001929 ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
00192a 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00192b 91a0 2808                 	lds r26, pulse2_param
00192d 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
00192e 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
00192f 93a0 2808                 	sts pulse2_param, r26
001931 6092                      	sbr pulse_channel_flags, 2
001932 d0ef                      	rcall sound_driver_channel1_increment_offset
001933 ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001934 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001935 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001937 d0ea                      	rcall sound_driver_channel1_increment_offset
001938 c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001939 9220 287a                 	sts pulse2_volume_macro, zero //reset all macro addresses
00193b 9220 287b                 	sts pulse2_volume_macro+1, zero
00193d 9220 287f                 	sts pulse2_arpeggio_macro, zero
00193f 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
001941 9220 2887                 	sts pulse2_pitch_macro, zero
001943 9220 2888                 	sts pulse2_pitch_macro+1, zero
001945 9220 288d                 	sts pulse2_hi_pitch_macro, zero
001947 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
001949 9220 2892                 	sts pulse2_duty_macro, zero
00194b 9220 2893                 	sts pulse2_duty_macro+1, zero
00194d 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
00194f 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001951 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001953 9631                      	adiw Z, 1 //point to the byte next to the flag
001954 91b4                      	lpm r27, Z //store the instrument offset into r27
001955 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001956 e0fd                      	ldi ZH, HIGH(instruments)
001957 0feb                      	add ZL, r27 //point Z to offsetted instrument
001958 1df2                      	adc ZH, zero
001959 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00195a 1fff                      	rol ZH
00195b 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00195c 91b4                      	lpm r27, Z
                                 
00195d 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
00195e 1fbb                      	rol r27
00195f 2fea                      	mov ZL, r26
001960 2ffb                      	mov ZH, r27
001961 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001962 9632                      	adiw Z, 2 //point Z to the address of the macro
001963 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001964 95aa                      	dec r26
001965 f019                      	breq sound_driver_channel1_instrument_change_exit
001966 95b6                      	lsr r27
001967 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001968 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001969 e0a3                      	ldi r26, 0x03
00196a e0b2                      	ldi r27, 0x02
00196b 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
00196d 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
00196f 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001971 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001973 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001975 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001976 cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001977 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001978 91d5                      	lpm r29, Z+
                                 
001979 30a5                      	cpi r26, 5
00197a f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
00197b 30a4                      	cpi r26, 4
00197c f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
00197d 30a3                      	cpi r26, 3
00197e f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
00197f 30a2                      	cpi r26, 2
001980 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001981 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001982 93c0 287a                 	sts pulse2_volume_macro, r28
001984 93d0 287b                 	sts pulse2_volume_macro+1, r29
001986 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001987 93c0 287e                 	sts pulse2_volume_macro_release, r28
001989 93d0 287d                 	sts pulse2_volume_macro_loop, r29
00198b cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
00198c 93c0 287f                 	sts pulse2_arpeggio_macro, r28
00198e 93d0 2880                 	sts pulse2_arpeggio_macro+1, r29
001990 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001992 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001994 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001996 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001998 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001999 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
00199a 93c0 2887                 	sts pulse2_pitch_macro, r28
00199c 93d0 2888                 	sts pulse2_pitch_macro+1, r29
00199e 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019a0 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
0019a2 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
0019a4 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
0019a6 d021                      	rcall sound_driver_channel1_instrument_change_read_header
0019a7 93c0 288b                 	sts pulse2_pitch_macro_release, r28
0019a9 93d0 288a                 	sts pulse2_pitch_macro_loop, r29
0019ab cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
0019ac 93c0 288d                 	sts pulse2_hi_pitch_macro, r28
0019ae 93d0 288e                 	sts pulse2_hi_pitch_macro+1, r29
0019b0 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019b2 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
0019b4 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
0019b6 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
0019b8 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
0019b9 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
0019bb 93d0 2890                 	sts pulse2_hi_pitch_macro_loop, r29
0019bd cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
0019be 93c0 2892                 	sts pulse2_duty_macro, r28
0019c0 93d0 2893                 	sts pulse2_duty_macro+1, r29
0019c2 d005                      	rcall sound_driver_channel1_instrument_change_read_header
0019c3 93c0 2896                 	sts pulse2_duty_macro_release, r28
0019c5 93d0 2895                 	sts pulse2_duty_macro_loop, r29
0019c7 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
0019c8 93ef                      	push ZL
0019c9 93ff                      	push ZH
0019ca 2fec                      	mov ZL, r28
0019cb 2ffd                      	mov ZH, r29
0019cc 0fee                      	lsl ZL
0019cd 1fff                      	rol ZH
0019ce 91c5                      	lpm r28, Z+
0019cf 91d4                      	lpm r29, Z
0019d0 91ff                      	pop ZH
0019d1 91ef                      	pop ZL
0019d2 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
0019d3 93ef                      	push ZL
0019d4 93ff                      	push ZH
0019d5 2fec                      	mov ZL, r28
0019d6 2ffd                      	mov ZH, r29
0019d7 0fee                      	lsl ZL
0019d8 1fff                      	rol ZH
0019d9 91c5                      	lpm r28, Z+
0019da 91d5                      	lpm r29, Z+
0019db 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
0019dd 93d0 2882                 	sts pulse2_arpeggio_macro_loop, r29
0019df 91c4                      	lpm r28, Z
0019e0 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
0019e2 91ff                      	pop ZH
0019e3 91ef                      	pop ZL
0019e4 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
0019e5 91b0 287e                 	lds r27, pulse2_volume_macro_release
0019e7 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0019e8 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
0019e9 95b3                      	inc r27
0019ea 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
0019ec 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
0019ee 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
0019ef f019                      	breq sound_driver_channel1_release_pitch
0019f0 95b3                      	inc r27
0019f1 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
0019f3 91b0 288b                 	lds r27, pulse2_pitch_macro_release
0019f5 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
0019f6 f019                      	breq sound_driver_channel1_release_hi_pitch
0019f7 95b3                      	inc r27
0019f8 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
0019fa 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
0019fc 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
0019fd f019                      	breq sound_driver_channel1_release_duty
0019fe 95b3                      	inc r27
0019ff 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001a01 91b0 2896                 	lds r27, pulse2_duty_macro_release
001a03 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001a04 f019                      	breq sound_driver_channel1_release_exit
001a05 95b3                      	inc r27
001a06 93b0 2894                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001a08 d019                      	rcall sound_driver_channel1_increment_offset
001a09 cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001a0a 91e0 2819                 	lds ZL, song_frames
001a0c 91f0 281a                 	lds ZH, song_frames+1
001a0e 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001a10 91b0 281c                 	lds r27, song_frame_offset+1
001a12 9612                      	adiw r27:r26, 2 //offset for channel 1
001a13 0fea                      	add ZL, r26
001a14 1ffb                      	adc ZH, r27
                                 
001a15 91a5                      	lpm r26, Z+ //load the address of the next pattern
001a16 91b4                      	lpm r27, Z
001a17 0faa                      	lsl r26
001a18 1fbb                      	rol r27
001a19 93a0 2874                 	sts pulse2_pattern, r26
001a1b 93b0 2875                 	sts pulse2_pattern+1, r27
                                 
001a1d 9220 2878                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001a1f 9220 2879                 	sts pulse2_pattern_offset+1, zero
001a21 cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001a22 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a24 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001a26 9631                      	adiw Z, 1
001a27 93e0 2878                 	sts pulse2_pattern_offset, ZL
001a29 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001a2b 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001a2c 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a2e 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001a30 9632                      	adiw Z, 2 //increment the pointer twice
001a31 93e0 2878                 	sts pulse2_pattern_offset, ZL
001a33 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001a35 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001a36 95ba                      	dec r27
001a37 93b0 2877                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001a39 91a0 28c7                 	lds r26, triangle_pattern_delay_rows
001a3b 91b0 28c8                 	lds r27, triangle_pattern_delay_frames
001a3d 9610                      	adiw r27:r26, 0
001a3e f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001a3f c2bf                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001a40 91e0 28c5                 	lds ZL, triangle_pattern //current pattern for triangle
001a42 91f0 28c6                 	lds ZH, triangle_pattern+1
001a44 91a0 28c9                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001a46 91b0 28ca                 	lds r27, triangle_pattern_offset+1
001a48 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001a49 1ffb                      	adc ZH, r27
001a4a 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001a4b 35b7                      	cpi r27, 0x57
001a4c f408                      	brsh sound_driver_channel2_check_if_volume
001a4d c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001a4e 36b7                      	cpi r27, 0x67
001a4f f408                      	brsh sound_driver_channel2_check_if_delay
001a50 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001a51 3eb3                      	cpi r27, 0xE3
001a52 f408                      	brsh sound_driver_channel2_check_if_instrument
001a53 c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001a54 f409                      	brne sound_driver_channel2_check_if_release
001a55 c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001a56 3eb4                      	cpi r27, 0xE4
001a57 f409                      	brne sound_driver_channel2_check_if_end
001a58 c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001a59 3fbf                      	cpi r27, 0xFF
001a5a f409                      	brne sound_driver_channel2_check_if_fx
001a5b c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001a5c 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001a5d 91a4                      	lpm r26, Z //load the fx data into r26
001a5e d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001a5f 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001a60 e8e8                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001a61 e5f7                      	ldi ZH, HIGH(channel2_fx << 1)
001a62 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001a63 0feb                      	add ZL, r27 //add offset
001a64 1df2                      	adc ZH, zero
001a65 91c5                      	lpm r28, Z+ //load address bytes
001a66 91d4                      	lpm r29, Z
001a67 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001a68 2ffd                      	mov ZH, r29
001a69 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001a6a 93a0 28e8                 	sts triangle_fx_0xy_sequence, r26
001a6c 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001a6e cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001a6f 9220 28ee                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001a71 9220 28ef                 	sts triangle_fx_2xx+1, zero
001a73 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001a75 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001a77 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a78 937f                      	push r23
001a79 2f6a                      	mov r22, r26 //store the rate into r22
001a7a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a7b 9f67                      	mul r22, r23
001a7c 917f                      	pop r23
001a7d 916f                      	pop r22
                                 
001a7e 9416                      	lsr r1 //shift out the fractional bits
001a7f 9407                      	ror r0
001a80 9416                      	lsr r1
001a81 9407                      	ror r0
001a82 9416                      	lsr r1
001a83 9407                      	ror r0
001a84 9416                      	lsr r1
001a85 9407                      	ror r0
001a86 9200 28ea                 	sts triangle_fx_1xx, r0
001a88 9210 28eb                 	sts triangle_fx_1xx+1, r1
001a8a cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001a8b 9220 28ea                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001a8d 9220 28eb                 	sts triangle_fx_1xx+1, zero
001a8f 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001a91 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001a93 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a94 937f                      	push r23
001a95 2f6a                      	mov r22, r26 //store the rate into r22
001a96 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a97 9f67                      	mul r22, r23
001a98 917f                      	pop r23
001a99 916f                      	pop r22
                                 
001a9a 9416                      	lsr r1 //shift out the fractional bits
001a9b 9407                      	ror r0
001a9c 9416                      	lsr r1
001a9d 9407                      	ror r0
001a9e 9416                      	lsr r1
001a9f 9407                      	ror r0
001aa0 9416                      	lsr r1
001aa1 9407                      	ror r0
001aa2 9200 28ee                 	sts triangle_fx_2xx, r0
001aa4 9210 28ef                 	sts triangle_fx_2xx+1, r1
001aa6 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001aa7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001aa8 937f                      	push r23
001aa9 2f6a                      	mov r22, r26 //store the rate into r22
001aaa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001aab 9f67                      	mul r22, r23
001aac 917f                      	pop r23
001aad 916f                      	pop r22
                                 
001aae 9416                      	lsr r1 //shift out the fractional bits
001aaf 9407                      	ror r0
001ab0 9416                      	lsr r1
001ab1 9407                      	ror r0
001ab2 9416                      	lsr r1
001ab3 9407                      	ror r0
001ab4 9416                      	lsr r1
001ab5 9407                      	ror r0
001ab6 9200 28f6                 	sts triangle_fx_3xx_speed, r0
001ab8 9210 28f7                 	sts triangle_fx_3xx_speed+1, r1
                                 
001aba 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001abb c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001abc cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001abd 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001abf 91b0 0aad                 	lds r27, TCB2_CCMPH
001ac1 93a0 28f2                 	sts triangle_fx_3xx_start, r26
001ac3 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
                                 
001ac5 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
001ac7 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001ac9 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001aca 2fba                      	mov r27, r26
001acb 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001acc 95a2                      	swap r26
001acd 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001ace 93a0 28fa                 	sts triangle_fx_4xy_speed, r26
001ad0 93b0 28fb                 	sts triangle_fx_4xy_depth, r27
001ad2 9220 28fc                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001ad4 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001ad5 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001ad6 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001ad7 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001ad9 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001ada 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001adc cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001add 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001adf cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001ae0 15a2                      	cp r26, zero
001ae1 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001ae2 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ae3 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001ae5 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001ae6 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001ae8 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001aea 9220 0aad                 	sts TCB2_CCMPH, zero
001aec cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001aed 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001aef cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001af0 15a2                      	cp r26, zero
001af1 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001af2 91b0 281f                 	lds r27, song_speed
001af4 17ab                      	cp r26, r27
001af5 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001af6 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001af8 e0b1                      	ldi r27, 0x01
001af9 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001afb c206                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001afc cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001afd cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001afe cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001aff cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001b00 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001b01 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b02 937f                      	push r23
001b03 2f6a                      	mov r22, r26
001b04 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b05 0367                      	mulsu r22, r23
001b06 917f                      	pop r23
001b07 916f                      	pop r22
001b08 9416                      	lsr r1 //shift out the fractional bits
001b09 9407                      	ror r0
001b0a 9416                      	lsr r1
001b0b 9407                      	ror r0
001b0c 9416                      	lsr r1
001b0d 9407                      	ror r0
001b0e 9416                      	lsr r1
001b0f 9407                      	ror r0
001b10 fe13                      	sbrs r1, 3 //check if result was a negative number
001b11 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001b12 efb0                      	ldi r27, 0xF0
001b13 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001b14 9200 28ff                 	sts triangle_fx_Pxx_total, r0
001b16 9210 2900                 	sts triangle_fx_Pxx_total+1, r1
001b18 cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001b19 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
001b1b 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
001b1d 9630                      	adiw Z, 0
001b1e f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001b1f cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001b20 91e0 28d8                 	lds ZL, triangle_pitch_macro
001b22 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
001b24 9630                      	adiw Z, 0
001b25 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001b26 cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001b27 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
001b29 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
001b2b 9630                      	adiw Z, 0
001b2c f009                      	breq sound_driver_channel2_fx_Qxy_process
001b2d cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001b2e 2fba                      	mov r27, r26 //copy fx parameters into r27
001b2f 70bf                      	andi r27, 0x0F //mask note index offset
001b30 91c0 2901                 	lds r28, triangle_fx_Qxy_target_note //load current note index
001b32 0fbc                      	add r27, r28
001b33 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001b34 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001b35 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001b36 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
001b38 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001b39 e0f0                      	ldi ZH, HIGH(note_table << 1)
001b3a 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001b3b 0feb                      	add ZL, r27 //add offset
001b3c 1df2                      	adc ZH, zero
001b3d 91c5                      	lpm r28, Z+ //load bytes
001b3e 91d4                      	lpm r29, Z
001b3f 93c0 2902                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001b41 93d0 2903                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
001b43 95a2                      	swap r26
001b44 70af                      	andi r26, 0x0F //mask effect speed
001b45 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b46 95a3                      	inc r26 //increment the speed by 1
                                 
001b47 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b48 937f                      	push r23
001b49 2f6a                      	mov r22, r26 //store the speed data into r27
001b4a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b4b 9f67                      	mul r22, r23
001b4c 917f                      	pop r23
001b4d 916f                      	pop r22
                                 
001b4e 9416                      	lsr r1 //shift out the fractional bits
001b4f 9407                      	ror r0
001b50 9416                      	lsr r1
001b51 9407                      	ror r0
001b52 9416                      	lsr r1
001b53 9407                      	ror r0
001b54 9416                      	lsr r1
001b55 9407                      	ror r0
                                 
001b56 9200 2904                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001b58 9210 2905                 	sts triangle_fx_Qxy_speed+1, r1
001b5a cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001b5b 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
001b5d 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
001b5f 9630                      	adiw Z, 0
001b60 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001b61 cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001b62 91e0 28d8                 	lds ZL, triangle_pitch_macro
001b64 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
001b66 9630                      	adiw Z, 0
001b67 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001b68 ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001b69 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
001b6b 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
001b6d 9630                      	adiw Z, 0
001b6e f009                      	breq sound_driver_channel2_fx_Rxy_process
001b6f ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001b70 2fba                      	mov r27, r26 //copy fx parameters into r27
001b71 70bf                      	andi r27, 0x0F //mask note index offset
001b72 91c0 2908                 	lds r28, triangle_fx_Rxy_target_note //load current note index
001b74 1bcb                      	sub r28, r27
001b75 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001b76 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001b77 93c0 2908                 	sts triangle_fx_Rxy_target_note, r28
001b79 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001b7a e0f0                      	ldi ZH, HIGH(note_table << 1)
001b7b 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001b7c 0fec                      	add ZL, r28 //add offset
001b7d 1df2                      	adc ZH, zero
001b7e 91c5                      	lpm r28, Z+ //load bytes
001b7f 91d4                      	lpm r29, Z
001b80 93c0 2909                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001b82 93d0 290a                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
001b84 95a2                      	swap r26
001b85 70af                      	andi r26, 0x0F //mask effect speed
001b86 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b87 95a3                      	inc r26 //increment the speed by 1
                                 
001b88 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b89 937f                      	push r23
001b8a 2f6a                      	mov r22, r26 //store the speed data into r27
001b8b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b8c 9f67                      	mul r22, r23
001b8d 917f                      	pop r23
001b8e 916f                      	pop r22
                                 
001b8f 9416                      	lsr r1 //shift out the fractional bits
001b90 9407                      	ror r0
001b91 9416                      	lsr r1
001b92 9407                      	ror r0
001b93 9416                      	lsr r1
001b94 9407                      	ror r0
001b95 9416                      	lsr r1
001b96 9407                      	ror r0
                                 
001b97 9200 290b                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001b99 9210 290c                 	sts triangle_fx_Rxy_speed+1, r1
001b9b cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001b9c 15a2                      	cp r26, zero
001b9d f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001b9e 91b0 281f                 	lds r27, song_speed
001ba0 17ab                      	cp r26, r27
001ba1 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001ba2 93a0 290f                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ba4 e0b1                      	ldi r27, 0x01
001ba5 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001ba7 c15a                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
001ba8 ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001ba9 ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001baa ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001bab ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001bac ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001bad ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001bae 93b0 2812                 	sts triangle_note, r27 //store the note index
001bb0 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
001bb2 93b0 2908                 	sts triangle_fx_Rxy_target_note, r27
001bb4 e0a3                      	ldi r26, 0x03
001bb5 e0b2                      	ldi r27, 0x02
001bb6 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001bb8 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
001bba 93b0 28da                 	sts triangle_pitch_macro_offset, r27
001bbc 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
001bbe 93b0 28e5                 	sts triangle_duty_macro_offset, r27
001bc0 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001bc2 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001bc4 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
001bc6 9220 28ec                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001bc8 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
001bca 9220 28f0                 	sts triangle_fx_2xx_total, zero
001bcc 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
001bce 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001bd0 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001bd2 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001bd4 91b0 0aad                 	lds r27, TCB2_CCMPH
001bd6 93a0 28f2                 	sts triangle_fx_3xx_start, r26
001bd8 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
001bda 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001bdc 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
001bde 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
001be0 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
001be2 9220 2909                 	sts triangle_fx_Rxy_target, zero
001be4 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
001be6 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
001be8 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
001bea e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001beb 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001bed d0fd                      	rcall sound_driver_channel2_increment_offset
001bee ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001bef d0fb                      	rcall sound_driver_channel2_increment_offset
001bf0 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001bf1 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001bf2 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001bf3 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001bf5 ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001bf6 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001bf8 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001bfa 9220 0aad                 	sts TCB2_CCMPH, zero
001bfc ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001bfd 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001bfe 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001c00 d0ea                      	rcall sound_driver_channel2_increment_offset
001c01 c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001c02 9220 28cb                 	sts triangle_volume_macro, zero //reset all macro addresses
001c04 9220 28cc                 	sts triangle_volume_macro+1, zero
001c06 9220 28d0                 	sts triangle_arpeggio_macro, zero
001c08 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
001c0a 9220 28d8                 	sts triangle_pitch_macro, zero
001c0c 9220 28d9                 	sts triangle_pitch_macro+1, zero
001c0e 9220 28de                 	sts triangle_hi_pitch_macro, zero
001c10 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
001c12 9220 28e3                 	sts triangle_duty_macro, zero
001c14 9220 28e4                 	sts triangle_duty_macro+1, zero
001c16 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001c18 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001c1a 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001c1c 9631                      	adiw Z, 1 //point to the byte next to the flag
001c1d 91b4                      	lpm r27, Z //store the instrument offset into r27
001c1e e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001c1f e0fd                      	ldi ZH, HIGH(instruments)
001c20 0feb                      	add ZL, r27 //point Z to offsetted instrument
001c21 1df2                      	adc ZH, zero
001c22 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001c23 1fff                      	rol ZH
001c24 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001c25 91b4                      	lpm r27, Z
                                 
001c26 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001c27 1fbb                      	rol r27
001c28 2fea                      	mov ZL, r26
001c29 2ffb                      	mov ZH, r27
001c2a 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001c2b 9632                      	adiw Z, 2 //point Z to the address of the macro
001c2c e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001c2d 95aa                      	dec r26
001c2e f019                      	breq sound_driver_channel2_instrument_change_exit
001c2f 95b6                      	lsr r27
001c30 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001c31 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001c32 e0a3                      	ldi r26, 0x03
001c33 e0b2                      	ldi r27, 0x02
001c34 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001c36 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
001c38 93b0 28da                 	sts triangle_pitch_macro_offset, r27
001c3a 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
001c3c 93b0 28e5                 	sts triangle_duty_macro_offset, r27
001c3e d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001c3f ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001c40 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001c41 91d5                      	lpm r29, Z+
                                 
001c42 30a5                      	cpi r26, 5
001c43 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
001c44 30a4                      	cpi r26, 4
001c45 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
001c46 30a3                      	cpi r26, 3
001c47 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
001c48 30a2                      	cpi r26, 2
001c49 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
001c4a c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
001c4b 93c0 28cb                 	sts triangle_volume_macro, r28
001c4d 93d0 28cc                 	sts triangle_volume_macro+1, r29
001c4f d041                      	rcall sound_driver_channel2_instrument_change_read_header
001c50 93c0 28cf                 	sts triangle_volume_macro_release, r28
001c52 93d0 28ce                 	sts triangle_volume_macro_loop, r29
001c54 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
001c55 93c0 28d0                 	sts triangle_arpeggio_macro, r28
001c57 93d0 28d1                 	sts triangle_arpeggio_macro+1, r29
001c59 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c5b 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
001c5d 9220 2909                 	sts triangle_fx_Rxy_target, zero
001c5f 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
001c61 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
001c62 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
001c63 93c0 28d8                 	sts triangle_pitch_macro, r28
001c65 93d0 28d9                 	sts triangle_pitch_macro+1, r29
001c67 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c69 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
001c6b 9220 2909                 	sts triangle_fx_Rxy_target, zero
001c6d 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
001c6f d021                      	rcall sound_driver_channel2_instrument_change_read_header
001c70 93c0 28dc                 	sts triangle_pitch_macro_release, r28
001c72 93d0 28db                 	sts triangle_pitch_macro_loop, r29
001c74 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001c75 93c0 28de                 	sts triangle_hi_pitch_macro, r28
001c77 93d0 28df                 	sts triangle_hi_pitch_macro+1, r29
001c79 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c7b 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
001c7d 9220 2909                 	sts triangle_fx_Rxy_target, zero
001c7f 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
001c81 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001c82 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
001c84 93d0 28e1                 	sts triangle_hi_pitch_macro_loop, r29
001c86 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
001c87 93c0 28e3                 	sts triangle_duty_macro, r28
001c89 93d0 28e4                 	sts triangle_duty_macro+1, r29
001c8b d005                      	rcall sound_driver_channel2_instrument_change_read_header
001c8c 93c0 28e7                 	sts triangle_duty_macro_release, r28
001c8e 93d0 28e6                 	sts triangle_duty_macro_loop, r29
001c90 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001c91 93ef                      	push ZL
001c92 93ff                      	push ZH
001c93 2fec                      	mov ZL, r28
001c94 2ffd                      	mov ZH, r29
001c95 0fee                      	lsl ZL
001c96 1fff                      	rol ZH
001c97 91c5                      	lpm r28, Z+
001c98 91d4                      	lpm r29, Z
001c99 91ff                      	pop ZH
001c9a 91ef                      	pop ZL
001c9b 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
001c9c 93ef                      	push ZL
001c9d 93ff                      	push ZH
001c9e 2fec                      	mov ZL, r28
001c9f 2ffd                      	mov ZH, r29
001ca0 0fee                      	lsl ZL
001ca1 1fff                      	rol ZH
001ca2 91c5                      	lpm r28, Z+
001ca3 91d5                      	lpm r29, Z+
001ca4 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
001ca6 93d0 28d3                 	sts triangle_arpeggio_macro_loop, r29
001ca8 91c4                      	lpm r28, Z
001ca9 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
001cab 91ff                      	pop ZH
001cac 91ef                      	pop ZL
001cad 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001cae 91b0 28cf                 	lds r27, triangle_volume_macro_release
001cb0 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001cb1 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001cb2 95b3                      	inc r27
001cb3 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001cb5 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
001cb7 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001cb8 f019                      	breq sound_driver_channel2_release_pitch
001cb9 95b3                      	inc r27
001cba 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
001cbc 91b0 28dc                 	lds r27, triangle_pitch_macro_release
001cbe 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001cbf f019                      	breq sound_driver_channel2_release_hi_pitch
001cc0 95b3                      	inc r27
001cc1 93b0 28da                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001cc3 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
001cc5 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001cc6 f019                      	breq sound_driver_channel2_release_duty
001cc7 95b3                      	inc r27
001cc8 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
001cca 91b0 28e7                 	lds r27, triangle_duty_macro_release
001ccc 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001ccd f019                      	breq sound_driver_channel2_release_exit
001cce 95b3                      	inc r27
001ccf 93b0 28e5                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001cd1 d019                      	rcall sound_driver_channel2_increment_offset
001cd2 cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001cd3 91e0 2819                 	lds ZL, song_frames
001cd5 91f0 281a                 	lds ZH, song_frames+1
001cd7 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001cd9 91b0 281c                 	lds r27, song_frame_offset+1
001cdb 9614                      	adiw r27:r26, 4 //offset for channel 2
001cdc 0fea                      	add ZL, r26
001cdd 1ffb                      	adc ZH, r27
                                 
001cde 91a5                      	lpm r26, Z+ //load the address of the next pattern
001cdf 91b4                      	lpm r27, Z
001ce0 0faa                      	lsl r26
001ce1 1fbb                      	rol r27
001ce2 93a0 28c5                 	sts triangle_pattern, r26
001ce4 93b0 28c6                 	sts triangle_pattern+1, r27
                                 
001ce6 9220 28c9                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ce8 9220 28ca                 	sts triangle_pattern_offset+1, zero
001cea cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
001ceb 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001ced 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
001cef 9631                      	adiw Z, 1
001cf0 93e0 28c9                 	sts triangle_pattern_offset, ZL
001cf2 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
001cf4 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001cf5 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001cf7 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
001cf9 9632                      	adiw Z, 2 //increment the pointer twice
001cfa 93e0 28c9                 	sts triangle_pattern_offset, ZL
001cfc 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
001cfe 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001cff 95ba                      	dec r27
001d00 93b0 28c8                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
001d02 91a0 2913                 	lds r26, noise_pattern_delay_rows
001d04 91b0 2914                 	lds r27, noise_pattern_delay_frames
001d06 9610                      	adiw r27:r26, 0
001d07 f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
001d08 c1b9                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
001d09 91e0 2911                 	lds ZL, noise_pattern //current pattern for noise
001d0b 91f0 2912                 	lds ZH, noise_pattern+1
001d0d 91a0 2915                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
001d0f 91b0 2916                 	lds r27, noise_pattern_offset+1
001d11 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001d12 1ffb                      	adc ZH, r27
001d13 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
001d14 35b7                      	cpi r27, 0x57
001d15 f408                      	brsh sound_driver_channel3_check_if_volume
001d16 c096                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
001d17 36b7                      	cpi r27, 0x67
001d18 f408                      	brsh sound_driver_channel3_check_if_delay
001d19 c0b1                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001d1a 3eb3                      	cpi r27, 0xE3
001d1b f408                      	brsh sound_driver_channel3_check_if_instrument
001d1c c0b7                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
001d1d f409                      	brne sound_driver_channel3_check_if_release
001d1e c0ba                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
001d1f 3eb4                      	cpi r27, 0xE4
001d20 f409                      	brne sound_driver_channel3_check_if_end
001d21 c14b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
001d22 3fbf                      	cpi r27, 0xFF
001d23 f409                      	brne sound_driver_channel3_check_if_fx
001d24 c16d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
001d25 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001d26 91a4                      	lpm r26, Z //load the fx data into r26
001d27 d190                      	rcall sound_driver_channel3_increment_offset_twice
                                 
001d28 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001d29 ebec                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
001d2a e5f7                      	ldi ZH, HIGH(channel3_fx << 1)
001d2b 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001d2c 0feb                      	add ZL, r27 //add offset
001d2d 1df2                      	adc ZH, zero
001d2e 91c5                      	lpm r28, Z+ //load address bytes
001d2f 91d4                      	lpm r29, Z
001d30 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001d31 2ffd                      	mov ZH, r29
001d32 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
001d33 93a0 2934                 	sts noise_fx_0xy_sequence, r26
001d35 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
001d37 cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
001d38 9220 2938                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
001d3a 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001d3c 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
001d3e 93a0 2936                 	sts noise_fx_1xx, r26
001d40 cfc8                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
001d41 9220 2936                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
001d43 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001d45 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
001d47 93a0 2938                 	sts noise_fx_2xx, r26
001d49 cfbf                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx: //automatic portamento
001d4a cfbe                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
001d4b 2fba                      	mov r27, r26
001d4c 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001d4d 95a2                      	swap r26
001d4e 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001d4f 93a0 293a                 	sts noise_fx_4xy_speed, r26
001d51 93b0 293b                 	sts noise_fx_4xy_depth, r27
001d53 9220 293c                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
001d55 9220 293d                 	sts noise_fx_4xy_offset, zero
001d57 cfb1                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
001d58 2fba                      	mov r27, r26
001d59 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001d5a 95a2                      	swap r26
001d5b 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001d5c 93a0 293e                 	sts noise_fx_7xy_speed, r26
001d5e 93b0 293f                 	sts noise_fx_7xy_depth, r27
001d60 9220 2940                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
001d62 9220 2941                 	sts noise_fx_7xy_value, zero //reset the tremelo value
001d64 cfa4                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
001d65 93a0 2942                 	sts noise_fx_Axy, r26
001d67 cfa1                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
001d68 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001d6a cf9e                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
001d6b 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001d6d cf9b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
001d6e 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001d70 cf98                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
001d71 91b0 2813                 	lds r27, noise_param
001d73 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001d74 2bba                      	or r27, r26 //move new VVVV bits into noise_param
001d75 93b0 2813                 	sts noise_param, r27
001d77 cf91                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
001d78 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001d7a cf8e                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
001d7b 15a2                      	cp r26, zero
001d7c f051                      	breq sound_driver_channel3_fx_Gxx_invalid
001d7d 91b0 281f                 	lds r27, song_speed
001d7f 17ab                      	cp r26, r27
001d80 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
001d81 93a0 2943                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001d83 e0b1                      	ldi r27, 0x01
001d84 93b0 2913                 	sts noise_pattern_delay_rows, r27
001d86 c13e                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
001d87 cf81                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
001d88 cf80                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
001d89 cf7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
001d8a cf7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
001d8b cf7d                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
001d8c 93a0 2945                 	sts noise_fx_Pxx_total, r26
001d8e cf7a                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Qxy: //note slide up
001d8f cf79                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Rxy: //note slide down
001d90 cf78                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
001d91 15a2                      	cp r26, zero
001d92 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
001d93 91b0 281f                 	lds r27, song_speed
001d95 17ab                      	cp r26, r27
001d96 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
001d97 93a0 2946                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001d99 e0b1                      	ldi r27, 0x01
001d9a 93b0 2913                 	sts noise_pattern_delay_rows, r27
001d9c c128                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
001d9d cf6b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
001d9e 95a6                      	lsr r26
001d9f 95a7                      	ror r26 //move mode bit to bit 7
001da0 91b0 2814                 	lds r27, noise_period
001da2 77bf                      	andi r27, 0b01111111
001da3 2bba                      	or r27, r26 //store the new noise mode
001da4 93b0 2813                 	sts noise_param, r27
                                 
001da6 776f                      	andi noise_sequence_HIGH, 0b01111111
001da7 2b6a                      	or noise_sequence_HIGH, r26
001da8 cf60                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
001da9 cf5f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
001daa cf5e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
001dab cf5d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
001dac cf5c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
001dad 93b0 2817                 	sts noise_note, r27
001daf 93b0 2818                 	sts noise_adjusted_note, r27
001db1 e0a3                      	ldi r26, 0x03
001db2 e0b2                      	ldi r27, 0x02
001db3 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001db5 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
001db7 93b0 2926                 	sts noise_pitch_macro_offset, r27
001db9 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
001dbb 93b0 2931                 	sts noise_duty_macro_offset, r27
001dbd 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
001dbf 9220 2923                 	sts noise_total_pitch_offset+1, zero
001dc1 9220 2929                 	sts noise_total_hi_pitch_offset, zero
001dc3 9220 2937                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001dc5 9220 2939                 	sts noise_fx_2xx_total, zero
001dc7 9220 293d                 	sts noise_fx_4xy_offset, zero
001dc9 d0e4                      	rcall sound_driver_channel3_increment_offset
001dca cf3e                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
001dcb 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001dcc 91a0 2813                 	lds r26, noise_param
001dce 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001dcf 2bab                      	or r26, r27 //move new VVVV bits into noise_param
001dd0 93a0 2813                 	sts noise_param, r26
001dd2 d0db                      	rcall sound_driver_channel3_increment_offset
001dd3 cf35                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
001dd4 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001dd5 93b0 2913                 	sts noise_pattern_delay_rows, r27
001dd7 d0d6                      	rcall sound_driver_channel3_increment_offset
001dd8 c0ec                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
001dd9 9220 2917                 	sts noise_volume_macro, zero //reset all macro addresses
001ddb 9220 2918                 	sts noise_volume_macro+1, zero
001ddd 9220 291c                 	sts noise_arpeggio_macro, zero
001ddf 9220 291d                 	sts noise_arpeggio_macro+1, zero
001de1 9220 2924                 	sts noise_pitch_macro, zero
001de3 9220 2925                 	sts noise_pitch_macro+1, zero
001de5 9220 292a                 	sts noise_hi_pitch_macro, zero
001de7 9220 292b                 	sts noise_hi_pitch_macro+1, zero
001de9 9220 292f                 	sts noise_duty_macro, zero
001deb 9220 2930                 	sts noise_duty_macro+1, zero
001ded 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch offset
001def 9220 2923                 	sts noise_total_pitch_offset+1, zero
001df1 9220 2929                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001df3 9631                      	adiw Z, 1 //point to the byte next to the flag
001df4 91b4                      	lpm r27, Z //store the instrument offset into r27
001df5 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001df6 e0fd                      	ldi ZH, HIGH(instruments)
001df7 0feb                      	add ZL, r27 //point Z to offsetted instrument
001df8 1df2                      	adc ZH, zero
001df9 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001dfa 1fff                      	rol ZH
001dfb 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001dfc 91b4                      	lpm r27, Z
                                 
001dfd 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001dfe 1fbb                      	rol r27
001dff 2fea                      	mov ZL, r26
001e00 2ffb                      	mov ZH, r27
001e01 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001e02 9632                      	adiw Z, 2 //point Z to the address of the macro
001e03 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
001e04 95aa                      	dec r26
001e05 f019                      	breq sound_driver_channel3_instrument_change_exit
001e06 95b6                      	lsr r27
001e07 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
001e08 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
001e09 e0a3                      	ldi r26, 0x03
001e0a e0b2                      	ldi r27, 0x02
001e0b 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001e0d 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
001e0f 93b0 2926                 	sts noise_pitch_macro_offset, r27
001e11 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
001e13 93b0 2931                 	sts noise_duty_macro_offset, r27
001e15 d0a2                      	rcall sound_driver_channel3_increment_offset_twice
001e16 cef2                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
001e17 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001e18 91d5                      	lpm r29, Z+
                                 
001e19 30a5                      	cpi r26, 5
001e1a f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
001e1b 30a4                      	cpi r26, 4
001e1c f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
001e1d 30a3                      	cpi r26, 3
001e1e f099                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
001e1f 30a2                      	cpi r26, 2
001e20 f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
001e21 c024                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
001e22 93c0 2917                 	sts noise_volume_macro, r28
001e24 93d0 2918                 	sts noise_volume_macro+1, r29
001e26 d029                      	rcall sound_driver_channel3_instrument_change_read_header
001e27 93c0 291b                 	sts noise_volume_macro_release, r28
001e29 93d0 291a                 	sts noise_volume_macro_loop, r29
001e2b cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
001e2c 93c0 291c                 	sts noise_arpeggio_macro, r28
001e2e 93d0 291d                 	sts noise_arpeggio_macro+1, r29
001e30 d02a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
001e31 cfd2                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
001e32 93c0 2924                 	sts noise_pitch_macro, r28
001e34 93d0 2925                 	sts noise_pitch_macro+1, r29
001e36 d019                      	rcall sound_driver_channel3_instrument_change_read_header
001e37 93c0 2928                 	sts noise_pitch_macro_release, r28
001e39 93d0 2927                 	sts noise_pitch_macro_loop, r29
001e3b cfc8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
001e3c 93c0 292a                 	sts noise_hi_pitch_macro, r28
001e3e 93d0 292b                 	sts noise_hi_pitch_macro+1, r29
001e40 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
001e41 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
001e43 93d0 292d                 	sts noise_hi_pitch_macro_loop, r29
001e45 cfbe                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
001e46 93c0 292f                 	sts noise_duty_macro, r28
001e48 93d0 2930                 	sts noise_duty_macro+1, r29
001e4a d005                      	rcall sound_driver_channel3_instrument_change_read_header
001e4b 93c0 2933                 	sts noise_duty_macro_release, r28
001e4d 93d0 2932                 	sts noise_duty_macro_loop, r29
001e4f cfb4                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
001e50 93ef                      	push ZL
001e51 93ff                      	push ZH
001e52 2fec                      	mov ZL, r28
001e53 2ffd                      	mov ZH, r29
001e54 0fee                      	lsl ZL
001e55 1fff                      	rol ZH
001e56 91c5                      	lpm r28, Z+
001e57 91d4                      	lpm r29, Z
001e58 91ff                      	pop ZH
001e59 91ef                      	pop ZL
001e5a 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
001e5b 93ef                      	push ZL
001e5c 93ff                      	push ZH
001e5d 2fec                      	mov ZL, r28
001e5e 2ffd                      	mov ZH, r29
001e5f 0fee                      	lsl ZL
001e60 1fff                      	rol ZH
001e61 91c5                      	lpm r28, Z+
001e62 91d5                      	lpm r29, Z+
001e63 93c0 2920                 	sts noise_arpeggio_macro_release, r28
001e65 93d0 291f                 	sts noise_arpeggio_macro_loop, r29
001e67 91c4                      	lpm r28, Z
001e68 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
001e6a 91ff                      	pop ZH
001e6b 91ef                      	pop ZL
001e6c 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
001e6d 91b0 291b                 	lds r27, noise_volume_macro_release
001e6f 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001e70 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
001e71 95b3                      	inc r27
001e72 93b0 2919                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
001e74 91b0 2920                 	lds r27, noise_arpeggio_macro_release
001e76 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001e77 f019                      	breq sound_driver_channel3_release_pitch
001e78 95b3                      	inc r27
001e79 93b0 291e                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
001e7b 91b0 2928                 	lds r27, noise_pitch_macro_release
001e7d 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001e7e f019                      	breq sound_driver_channel3_release_hi_pitch
001e7f 95b3                      	inc r27
001e80 93b0 2926                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
001e82 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
001e84 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001e85 f019                      	breq sound_driver_channel3_release_duty
001e86 95b3                      	inc r27
001e87 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
001e89 91b0 2933                 	lds r27, noise_duty_macro_release
001e8b 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001e8c f019                      	breq sound_driver_channel3_release_exit
001e8d 95b3                      	inc r27
001e8e 93b0 2931                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
001e90 d01d                      	rcall sound_driver_channel3_increment_offset
001e91 ce77                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
001e92 91e0 2819                 	lds ZL, song_frames
001e94 91f0 281a                 	lds ZH, song_frames+1
001e96 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001e98 91b0 281c                 	lds r27, song_frame_offset+1
001e9a 93a0 281b                 	sts song_frame_offset, r26
001e9c 93b0 281c                 	sts song_frame_offset+1, r27
001e9e 9616                      	adiw r27:r26, 6 //offset for channel 3
001e9f 0fea                      	add ZL, r26
001ea0 1ffb                      	adc ZH, r27
                                 
001ea1 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ea2 91b4                      	lpm r27, Z
001ea3 0faa                      	lsl r26
001ea4 1fbb                      	rol r27
001ea5 93a0 2911                 	sts noise_pattern, r26
001ea7 93b0 2912                 	sts noise_pattern+1, r27
                                 
001ea9 9220 2915                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001eab 9220 2916                 	sts noise_pattern_offset+1, zero
001ead ce5b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
001eae 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
001eb0 91f0 2916                 	lds ZH, noise_pattern_offset+1
001eb2 9631                      	adiw Z, 1
001eb3 93e0 2915                 	sts noise_pattern_offset, ZL
001eb5 93f0 2916                 	sts noise_pattern_offset+1, ZH
001eb7 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001eb8 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
001eba 91f0 2916                 	lds ZH, noise_pattern_offset+1
001ebc 9632                      	adiw Z, 2 //increment the pointer twice
001ebd 93e0 2915                 	sts noise_pattern_offset, ZL
001ebf 93f0 2916                 	sts noise_pattern_offset+1, ZH
001ec1 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
001ec2 95ba                      	dec r27
001ec3 93b0 2914                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
001ec5 91f0 281f                 	lds r31, song_speed
001ec7 2fef                      	mov r30, r31
001ec8 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
001ec9 91a0 2826                 	lds r26, pulse1_pattern_delay_frames
001ecb 11a2                      	cpse r26, zero
001ecc c042                      	rjmp sound_driver_calculate_delays_pulse2
001ecd c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
001ece 2faf                      	mov r26, r31 //move the speed to r26
001ecf 91b0 2825                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
001ed1 15b2                      	cp r27, zero
001ed2 f409                      	brne PC+2
001ed3 c03b                      	rjmp sound_driver_calculate_delays_pulse2
001ed4 95ba                      	dec r27
001ed5 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001ed7 11b2                      	cpse r27, zero
001ed8 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
001ed9 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
001eda efbf                      	ldi r27, 0xFF
001edb 91c0 2872                 	lds r28, pulse1_fx_Sxx_pre
001edd 91d0 2873                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
001edf 17cb                      	cp r28, r27
001ee0 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
001ee1 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
001ee2 17db                      	cp r29, r27
001ee3 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
001ee4 c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
001ee5 91c0 2860                 	lds r28, pulse1_fx_Gxx_pre
001ee7 91d0 2861                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
001ee9 17cb                      	cp r28, r27
001eea f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
001eeb c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
001eec 17db                      	cp r29, r27
001eed f0f9                      	breq sound_driver_calculate_delays_pulse1_store
001eee c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
001eef 93b0 2872                 	sts pulse1_fx_Sxx_pre, r27
001ef1 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001ef2 93e0 2873                 	sts pulse1_fx_Sxx_post, r30
001ef4 95ca                      	dec r28
001ef5 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
001ef7 2fef                      	mov r30, r31
001ef8 50e1                      	subi r30, 1
001ef9 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
001efa 93b0 2873                 	sts pulse1_fx_Sxx_post, r27
001efc 2fad                      	mov r26, r29
001efd c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
001efe 93b0 2860                 	sts pulse1_fx_Gxx_pre, r27
001f00 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001f01 93e0 2861                 	sts pulse1_fx_Gxx_post, r30
001f03 95ca                      	dec r28
001f04 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
001f06 2fef                      	mov r30, r31
001f07 50e1                      	subi r30, 1
001f08 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
001f09 93b0 2861                 	sts pulse1_fx_Gxx_post, r27
001f0b 2fad                      	mov r26, r29
001f0c c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
001f0d 93a0 2826                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
001f0f 91a0 2877                 	lds r26, pulse2_pattern_delay_frames
001f11 11a2                      	cpse r26, zero
001f12 c042                      	rjmp sound_driver_calculate_delays_triangle
001f13 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
001f14 2faf                      	mov r26, r31 //move the speed to r26
001f15 91b0 2876                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
001f17 15b2                      	cp r27, zero
001f18 f409                      	brne PC+2
001f19 c03b                      	rjmp sound_driver_calculate_delays_triangle
001f1a 95ba                      	dec r27
001f1b 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001f1d 11b2                      	cpse r27, zero
001f1e c034                      	rjmp sound_driver_calculate_delays_pulse2_store
001f1f 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
001f20 efbf                      	ldi r27, 0xFF
001f21 91c0 28c3                 	lds r28, pulse2_fx_Sxx_pre
001f23 91d0 28c4                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
001f25 17cb                      	cp r28, r27
001f26 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
001f27 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
001f28 17db                      	cp r29, r27
001f29 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
001f2a c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
001f2b 91c0 28b1                 	lds r28, pulse2_fx_Gxx_pre
001f2d 91d0 28b2                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
001f2f 17cb                      	cp r28, r27
001f30 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
001f31 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
001f32 17db                      	cp r29, r27
001f33 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
001f34 c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
001f35 93b0 28c3                 	sts pulse2_fx_Sxx_pre, r27
001f37 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001f38 93e0 28c4                 	sts pulse2_fx_Sxx_post, r30
001f3a 95ca                      	dec r28
001f3b 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
001f3d 2fef                      	mov r30, r31
001f3e 50e1                      	subi r30, 1
001f3f cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
001f40 93b0 28c4                 	sts pulse2_fx_Sxx_post, r27
001f42 2fad                      	mov r26, r29
001f43 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
001f44 93b0 28b1                 	sts pulse2_fx_Gxx_pre, r27
001f46 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001f47 93e0 28b2                 	sts pulse2_fx_Gxx_post, r30
001f49 95ca                      	dec r28
001f4a 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
001f4c 2fef                      	mov r30, r31
001f4d 50e1                      	subi r30, 1
001f4e cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
001f4f 93b0 28b2                 	sts pulse2_fx_Gxx_post, r27
001f51 2fad                      	mov r26, r29
001f52 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
001f53 93a0 2877                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
001f55 91a0 28c8                 	lds r26, triangle_pattern_delay_frames
001f57 11a2                      	cpse r26, zero
001f58 c042                      	rjmp sound_driver_calculate_delays_noise
001f59 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
001f5a 2faf                      	mov r26, r31 //move the speed to r26
001f5b 91b0 28c7                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
001f5d 15b2                      	cp r27, zero
001f5e f409                      	brne PC+2
001f5f c03b                      	rjmp sound_driver_calculate_delays_noise
001f60 95ba                      	dec r27
001f61 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001f63 11b2                      	cpse r27, zero
001f64 c034                      	rjmp sound_driver_calculate_delays_triangle_store
001f65 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
001f66 efbf                      	ldi r27, 0xFF
001f67 91c0 290f                 	lds r28, triangle_fx_Sxx_pre
001f69 91d0 2910                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
001f6b 17cb                      	cp r28, r27
001f6c f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
001f6d c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
001f6e 17db                      	cp r29, r27
001f6f f009                      	breq sound_driver_calculate_delays_triangle_Gxx
001f70 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
001f71 91c0 28fd                 	lds r28, triangle_fx_Gxx_pre
001f73 91d0 28fe                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
001f75 17cb                      	cp r28, r27
001f76 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
001f77 c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
001f78 17db                      	cp r29, r27
001f79 f0f9                      	breq sound_driver_calculate_delays_triangle_store
001f7a c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
001f7b 93b0 290f                 	sts triangle_fx_Sxx_pre, r27
001f7d 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001f7e 93e0 2910                 	sts triangle_fx_Sxx_post, r30
001f80 95ca                      	dec r28
001f81 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
001f83 2fef                      	mov r30, r31
001f84 50e1                      	subi r30, 1
001f85 c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
001f86 93b0 2910                 	sts triangle_fx_Sxx_post, r27
001f88 2fad                      	mov r26, r29
001f89 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
001f8a 93b0 28fd                 	sts triangle_fx_Gxx_pre, r27
001f8c 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001f8d 93e0 28fe                 	sts triangle_fx_Gxx_post, r30
001f8f 95ca                      	dec r28
001f90 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
001f92 2fef                      	mov r30, r31
001f93 50e1                      	subi r30, 1
001f94 c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
001f95 93b0 28fe                 	sts triangle_fx_Gxx_post, r27
001f97 2fad                      	mov r26, r29
001f98 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
001f99 93a0 28c8                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
001f9b 91a0 2914                 	lds r26, noise_pattern_delay_frames
001f9d 11a2                      	cpse r26, zero
001f9e c042                      	rjmp sound_driver_calculate_delays_dpcm
001f9f c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
001fa0 2faf                      	mov r26, r31 //move the speed to r26
001fa1 91b0 2913                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
001fa3 15b2                      	cp r27, zero
001fa4 f409                      	brne PC+2
001fa5 c03b                      	rjmp sound_driver_calculate_delays_dpcm
001fa6 95ba                      	dec r27
001fa7 93b0 2913                 	sts noise_pattern_delay_rows, r27
001fa9 11b2                      	cpse r27, zero
001faa c034                      	rjmp sound_driver_calculate_delays_noise_store
001fab 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
001fac efbf                      	ldi r27, 0xFF
001fad 91c0 2946                 	lds r28, noise_fx_Sxx_pre
001faf 91d0 2947                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
001fb1 17cb                      	cp r28, r27
001fb2 f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
001fb3 c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
001fb4 17db                      	cp r29, r27
001fb5 f009                      	breq sound_driver_calculate_delays_noise_Gxx
001fb6 c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
001fb7 91c0 2943                 	lds r28, noise_fx_Gxx_pre
001fb9 91d0 2944                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
001fbb 17cb                      	cp r28, r27
001fbc f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
001fbd c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
001fbe 17db                      	cp r29, r27
001fbf f0f9                      	breq sound_driver_calculate_delays_noise_store
001fc0 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
001fc1 93b0 2946                 	sts noise_fx_Sxx_pre, r27
001fc3 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001fc4 93e0 2947                 	sts noise_fx_Sxx_post, r30
001fc6 95ca                      	dec r28
001fc7 93c0 2914                 	sts noise_pattern_delay_frames, r28
001fc9 2fef                      	mov r30, r31
001fca 50e1                      	subi r30, 1
001fcb c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
001fcc 93b0 2947                 	sts noise_fx_Sxx_post, r27
001fce 2fad                      	mov r26, r29
001fcf c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
001fd0 93b0 2943                 	sts noise_fx_Gxx_pre, r27
001fd2 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001fd3 93e0 2944                 	sts noise_fx_Gxx_post, r30
001fd5 95ca                      	dec r28
001fd6 93c0 2914                 	sts noise_pattern_delay_frames, r28
001fd8 2fef                      	mov r30, r31
001fd9 50e1                      	subi r30, 1
001fda c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
001fdb 93b0 2944                 	sts noise_fx_Gxx_post, r27
001fdd 2fad                      	mov r26, r29
001fde c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
001fdf 93a0 2914                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
001fe1 91e0 2829                 	lds ZL, pulse1_volume_macro
001fe3 91f0 282a                 	lds ZH, pulse1_volume_macro+1
001fe5 9630                      	adiw Z, 0
001fe6 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
001fe7 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001fe8 1fff                      	rol ZH
001fe9 91a0 282b                 	lds r26, pulse1_volume_macro_offset
001feb 0fea                      	add ZL, r26
001fec 1df2                      	adc ZH, zero
                                 
001fed 91b0 282d                 	lds r27, pulse1_volume_macro_release
001fef 17ba                      	cp r27, r26
001ff0 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
001ff1 91a0 282c                 	lds r26, pulse1_volume_macro_loop
001ff3 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001ff4 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001ff5 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
001ff6 95a3                      	inc r26 //increment the macro offset
001ff7 93a0 282b                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
001ff9 91b4                      	lpm r27, Z //load volume data into r27
001ffa 3fbf                      	cpi r27, 0xFF //check for macro end flag
001ffb f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
001ffc 91b0 282d                 	lds r27, pulse1_volume_macro_release
001ffe 3fbf                      	cpi r27, 0xFF
001fff f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
002000 91b0 282c                 	lds r27, pulse1_volume_macro_loop //load the loop index
002002 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
002004 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
002005 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002006 93a0 282b                 	sts pulse1_volume_macro_offset, r26
002008 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
002009 efe0                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
00200a e5f7                      	ldi ZH, HIGH(volumes << 1)
00200b 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
00200c 0feb                      	add ZL, r27 //add offset to the table
00200d 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
00200e 91b0 2800                 	lds r27, pulse1_param //load main volume
002010 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002011 91a0 285e                 	lds r26, pulse1_fx_7xy_value
002013 30a0                      	cpi r26, 0x00
002014 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
002015 0feb                      	add ZL, r27 //offset the volume table by the main volume
002016 1df2                      	adc ZH, zero
002017 91b4                      	lpm r27, Z
002018 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00201a c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
00201b 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
00201d 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00201e 91a0 285e                 	lds r26, pulse1_fx_7xy_value
002020 30a0                      	cpi r26, 0x00
002021 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
002022 93b0 2806                 	sts pulse1_output_volume, r27
002024 c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
002025 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002026 f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
002027 f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
002028 0feb                      	add ZL, r27 //offset the volume table by the main volume
002029 1df2                      	adc ZH, zero
00202a 91b4                      	lpm r27, Z
00202b 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00202d c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
00202e e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00202f 0feb                      	add ZL, r27 //offset the volume table by the main volume
002030 1df2                      	adc ZH, zero
002031 91b4                      	lpm r27, Z
002032 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002034 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
002035 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002036 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002037 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002038 93b0 2806                 	sts pulse1_output_volume, r27
00203a c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
00203b e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00203c 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00203e 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
002040 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
002042 9630                      	adiw Z, 0
002043 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002044 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002045 1fff                      	rol ZH
002046 91a0 2830                 	lds r26, pulse1_arpeggio_macro_offset
002048 0fea                      	add ZL, r26
002049 1df2                      	adc ZH, zero
                                 
00204a 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
00204c 17ba                      	cp r27, r26
00204d f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00204e 91a0 2831                 	lds r26, pulse1_arpeggio_macro_loop
002050 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002051 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002052 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
002053 95a3                      	inc r26 //increment the macro offset
002054 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
002056 91b4                      	lpm r27, Z //load arpeggio data into r27
002057 38b0                      	cpi r27, 0x80 //check for macro end flag
002058 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002059 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
00205a 50a1                      	subi r26, 1 //keep the offset at the end flag
00205b 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
00205d 91b0 2833                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00205f 30b1                      	cpi r27, 0x01
002060 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
002061 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
002063 3fbf                      	cpi r27, 0xFF
002064 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
002065 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop
002067 3fbf                      	cpi r27, 0xFF
002068 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002069 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
00206a 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
00206c 3fbf                      	cpi r27, 0xFF
00206d f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
00206e 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
002070 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002071 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
002072 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
002074 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
002076 9620                      	adiw r29:r28, 0
002077 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002078 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002079 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
00207b cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
00207c 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
00207e cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
00207f 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
002081 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
002083 9620                      	adiw r29:r28, 0 //check for 0xy effect
002084 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
002085 95d6                      	lsr r29
002086 95c7                      	ror r28
002087 95d7                      	ror r29
002088 95c7                      	ror r28
002089 95d7                      	ror r29
00208a 95c7                      	ror r28
00208b 95d7                      	ror r29
00208c 95c7                      	ror r28
00208d 95d7                      	ror r29
00208e 95d2                      	swap r29
                                 
00208f 93c0 2846                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
002091 93d0 2847                 	sts pulse1_fx_0xy_sequence+1, r29
002093 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002094 91a0 2807                 	lds r26, pulse1_note //load the current note index
002096 0fac                      	add r26, r28 //add the note offset
002097 c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002098 91a0 2807                 	lds r26, pulse1_note //load the current note index
00209a c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
00209b 9220 2834                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00209d 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
00209f 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
0020a1 91a0 2833                 	lds r26, pulse1_arpeggio_macro_mode
0020a3 30a1                      	cpi r26, 0x01 //absolute mode
0020a4 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0020a5 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0020a6 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0020a7 91a0 2807                 	lds r26, pulse1_note //load the current note index
0020a9 0fab                      	add r26, r27 //offset the note with the arpeggio data
0020aa fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0020ab c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0020ac 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0020ad f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0020ae e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0020af c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0020b0 fda7                      	sbrc r26, 7 //check if result is negative
0020b1 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0020b2 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0020b3 2fab                      	mov r26, r27 //move the arpeggio data into r26
0020b4 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0020b5 91a0 2807                 	lds r26, pulse1_note //load the current note index
0020b7 0fab                      	add r26, r27 //offset the note with the arpeggio data
0020b8 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0020b9 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0020ba 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0020bc 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0020bd f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0020be e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0020bf 93a0 2807                 	sts pulse1_note, r26
0020c1 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
0020c2 fda7                      	sbrc r26, 7 //check if result is negative
0020c3 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0020c4 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
0020c6 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0020c7 e0f0                      	ldi ZH, HIGH(note_table << 1)
0020c8 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0020c9 0fea                      	add ZL, r26 //add offset
0020ca 1df2                      	adc ZH, zero
0020cb 91a5                      	lpm r26, Z+ //load bytes
0020cc 91b4                      	lpm r27, Z
0020cd 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
0020cf 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
0020d1 93a0 2852                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0020d3 93b0 2853                 	sts pulse1_fx_3xx_target+1, r27
0020d5 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
0020d6 91e0 2836                 	lds ZL, pulse1_pitch_macro
0020d8 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
0020da 9630                      	adiw Z, 0
0020db f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
0020dc c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
0020dd 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0020de 1fff                      	rol ZH
0020df 91a0 2838                 	lds r26, pulse1_pitch_macro_offset
0020e1 0fea                      	add ZL, r26
0020e2 1df2                      	adc ZH, zero
                                 
0020e3 91b0 283a                 	lds r27, pulse1_pitch_macro_release
0020e5 17ba                      	cp r27, r26
0020e6 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0020e7 91a0 2839                 	lds r26, pulse1_pitch_macro_loop
0020e9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0020ea f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0020eb c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0020ec 95a3                      	inc r26 //increment the macro offset
0020ed 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0020ef 91b4                      	lpm r27, Z //load pitch data into r27
0020f0 38b0                      	cpi r27, 0x80 //check for macro end flag
0020f1 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0020f2 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0020f3 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
0020f5 91b0 283a                 	lds r27, pulse1_pitch_macro_release
0020f7 3fbf                      	cpi r27, 0xFF
0020f8 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0020f9 91b0 2839                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0020fb 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0020fc f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0020fd 93b0 2838                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0020ff cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002100 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002101 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002102 937f                      	push r23
002103 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002104 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002105 0367                      	mulsu r22, r23
002106 917f                      	pop r23
002107 916f                      	pop r22
                                 
002108 9416                      	lsr r1 //shift out the fractional bits
002109 9407                      	ror r0
00210a 9416                      	lsr r1
00210b 9407                      	ror r0
00210c 9416                      	lsr r1
00210d 9407                      	ror r0
00210e 9416                      	lsr r1
00210f 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
002110 fe13                      	sbrs r1, 3 //check if result was a negative number
002111 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
002112 efc0                      	ldi r28, 0xF0
002113 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
002114 70b7                      	andi r27, 0b00000111
002115 f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
002116 e0b1                      	ldi r27, 0x01
002117 0e0b                      	add r0, r27
002118 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002119 91a0 2834                 	lds r26, pulse1_total_pitch_offset
00211b 91b0 2835                 	lds r27, pulse1_total_pitch_offset+1
00211d 0e0a                      	add r0, r26
00211e 1e1b                      	adc r1, r27
00211f 9200 2834                 	sts pulse1_total_pitch_offset, r0
002121 9210 2835                 	sts pulse1_total_pitch_offset+1, r1
002123 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002125 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002127 0da0                      	add r26, r0 //offset the timer values
002128 1db1                      	adc r27, r1
                                 	
002129 91c0 284a                 	lds r28, pulse1_fx_1xx_total
00212b 91d0 284b                 	lds r29, pulse1_fx_1xx_total+1
00212d 1bac                      	sub r26, r28
00212e 0bbd                      	sbc r27, r29
00212f 91c0 284e                 	lds r28, pulse1_fx_2xx_total
002131 91d0 284f                 	lds r29, pulse1_fx_2xx_total+1
002133 0fac                      	add r26, r28
002134 1fbd                      	adc r27, r29
002135 91c0 2862                 	lds r28, pulse1_fx_Pxx_total
002137 91d0 2863                 	lds r29, pulse1_fx_Pxx_total+1
002139 0fac                      	add r26, r28
00213a 1fbd                      	adc r27, r29
00213b 91c0 2869                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00213d 91d0 286a                 	lds r29, pulse1_fx_Qxy_total_offset+1
00213f 1bac                      	sub r26, r28
002140 0bbd                      	sbc r27, r29
002141 91c0 2870                 	lds r28, pulse1_fx_Rxy_total_offset
002143 91d0 2871                 	lds r29, pulse1_fx_Rxy_total_offset+1
002145 0fac                      	add r26, r28
002146 1fbd                      	adc r27, r29
                                 
002147 e5c9                      	ldi r28, 0x59
002148 e0d0                      	ldi r29, 0x00
002149 17ac                      	cp r26, r28
00214a 07bd                      	cpc r27, r29
00214b f030                      	brlo sound_driver_instrument_routine_channel0_pitch_min
                                 
00214c e5ca                      	ldi r28, 0x5A
00214d e5d9                      	ldi r29, 0x59
00214e 17ac                      	cp r26, r28
00214f 07bd                      	cpc r27, r29
002150 f420                      	brsh sound_driver_instrument_routine_channel0_pitch_max
002151 c006                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_min:
002152 e5c9                      	ldi r28, 0x59
002153 e0d0                      	ldi r29, 0x00
002154 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_max:
002155 e5c9                      	ldi r28, 0x59
002156 e5d9                      	ldi r29, 0x59
002157 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_store:
002158 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00215a 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
00215c 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
00215e 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
002160 9630                      	adiw Z, 0
002161 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
002162 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
002163 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002164 1fff                      	rol ZH
002165 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_offset
002167 0fea                      	add ZL, r26
002168 1df2                      	adc ZH, zero
                                 
002169 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
00216b 17ba                      	cp r27, r26
00216c f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00216d 91a0 283f                 	lds r26, pulse1_hi_pitch_macro_loop
00216f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002170 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002171 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
002172 95a3                      	inc r26 //increment the macro offset
002173 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
002175 91b4                      	lpm r27, Z //load hi pitch data into r27
002176 38b0                      	cpi r27, 0x80 //check for macro end flag
002177 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
002178 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002179 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
00217b 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
00217d 3fbf                      	cpi r27, 0xFF
00217e f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
00217f 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
002181 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002182 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002183 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
002185 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
002186 91b0 283b                 	lds r27, pulse1_total_hi_pitch_offset
002188 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
002189 91a0 283b                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
00218b 0fba                      	add r27, r26
00218c 93b0 283b                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
00218e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00218f 937f                      	push r23
002190 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002191 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002192 0367                      	mulsu r22, r23
002193 917f                      	pop r23
002194 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
002195 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002197 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002199 0da0                      	add r26, r0 //offset the timer values
00219a 1db1                      	adc r27, r1
00219b 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00219d 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
00219f 91e0 2841                 	lds ZL, pulse1_duty_macro
0021a1 91f0 2842                 	lds ZH, pulse1_duty_macro+1
0021a3 9630                      	adiw Z, 0
0021a4 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0021a5 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0021a6 1fff                      	rol ZH
0021a7 91a0 2843                 	lds r26, pulse1_duty_macro_offset
0021a9 0fea                      	add ZL, r26
0021aa 1df2                      	adc ZH, zero
                                 
0021ab 91b0 2845                 	lds r27, pulse1_duty_macro_release
0021ad 17ba                      	cp r27, r26
0021ae f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0021af 91a0 2844                 	lds r26, pulse1_duty_macro_loop
0021b1 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0021b2 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0021b3 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0021b4 95a3                      	inc r26 //increment the macro offset
0021b5 93a0 2843                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0021b7 91b4                      	lpm r27, Z //load pitch data into r27
0021b8 3fbf                      	cpi r27, 0xFF //check for macro end flag
0021b9 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0021ba 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0021bb 93a0 2843                 	sts pulse1_duty_macro_offset, r26
0021bd 91b0 2845                 	lds r27, pulse1_duty_macro_release
0021bf 3fbf                      	cpi r27, 0xFF
0021c0 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0021c1 91b0 2844                 	lds r27, pulse1_duty_macro_loop //load the loop index
0021c3 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0021c4 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0021c5 93b0 2843                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0021c7 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0021c8 e1ec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0021c9 e5f7                      	ldi ZH, HIGH(sequences << 1)
0021ca 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0021cb 1df2                      	adc ZH, zero
                                 
0021cc 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0021cd 95b7                      	ror r27
0021ce 95b7                      	ror r27
0021cf 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0021d1 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0021d2 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0021d3 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0021d4 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0021d5 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0021d6 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0021d7 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0021d8 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0021d9 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0021db 91e0 2848                 	lds ZL, pulse1_fx_1xx
0021dd 91f0 2849                 	lds ZH, pulse1_fx_1xx+1
0021df 9630                      	adiw Z, 0
0021e0 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0021e1 91a0 284a                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0021e3 91b0 284b                 	lds r27, pulse1_fx_1xx_total+1
0021e5 0fae                      	add r26, ZL //increase the total offset by the rate
0021e6 1fbf                      	adc r27, ZH
0021e7 93a0 284a                 	sts pulse1_fx_1xx_total, r26
0021e9 93b0 284b                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0021eb 91e0 284c                 	lds ZL, pulse1_fx_2xx
0021ed 91f0 284d                 	lds ZH, pulse1_fx_2xx+1
0021ef 9630                      	adiw Z, 0
0021f0 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0021f1 91a0 284e                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0021f3 91b0 284f                 	lds r27, pulse1_fx_2xx_total+1
0021f5 0fae                      	add r26, ZL //increase the total offset by the rate
0021f6 1fbf                      	adc r27, ZH
0021f7 93a0 284e                 	sts pulse1_fx_2xx_total, r26
0021f9 93b0 284f                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0021fb 91e0 2854                 	lds ZL, pulse1_fx_3xx_speed
0021fd 91f0 2855                 	lds ZH, pulse1_fx_3xx_speed+1
0021ff 9630                      	adiw Z, 0
002200 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
002201 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
002202 91a0 2850                 	lds r26, pulse1_fx_3xx_start
002204 91b0 2851                 	lds r27, pulse1_fx_3xx_start+1
002206 9610                      	adiw r26:r27, 0
002207 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
002208 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
002209 91c0 2852                 	lds r28, pulse1_fx_3xx_target
00220b 91d0 2853                 	lds r29, pulse1_fx_3xx_target+1
                                 
00220d 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00220e 07bd                      	cpc r27, r29
00220f f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
002210 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002211 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
002212 9220 2850                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002214 9220 2851                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002216 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
002217 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002218 0bdb                      	sbc r29, r27
002219 91a0 2856                 	lds r26, pulse1_fx_3xx_total_offset
00221b 91b0 2857                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
00221d 0fae                      	add r26, ZL //add the speed to the total offset
00221e 1fbf                      	adc r27, ZH
00221f 1bca                      	sub r28, r26 //invert the total difference with the total offset
002220 0bdb                      	sbc r29, r27
002221 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002222 93a0 2856                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
002224 93b0 2857                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
002226 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
002228 91b0 0a8d                 	lds r27, TCB0_CCMPH
00222a 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00222b 0bbd                      	sbc r27, r29
00222c 93a0 0a8c                 	sts TCB0_CCMPL, r26
00222e 93b0 0a8d                 	sts TCB0_CCMPH, r27
002230 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002231 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002232 0bbd                      	sbc r27, r29
002233 91c0 2856                 	lds r28, pulse1_fx_3xx_total_offset
002235 91d0 2857                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
002237 0fce                      	add r28, ZL //add the speed to the total offset
002238 1fdf                      	adc r29, ZH
002239 1bac                      	sub r26, r28 //invert the total difference with the total offset
00223a 0bbd                      	sbc r27, r29
00223b f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00223c 93c0 2856                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
00223e 93d0 2857                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
002240 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
002242 91d0 0a8d                 	lds r29, TCB0_CCMPH
002244 0fca                      	add r28, r26 //offset the current timer period with the total offset
002245 1fdb                      	adc r29, r27
002246 93c0 0a8c                 	sts TCB0_CCMPL, r28
002248 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
00224a 91a0 2858                 	lds r26, pulse1_fx_4xy_speed
00224c 15a2                      	cp r26, zero
00224d f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
00224e c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00224f 91b0 2859                 	lds r27, pulse1_fx_4xy_depth
002251 91c0 285a                 	lds r28, pulse1_fx_4xy_phase
002253 0fca                      	add r28, r26 //increase the phase by the speed
002254 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002255 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002256 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
002257 93c0 285a                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002259 31c0                      	cpi r28, 16
00225a f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
00225b 32c0                      	cpi r28, 32
00225c f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
00225d 33c0                      	cpi r28, 48
00225e f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
00225f c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
002260 70cf                      	andi r28, 0x0F //mask for values 0-15
002261 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
002262 6fc0                      	ori r28, 0xF0
002263 95c0                      	com r28 //invert values 0-15
002264 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
002265 70cf                      	andi r28, 0x0F //mask for values 0-15
002266 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
002267 6fc0                      	ori r28, 0xF0
002268 95c0                      	com r28 //invert values 0-15
002269 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
00226a 95b2                      	swap r27 //multiply depth by 16
00226b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00226c e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00226d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00226e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00226f 1df2                      	adc ZH, zero
002270 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002271 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002272 937f                      	push r23
002273 2f6c                      	mov r22, r28 //store the vibrato value into r22
002274 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002275 9f67                      	mul r22, r23
002276 917f                      	pop r23
002277 916f                      	pop r22
                                 
002278 9416                      	lsr r1 //shift out the fractional bits
002279 9407                      	ror r0
00227a 9416                      	lsr r1
00227b 9407                      	ror r0
00227c 9416                      	lsr r1
00227d 9407                      	ror r0
00227e 9416                      	lsr r1
00227f 9407                      	ror r0
                                 	
002280 91a0 0a8c                 	lds r26, TCB0_CCMPL
002282 91b0 0a8d                 	lds r27, TCB0_CCMPH
002284 0da0                      	add r26, r0
002285 1db1                      	adc r27, r1
002286 93a0 0a8c                 	sts TCB0_CCMPL, r26
002288 93b0 0a8d                 	sts TCB0_CCMPH, r27
00228a c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
00228b 95b2                      	swap r27 //multiply depth by 16
00228c 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00228d e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00228e e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00228f 0fec                      	add ZL, r28 //offset the table by the depth+phase
002290 1df2                      	adc ZH, zero
002291 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002292 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002293 937f                      	push r23
002294 2f6c                      	mov r22, r28 //store the vibrato value into r22
002295 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002296 9f67                      	mul r22, r23
002297 917f                      	pop r23
002298 916f                      	pop r22
                                 
002299 9416                      	lsr r1 //shift out the fractional bits
00229a 9407                      	ror r0
00229b 9416                      	lsr r1
00229c 9407                      	ror r0
00229d 9416                      	lsr r1
00229e 9407                      	ror r0
00229f 9416                      	lsr r1
0022a0 9407                      	ror r0
                                 
0022a1 91a0 0a8c                 	lds r26, TCB0_CCMPL
0022a3 91b0 0a8d                 	lds r27, TCB0_CCMPH
0022a5 19a0                      	sub r26, r0
0022a6 09b1                      	sbc r27, r1
0022a7 93a0 0a8c                 	sts TCB0_CCMPL, r26
0022a9 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0022ab 91a0 285b                 	lds r26, pulse1_fx_7xy_speed
0022ad 15a2                      	cp r26, zero
0022ae f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0022af 91b0 285c                 	lds r27, pulse1_fx_7xy_depth
0022b1 91c0 285d                 	lds r28, pulse1_fx_7xy_phase
0022b3 0fca                      	add r28, r26 //increase the phase by the speed
0022b4 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0022b5 f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0022b6 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0022b7 93c0 285d                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
0022b9 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0022ba ffc4                      	sbrs r28, 4
0022bb c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
0022bc c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
0022bd 70cf                      	andi r28, 0x0F //mask for values 0-15
0022be c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
0022bf 6fc0                      	ori r28, 0xF0
0022c0 95c0                      	com r28 //invert values 0-15
0022c1 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
0022c2 95b2                      	swap r27 //multiply depth by 16
0022c3 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0022c4 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0022c5 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0022c6 0fec                      	add ZL, r28 //offset the table by the depth+phase
0022c7 1df2                      	adc ZH, zero
0022c8 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0022c9 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0022ca 93c0 285e                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
0022cc 91b0 285f                 	lds r27, pulse1_fx_Axy
0022ce 15b2                      	cp r27, zero
0022cf f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0022d0 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0022d2 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0022d4 2fda                      	mov r29, r26 //copy fractional volume into r29
0022d5 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0022d6 95e2                      	swap r30
0022d7 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0022d8 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0022d9 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0022da f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0022db 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0022dc fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0022dd c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0022de 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0022df f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0022e0 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0022e1 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0022e2 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0022e3 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0022e4 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0022e5 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0022e7 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0022e8 95a2                      	swap r26
0022e9 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0022ea 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0022eb 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0022ed 91e0 2865                 	lds ZL, pulse1_fx_Qxy_target
0022ef 91f0 2866                 	lds ZH, pulse1_fx_Qxy_target+1
0022f1 9630                      	adiw Z, 0
0022f2 f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0022f3 91a0 2869                 	lds r26, pulse1_fx_Qxy_total_offset
0022f5 91b0 286a                 	lds r27, pulse1_fx_Qxy_total_offset+1
0022f7 91c0 0a8c                 	lds r28, TCB0_CCMPL
0022f9 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0022fb 1bec                      	sub ZL, r28 //calculate the difference to the target
0022fc 0bfd                      	sbc ZH, r29
0022fd f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0022fe f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0022ff 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
002301 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
002303 9220 2865                 	sts pulse1_fx_Qxy_target, zero
002305 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
002307 91b0 2864                 	lds r27, pulse1_fx_Qxy_target_note
002309 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
00230b c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
00230c 91c0 2867                 	lds r28, pulse1_fx_Qxy_speed
00230e 91d0 2868                 	lds r29, pulse1_fx_Qxy_speed+1
002310 0fac                      	add r26, r28 //increase the total offset by the speed
002311 1fbd                      	adc r27, r29
002312 93a0 2869                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
002314 93b0 286a                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
002316 91e0 286c                 	lds ZL, pulse1_fx_Rxy_target
002318 91f0 286d                 	lds ZH, pulse1_fx_Rxy_target+1
00231a 9630                      	adiw Z, 0
00231b f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
00231c 91a0 2870                 	lds r26, pulse1_fx_Rxy_total_offset
00231e 91b0 2871                 	lds r27, pulse1_fx_Rxy_total_offset+1
002320 91c0 0a8c                 	lds r28, TCB0_CCMPL
002322 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002324 1bce                      	sub r28, ZL //calculate the difference to the target
002325 0bdf                      	sbc r29, ZH
002326 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
002327 f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
002328 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
00232a 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
00232c 9220 286c                 	sts pulse1_fx_Rxy_target, zero
00232e 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
002330 91b0 286b                 	lds r27, pulse1_fx_Rxy_target_note
002332 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
002334 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
002335 91c0 286e                 	lds r28, pulse1_fx_Rxy_speed
002337 91d0 286f                 	lds r29, pulse1_fx_Rxy_speed+1
002339 0fac                      	add r26, r28 //increase the total offset by the speed
00233a 1fbd                      	adc r27, r29
00233b 93a0 2870                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
00233d 93b0 2871                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
00233f 91e0 287a                 	lds ZL, pulse2_volume_macro
002341 91f0 287b                 	lds ZH, pulse2_volume_macro+1
002343 9630                      	adiw Z, 0
002344 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
002345 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002346 1fff                      	rol ZH
002347 91a0 287c                 	lds r26, pulse2_volume_macro_offset
002349 0fea                      	add ZL, r26
00234a 1df2                      	adc ZH, zero
                                 
00234b 91b0 287e                 	lds r27, pulse2_volume_macro_release
00234d 17ba                      	cp r27, r26
00234e f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
00234f 91a0 287d                 	lds r26, pulse2_volume_macro_loop
002351 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002352 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002353 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
002354 95a3                      	inc r26 //increment the macro offset
002355 93a0 287c                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002357 91b4                      	lpm r27, Z //load volume data into r27
002358 3fbf                      	cpi r27, 0xFF //check for macro end flag
002359 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
00235a 91b0 287e                 	lds r27, pulse2_volume_macro_release
00235c 3fbf                      	cpi r27, 0xFF
00235d f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
00235e 91b0 287d                 	lds r27, pulse2_volume_macro_loop //load the loop index
002360 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
002362 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
002363 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002364 93a0 287c                 	sts pulse2_volume_macro_offset, r26
002366 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
002367 efe0                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002368 e5f7                      	ldi ZH, HIGH(volumes << 1)
002369 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
00236a 0feb                      	add ZL, r27 //add offset to the table
00236b 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
00236c 91b0 2808                 	lds r27, pulse2_param //load main volume
00236e 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00236f 91a0 28af                 	lds r26, pulse2_fx_7xy_value
002371 30a0                      	cpi r26, 0x00
002372 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
002373 0feb                      	add ZL, r27 //offset the volume table by the main volume
002374 1df2                      	adc ZH, zero
002375 91b4                      	lpm r27, Z
002376 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002378 c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
002379 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
00237b 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00237c 91a0 28af                 	lds r26, pulse2_fx_7xy_value
00237e 30a0                      	cpi r26, 0x00
00237f f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
002380 93b0 280e                 	sts pulse2_output_volume, r27
002382 c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
002383 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002384 f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002385 f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
002386 0feb                      	add ZL, r27 //offset the volume table by the main volume
002387 1df2                      	adc ZH, zero
002388 91b4                      	lpm r27, Z
002389 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00238b c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
00238c e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00238d 0feb                      	add ZL, r27 //offset the volume table by the main volume
00238e 1df2                      	adc ZH, zero
00238f 91b4                      	lpm r27, Z
002390 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002392 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
002393 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002394 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002395 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002396 93b0 280e                 	sts pulse2_output_volume, r27
002398 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002399 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00239a 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00239c 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
00239e 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
0023a0 9630                      	adiw Z, 0
0023a1 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0023a2 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0023a3 1fff                      	rol ZH
0023a4 91a0 2881                 	lds r26, pulse2_arpeggio_macro_offset
0023a6 0fea                      	add ZL, r26
0023a7 1df2                      	adc ZH, zero
                                 
0023a8 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
0023aa 17ba                      	cp r27, r26
0023ab f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0023ac 91a0 2882                 	lds r26, pulse2_arpeggio_macro_loop
0023ae 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0023af f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0023b0 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
0023b1 95a3                      	inc r26 //increment the macro offset
0023b2 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
0023b4 91b4                      	lpm r27, Z //load arpeggio data into r27
0023b5 38b0                      	cpi r27, 0x80 //check for macro end flag
0023b6 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
0023b7 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
0023b8 50a1                      	subi r26, 1 //keep the offset at the end flag
0023b9 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
0023bb 91b0 2884                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0023bd 30b1                      	cpi r27, 0x01
0023be f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
0023bf 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
0023c1 3fbf                      	cpi r27, 0xFF
0023c2 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
0023c3 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop
0023c5 3fbf                      	cpi r27, 0xFF
0023c6 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0023c7 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
0023c8 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
0023ca 3fbf                      	cpi r27, 0xFF
0023cb f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
0023cc 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
0023ce 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0023cf f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
0023d0 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
0023d2 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
0023d4 9620                      	adiw r29:r28, 0
0023d5 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0023d6 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0023d7 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
0023d9 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
0023da 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
0023dc cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
0023dd 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
0023df 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
0023e1 9620                      	adiw r29:r28, 0 //check for 0xy effect
0023e2 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
0023e3 95d6                      	lsr r29
0023e4 95c7                      	ror r28
0023e5 95d7                      	ror r29
0023e6 95c7                      	ror r28
0023e7 95d7                      	ror r29
0023e8 95c7                      	ror r28
0023e9 95d7                      	ror r29
0023ea 95c7                      	ror r28
0023eb 95d7                      	ror r29
0023ec 95d2                      	swap r29
                                 
0023ed 93c0 2897                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
0023ef 93d0 2898                 	sts pulse2_fx_0xy_sequence+1, r29
0023f1 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0023f2 91a0 280f                 	lds r26, pulse2_note //load the current note index
0023f4 0fac                      	add r26, r28 //add the note offset
0023f5 c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0023f6 91a0 280f                 	lds r26, pulse2_note //load the current note index
0023f8 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0023f9 9220 2885                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0023fb 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
0023fd 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
0023ff 91a0 2884                 	lds r26, pulse2_arpeggio_macro_mode
002401 30a1                      	cpi r26, 0x01 //absolute mode
002402 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
002403 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
002404 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
002405 91a0 280f                 	lds r26, pulse2_note //load the current note index
002407 0fab                      	add r26, r27 //offset the note with the arpeggio data
002408 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002409 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
00240a 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00240b f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
00240c e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00240d c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
00240e fda7                      	sbrc r26, 7 //check if result is negative
00240f e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002410 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
002411 2fab                      	mov r26, r27 //move the arpeggio data into r26
002412 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
002413 91a0 280f                 	lds r26, pulse2_note //load the current note index
002415 0fab                      	add r26, r27 //offset the note with the arpeggio data
002416 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002417 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
002418 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
00241a 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00241b f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
00241c e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00241d 93a0 280f                 	sts pulse2_note, r26
00241f c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
002420 fda7                      	sbrc r26, 7 //check if result is negative
002421 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002422 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
002424 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002425 e0f0                      	ldi ZH, HIGH(note_table << 1)
002426 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002427 0fea                      	add ZL, r26 //add offset
002428 1df2                      	adc ZH, zero
002429 91a5                      	lpm r26, Z+ //load bytes
00242a 91b4                      	lpm r27, Z
00242b 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
00242d 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
00242f 93a0 28a3                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002431 93b0 28a4                 	sts pulse2_fx_3xx_target+1, r27
002433 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
002434 91e0 2887                 	lds ZL, pulse2_pitch_macro
002436 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
002438 9630                      	adiw Z, 0
002439 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
00243a c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
00243b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00243c 1fff                      	rol ZH
00243d 91a0 2889                 	lds r26, pulse2_pitch_macro_offset
00243f 0fea                      	add ZL, r26
002440 1df2                      	adc ZH, zero
                                 
002441 91b0 288b                 	lds r27, pulse2_pitch_macro_release
002443 17ba                      	cp r27, r26
002444 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
002445 91a0 288a                 	lds r26, pulse2_pitch_macro_loop
002447 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002448 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002449 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
00244a 95a3                      	inc r26 //increment the macro offset
00244b 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
00244d 91b4                      	lpm r27, Z //load pitch data into r27
00244e 38b0                      	cpi r27, 0x80 //check for macro end flag
00244f f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002450 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002451 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
002453 91b0 288b                 	lds r27, pulse2_pitch_macro_release
002455 3fbf                      	cpi r27, 0xFF
002456 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002457 91b0 288a                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002459 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00245a f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00245b 93b0 2889                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
00245d cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
00245e e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
00245f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002460 937f                      	push r23
002461 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002462 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002463 0367                      	mulsu r22, r23
002464 917f                      	pop r23
002465 916f                      	pop r22
                                 
002466 9416                      	lsr r1 //shift out the fractional bits
002467 9407                      	ror r0
002468 9416                      	lsr r1
002469 9407                      	ror r0
00246a 9416                      	lsr r1
00246b 9407                      	ror r0
00246c 9416                      	lsr r1
00246d 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
00246e fe13                      	sbrs r1, 3 //check if result was a negative number
00246f c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002470 efc0                      	ldi r28, 0xF0
002471 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
002472 70b7                      	andi r27, 0b00000111
002473 f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
002474 e0b1                      	ldi r27, 0x01
002475 0e0b                      	add r0, r27
002476 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002477 91a0 2885                 	lds r26, pulse2_total_pitch_offset
002479 91b0 2886                 	lds r27, pulse2_total_pitch_offset+1
00247b 0e0a                      	add r0, r26
00247c 1e1b                      	adc r1, r27
00247d 9200 2885                 	sts pulse2_total_pitch_offset, r0
00247f 9210 2886                 	sts pulse2_total_pitch_offset+1, r1
002481 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002483 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002485 0da0                      	add r26, r0 //offset the timer values
002486 1db1                      	adc r27, r1
                                 	
002487 91c0 289b                 	lds r28, pulse2_fx_1xx_total
002489 91d0 289c                 	lds r29, pulse2_fx_1xx_total+1
00248b 1bac                      	sub r26, r28
00248c 0bbd                      	sbc r27, r29
00248d 91c0 289f                 	lds r28, pulse2_fx_2xx_total
00248f 91d0 28a0                 	lds r29, pulse2_fx_2xx_total+1
002491 0fac                      	add r26, r28
002492 1fbd                      	adc r27, r29
002493 91c0 28b3                 	lds r28, pulse2_fx_Pxx_total
002495 91d0 28b4                 	lds r29, pulse2_fx_Pxx_total+1
002497 0fac                      	add r26, r28
002498 1fbd                      	adc r27, r29
002499 91c0 28ba                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00249b 91d0 28bb                 	lds r29, pulse2_fx_Qxy_total_offset+1
00249d 1bac                      	sub r26, r28
00249e 0bbd                      	sbc r27, r29
00249f 91c0 28c1                 	lds r28, pulse2_fx_Rxy_total_offset
0024a1 91d0 28c2                 	lds r29, pulse2_fx_Rxy_total_offset+1
0024a3 0fac                      	add r26, r28
0024a4 1fbd                      	adc r27, r29
                                 
0024a5 e5c9                      	ldi r28, 0x59
0024a6 e0d0                      	ldi r29, 0x00
0024a7 17ac                      	cp r26, r28
0024a8 07bd                      	cpc r27, r29
0024a9 f030                      	brlo sound_driver_instrument_routine_channel1_pitch_min
                                 
0024aa e5ca                      	ldi r28, 0x5A
0024ab e5d9                      	ldi r29, 0x59
0024ac 17ac                      	cp r26, r28
0024ad 07bd                      	cpc r27, r29
0024ae f420                      	brsh sound_driver_instrument_routine_channel1_pitch_max
0024af c006                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_min:
0024b0 e5c9                      	ldi r28, 0x59
0024b1 e0d0                      	ldi r29, 0x00
0024b2 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_max:
0024b3 e5c9                      	ldi r28, 0x59
0024b4 e5d9                      	ldi r29, 0x59
0024b5 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_store:
0024b6 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0024b8 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
0024ba 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
0024bc 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
0024be 9630                      	adiw Z, 0
0024bf f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
0024c0 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
0024c1 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0024c2 1fff                      	rol ZH
0024c3 91a0 288f                 	lds r26, pulse2_hi_pitch_macro_offset
0024c5 0fea                      	add ZL, r26
0024c6 1df2                      	adc ZH, zero
                                 
0024c7 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
0024c9 17ba                      	cp r27, r26
0024ca f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0024cb 91a0 2890                 	lds r26, pulse2_hi_pitch_macro_loop
0024cd 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0024ce f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0024cf c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
0024d0 95a3                      	inc r26 //increment the macro offset
0024d1 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
0024d3 91b4                      	lpm r27, Z //load hi pitch data into r27
0024d4 38b0                      	cpi r27, 0x80 //check for macro end flag
0024d5 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
0024d6 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0024d7 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
0024d9 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
0024db 3fbf                      	cpi r27, 0xFF
0024dc f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
0024dd 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
0024df 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0024e0 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0024e1 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
0024e3 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
0024e4 91b0 288c                 	lds r27, pulse2_total_hi_pitch_offset
0024e6 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
0024e7 91a0 288c                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
0024e9 0fba                      	add r27, r26
0024ea 93b0 288c                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
0024ec 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0024ed 937f                      	push r23
0024ee 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0024ef eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0024f0 0367                      	mulsu r22, r23
0024f1 917f                      	pop r23
0024f2 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
0024f3 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0024f5 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0024f7 0da0                      	add r26, r0 //offset the timer values
0024f8 1db1                      	adc r27, r1
0024f9 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0024fb 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
0024fd 91e0 2892                 	lds ZL, pulse2_duty_macro
0024ff 91f0 2893                 	lds ZH, pulse2_duty_macro+1
002501 9630                      	adiw Z, 0
002502 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002503 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002504 1fff                      	rol ZH
002505 91a0 2894                 	lds r26, pulse2_duty_macro_offset
002507 0fea                      	add ZL, r26
002508 1df2                      	adc ZH, zero
                                 
002509 91b0 2896                 	lds r27, pulse2_duty_macro_release
00250b 17ba                      	cp r27, r26
00250c f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
00250d 91a0 2895                 	lds r26, pulse2_duty_macro_loop
00250f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002510 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002511 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002512 95a3                      	inc r26 //increment the macro offset
002513 93a0 2894                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002515 91b4                      	lpm r27, Z //load pitch data into r27
002516 3fbf                      	cpi r27, 0xFF //check for macro end flag
002517 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002518 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002519 93a0 2894                 	sts pulse2_duty_macro_offset, r26
00251b 91b0 2896                 	lds r27, pulse2_duty_macro_release
00251d 3fbf                      	cpi r27, 0xFF
00251e f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
00251f 91b0 2895                 	lds r27, pulse2_duty_macro_loop //load the loop index
002521 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002522 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002523 93b0 2894                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002525 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002526 e1ec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002527 e5f7                      	ldi ZH, HIGH(sequences << 1)
002528 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002529 1df2                      	adc ZH, zero
                                 
00252a 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
00252b 95b7                      	ror r27
00252c 95b7                      	ror r27
00252d 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
00252f 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002530 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002531 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002532 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002533 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002534 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002535 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002536 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002537 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002539 91e0 2899                 	lds ZL, pulse2_fx_1xx
00253b 91f0 289a                 	lds ZH, pulse2_fx_1xx+1
00253d 9630                      	adiw Z, 0
00253e f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
00253f 91a0 289b                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002541 91b0 289c                 	lds r27, pulse2_fx_1xx_total+1
002543 0fae                      	add r26, ZL //increase the total offset by the rate
002544 1fbf                      	adc r27, ZH
002545 93a0 289b                 	sts pulse2_fx_1xx_total, r26
002547 93b0 289c                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002549 91e0 289d                 	lds ZL, pulse2_fx_2xx
00254b 91f0 289e                 	lds ZH, pulse2_fx_2xx+1
00254d 9630                      	adiw Z, 0
00254e f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
00254f 91a0 289f                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002551 91b0 28a0                 	lds r27, pulse2_fx_2xx_total+1
002553 0fae                      	add r26, ZL //increase the total offset by the rate
002554 1fbf                      	adc r27, ZH
002555 93a0 289f                 	sts pulse2_fx_2xx_total, r26
002557 93b0 28a0                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002559 91e0 28a5                 	lds ZL, pulse2_fx_3xx_speed
00255b 91f0 28a6                 	lds ZH, pulse2_fx_3xx_speed+1
00255d 9630                      	adiw Z, 0
00255e f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
00255f c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002560 91a0 28a1                 	lds r26, pulse2_fx_3xx_start
002562 91b0 28a2                 	lds r27, pulse2_fx_3xx_start+1
002564 9610                      	adiw r26:r27, 0
002565 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002566 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002567 91c0 28a3                 	lds r28, pulse2_fx_3xx_target
002569 91d0 28a4                 	lds r29, pulse2_fx_3xx_target+1
                                 
00256b 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00256c 07bd                      	cpc r27, r29
00256d f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
00256e f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00256f c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002570 9220 28a1                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002572 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002574 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002575 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002576 0bdb                      	sbc r29, r27
002577 91a0 28a7                 	lds r26, pulse2_fx_3xx_total_offset
002579 91b0 28a8                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
00257b 0fae                      	add r26, ZL //add the speed to the total offset
00257c 1fbf                      	adc r27, ZH
00257d 1bca                      	sub r28, r26 //invert the total difference with the total offset
00257e 0bdb                      	sbc r29, r27
00257f f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002580 93a0 28a7                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002582 93b0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002584 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002586 91b0 0a9d                 	lds r27, TCB1_CCMPH
002588 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002589 0bbd                      	sbc r27, r29
00258a 93a0 0a9c                 	sts TCB1_CCMPL, r26
00258c 93b0 0a9d                 	sts TCB1_CCMPH, r27
00258e c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
00258f 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002590 0bbd                      	sbc r27, r29
002591 91c0 28a7                 	lds r28, pulse2_fx_3xx_total_offset
002593 91d0 28a8                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002595 0fce                      	add r28, ZL //add the speed to the total offset
002596 1fdf                      	adc r29, ZH
002597 1bac                      	sub r26, r28 //invert the total difference with the total offset
002598 0bbd                      	sbc r27, r29
002599 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00259a 93c0 28a7                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
00259c 93d0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
00259e 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
0025a0 91d0 0a9d                 	lds r29, TCB1_CCMPH
0025a2 0fca                      	add r28, r26 //offset the current timer period with the total offset
0025a3 1fdb                      	adc r29, r27
0025a4 93c0 0a9c                 	sts TCB1_CCMPL, r28
0025a6 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
0025a8 91a0 28a9                 	lds r26, pulse2_fx_4xy_speed
0025aa 15a2                      	cp r26, zero
0025ab f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
0025ac c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
0025ad 91b0 28aa                 	lds r27, pulse2_fx_4xy_depth
0025af 91c0 28ab                 	lds r28, pulse2_fx_4xy_phase
0025b1 0fca                      	add r28, r26 //increase the phase by the speed
0025b2 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0025b3 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0025b4 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
0025b5 93c0 28ab                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
0025b7 31c0                      	cpi r28, 16
0025b8 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
0025b9 32c0                      	cpi r28, 32
0025ba f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
0025bb 33c0                      	cpi r28, 48
0025bc f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
0025bd c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
0025be 70cf                      	andi r28, 0x0F //mask for values 0-15
0025bf c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
0025c0 6fc0                      	ori r28, 0xF0
0025c1 95c0                      	com r28 //invert values 0-15
0025c2 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
0025c3 70cf                      	andi r28, 0x0F //mask for values 0-15
0025c4 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
0025c5 6fc0                      	ori r28, 0xF0
0025c6 95c0                      	com r28 //invert values 0-15
0025c7 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
0025c8 95b2                      	swap r27 //multiply depth by 16
0025c9 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0025ca e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0025cb e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0025cc 0fec                      	add ZL, r28 //offset the table by the depth+phase
0025cd 1df2                      	adc ZH, zero
0025ce 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0025cf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025d0 937f                      	push r23
0025d1 2f6c                      	mov r22, r28 //store the vibrato value into r22
0025d2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025d3 9f67                      	mul r22, r23
0025d4 917f                      	pop r23
0025d5 916f                      	pop r22
                                 
0025d6 9416                      	lsr r1 //shift out the fractional bits
0025d7 9407                      	ror r0
0025d8 9416                      	lsr r1
0025d9 9407                      	ror r0
0025da 9416                      	lsr r1
0025db 9407                      	ror r0
0025dc 9416                      	lsr r1
0025dd 9407                      	ror r0
                                 	
0025de 91a0 0a9c                 	lds r26, TCB1_CCMPL
0025e0 91b0 0a9d                 	lds r27, TCB1_CCMPH
0025e2 0da0                      	add r26, r0
0025e3 1db1                      	adc r27, r1
0025e4 93a0 0a9c                 	sts TCB1_CCMPL, r26
0025e6 93b0 0a9d                 	sts TCB1_CCMPH, r27
0025e8 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
0025e9 95b2                      	swap r27 //multiply depth by 16
0025ea 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0025eb e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0025ec e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0025ed 0fec                      	add ZL, r28 //offset the table by the depth+phase
0025ee 1df2                      	adc ZH, zero
0025ef 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0025f0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025f1 937f                      	push r23
0025f2 2f6c                      	mov r22, r28 //store the vibrato value into r22
0025f3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025f4 9f67                      	mul r22, r23
0025f5 917f                      	pop r23
0025f6 916f                      	pop r22
                                 
0025f7 9416                      	lsr r1 //shift out the fractional bits
0025f8 9407                      	ror r0
0025f9 9416                      	lsr r1
0025fa 9407                      	ror r0
0025fb 9416                      	lsr r1
0025fc 9407                      	ror r0
0025fd 9416                      	lsr r1
0025fe 9407                      	ror r0
                                 
0025ff 91a0 0a9c                 	lds r26, TCB1_CCMPL
002601 91b0 0a9d                 	lds r27, TCB1_CCMPH
002603 19a0                      	sub r26, r0
002604 09b1                      	sbc r27, r1
002605 93a0 0a9c                 	sts TCB1_CCMPL, r26
002607 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002609 91a0 28ac                 	lds r26, pulse2_fx_7xy_speed
00260b 15a2                      	cp r26, zero
00260c f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00260d 91b0 28ad                 	lds r27, pulse2_fx_7xy_depth
00260f 91c0 28ae                 	lds r28, pulse2_fx_7xy_phase
002611 0fca                      	add r28, r26 //increase the phase by the speed
002612 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002613 f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002614 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002615 93c0 28ae                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002617 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002618 ffc4                      	sbrs r28, 4
002619 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
00261a c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
00261b 70cf                      	andi r28, 0x0F //mask for values 0-15
00261c c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
00261d 6fc0                      	ori r28, 0xF0
00261e 95c0                      	com r28 //invert values 0-15
00261f c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002620 95b2                      	swap r27 //multiply depth by 16
002621 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002622 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002623 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002624 0fec                      	add ZL, r28 //offset the table by the depth+phase
002625 1df2                      	adc ZH, zero
002626 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002627 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002628 93c0 28af                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
00262a 91b0 28b0                 	lds r27, pulse2_fx_Axy
00262c 15b2                      	cp r27, zero
00262d f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00262e 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002630 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002632 2fda                      	mov r29, r26 //copy fractional volume into r29
002633 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002634 95e2                      	swap r30
002635 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002636 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002637 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002638 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002639 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
00263a fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
00263b c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
00263c 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00263d f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00263e efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
00263f c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002640 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002641 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002642 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002643 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002645 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002646 95a2                      	swap r26
002647 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002648 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002649 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
00264b 91e0 28b6                 	lds ZL, pulse2_fx_Qxy_target
00264d 91f0 28b7                 	lds ZH, pulse2_fx_Qxy_target+1
00264f 9630                      	adiw Z, 0
002650 f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002651 91a0 28ba                 	lds r26, pulse2_fx_Qxy_total_offset
002653 91b0 28bb                 	lds r27, pulse2_fx_Qxy_total_offset+1
002655 91c0 0a9c                 	lds r28, TCB1_CCMPL
002657 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002659 1bec                      	sub ZL, r28 //calculate the difference to the target
00265a 0bfd                      	sbc ZH, r29
00265b f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
00265c f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
00265d 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
00265f 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
002661 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
002663 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
002665 91b0 28b5                 	lds r27, pulse2_fx_Qxy_target_note
002667 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002669 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
00266a 91c0 28b8                 	lds r28, pulse2_fx_Qxy_speed
00266c 91d0 28b9                 	lds r29, pulse2_fx_Qxy_speed+1
00266e 0fac                      	add r26, r28 //increase the total offset by the speed
00266f 1fbd                      	adc r27, r29
002670 93a0 28ba                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002672 93b0 28bb                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002674 91e0 28bd                 	lds ZL, pulse2_fx_Rxy_target
002676 91f0 28be                 	lds ZH, pulse2_fx_Rxy_target+1
002678 9630                      	adiw Z, 0
002679 f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
00267a 91a0 28c1                 	lds r26, pulse2_fx_Rxy_total_offset
00267c 91b0 28c2                 	lds r27, pulse2_fx_Rxy_total_offset+1
00267e 91c0 0a9c                 	lds r28, TCB1_CCMPL
002680 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002682 1bce                      	sub r28, ZL //calculate the difference to the target
002683 0bdf                      	sbc r29, ZH
002684 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002685 f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002686 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
002688 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
00268a 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
00268c 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
00268e 91b0 28bc                 	lds r27, pulse2_fx_Rxy_target_note
002690 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002692 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002693 91c0 28bf                 	lds r28, pulse2_fx_Rxy_speed
002695 91d0 28c0                 	lds r29, pulse2_fx_Rxy_speed+1
002697 0fac                      	add r26, r28 //increase the total offset by the speed
002698 1fbd                      	adc r27, r29
002699 93a0 28c1                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
00269b 93b0 28c2                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
00269d 91e0 28cb                 	lds ZL, triangle_volume_macro
00269f 91f0 28cc                 	lds ZH, triangle_volume_macro+1
0026a1 9630                      	adiw Z, 0
0026a2 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
0026a3 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0026a4 1fff                      	rol ZH
0026a5 91a0 28cd                 	lds r26, triangle_volume_macro_offset
0026a7 0fea                      	add ZL, r26
0026a8 1df2                      	adc ZH, zero
                                 
0026a9 91b0 28cf                 	lds r27, triangle_volume_macro_release
0026ab 17ba                      	cp r27, r26
0026ac f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
0026ad 91a0 28ce                 	lds r26, triangle_volume_macro_loop
0026af 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026b0 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026b1 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
0026b2 95a3                      	inc r26 //increment the macro offset
0026b3 93a0 28cd                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
0026b5 91b4                      	lpm r27, Z //load volume data into r27
0026b6 3fbf                      	cpi r27, 0xFF //check for macro end flag
0026b7 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
0026b8 91b0 28cf                 	lds r27, triangle_volume_macro_release
0026ba 3fbf                      	cpi r27, 0xFF
0026bb f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
0026bc 91b0 28ce                 	lds r27, triangle_volume_macro_loop //load the loop index
0026be 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
0026c0 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
0026c1 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0026c2 93a0 28cd                 	sts triangle_volume_macro_offset, r26
0026c4 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
0026c5 15b2                      	cp r27, zero
0026c6 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
0026c7 91b0 0aa5                 	lds r27, TCB2_INTCTRL
0026c9 30b1                      	cpi r27, TCB_CAPT_bm
0026ca f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
0026cb e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0026cc 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0026ce c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
0026cf 9220 0aa5                 	sts TCB2_INTCTRL, zero
0026d1 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
0026d3 9220 0aad                 	sts TCB2_CCMPH, zero
0026d5 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0026d6 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
0026d8 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
0026da 9630                      	adiw Z, 0
0026db f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0026dc 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0026dd 1fff                      	rol ZH
0026de 91a0 28d2                 	lds r26, triangle_arpeggio_macro_offset
0026e0 0fea                      	add ZL, r26
0026e1 1df2                      	adc ZH, zero
                                 
0026e2 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
0026e4 17ba                      	cp r27, r26
0026e5 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0026e6 91a0 28d3                 	lds r26, triangle_arpeggio_macro_loop
0026e8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026e9 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0026ea c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
0026eb 95a3                      	inc r26 //increment the macro offset
0026ec 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
0026ee 91b4                      	lpm r27, Z //load arpeggio data into r27
0026ef 38b0                      	cpi r27, 0x80 //check for macro end flag
0026f0 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
0026f1 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
0026f2 50a1                      	subi r26, 1 //keep the offset at the end flag
0026f3 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
0026f5 91b0 28d5                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0026f7 30b1                      	cpi r27, 0x01
0026f8 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
0026f9 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
0026fb 3fbf                      	cpi r27, 0xFF
0026fc f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
0026fd 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop
0026ff 3fbf                      	cpi r27, 0xFF
002700 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002701 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002702 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002704 3fbf                      	cpi r27, 0xFF
002705 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002706 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002708 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002709 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
00270a 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
00270c 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
00270e 9620                      	adiw r29:r28, 0
00270f f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002710 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002711 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002713 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002714 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002716 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002717 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002719 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
00271b 9620                      	adiw r29:r28, 0 //check for 0xy effect
00271c f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
00271d 95d6                      	lsr r29
00271e 95c7                      	ror r28
00271f 95d7                      	ror r29
002720 95c7                      	ror r28
002721 95d7                      	ror r29
002722 95c7                      	ror r28
002723 95d7                      	ror r29
002724 95c7                      	ror r28
002725 95d7                      	ror r29
002726 95d2                      	swap r29
                                 
002727 93c0 28e8                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002729 93d0 28e9                 	sts triangle_fx_0xy_sequence+1, r29
00272b 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00272c 91a0 2812                 	lds r26, triangle_note //load the current note index
00272e 0fac                      	add r26, r28 //add the note offset
00272f c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002730 91a0 2812                 	lds r26, triangle_note //load the current note index
002732 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002733 9220 28d6                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002735 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
002737 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
002739 91a0 28d5                 	lds r26, triangle_arpeggio_macro_mode
00273b 30a1                      	cpi r26, 0x01 //absolute mode
00273c f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
00273d f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
00273e c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
00273f 91a0 2812                 	lds r26, triangle_note //load the current note index
002741 0fab                      	add r26, r27 //offset the note with the arpeggio data
002742 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002743 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002744 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002745 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002746 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002747 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002748 fda7                      	sbrc r26, 7 //check if result is negative
002749 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00274a c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
00274b 2fab                      	mov r26, r27 //move the arpeggio data into r26
00274c c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
00274d 91a0 2812                 	lds r26, triangle_note //load the current note index
00274f 0fab                      	add r26, r27 //offset the note with the arpeggio data
002750 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002751 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002752 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002754 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002755 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002756 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002757 93a0 2812                 	sts triangle_note, r26
002759 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
00275a fda7                      	sbrc r26, 7 //check if result is negative
00275b e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00275c 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
00275e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00275f e0f0                      	ldi ZH, HIGH(note_table << 1)
002760 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002761 0fea                      	add ZL, r26 //add offset
002762 1df2                      	adc ZH, zero
002763 91a5                      	lpm r26, Z+ //load bytes
002764 91b4                      	lpm r27, Z
002765 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002767 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002769 93a0 28f4                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00276b 93b0 28f5                 	sts triangle_fx_3xx_target+1, r27
00276d c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
00276e 91e0 28d8                 	lds ZL, triangle_pitch_macro
002770 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
002772 9630                      	adiw Z, 0
002773 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002774 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002775 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002776 1fff                      	rol ZH
002777 91a0 28da                 	lds r26, triangle_pitch_macro_offset
002779 0fea                      	add ZL, r26
00277a 1df2                      	adc ZH, zero
                                 
00277b 91b0 28dc                 	lds r27, triangle_pitch_macro_release
00277d 17ba                      	cp r27, r26
00277e f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
00277f 91a0 28db                 	lds r26, triangle_pitch_macro_loop
002781 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002782 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002783 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002784 95a3                      	inc r26 //increment the macro offset
002785 93a0 28da                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002787 91b4                      	lpm r27, Z //load pitch data into r27
002788 38b0                      	cpi r27, 0x80 //check for macro end flag
002789 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
00278a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00278b 93a0 28da                 	sts triangle_pitch_macro_offset, r26
00278d 91b0 28dc                 	lds r27, triangle_pitch_macro_release
00278f 3fbf                      	cpi r27, 0xFF
002790 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002791 91b0 28db                 	lds r27, triangle_pitch_macro_loop //load the loop index
002793 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002794 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002795 93b0 28da                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002797 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002798 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002799 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00279a 937f                      	push r23
00279b 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00279c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00279d 0367                      	mulsu r22, r23
00279e 917f                      	pop r23
00279f 916f                      	pop r22
                                 
0027a0 9416                      	lsr r1 //shift out the fractional bits
0027a1 9407                      	ror r0
0027a2 9416                      	lsr r1
0027a3 9407                      	ror r0
0027a4 9416                      	lsr r1
0027a5 9407                      	ror r0
0027a6 9416                      	lsr r1
0027a7 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
0027a8 fe13                      	sbrs r1, 3 //check if result was a negative number
0027a9 c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
0027aa efc0                      	ldi r28, 0xF0
0027ab 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
0027ac 70b7                      	andi r27, 0b00000111
0027ad f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
0027ae e0b1                      	ldi r27, 0x01
0027af 0e0b                      	add r0, r27
0027b0 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
0027b1 91a0 28d6                 	lds r26, triangle_total_pitch_offset
0027b3 91b0 28d7                 	lds r27, triangle_total_pitch_offset+1
0027b5 0e0a                      	add r0, r26
0027b6 1e1b                      	adc r1, r27
0027b7 9200 28d6                 	sts triangle_total_pitch_offset, r0
0027b9 9210 28d7                 	sts triangle_total_pitch_offset+1, r1
0027bb 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
0027bd 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
0027bf 0da0                      	add r26, r0 //offset the timer values
0027c0 1db1                      	adc r27, r1
                                 	
0027c1 91c0 28ec                 	lds r28, triangle_fx_1xx_total
0027c3 91d0 28ed                 	lds r29, triangle_fx_1xx_total+1
0027c5 1bac                      	sub r26, r28
0027c6 0bbd                      	sbc r27, r29
0027c7 91c0 28f0                 	lds r28, triangle_fx_2xx_total
0027c9 91d0 28f1                 	lds r29, triangle_fx_2xx_total+1
0027cb 0fac                      	add r26, r28
0027cc 1fbd                      	adc r27, r29
0027cd 91c0 28ff                 	lds r28, triangle_fx_Pxx_total
0027cf 91d0 2900                 	lds r29, triangle_fx_Pxx_total+1
0027d1 0fac                      	add r26, r28
0027d2 1fbd                      	adc r27, r29
0027d3 91c0 2906                 	lds r28, triangle_fx_Qxy_total_offset
0027d5 91d0 2907                 	lds r29, triangle_fx_Qxy_total_offset+1
0027d7 1bac                      	sub r26, r28
0027d8 0bbd                      	sbc r27, r29
0027d9 91c0 290d                 	lds r28, triangle_fx_Rxy_total_offset
0027db 91d0 290e                 	lds r29, triangle_fx_Rxy_total_offset+1
0027dd 0fac                      	add r26, r28
0027de 1fbd                      	adc r27, r29
                                 
0027df e5c9                      	ldi r28, 0x59
0027e0 e0d0                      	ldi r29, 0x00
0027e1 17ac                      	cp r26, r28
0027e2 07bd                      	cpc r27, r29
0027e3 f030                      	brlo sound_driver_instrument_routine_channel2_pitch_min
                                 
0027e4 e5ca                      	ldi r28, 0x5A
0027e5 e5d9                      	ldi r29, 0x59
0027e6 17ac                      	cp r26, r28
0027e7 07bd                      	cpc r27, r29
0027e8 f420                      	brsh sound_driver_instrument_routine_channel2_pitch_max
0027e9 c006                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_min:
0027ea e5c9                      	ldi r28, 0x59
0027eb e0d0                      	ldi r29, 0x00
0027ec c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_max:
0027ed e5c9                      	ldi r28, 0x59
0027ee e5d9                      	ldi r29, 0x59
0027ef c000                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_store:
0027f0 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
0027f2 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
0027f4 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
0027f6 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
0027f8 9630                      	adiw Z, 0
0027f9 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
0027fa c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
0027fb 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0027fc 1fff                      	rol ZH
0027fd 91a0 28e0                 	lds r26, triangle_hi_pitch_macro_offset
0027ff 0fea                      	add ZL, r26
002800 1df2                      	adc ZH, zero
                                 
002801 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002803 17ba                      	cp r27, r26
002804 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002805 91a0 28e1                 	lds r26, triangle_hi_pitch_macro_loop
002807 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002808 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002809 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
00280a 95a3                      	inc r26 //increment the macro offset
00280b 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
00280d 91b4                      	lpm r27, Z //load hi pitch data into r27
00280e 38b0                      	cpi r27, 0x80 //check for macro end flag
00280f f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002810 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002811 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
002813 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002815 3fbf                      	cpi r27, 0xFF
002816 f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002817 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002819 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00281a f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00281b 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
00281d cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
00281e 91b0 28dd                 	lds r27, triangle_total_hi_pitch_offset
002820 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002821 91a0 28dd                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002823 0fba                      	add r27, r26
002824 93b0 28dd                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002826 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002827 937f                      	push r23
002828 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002829 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00282a 0367                      	mulsu r22, r23
00282b 917f                      	pop r23
00282c 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
00282d 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
00282f 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002831 0da0                      	add r26, r0 //offset the timer values
002832 1db1                      	adc r27, r1
002833 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002835 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002837 91e0 28ea                 	lds ZL, triangle_fx_1xx
002839 91f0 28eb                 	lds ZH, triangle_fx_1xx+1
00283b 9630                      	adiw Z, 0
00283c f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
00283d 91a0 28ec                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
00283f 91b0 28ed                 	lds r27, triangle_fx_1xx_total+1
002841 0fae                      	add r26, ZL //increase the total offset by the rate
002842 1fbf                      	adc r27, ZH
002843 93a0 28ec                 	sts triangle_fx_1xx_total, r26
002845 93b0 28ed                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002847 91e0 28ee                 	lds ZL, triangle_fx_2xx
002849 91f0 28ef                 	lds ZH, triangle_fx_2xx+1
00284b 9630                      	adiw Z, 0
00284c f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
00284d 91a0 28f0                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
00284f 91b0 28f1                 	lds r27, triangle_fx_2xx_total+1
002851 0fae                      	add r26, ZL //increase the total offset by the rate
002852 1fbf                      	adc r27, ZH
002853 93a0 28f0                 	sts triangle_fx_2xx_total, r26
002855 93b0 28f1                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002857 91e0 28f6                 	lds ZL, triangle_fx_3xx_speed
002859 91f0 28f7                 	lds ZH, triangle_fx_3xx_speed+1
00285b 9630                      	adiw Z, 0
00285c f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
00285d c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
00285e 91a0 28f2                 	lds r26, triangle_fx_3xx_start
002860 91b0 28f3                 	lds r27, triangle_fx_3xx_start+1
002862 9610                      	adiw r26:r27, 0
002863 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002864 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002865 91c0 28f4                 	lds r28, triangle_fx_3xx_target
002867 91d0 28f5                 	lds r29, triangle_fx_3xx_target+1
                                 
002869 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00286a 07bd                      	cpc r27, r29
00286b f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
00286c f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00286d c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
00286e 9220 28f2                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002870 9220 28f3                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002872 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002873 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002874 0bdb                      	sbc r29, r27
002875 91a0 28f8                 	lds r26, triangle_fx_3xx_total_offset
002877 91b0 28f9                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002879 0fae                      	add r26, ZL //add the speed to the total offset
00287a 1fbf                      	adc r27, ZH
00287b 1bca                      	sub r28, r26 //invert the total difference with the total offset
00287c 0bdb                      	sbc r29, r27
00287d f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00287e 93a0 28f8                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002880 93b0 28f9                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002882 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002884 91b0 0aad                 	lds r27, TCB2_CCMPH
002886 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002887 0bbd                      	sbc r27, r29
002888 93a0 0aac                 	sts TCB2_CCMPL, r26
00288a 93b0 0aad                 	sts TCB2_CCMPH, r27
00288c c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
00288d 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00288e 0bbd                      	sbc r27, r29
00288f 91c0 28f8                 	lds r28, triangle_fx_3xx_total_offset
002891 91d0 28f9                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002893 0fce                      	add r28, ZL //add the speed to the total offset
002894 1fdf                      	adc r29, ZH
002895 1bac                      	sub r26, r28 //invert the total difference with the total offset
002896 0bbd                      	sbc r27, r29
002897 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002898 93c0 28f8                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
00289a 93d0 28f9                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
00289c 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
00289e 91d0 0aad                 	lds r29, TCB2_CCMPH
0028a0 0fca                      	add r28, r26 //offset the current timer period with the total offset
0028a1 1fdb                      	adc r29, r27
0028a2 93c0 0aac                 	sts TCB2_CCMPL, r28
0028a4 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
0028a6 91a0 28fa                 	lds r26, triangle_fx_4xy_speed
0028a8 15a2                      	cp r26, zero
0028a9 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
0028aa c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
0028ab 91b0 28fb                 	lds r27, triangle_fx_4xy_depth
0028ad 91c0 28fc                 	lds r28, triangle_fx_4xy_phase
0028af 0fca                      	add r28, r26 //increase the phase by the speed
0028b0 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0028b1 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0028b2 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
0028b3 93c0 28fc                 	sts triangle_fx_4xy_phase, r28 //store the new phase
0028b5 31c0                      	cpi r28, 16
0028b6 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
0028b7 32c0                      	cpi r28, 32
0028b8 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
0028b9 33c0                      	cpi r28, 48
0028ba f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
0028bb c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
0028bc 70cf                      	andi r28, 0x0F //mask for values 0-15
0028bd c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
0028be 6fc0                      	ori r28, 0xF0
0028bf 95c0                      	com r28 //invert values 0-15
0028c0 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
0028c1 70cf                      	andi r28, 0x0F //mask for values 0-15
0028c2 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
0028c3 6fc0                      	ori r28, 0xF0
0028c4 95c0                      	com r28 //invert values 0-15
0028c5 c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
0028c6 95b2                      	swap r27 //multiply depth by 16
0028c7 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0028c8 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0028c9 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0028ca 0fec                      	add ZL, r28 //offset the table by the depth+phase
0028cb 1df2                      	adc ZH, zero
0028cc 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0028cd 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028ce 937f                      	push r23
0028cf 2f6c                      	mov r22, r28 //store the vibrato value into r22
0028d0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028d1 9f67                      	mul r22, r23
0028d2 917f                      	pop r23
0028d3 916f                      	pop r22
                                 
0028d4 9416                      	lsr r1 //shift out the fractional bits
0028d5 9407                      	ror r0
0028d6 9416                      	lsr r1
0028d7 9407                      	ror r0
0028d8 9416                      	lsr r1
0028d9 9407                      	ror r0
0028da 9416                      	lsr r1
0028db 9407                      	ror r0
                                 	
0028dc 91a0 0aac                 	lds r26, TCB2_CCMPL
0028de 91b0 0aad                 	lds r27, TCB2_CCMPH
0028e0 0da0                      	add r26, r0
0028e1 1db1                      	adc r27, r1
0028e2 93a0 0aac                 	sts TCB2_CCMPL, r26
0028e4 93b0 0aad                 	sts TCB2_CCMPH, r27
0028e6 c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
0028e7 95b2                      	swap r27 //multiply depth by 16
0028e8 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0028e9 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0028ea e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0028eb 0fec                      	add ZL, r28 //offset the table by the depth+phase
0028ec 1df2                      	adc ZH, zero
0028ed 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0028ee 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028ef 937f                      	push r23
0028f0 2f6c                      	mov r22, r28 //store the vibrato value into r22
0028f1 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028f2 9f67                      	mul r22, r23
0028f3 917f                      	pop r23
0028f4 916f                      	pop r22
                                 
0028f5 9416                      	lsr r1 //shift out the fractional bits
0028f6 9407                      	ror r0
0028f7 9416                      	lsr r1
0028f8 9407                      	ror r0
0028f9 9416                      	lsr r1
0028fa 9407                      	ror r0
0028fb 9416                      	lsr r1
0028fc 9407                      	ror r0
                                 
0028fd 91a0 0aac                 	lds r26, TCB2_CCMPL
0028ff 91b0 0aad                 	lds r27, TCB2_CCMPH
002901 19a0                      	sub r26, r0
002902 09b1                      	sbc r27, r1
002903 93a0 0aac                 	sts TCB2_CCMPL, r26
002905 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002907 91e0 2902                 	lds ZL, triangle_fx_Qxy_target
002909 91f0 2903                 	lds ZH, triangle_fx_Qxy_target+1
00290b 9630                      	adiw Z, 0
00290c f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00290d 91a0 2906                 	lds r26, triangle_fx_Qxy_total_offset
00290f 91b0 2907                 	lds r27, triangle_fx_Qxy_total_offset+1
002911 91c0 0aac                 	lds r28, TCB2_CCMPL
002913 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002915 1bec                      	sub ZL, r28 //calculate the difference to the target
002916 0bfd                      	sbc ZH, r29
002917 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002918 f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002919 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
00291b 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
00291d 9220 2902                 	sts triangle_fx_Qxy_target, zero
00291f 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002921 91b0 2901                 	lds r27, triangle_fx_Qxy_target_note
002923 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002925 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002926 91c0 2904                 	lds r28, triangle_fx_Qxy_speed
002928 91d0 2905                 	lds r29, triangle_fx_Qxy_speed+1
00292a 0fac                      	add r26, r28 //increase the total offset by the speed
00292b 1fbd                      	adc r27, r29
00292c 93a0 2906                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
00292e 93b0 2907                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002930 91e0 2909                 	lds ZL, triangle_fx_Rxy_target
002932 91f0 290a                 	lds ZH, triangle_fx_Rxy_target+1
002934 9630                      	adiw Z, 0
002935 f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002936 91a0 290d                 	lds r26, triangle_fx_Rxy_total_offset
002938 91b0 290e                 	lds r27, triangle_fx_Rxy_total_offset+1
00293a 91c0 0aac                 	lds r28, TCB2_CCMPL
00293c 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
00293e 1bce                      	sub r28, ZL //calculate the difference to the target
00293f 0bdf                      	sbc r29, ZH
002940 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002941 f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002942 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002944 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
002946 9220 2909                 	sts triangle_fx_Rxy_target, zero
002948 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
00294a 91b0 2908                 	lds r27, triangle_fx_Rxy_target_note
00294c 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
00294e c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
00294f 91c0 290b                 	lds r28, triangle_fx_Rxy_speed
002951 91d0 290c                 	lds r29, triangle_fx_Rxy_speed+1
002953 0fac                      	add r26, r28 //increase the total offset by the speed
002954 1fbd                      	adc r27, r29
002955 93a0 290d                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002957 93b0 290e                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002959 91e0 2917                 	lds ZL, noise_volume_macro
00295b 91f0 2918                 	lds ZH, noise_volume_macro+1
00295d 9630                      	adiw Z, 0
00295e f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
00295f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002960 1fff                      	rol ZH
002961 91a0 2919                 	lds r26, noise_volume_macro_offset
002963 0fea                      	add ZL, r26
002964 1df2                      	adc ZH, zero
                                 
002965 91b0 291b                 	lds r27, noise_volume_macro_release
002967 17ba                      	cp r27, r26
002968 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002969 91a0 291a                 	lds r26, noise_volume_macro_loop
00296b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00296c f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00296d c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
00296e 95a3                      	inc r26 //increment the macro offset
00296f 93a0 2919                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002971 91b4                      	lpm r27, Z //load volume data into r27
002972 3fbf                      	cpi r27, 0xFF //check for macro end flag
002973 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002974 91b0 291b                 	lds r27, noise_volume_macro_release
002976 3fbf                      	cpi r27, 0xFF
002977 f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002978 91b0 291a                 	lds r27, noise_volume_macro_loop //load the loop index
00297a 93b0 2919                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
00297c cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
00297d 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00297e 93a0 2919                 	sts noise_volume_macro_offset, r26
002980 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002981 efe0                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002982 e5f7                      	ldi ZH, HIGH(volumes << 1)
002983 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002984 0feb                      	add ZL, r27 //add offset to the table
002985 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002986 91b0 2813                 	lds r27, noise_param //load main volume
002988 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002989 91a0 2941                 	lds r26, noise_fx_7xy_value
00298b 30a0                      	cpi r26, 0x00
00298c f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
00298d 0feb                      	add ZL, r27 //offset the volume table by the main volume
00298e 1df2                      	adc ZH, zero
00298f 91b4                      	lpm r27, Z
002990 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002992 c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002993 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002995 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002996 91a0 2941                 	lds r26, noise_fx_7xy_value
002998 30a0                      	cpi r26, 0x00
002999 f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
00299a 93b0 2816                 	sts noise_output_volume, r27
00299c c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
00299d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00299e f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
00299f f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
0029a0 0feb                      	add ZL, r27 //offset the volume table by the main volume
0029a1 1df2                      	adc ZH, zero
0029a2 91b4                      	lpm r27, Z
0029a3 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
0029a5 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
0029a6 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0029a7 0feb                      	add ZL, r27 //offset the volume table by the main volume
0029a8 1df2                      	adc ZH, zero
0029a9 91b4                      	lpm r27, Z
0029aa 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
0029ac c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
0029ad 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0029ae f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
0029af f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
0029b0 93b0 2816                 	sts noise_output_volume, r27
0029b2 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
0029b3 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0029b4 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0029b6 91e0 291c                 	lds ZL, noise_arpeggio_macro
0029b8 91f0 291d                 	lds ZH, noise_arpeggio_macro+1
0029ba 9630                      	adiw Z, 0
0029bb f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0029bc 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0029bd 1fff                      	rol ZH
0029be 91a0 291e                 	lds r26, noise_arpeggio_macro_offset
0029c0 0fea                      	add ZL, r26
0029c1 1df2                      	adc ZH, zero
                                 
0029c2 91b0 2920                 	lds r27, noise_arpeggio_macro_release
0029c4 17ba                      	cp r27, r26
0029c5 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0029c6 91a0 291f                 	lds r26, noise_arpeggio_macro_loop
0029c8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0029c9 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0029ca c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
0029cb 95a3                      	inc r26 //increment the macro offset
0029cc 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
0029ce 91b4                      	lpm r27, Z //load arpeggio data into r27
0029cf 38b0                      	cpi r27, 0x80 //check for macro end flag
0029d0 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
0029d1 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
0029d2 50a1                      	subi r26, 1 //keep the offset at the end flag
0029d3 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
0029d5 91b0 2921                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0029d7 30b1                      	cpi r27, 0x01
0029d8 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
0029d9 91b0 2920                 	lds r27, noise_arpeggio_macro_release
0029db 3fbf                      	cpi r27, 0xFF
0029dc f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
0029dd 91b0 291f                 	lds r27, noise_arpeggio_macro_loop
0029df 3fbf                      	cpi r27, 0xFF
0029e0 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0029e1 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
0029e2 91b0 2920                 	lds r27, noise_arpeggio_macro_release
0029e4 3fbf                      	cpi r27, 0xFF
0029e5 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
0029e6 91b0 291f                 	lds r27, noise_arpeggio_macro_loop //load the loop index
0029e8 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0029e9 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
0029ea 91c0 2934                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
0029ec 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
0029ee 9620                      	adiw r29:r28, 0
0029ef f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0029f0 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0029f1 93a0 291e                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
0029f3 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
0029f4 93b0 291e                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
0029f6 cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
0029f7 91c0 2934                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
0029f9 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
0029fb 9620                      	adiw r29:r28, 0 //check for 0xy effect
0029fc f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
0029fd 95d6                      	lsr r29
0029fe 95c7                      	ror r28
0029ff 95d7                      	ror r29
002a00 95c7                      	ror r28
002a01 95d7                      	ror r29
002a02 95c7                      	ror r28
002a03 95d7                      	ror r29
002a04 95c7                      	ror r28
002a05 95d7                      	ror r29
002a06 95d2                      	swap r29
                                 
002a07 93c0 2934                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002a09 93d0 2935                 	sts noise_fx_0xy_sequence+1, r29
002a0b 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002a0c 91a0 2817                 	lds r26, noise_note //load the current note index
002a0e 0fac                      	add r26, r28 //add the note offset
002a0f c01c                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002a10 91a0 2817                 	lds r26, noise_note //load the current note index
002a12 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002a13 9220 2922                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002a15 9220 2923                 	sts noise_total_pitch_offset+1, zero
002a17 9220 2929                 	sts noise_total_hi_pitch_offset, zero
002a19 91a0 2921                 	lds r26, noise_arpeggio_macro_mode
002a1b 30a1                      	cpi r26, 0x01 //absolute mode
002a1c f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002a1d f031                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002a1e c007                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002a1f 91a0 2817                 	lds r26, noise_note //load the current note index
002a21 0fab                      	add r26, r27 //offset the note with the arpeggio data
002a22 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002a23 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002a24 2fab                      	mov r26, r27 //move the arpeggio data into r26
002a25 c006                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002a26 91a0 2817                 	lds r26, noise_note //load the current note index
002a28 0fab                      	add r26, r27 //offset the note with the arpeggio data
002a29 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002a2a 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002a2c 93a0 2818                 	sts noise_adjusted_note, r26
002a2e c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002a2f 91e0 2924                 	lds ZL, noise_pitch_macro
002a31 91f0 2925                 	lds ZH, noise_pitch_macro+1
002a33 9630                      	adiw Z, 0
002a34 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002a35 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002a36 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a37 1fff                      	rol ZH
002a38 91a0 2926                 	lds r26, noise_pitch_macro_offset
002a3a 0fea                      	add ZL, r26
002a3b 1df2                      	adc ZH, zero
                                 
002a3c 91b0 2928                 	lds r27, noise_pitch_macro_release
002a3e 17ba                      	cp r27, r26
002a3f f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a40 91a0 2927                 	lds r26, noise_pitch_macro_loop
002a42 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a43 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a44 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002a45 95a3                      	inc r26 //increment the macro offset
002a46 93a0 2926                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002a48 91b4                      	lpm r27, Z //load pitch data into r27
002a49 38b0                      	cpi r27, 0x80 //check for macro end flag
002a4a f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002a4b 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a4c 93a0 2926                 	sts noise_pitch_macro_offset, r26
002a4e 91b0 2928                 	lds r27, noise_pitch_macro_release
002a50 3fbf                      	cpi r27, 0xFF
002a51 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002a52 91b0 2927                 	lds r27, noise_pitch_macro_loop //load the loop index
002a54 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a55 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002a56 93b0 2926                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
002a58 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
002a59 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
002a5a 91a0 2922                 	lds r26, noise_total_pitch_offset
002a5c 0fba                      	add r27, r26
002a5d 93b0 2922                 	sts noise_total_pitch_offset, r27
002a5f 91a0 2818                 	lds r26, noise_adjusted_note
002a61 1bab                      	sub r26, r27
                                 	
002a62 91b0 2937                 	lds r27, noise_fx_1xx_total
002a64 0fab                      	add r26, r27
002a65 91b0 2939                 	lds r27, noise_fx_2xx_total
002a67 1bab                      	sub r26, r27
002a68 91b0 293d                 	lds r27, noise_fx_4xy_offset
002a6a 1bab                      	sub r26, r27
002a6b 91b0 2945                 	lds r27, noise_fx_Pxx_total
002a6d 1bab                      	sub r26, r27
                                 
002a6e 70af                      	andi r26, 0x0F
                                 
002a6f e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002a70 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002a71 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002a72 0fea                      	add ZL, r26 //add offset
002a73 1df2                      	adc ZH, zero
002a74 91a5                      	lpm r26, Z+ //load bytes
002a75 91b4                      	lpm r27, Z
002a76 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002a78 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
002a7a 91e0 292a                 	lds ZL, noise_hi_pitch_macro
002a7c 91f0 292b                 	lds ZH, noise_hi_pitch_macro+1
002a7e 9630                      	adiw Z, 0
002a7f f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
002a80 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
002a81 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a82 1fff                      	rol ZH
002a83 91a0 292c                 	lds r26, noise_hi_pitch_macro_offset
002a85 0fea                      	add ZL, r26
002a86 1df2                      	adc ZH, zero
                                 
002a87 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002a89 17ba                      	cp r27, r26
002a8a f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a8b 91a0 292d                 	lds r26, noise_hi_pitch_macro_loop
002a8d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a8e f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a8f c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
002a90 95a3                      	inc r26 //increment the macro offset
002a91 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
002a93 91b4                      	lpm r27, Z //load hi pitch data into r27
002a94 38b0                      	cpi r27, 0x80 //check for macro end flag
002a95 f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
002a96 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a97 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
002a99 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002a9b 3fbf                      	cpi r27, 0xFF
002a9c f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
002a9d 91b0 292d                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
002a9f 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002aa0 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002aa1 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
002aa3 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
002aa4 91b0 2929                 	lds r27, noise_total_hi_pitch_offset
002aa6 c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
002aa7 91a0 2929                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
002aa9 0fba                      	add r27, r26
002aaa 93b0 2929                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
002aac 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002aad 937f                      	push r23
002aae 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002aaf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ab0 0367                      	mulsu r22, r23
002ab1 917f                      	pop r23
002ab2 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
002ab3 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002ab5 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002ab7 0da0                      	add r26, r0 //offset the timer values
002ab8 1db1                      	adc r27, r1
002ab9 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002abb 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
002abd 91e0 292f                 	lds ZL, noise_duty_macro
002abf 91f0 2930                 	lds ZH, noise_duty_macro+1
002ac1 9630                      	adiw Z, 0
002ac2 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
002ac3 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002ac4 1fff                      	rol ZH
002ac5 91a0 2931                 	lds r26, noise_duty_macro_offset
002ac7 0fea                      	add ZL, r26
002ac8 1df2                      	adc ZH, zero
                                 
002ac9 91b0 2933                 	lds r27, noise_duty_macro_release
002acb 17ba                      	cp r27, r26
002acc f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
002acd 91a0 2932                 	lds r26, noise_duty_macro_loop
002acf 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ad0 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ad1 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
002ad2 95a3                      	inc r26 //increment the macro offset
002ad3 93a0 2931                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
002ad5 91b4                      	lpm r27, Z //load pitch data into r27
002ad6 3fbf                      	cpi r27, 0xFF //check for macro end flag
002ad7 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
002ad8 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002ad9 93a0 2931                 	sts noise_duty_macro_offset, r26
002adb 91b0 2933                 	lds r27, noise_duty_macro_release
002add 3fbf                      	cpi r27, 0xFF
002ade f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
002adf 91b0 2932                 	lds r27, noise_duty_macro_loop //load the loop index
002ae1 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002ae2 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002ae3 93b0 2931                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
002ae5 cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
002ae6 95b6                      	lsr r27
002ae7 95b7                      	ror r27 //move mode bit to bit 7
002ae8 91c0 2814                 	lds r28, noise_period
002aea 77cf                      	andi r28, 0b01111111
002aeb 2bcb                      	or r28, r27 //store the new noise mode
002aec 93c0 2813                 	sts noise_param, r28
                                 
002aee 776f                      	andi noise_sequence_HIGH, 0b01111111
002aef 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
002af0 91e0 2936                 	lds ZL, noise_fx_1xx
002af2 30e0                      	cpi ZL, 0
002af3 f029                      	breq sound_driver_channel3_fx_2xx_routine
                                 
002af4 91a0 2937                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
002af6 0fae                      	add r26, ZL //increase the total offset by the rate
002af7 93a0 2937                 	sts noise_fx_1xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
002af9 91e0 2938                 	lds ZL, noise_fx_2xx
002afb 30e0                      	cpi ZL, 0
002afc f029                      	breq sound_driver_channel3_fx_3xx_routine
                                 
002afd 91a0 2939                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
002aff 0fae                      	add r26, ZL //increase the total offset by the rate
002b00 93a0 2939                 	sts noise_fx_2xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
002b02 91a0 293a                 	lds r26, noise_fx_4xy_speed
002b04 15a2                      	cp r26, zero
002b05 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
002b06 c02f                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
002b07 91b0 293b                 	lds r27, noise_fx_4xy_depth
002b09 91c0 293c                 	lds r28, noise_fx_4xy_phase
002b0b 0fca                      	add r28, r26 //increase the phase by the speed
002b0c 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002b0d f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002b0e e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
002b0f 93c0 293c                 	sts noise_fx_4xy_phase, r28 //store the new phase
002b11 31c0                      	cpi r28, 16
002b12 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
002b13 32c0                      	cpi r28, 32
002b14 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
002b15 33c0                      	cpi r28, 48
002b16 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
002b17 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
002b18 70cf                      	andi r28, 0x0F //mask for values 0-15
002b19 c012                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
002b1a 6fc0                      	ori r28, 0xF0
002b1b 95c0                      	com r28 //invert values 0-15
002b1c c00f                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
002b1d 70cf                      	andi r28, 0x0F //mask for values 0-15
002b1e c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
002b1f 6fc0                      	ori r28, 0xF0
002b20 95c0                      	com r28 //invert values 0-15
002b21 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
002b22 95b2                      	swap r27 //multiply depth by 16
002b23 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b24 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b25 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b26 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b27 1df2                      	adc ZH, zero
002b28 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002b29 93c0 293d                 	sts noise_fx_4xy_offset, r28
002b2b c00a                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
002b2c 95b2                      	swap r27 //multiply depth by 16
002b2d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002b2e e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b2f e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b30 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b31 1df2                      	adc ZH, zero
002b32 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002b33 95c1                      	neg r28
002b34 93c0 293d                 	sts noise_fx_4xy_offset, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
002b36 91a0 293e                 	lds r26, noise_fx_7xy_speed
002b38 15a2                      	cp r26, zero
002b39 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002b3a 91b0 293f                 	lds r27, noise_fx_7xy_depth
002b3c 91c0 2940                 	lds r28, noise_fx_7xy_phase
002b3e 0fca                      	add r28, r26 //increase the phase by the speed
002b3f 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002b40 f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002b41 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
002b42 93c0 2940                 	sts noise_fx_7xy_phase, r28 //store the new phase
002b44 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002b45 ffc4                      	sbrs r28, 4
002b46 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
002b47 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
002b48 70cf                      	andi r28, 0x0F //mask for values 0-15
002b49 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
002b4a 6fc0                      	ori r28, 0xF0
002b4b 95c0                      	com r28 //invert values 0-15
002b4c c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
002b4d 95b2                      	swap r27 //multiply depth by 16
002b4e 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b4f e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b50 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b51 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b52 1df2                      	adc ZH, zero
002b53 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002b54 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002b55 93c0 2941                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
002b57 91b0 2942                 	lds r27, noise_fx_Axy
002b59 15b2                      	cp r27, zero
002b5a f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002b5b 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
002b5d 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
002b5f 2fda                      	mov r29, r26 //copy fractional volume into r29
002b60 2fec                      	mov r30, r28 //copy the noise_param into r30
002b61 95e2                      	swap r30
002b62 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002b63 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002b64 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002b65 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
002b66 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
002b67 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002b68 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
002b69 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002b6a f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002b6b efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002b6c c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
002b6d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002b6e f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002b6f e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
002b70 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
002b72 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002b73 95a2                      	swap r26
002b74 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002b75 2bca                      	or r28, r26 //store the new volume back into noise_param
002b76 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Qxy_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
002b78 91ff                      	pop r31
002b79 91ef                      	pop r30
002b7a 91df                      	pop r29
002b7b 91cf                      	pop r28
002b7c 940c 125f                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
002b7e 7f05
002b7f 010a
002b80 0214
002b81 0328
002b82 0450
002b83 051e
002b84 0607
002b85 070d
002b86 0806
002b87 090c
002b88 0a18
002b89 0b30
002b8a 0c60
002b8b 0d24
002b8c 0e08
002b8d 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
002b8e 0301
002b8f fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
002b90 149b
002b91 14a0
002b92 14bc
002b93 14d8
002b94 14fb                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
002b95 1506
002b96 1513
002b97 1516
002b98 1519
002b99 151c                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
002b9a 151f
002b9b 1527
002b9c 152a
002b9d 1537
002b9e 1538                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
002b9f 1539
002ba0 153a
002ba1 153b
002ba2 1553
002ba3 1595                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
002ba4 15d6
002ba5 15e3
002ba6 15f7
002ba7 15f8
002ba8 15f9                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
002ba9 15fa                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
002baa 1789
002bab 178e
002bac 17aa
002bad 17c6
002bae 17e9                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
002baf 17f4
002bb0 1801
002bb1 1804
002bb2 1807
002bb3 180a                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
002bb4 180d
002bb5 1815
002bb6 1818
002bb7 1825
002bb8 1826                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
002bb9 1827
002bba 1828
002bbb 1829
002bbc 1841
002bbd 1883                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
002bbe 18c4
002bbf 18d1
002bc0 18e5
002bc1 18e6
002bc2 18e7                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
002bc3 18e8                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
002bc4 1a6a
002bc5 1a6f
002bc6 1a8b
002bc7 1aa7
002bc8 1aca                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
002bc9 1ad5
002bca 1ad6
002bcb 1ad7
002bcc 1ada
002bcd 1add                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
002bce 1ae0
002bcf 1aed
002bd0 1af0
002bd1 1afd
002bd2 1afe                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
002bd3 1aff
002bd4 1b00
002bd5 1b01
002bd6 1b19
002bd7 1b5b                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
002bd8 1b9c
002bd9 1ba9
002bda 1baa
002bdb 1bab
002bdc 1bac                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
002bdd 1bad                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
002bde 1d33
002bdf 1d38
002be0 1d41
002be1 1d4a
002be2 1d4b                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
002be3 1d58
002be4 1d65
002be5 1d68
002be6 1d6b
002be7 1d6e                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
002be8 1d71
002be9 1d78
002bea 1d7b
002beb 1d88
002bec 1d89                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
002bed 1d8a
002bee 1d8b
002bef 1d8c
002bf0 1d8f
002bf1 1d90                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
002bf2 1d91
002bf3 1d9e
002bf4 1da9
002bf5 1daa
002bf6 1dab                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
002bf7 1dac                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
002bf8 0000
002bf9 0000
002bfa 0000
002bfb 0000
002bfc 0000
002bfd 0000
002bfe 0000
002bff 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
002c00 0100
002c01 0101
002c02 0101
002c03 0101
002c04 0101
002c05 0101
002c06 0101
002c07 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
002c08 0100
002c09 0101
002c0a 0101
002c0b 0101
002c0c 0101
002c0d 0101
002c0e 0101
002c0f 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
002c10 0100
002c11 0101
002c12 0101
002c13 0101
002c14 0101
002c15 0202
002c16 0202
002c17 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
002c18 0100
002c19 0101
002c1a 0101
002c1b 0101
002c1c 0202
002c1d 0202
002c1e 0303
002c1f 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
002c20 0100
002c21 0101
002c22 0101
002c23 0202
002c24 0302
002c25 0303
002c26 0404
002c27 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
002c28 0100
002c29 0101
002c2a 0201
002c2b 0202
002c2c 0303
002c2d 0404
002c2e 0504
002c2f 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
002c30 0100
002c31 0101
002c32 0201
002c33 0302
002c34 0403
002c35 0504
002c36 0605
002c37 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
002c38 0100
002c39 0101
002c3a 0202
002c3b 0303
002c3c 0404
002c3d 0505
002c3e 0606
002c3f 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
002c40 0100
002c41 0101
002c42 0302
002c43 0403
002c44 0504
002c45 0606
002c46 0707
002c47 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
002c48 0100
002c49 0201
002c4a 0302
002c4b 0404
002c4c 0605
002c4d 0706
002c4e 0808
002c4f 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
002c50 0100
002c51 0201
002c52 0302
002c53 0504
002c54 0605
002c55 0807
002c56 0908
002c57 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
002c58 0100
002c59 0201
002c5a 0403
002c5b 0504
002c5c 0706
002c5d 0808
002c5e 0a09
002c5f 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
002c60 0100
002c61 0201
002c62 0403
002c63 0605
002c64 0706
002c65 0908
002c66 0b0a
002c67 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
002c68 0100
002c69 0201
002c6a 0403
002c6b 0605
002c6c 0807
002c6d 0a09
002c6e 0c0b
002c6f 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
002c70 0100
002c71 0302
002c72 0504
002c73 0706
002c74 0908
002c75 0b0a
002c76 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 233 r0 : 148 r1 : 160 r2 : 643 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 138 r23: 124 r24:   0 r25:  24 r26: 908 r27:1143 r28: 661 
r29: 339 r30: 359 r31: 312 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 128 add   : 178 adiw  :  94 and   :   0 
andi  :  97 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   6 brcs  :  13 break :   0 breq  : 163 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  76 brlt  :   0 brmi  :   0 
brne  : 119 brpl  :   0 brsh  :  32 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 106 cpc   :  15 
cpi   : 167 cpse  :  19 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  46 
jmp   :  11 ld    :   0 ldd   :   0 ldi   : 296 lds   : 653 lpm   : 254 
lsl   :  75 lsr   : 135 mov   : 128 movw  :   0 mul   :  21 muls  :   0 
mulsu :  10 neg   :   1 nop   :   0 or    :  24 ori   :  12 out   :   9 
pop   :  97 push  :  91 rcall :  50 ret   :  32 reti  :   7 rjmp  : 506 
rol   :  53 ror   : 156 sbc   :  30 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  25 sbrs  :  18 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1307 sub   :  51 subi  :  45 swap  :  44 tst   :   0 wdr   :   0 

Instructions used: 53 out of 114 (46.5%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0058f0  14746   7910  22656   49152  46.1%
[.dseg] 0x002800 0x002949      0    329    329    6144   5.4%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 55 warnings
