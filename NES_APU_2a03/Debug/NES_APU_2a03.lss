
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Thu Jan 21 23:56:03 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
                                 
002818                           song_frames: .byte 2
00281a                           song_frame_offset: .byte 2
00281c                           song_size: .byte 2
00281e                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281f                           song_fx_Bxx: .byte 1
002820                           song_fx_Cxx: .byte 1
002821                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002822                           pulse1_pattern: .byte 2
002824                           pulse1_pattern_delay_rows: .byte 1
002825                           pulse1_pattern_delay_frames: .byte 1
002826                           pulse1_pattern_offset: .byte 2
                                 
002828                           pulse1_volume_macro: .byte 2
00282a                           pulse1_volume_macro_offset: .byte 1
00282b                           pulse1_volume_macro_loop: .byte 1
00282c                           pulse1_volume_macro_release: .byte 1
                                 
00282d                           pulse1_arpeggio_macro: .byte 2
00282f                           pulse1_arpeggio_macro_offset: .byte 1
002830                           pulse1_arpeggio_macro_loop: .byte 1
002831                           pulse1_arpeggio_macro_release: .byte 1
002832                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002833                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002835                           pulse1_pitch_macro: .byte 2
002837                           pulse1_pitch_macro_offset: .byte 1
002838                           pulse1_pitch_macro_loop: .byte 1
002839                           pulse1_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283b                           pulse1_hi_pitch_macro: .byte 2
00283d                           pulse1_hi_pitch_macro_offset: .byte 1
00283e                           pulse1_hi_pitch_macro_loop: .byte 1
00283f                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002840                           pulse1_duty_macro: .byte 2
002842                           pulse1_duty_macro_offset: .byte 1
002843                           pulse1_duty_macro_loop: .byte 1
002844                           pulse1_duty_macro_release: .byte 1
                                 
002845                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002847                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002849                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284b                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284d                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00284f                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002851                           pulse1_fx_3xx_target: .byte 2 //target note period
002853                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_3xx_total_offset: .byte 2
002857                           pulse1_fx_4xy_speed: .byte 1
002858                           pulse1_fx_4xy_depth: .byte 1
002859                           pulse1_fx_4xy_phase: .byte 1
00285a                           pulse1_fx_7xy_speed: .byte 1
00285b                           pulse1_fx_7xy_depth: .byte 1
00285c                           pulse1_fx_7xy_phase: .byte 1
00285d                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00285f                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002860                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002861                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002863                           pulse1_fx_Qxy_target: .byte 2 //target note period
002865                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002867                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002869                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286b                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00286d                           pulse1_fx_Rxy_total_offset: .byte 2
00286f                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002870                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002871                           pulse2_pattern: .byte 2
002873                           pulse2_pattern_delay_rows: .byte 1
002874                           pulse2_pattern_delay_frames: .byte 1
002875                           pulse2_pattern_offset: .byte 2
                                 
002877                           pulse2_volume_macro: .byte 2
002879                           pulse2_volume_macro_offset: .byte 1
00287a                           pulse2_volume_macro_loop: .byte 1
00287b                           pulse2_volume_macro_release: .byte 1
                                 
00287c                           pulse2_arpeggio_macro: .byte 2
00287e                           pulse2_arpeggio_macro_offset: .byte 1
00287f                           pulse2_arpeggio_macro_loop: .byte 1
002880                           pulse2_arpeggio_macro_release: .byte 1
002881                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002882                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002884                           pulse2_pitch_macro: .byte 2
002886                           pulse2_pitch_macro_offset: .byte 1
002887                           pulse2_pitch_macro_loop: .byte 1
002888                           pulse2_pitch_macro_release: .byte 1
                                 
002889                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288a                           pulse2_hi_pitch_macro: .byte 2
00288c                           pulse2_hi_pitch_macro_offset: .byte 1
00288d                           pulse2_hi_pitch_macro_loop: .byte 1
00288e                           pulse2_hi_pitch_macro_release: .byte 1
                                 
00288f                           pulse2_duty_macro: .byte 2
002891                           pulse2_duty_macro_offset: .byte 1
002892                           pulse2_duty_macro_loop: .byte 1
002893                           pulse2_duty_macro_release: .byte 1
                                 
002894                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002896                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002898                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289a                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289c                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00289e                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a0                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a2                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a4                           pulse2_fx_3xx_total_offset: .byte 2
0028a6                           pulse2_fx_4xy_speed: .byte 1
0028a7                           pulse2_fx_4xy_depth: .byte 1
0028a8                           pulse2_fx_4xy_phase: .byte 1
0028a9                           pulse2_fx_7xy_speed: .byte 1
0028aa                           pulse2_fx_7xy_depth: .byte 1
0028ab                           pulse2_fx_7xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028ad                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028ae                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028af                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b0                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b2                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b4                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028b6                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028b8                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028ba                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028bc                           pulse2_fx_Rxy_total_offset: .byte 2
0028be                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028bf                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c0                           triangle_pattern: .byte 2
0028c2                           triangle_pattern_delay_rows: .byte 1
0028c3                           triangle_pattern_delay_frames: .byte 1
0028c4                           triangle_pattern_offset: .byte 2
                                 
0028c6                           triangle_volume_macro: .byte 2
0028c8                           triangle_volume_macro_offset: .byte 1
0028c9                           triangle_volume_macro_loop: .byte 1
0028ca                           triangle_volume_macro_release: .byte 1
                                 
0028cb                           triangle_arpeggio_macro: .byte 2
0028cd                           triangle_arpeggio_macro_offset: .byte 1
0028ce                           triangle_arpeggio_macro_loop: .byte 1
0028cf                           triangle_arpeggio_macro_release: .byte 1
0028d0                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d1                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d3                           triangle_pitch_macro: .byte 2
0028d5                           triangle_pitch_macro_offset: .byte 1
0028d6                           triangle_pitch_macro_loop: .byte 1
0028d7                           triangle_pitch_macro_release: .byte 1
                                 
0028d8                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028d9                           triangle_hi_pitch_macro: .byte 2
0028db                           triangle_hi_pitch_macro_offset: .byte 1
0028dc                           triangle_hi_pitch_macro_loop: .byte 1
0028dd                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028de                           triangle_duty_macro: .byte 2
0028e0                           triangle_duty_macro_offset: .byte 1
0028e1                           triangle_duty_macro_loop: .byte 1
0028e2                           triangle_duty_macro_release: .byte 1
                                 
0028e3                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028e5                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028e7                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028e9                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028eb                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028ed                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028ef                           triangle_fx_3xx_target: .byte 2 //target note period
0028f1                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f3                           triangle_fx_3xx_total_offset: .byte 2
0028f5                           triangle_fx_4xy_speed: .byte 1
0028f6                           triangle_fx_4xy_depth: .byte 1
0028f7                           triangle_fx_4xy_phase: .byte 1
0028f8                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028f9                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028fa                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028fc                           triangle_fx_Qxy_target: .byte 2 //target note period
0028fe                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002900                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002902                           triangle_fx_Rxy_target: .byte 2 //target note period
002904                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Rxy_total_offset: .byte 2
002908                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002909                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
00290a                           noise_pattern: .byte 2
00290c                           noise_pattern_delay_rows: .byte 1
00290d                           noise_pattern_delay_frames: .byte 1
00290e                           noise_pattern_offset: .byte 2
                                 
002910                           noise_volume_macro: .byte 2
002912                           noise_volume_macro_offset: .byte 1
002913                           noise_volume_macro_loop: .byte 1
002914                           noise_volume_macro_release: .byte 1
                                 
002915                           noise_arpeggio_macro: .byte 2
002917                           noise_arpeggio_macro_offset: .byte 1
002918                           noise_arpeggio_macro_loop: .byte 1
002919                           noise_arpeggio_macro_release: .byte 1
00291a                           noise_arpeggio_macro_mode: .byte 1
                                 
00291b                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
00291d                           noise_pitch_macro: .byte 2
00291f                           noise_pitch_macro_offset: .byte 1
002920                           noise_pitch_macro_loop: .byte 1
002921                           noise_pitch_macro_release: .byte 1
                                 
002922                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002923                           noise_hi_pitch_macro: .byte 2
002925                           noise_hi_pitch_macro_offset: .byte 1
002926                           noise_hi_pitch_macro_loop: .byte 1
002927                           noise_hi_pitch_macro_release: .byte 1
                                 
002928                           noise_duty_macro: .byte 2
00292a                           noise_duty_macro_offset: .byte 1
00292b                           noise_duty_macro_loop: .byte 1
00292c                           noise_duty_macro_release: .byte 1
                                 
00292d                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00292f                           noise_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002931                           noise_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002933                           noise_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002935                           noise_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002937                           noise_fx_3xx_start: .byte 2 //the starting note period
002939                           noise_fx_3xx_target: .byte 2 //target note period
00293b                           noise_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00293d                           noise_fx_3xx_total_offset: .byte 2
00293f                           noise_fx_4xy_speed: .byte 1
002940                           noise_fx_4xy_depth: .byte 1
002941                           noise_fx_4xy_phase: .byte 1
002942                           noise_fx_7xy_speed: .byte 1
002943                           noise_fx_7xy_depth: .byte 1
002944                           noise_fx_7xy_phase: .byte 1
002945                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002946                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002947                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002948                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002949                           noise_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
00294b                           noise_fx_Qxy_target: .byte 2 //target note period
00294d                           noise_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00294f                           noise_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002951                           noise_fx_Rxy_target: .byte 2 //target note period
002953                           noise_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002955                           noise_fx_Rxy_total_offset: .byte 2
002957                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002958                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002959                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 135b                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 1809                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1710                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 171b                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1710                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1732                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 177f                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 17cc                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 17d7                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(126): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(144): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(149): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(153): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(155): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(156): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(160): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(161): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(168): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(169): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(171): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(173): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(174): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(176): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(177): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(179): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(180): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(181): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(185): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(186): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(297): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(298): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(299): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(301): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(306): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(307): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(308): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(309): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(311): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(312): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(313): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(314): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(316): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(320): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(322): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(323): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(325): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(326): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(328): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(332): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(336): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(337): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(338): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(339): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(341): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(342): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(343): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(346): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(347): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(350): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(351): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(353): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(360): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(361): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(348): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
00135b edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
00135c 93c0 0034                 	sts CPU_CCP, r28
00135e e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
00135f 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001361 2422                      	clr zero
                                 
                                 	//MEMORY
001362 e3c0                      	ldi r28, 0b00110000
001363 93c0 2800                 	sts pulse1_param, r28
001365 e8c0                      	ldi r28, 0b10000000
001366 93c0 2801                 	sts pulse1_sweep_param, r28
001368 efcf                      	ldi r28, 0xFF
001369 93c0 2802                 	sts pulse1_timerL, r28
00136b 93c0 2803                 	sts pulse1_timerH, r28
00136d 93c0 2804                 	sts pulse1_length, r28
                                 
00136f e3c0                      	ldi r28, 0b00110000
001370 93c0 2808                 	sts pulse2_param, r28
001372 e8c0                      	ldi r28, 0b10000000
001373 93c0 2809                 	sts pulse2_sweep_param, r28
001375 efcf                      	ldi r28, 0xFF
001376 93c0 280a                 	sts pulse2_timerL, r28
001378 93c0 280b                 	sts pulse2_timerH, r28
00137a 93c0 280c                 	sts pulse2_length, r28
                                 
00137c efcf                      	ldi r28, 0xFF
00137d 93c0 2810                 	sts triangle_timerL, r28
00137f 93c0 2811                 	sts triangle_timerH, r28
                                 
001381 e3c0                      	ldi r28, 0b00110000
001382 93c0 2813                 	sts noise_param, r28
001384 e0cf                      	ldi r28, 0b00001111
001385 93c0 2814                 	sts noise_period, r28
                                 
001387 e0c2                      	ldi r28, 0x02
001388 93c0 281a                 	sts song_frame_offset, r28
00138a 9220 281b                 	sts song_frame_offset+1, zero
00138c efcf                      	ldi r28, 0xFF
00138d 93c0 281f                 	sts song_fx_Bxx, r28
00138f 9220 2820                 	sts song_fx_Cxx, zero
001391 9220 2821                 	sts song_fx_Dxx, zero
001393 e4ee                      	ldi ZL, LOW(song0_frames << 1)
001394 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
001395 93e0 2818                 	sts song_frames, ZL
001397 93f0 2819                 	sts song_frames+1, ZH
001399 91c5                      	lpm r28, Z+ //load the song size
00139a 91d5                      	lpm r29, Z+
00139b 93c0 281c                 	sts song_size, r28
00139d 93d0 281d                 	sts song_size+1, r29
00139f 9220 281e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0013a1 91c5                      	lpm r28, Z+
0013a2 91d5                      	lpm r29, Z+
0013a3 0fcc                      	lsl r28
0013a4 1fdd                      	rol r29
0013a5 93c0 2822                 	sts pulse1_pattern, r28
0013a7 93d0 2823                 	sts pulse1_pattern+1, r29
0013a9 9220 2824                 	sts pulse1_pattern_delay_rows, zero
0013ab 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0013ad 9220 2826                 	sts pulse1_pattern_offset, zero
0013af 9220 2827                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0013b1 91c5                      	lpm r28, Z+
0013b2 91d5                      	lpm r29, Z+
0013b3 0fcc                      	lsl r28
0013b4 1fdd                      	rol r29
0013b5 93c0 2871                 	sts pulse2_pattern, r28
0013b7 93d0 2872                 	sts pulse2_pattern+1, r29
0013b9 9220 2873                 	sts pulse2_pattern_delay_rows, zero
0013bb 9220 2874                 	sts pulse2_pattern_delay_frames, zero
0013bd 9220 2875                 	sts pulse2_pattern_offset, zero
0013bf 9220 2876                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0013c1 91c5                      	lpm r28, Z+
0013c2 91d5                      	lpm r29, Z+
0013c3 0fcc                      	lsl r28
0013c4 1fdd                      	rol r29
0013c5 93c0 28c0                 	sts triangle_pattern, r28
0013c7 93d0 28c1                 	sts triangle_pattern+1, r29
0013c9 9220 28c2                 	sts triangle_pattern_delay_rows, zero
0013cb 9220 28c3                 	sts triangle_pattern_delay_frames, zero
0013cd 9220 28c4                 	sts triangle_pattern_offset, zero
0013cf 9220 28c5                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0013d1 91c5                      	lpm r28, Z+
0013d2 91d5                      	lpm r29, Z+
0013d3 0fcc                      	lsl r28
0013d4 1fdd                      	rol r29
0013d5 93c0 290a                 	sts noise_pattern, r28
0013d7 93d0 290b                 	sts noise_pattern+1, r29
0013d9 9220 290c                 	sts noise_pattern_delay_rows, zero
0013db 9220 290d                 	sts noise_pattern_delay_frames, zero
0013dd 9220 290e                 	sts noise_pattern_offset, zero
0013df 9220 290f                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0013e1 efcf                      	ldi r28, 0xFF
0013e2 9220 282a                 	sts pulse1_volume_macro_offset, zero
0013e4 93c0 282b                 	sts pulse1_volume_macro_loop, r28
0013e6 93c0 282c                 	sts pulse1_volume_macro_release, r28
0013e8 9220 282f                 	sts pulse1_arpeggio_macro_offset, zero
0013ea 93c0 2830                 	sts pulse1_arpeggio_macro_loop, r28
0013ec 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
0013ee 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
0013f0 9220 2837                 	sts pulse1_pitch_macro_offset, zero
0013f2 93c0 2838                 	sts pulse1_pitch_macro_loop, r28
0013f4 93c0 2839                 	sts pulse1_pitch_macro_release, r28
0013f6 9220 283d                 	sts pulse1_hi_pitch_macro_offset, zero
0013f8 93c0 283e                 	sts pulse1_hi_pitch_macro_loop, r28
0013fa 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
0013fc 9220 2842                 	sts pulse1_duty_macro_offset, zero
0013fe 93c0 2843                 	sts pulse1_duty_macro_loop, r28
001400 93c0 2844                 	sts pulse1_duty_macro_release, r28
                                 
001402 9220 2828                 	sts pulse1_volume_macro, zero
001404 9220 2829                 	sts pulse1_volume_macro+1, zero
001406 9220 282d                 	sts pulse1_arpeggio_macro, zero
001408 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
00140a 9220 2833                 	sts pulse1_total_pitch_offset, zero
00140c 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
00140e 9220 2835                 	sts pulse1_pitch_macro, zero
001410 9220 2836                 	sts pulse1_pitch_macro+1, zero
001412 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
001414 9220 283b                 	sts pulse1_hi_pitch_macro, zero
001416 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
001418 9220 2840                 	sts pulse1_duty_macro, zero
00141a 9220 2841                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
00141c e00f                      	ldi pulse1_volume_divider, 0x0F
00141d 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00141f 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001420 9190 2800                 	lds pulse_channel_flags, pulse1_param
001422 7390                      	andi pulse_channel_flags, 0b00110000
001423 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001424 9220 2806                 	sts pulse1_output_volume, zero
001426 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001428 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001429 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00142a 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
00142b 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
00142d 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
00142e 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
00142f efcf                      	ldi r28, 0xFF
001430 9220 2845                 	sts pulse1_fx_0xy_sequence, zero
001432 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
001434 9220 2847                 	sts pulse1_fx_1xx, zero
001436 9220 2848                 	sts pulse1_fx_1xx+1, zero
001438 9220 2849                 	sts pulse1_fx_1xx_total, zero
00143a 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
00143c 9220 284b                 	sts pulse1_fx_2xx, zero
00143e 9220 284c                 	sts pulse1_fx_2xx+1, zero
001440 9220 284d                 	sts pulse1_fx_2xx_total, zero
001442 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
001444 9220 284f                 	sts pulse1_fx_3xx_start, zero
001446 9220 2850                 	sts pulse1_fx_3xx_start+1, zero
001448 9220 2851                 	sts pulse1_fx_3xx_target, zero
00144a 9220 2852                 	sts pulse1_fx_3xx_target+1, zero
00144c 9220 2853                 	sts pulse1_fx_3xx_speed, zero
00144e 9220 2854                 	sts pulse1_fx_3xx_speed+1, zero
001450 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
001452 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
001454 9220 2857                 	sts pulse1_fx_4xy_speed, zero
001456 9220 2858                 	sts pulse1_fx_4xy_depth, zero
001458 9220 2859                 	sts pulse1_fx_4xy_phase, zero
00145a 9220 285a                 	sts pulse1_fx_7xy_speed, zero
00145c 9220 285b                 	sts pulse1_fx_7xy_depth, zero
00145e 9220 285c                 	sts pulse1_fx_7xy_phase, zero
001460 9220 285d                 	sts pulse1_fx_7xy_value, zero
001462 9220 285e                 	sts pulse1_fx_Axy, zero
001464 93c0 285f                 	sts pulse1_fx_Gxx_pre, r28
001466 93c0 2860                 	sts pulse1_fx_Gxx_post, r28
001468 9220 2861                 	sts pulse1_fx_Pxx_total, zero
00146a 9220 2862                 	sts pulse1_fx_Pxx_total+1, zero
00146c 9220 2863                 	sts pulse1_fx_Qxy_target, zero
00146e 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001470 9220 2865                 	sts pulse1_fx_Qxy_speed, zero
001472 9220 2866                 	sts pulse1_fx_Qxy_speed+1, zero
001474 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001476 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001478 9220 2869                 	sts pulse1_fx_Rxy_target, zero
00147a 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
00147c 9220 286b                 	sts pulse1_fx_Rxy_speed, zero
00147e 9220 286c                 	sts pulse1_fx_Rxy_speed+1, zero
001480 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
001482 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
001484 93c0 286f                 	sts pulse1_fx_Sxx_pre, r28
001486 93c0 2870                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
001488 efcf                      	ldi r28, 0xFF
001489 9220 2879                 	sts pulse2_volume_macro_offset, zero
00148b 93c0 287a                 	sts pulse2_volume_macro_loop, r28
00148d 93c0 287b                 	sts pulse2_volume_macro_release, r28
00148f 9220 287e                 	sts pulse2_arpeggio_macro_offset, zero
001491 93c0 287f                 	sts pulse2_arpeggio_macro_loop, r28
001493 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
001495 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
001497 9220 2886                 	sts pulse2_pitch_macro_offset, zero
001499 93c0 2887                 	sts pulse2_pitch_macro_loop, r28
00149b 93c0 2888                 	sts pulse2_pitch_macro_release, r28
00149d 9220 288c                 	sts pulse2_hi_pitch_macro_offset, zero
00149f 93c0 288d                 	sts pulse2_hi_pitch_macro_loop, r28
0014a1 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
0014a3 9220 2891                 	sts pulse2_duty_macro_offset, zero
0014a5 93c0 2892                 	sts pulse2_duty_macro_loop, r28
0014a7 93c0 2893                 	sts pulse2_duty_macro_release, r28
                                 
0014a9 9220 2877                 	sts pulse2_volume_macro, zero
0014ab 9220 2878                 	sts pulse2_volume_macro+1, zero
0014ad 9220 287c                 	sts pulse2_arpeggio_macro, zero
0014af 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
0014b1 9220 2882                 	sts pulse2_total_pitch_offset, zero
0014b3 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
0014b5 9220 2884                 	sts pulse2_pitch_macro, zero
0014b7 9220 2885                 	sts pulse2_pitch_macro+1, zero
0014b9 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
0014bb 9220 288a                 	sts pulse2_hi_pitch_macro, zero
0014bd 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
0014bf 9220 288f                 	sts pulse2_duty_macro, zero
0014c1 9220 2890                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0014c3 e02f                      	ldi pulse2_volume_divider, 0x0F
0014c4 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0014c6 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0014c7 91d0 2808                 	lds r29, pulse2_param
0014c9 73d0                      	andi r29, 0b00110000
0014ca 62d0                      	sbr r29, 0b0100000 //set start flag
0014cb 95d2                      	swap r29
0014cc 2b9d                      	or pulse_channel_flags, r29
0014cd 9220 280e                 	sts pulse2_output_volume, zero
0014cf 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0014d1 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0014d2 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0014d3 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0014d4 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0014d6 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
0014d7 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0014d8 efcf                      	ldi r28, 0xFF
0014d9 9220 2894                 	sts pulse2_fx_0xy_sequence, zero
0014db 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
0014dd 9220 2896                 	sts pulse2_fx_1xx, zero
0014df 9220 2897                 	sts pulse2_fx_1xx+1, zero
0014e1 9220 2898                 	sts pulse2_fx_1xx_total, zero
0014e3 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
0014e5 9220 289a                 	sts pulse2_fx_2xx, zero
0014e7 9220 289b                 	sts pulse2_fx_2xx+1, zero
0014e9 9220 289c                 	sts pulse2_fx_2xx_total, zero
0014eb 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
0014ed 9220 289e                 	sts pulse2_fx_3xx_start, zero
0014ef 9220 289f                 	sts pulse2_fx_3xx_start+1, zero
0014f1 9220 28a0                 	sts pulse2_fx_3xx_target, zero
0014f3 9220 28a1                 	sts pulse2_fx_3xx_target+1, zero
0014f5 9220 28a2                 	sts pulse2_fx_3xx_speed, zero
0014f7 9220 28a3                 	sts pulse2_fx_3xx_speed+1, zero
0014f9 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
0014fb 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
0014fd 9220 28a6                 	sts pulse2_fx_4xy_speed, zero
0014ff 9220 28a7                 	sts pulse2_fx_4xy_depth, zero
001501 9220 28a8                 	sts pulse2_fx_4xy_phase, zero
001503 9220 28a9                 	sts pulse2_fx_7xy_speed, zero
001505 9220 28aa                 	sts pulse2_fx_7xy_depth, zero
001507 9220 28ab                 	sts pulse2_fx_7xy_phase, zero
001509 9220 28ac                 	sts pulse2_fx_7xy_value, zero
00150b 9220 28ad                 	sts pulse2_fx_Axy, zero
00150d 93c0 28ae                 	sts pulse2_fx_Gxx_pre, r28
00150f 93c0 28af                 	sts pulse2_fx_Gxx_post, r28
001511 9220 28b0                 	sts pulse2_fx_Pxx_total, zero
001513 9220 28b1                 	sts pulse2_fx_Pxx_total+1, zero
001515 9220 28b2                 	sts pulse2_fx_Qxy_target, zero
001517 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001519 9220 28b4                 	sts pulse2_fx_Qxy_speed, zero
00151b 9220 28b5                 	sts pulse2_fx_Qxy_speed+1, zero
00151d 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
00151f 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001521 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001523 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001525 9220 28ba                 	sts pulse2_fx_Rxy_speed, zero
001527 9220 28bb                 	sts pulse2_fx_Rxy_speed+1, zero
001529 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
00152b 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
00152d 93c0 28be                 	sts pulse2_fx_Sxx_pre, r28
00152f 93c0 28bf                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001531 efcf                      	ldi r28, 0xFF
001532 9220 28c8                 	sts triangle_volume_macro_offset, zero
001534 93c0 28c9                 	sts triangle_volume_macro_loop, r28
001536 93c0 28ca                 	sts triangle_volume_macro_release, r28
001538 9220 28cd                 	sts triangle_arpeggio_macro_offset, zero
00153a 93c0 28ce                 	sts triangle_arpeggio_macro_loop, r28
00153c 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
00153e 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
001540 9220 28d5                 	sts triangle_pitch_macro_offset, zero
001542 93c0 28d6                 	sts triangle_pitch_macro_loop, r28
001544 93c0 28d7                 	sts triangle_pitch_macro_release, r28
001546 9220 28db                 	sts triangle_hi_pitch_macro_offset, zero
001548 93c0 28dc                 	sts triangle_hi_pitch_macro_loop, r28
00154a 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
00154c 9220 28e0                 	sts triangle_duty_macro_offset, zero
00154e 93c0 28e1                 	sts triangle_duty_macro_loop, r28
001550 93c0 28e2                 	sts triangle_duty_macro_release, r28
                                 
001552 9220 28c6                 	sts triangle_volume_macro, zero
001554 9220 28c7                 	sts triangle_volume_macro+1, zero
001556 9220 28cb                 	sts triangle_arpeggio_macro, zero
001558 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
00155a 9220 28d1                 	sts triangle_total_pitch_offset, zero
00155c 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
00155e 9220 28d3                 	sts triangle_pitch_macro, zero
001560 9220 28d4                 	sts triangle_pitch_macro+1, zero
001562 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
001564 9220 28d9                 	sts triangle_hi_pitch_macro, zero
001566 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
001568 9220 28de                 	sts triangle_duty_macro, zero
00156a 9220 28df                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
00156c e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
00156d 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
00156e efcf                      	ldi r28, 0xFF
00156f 9220 28e3                 	sts triangle_fx_0xy_sequence, zero
001571 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001573 9220 28e5                 	sts triangle_fx_1xx, zero
001575 9220 28e6                 	sts triangle_fx_1xx+1, zero
001577 9220 28e7                 	sts triangle_fx_1xx_total, zero
001579 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
00157b 9220 28e9                 	sts triangle_fx_2xx, zero
00157d 9220 28ea                 	sts triangle_fx_2xx+1, zero
00157f 9220 28eb                 	sts triangle_fx_2xx_total, zero
001581 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
001583 9220 28ed                 	sts triangle_fx_3xx_start, zero
001585 9220 28ee                 	sts triangle_fx_3xx_start+1, zero
001587 9220 28ef                 	sts triangle_fx_3xx_target, zero
001589 9220 28f0                 	sts triangle_fx_3xx_target+1, zero
00158b 9220 28f1                 	sts triangle_fx_3xx_speed, zero
00158d 9220 28f2                 	sts triangle_fx_3xx_speed+1, zero
00158f 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
001591 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
001593 9220 28f5                 	sts triangle_fx_4xy_speed, zero
001595 9220 28f6                 	sts triangle_fx_4xy_depth, zero
001597 9220 28f7                 	sts triangle_fx_4xy_phase, zero
001599 93c0 28f8                 	sts triangle_fx_Gxx_pre, r28
00159b 93c0 28f9                 	sts triangle_fx_Gxx_post, r28
00159d 9220 28fa                 	sts triangle_fx_Pxx_total, zero
00159f 9220 28fb                 	sts triangle_fx_Pxx_total+1, zero
0015a1 9220 28fc                 	sts triangle_fx_Qxy_target, zero
0015a3 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
0015a5 9220 28fe                 	sts triangle_fx_Qxy_speed, zero
0015a7 9220 28ff                 	sts triangle_fx_Qxy_speed+1, zero
0015a9 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
0015ab 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
0015ad 9220 2902                 	sts triangle_fx_Rxy_target, zero
0015af 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
0015b1 9220 2904                 	sts triangle_fx_Rxy_speed, zero
0015b3 9220 2905                 	sts triangle_fx_Rxy_speed+1, zero
0015b5 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
0015b7 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
0015b9 93c0 2908                 	sts triangle_fx_Sxx_pre, r28
0015bb 93c0 2909                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0015bd efcf                      	ldi r28, 0xFF
0015be 9220 2912                 	sts noise_volume_macro_offset, zero
0015c0 93c0 2913                 	sts noise_volume_macro_loop, r28
0015c2 93c0 2914                 	sts noise_volume_macro_release, r28
0015c4 9220 2917                 	sts noise_arpeggio_macro_offset, zero
0015c6 93c0 2918                 	sts noise_arpeggio_macro_loop, r28
0015c8 93c0 2919                 	sts noise_arpeggio_macro_release, r28
0015ca 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
0015cc 9220 291f                 	sts noise_pitch_macro_offset, zero
0015ce 93c0 2920                 	sts noise_pitch_macro_loop, r28
0015d0 93c0 2921                 	sts noise_pitch_macro_release, r28
0015d2 9220 2925                 	sts noise_hi_pitch_macro_offset, zero
0015d4 93c0 2926                 	sts noise_hi_pitch_macro_loop, r28
0015d6 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
0015d8 9220 292a                 	sts noise_duty_macro_offset, zero
0015da 93c0 292b                 	sts noise_duty_macro_loop, r28
0015dc 93c0 292c                 	sts noise_duty_macro_release, r28
                                 
0015de 9220 2910                 	sts noise_volume_macro, zero
0015e0 9220 2911                 	sts noise_volume_macro+1, zero
0015e2 9220 2915                 	sts noise_arpeggio_macro, zero
0015e4 9220 2916                 	sts noise_arpeggio_macro+1, zero
0015e6 9220 291b                 	sts noise_total_pitch_offset, zero
0015e8 9220 291c                 	sts noise_total_pitch_offset+1, zero
0015ea 9220 291d                 	sts noise_pitch_macro, zero
0015ec 9220 291e                 	sts noise_pitch_macro+1, zero
0015ee 9220 2922                 	sts noise_total_hi_pitch_offset, zero
0015f0 9220 2923                 	sts noise_hi_pitch_macro, zero
0015f2 9220 2924                 	sts noise_hi_pitch_macro+1, zero
0015f4 9220 2928                 	sts noise_duty_macro, zero
0015f6 9220 2929                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
0015f8 9220 2816                 	sts noise_output_volume, zero
0015fa 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
0015fc e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
0015fd 2f5c                      	mov noise_sequence_LOW, r28
0015fe 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
0015ff efcf                      	ldi r28, 0xFF
001600 9220 292d                 	sts noise_fx_0xy_sequence, zero
001602 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
001604 9220 292f                 	sts noise_fx_1xx, zero
001606 9220 2930                 	sts noise_fx_1xx+1, zero
001608 9220 2931                 	sts noise_fx_1xx_total, zero
00160a 9220 2932                 	sts noise_fx_1xx_total+1, zero
00160c 9220 2933                 	sts noise_fx_2xx, zero
00160e 9220 2934                 	sts noise_fx_2xx+1, zero
001610 9220 2935                 	sts noise_fx_2xx_total, zero
001612 9220 2936                 	sts noise_fx_2xx_total+1, zero
001614 9220 2937                 	sts noise_fx_3xx_start, zero
001616 9220 2938                 	sts noise_fx_3xx_start+1, zero
001618 9220 2939                 	sts noise_fx_3xx_target, zero
00161a 9220 293a                 	sts noise_fx_3xx_target+1, zero
00161c 9220 293b                 	sts noise_fx_3xx_speed, zero
00161e 9220 293c                 	sts noise_fx_3xx_speed+1, zero
001620 9220 293d                 	sts noise_fx_3xx_total_offset, zero
001622 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
001624 9220 293f                 	sts noise_fx_4xy_speed, zero
001626 9220 2940                 	sts noise_fx_4xy_depth, zero
001628 9220 2941                 	sts noise_fx_4xy_phase, zero
00162a 9220 2942                 	sts noise_fx_7xy_speed, zero
00162c 9220 2943                 	sts noise_fx_7xy_depth, zero
00162e 9220 2944                 	sts noise_fx_7xy_phase, zero
001630 9220 2945                 	sts noise_fx_7xy_value, zero
001632 9220 2946                 	sts noise_fx_Axy, zero
001634 93c0 2947                 	sts noise_fx_Gxx_pre, r28
001636 93c0 2948                 	sts noise_fx_Gxx_post, r28
001638 9220 2949                 	sts noise_fx_Pxx_total, zero
00163a 9220 294a                 	sts noise_fx_Pxx_total+1, zero
00163c 9220 294b                 	sts noise_fx_Qxy_target, zero
00163e 9220 294c                 	sts noise_fx_Qxy_target+1, zero
001640 9220 294d                 	sts noise_fx_Qxy_speed, zero
001642 9220 294e                 	sts noise_fx_Qxy_speed+1, zero
001644 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
001646 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
001648 9220 2951                 	sts noise_fx_Rxy_target, zero
00164a 9220 2952                 	sts noise_fx_Rxy_target+1, zero
00164c 9220 2953                 	sts noise_fx_Rxy_speed, zero
00164e 9220 2954                 	sts noise_fx_Rxy_speed+1, zero
001650 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
001652 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
001654 93c0 2957                 	sts noise_fx_Sxx_pre, r28
001656 93c0 2958                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
001658 efcf                      	ldi r28, 0xFF
001659 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
00165a e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
00165b 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
00165d e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
00165e 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001660 e1c5                      	ldi r28, 0x15 //set the period for CMP0
001661 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
001663 e0c5                      	ldi r28, 0x05
001664 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
001666 e2cb                      	ldi r28, 0x2B //set the period for CMP1
001667 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
001669 e0ca                      	ldi r28, 0x0A
00166a 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
00166c e4c1                      	ldi r28, 0x41 //set the period for CMP2
00166d 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
00166f e0cf                      	ldi r28, 0x0F
001670 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
001672 e5c7                      	ldi r28, 0x57 //set the period for OVF
001673 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
001675 e1c4                      	ldi r28, 0x14
001676 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
001678 e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
001679 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
00167b e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
00167c 93c0 0a81                 	sts TCB0_CTRLB, r28
00167e e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
00167f 93c0 0a85                 	sts TCB0_INTCTRL, r28
001681 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001683 93c0 0a8c                 	sts TCB0_CCMPL, r28
001685 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001687 93c0 0a8d                 	sts TCB0_CCMPH, r28
001689 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00168a 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
00168c e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00168d 93b0 0a91                 	sts TCB1_CTRLB, r27
00168f e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001690 93b0 0a95                 	sts TCB1_INTCTRL, r27
001692 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001694 93b0 0a9c                 	sts TCB1_CCMPL, r27
001696 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001698 93b0 0a9d                 	sts TCB1_CCMPH, r27
00169a e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00169b 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
00169d e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00169e 93b0 0aa1                 	sts TCB2_CTRLB, r27
0016a0 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0016a1 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0016a3 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
0016a5 93b0 0aac                 	sts TCB2_CCMPL, r27
0016a7 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
0016a9 93b0 0aad                 	sts TCB2_CCMPH, r27
0016ab e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
0016ac 93b0 0aa0                 	sts TCB2_CTRLA, r27
0016ae 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
0016af e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0016b0 93b0 0ab1                 	sts TCB3_CTRLB, r27
0016b2 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0016b3 93b0 0ab5                 	sts TCB3_INTCTRL, r27
0016b5 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0016b7 93b0 0abc                 	sts TCB3_CCMPL, r27
0016b9 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0016bb 93b0 0abd                 	sts TCB3_CCMPH, r27
0016bd e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0016be 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0016c0 91c0 2806                 	lds r28, pulse1_output_volume
0016c2 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0016c4 fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0016c5 c015                      	rjmp volume_mixer_pulse1_off
                                 
0016c6 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
0016c7 f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0016c8 91e0 0a8c                 	lds r30, TCB0_CCMPL
0016ca e5f9                      	ldi r31, 0x059
0016cb 17ef                      	cp r30, r31
0016cc 91e0 0a8d                 	lds r30, TCB0_CCMPH
0016ce e0f0                      	ldi r31, 0x00
0016cf 07ef                      	cpc r30, r31
0016d0 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0016d1 91e0 0a8c                 	lds r30, TCB0_CCMPL
0016d3 e6f6                      	ldi r31, 0x66
0016d4 17ef                      	cp r30, r31
0016d5 91e0 0a8d                 	lds r30, TCB0_CCMPH
0016d7 e5f9                      	ldi r31, 0x59
0016d8 07ef                      	cpc r30, r31
0016d9 f408                      	brsh volume_mixer_pulse1_off
0016da c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0016db 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0016dc fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0016dd c015                      	rjmp volume_mixer_pulse2_off
                                 
0016de 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
0016df f099                      	breq volume_mixer_pulse2_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0016e0 91e0 0a9c                 	lds r30, TCB1_CCMPL
0016e2 e5f9                      	ldi r31, 0x059
0016e3 17ef                      	cp r30, r31
0016e4 91e0 0a9d                 	lds r30, TCB1_CCMPH
0016e6 e0f0                      	ldi r31, 0x00
0016e7 07ef                      	cpc r30, r31
0016e8 f050                      	brlo volume_mixer_pulse2_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0016e9 91e0 0a9c                 	lds r30, TCB1_CCMPL
0016eb e6f6                      	ldi r31, 0x66
0016ec 17ef                      	cp r30, r31
0016ed 91e0 0a9d                 	lds r30, TCB1_CCMPH
0016ef e5f9                      	ldi r31, 0x59
0016f0 07ef                      	cpc r30, r31
0016f1 f408                      	brsh volume_mixer_pulse2_off
0016f2 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
0016f3 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
0016f4 0fcd                      	add r28, r29
0016f5 e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
0016f6 e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
0016f7 0fec                      	add ZL, r28
0016f8 1df2                      	adc ZH, zero
0016f9 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
0016fa 2fd4                      	mov r29, triangle_sequence
0016fb fdd4                      	sbrc r29, 4 //check 5th bit
0016fc 95d0                      	com r29
0016fd 70df                      	andi r29, 0x0F
0016fe 2fed                      	mov r30, r29
0016ff 0fde                      	add r29, r30 //multiply the triangle volume by 3
001700 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
001701 27dd                      	clr r29
001702 fd50                      	sbrc noise_sequence_LOW, 0 //check 0th bit, skip if set
001703 c004                      	rjmp volume_mixer_tnd_out
001704 91e0 2816                 	lds r30, noise_output_volume
001706 0fee                      	lsl r30 //multiply noise volume by 2
001707 2fde                      	mov r29, r30
                                 
                                 volume_mixer_tnd_out:
001708 e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
001709 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
00170a 0fed                      	add ZL, r29
00170b 1df2                      	adc ZH, zero
00170c 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
00170d 0fcd                      	add r28, r29
00170e b9d1                      	out VPORTA_OUT, r29
00170f cfb0                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001710 b7bf                      	in r27, CPU_SREG
001711 93bf                      	push r27
001712 94f8                      	cli
                                 
                                 	//ENVELOPE
001713 d053                      	rcall pulse1_envelope_routine
001714 d09f                      	rcall pulse2_envelope_routine
                                 
001715 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
001716 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001718 91bf                      	pop r27
001719 bfbf                      	out CPU_SREG, r27
00171a 9518                      	reti
                                 
                                 sequence_1_3:
00171b b7bf                      	in r27, CPU_SREG
00171c 93bf                      	push r27
00171d 94f8                      	cli
                                 
                                 	//ENVELOPE
00171e d048                      	rcall pulse1_envelope_routine
00171f d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001720 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001721 d01b                      	rcall pulse1_sweep_routine
001722 fcf3                      	sbrc pulse2_sweep, 3
001723 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001724 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001725 c002                      	rjmp sequence_1_3_pulse2_length
001726 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001727 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001728 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001729 c002                      	rjmp sequence_1_3_exit
00172a 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
00172b 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
00172c e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
00172d 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00172f 91bf                      	pop r27
001730 bfbf                      	out CPU_SREG, r27
001731 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001732 b7bf                      	in r27, CPU_SREG
001733 93bf                      	push r27
001734 94f8                      	cli
                                 
001735 0caa                      	lsl pulse1_sequence //shifts sequence to the left
001736 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001737 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001738 93b0 0a86                 	sts TCB0_INTFLAGS, r27
00173a 91bf                      	pop r27
00173b bfbf                      	out CPU_SREG, r27
00173c 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00173d 2dbc                      	mov r27, pulse1_sweep
00173e 70b7                      	andi r27, 0x07 //mask for period divider bits
00173f f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001740 93df                      	push r29
001741 2ddc                      	mov r29, pulse1_sweep
001742 95d2                      	swap r29
001743 70d7                      	andi r29, 0x07 //mask for shift bits
001744 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001745 91df                      	pop r29
001746 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001747 91a0 0a8c                 	lds r26, TCB0_CCMPL
001749 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
00174b 95b6                      	lsr r27
00174c 95a7                      	ror r26
00174d 95da                      	dec r29
00174e f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00174f fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
001750 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001751 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001752 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001753 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001755 0fad                      	add r26, r29
001756 91d0 0a8d                 	lds r29, TCB0_CCMPH
001758 1fbd                      	adc r27, r29
                                 
001759 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00175b 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00175d 91df                      	pop r29
00175e c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
00175f 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001760 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
001761 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001762 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001764 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
001765 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
001766 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001767 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
001768 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001769 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
00176a f011                      	breq PC+3 //if the divider == 0, check loop flag
00176b 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
00176c 9508                      	ret
                                 
00176d 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
00176f 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001770 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001771 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001772 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001773 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001774 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001775 f409                      	brne PC+2 //if decay != 0, go decrement
001776 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001777 951a                      	dec pulse1_volume_decay
001778 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001779 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
00177a 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
00177c 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00177d e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
00177e 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
00177f b7bf                      	in r27, CPU_SREG
001780 93bf                      	push r27
001781 94f8                      	cli
                                 
001782 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
001783 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001784 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001785 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001787 91bf                      	pop r27
001788 bfbf                      	out CPU_SREG, r27
001789 9518                      	reti
                                 
                                 pulse2_sweep_routine:
00178a 2dbf                      	mov r27, pulse2_sweep
00178b 70b7                      	andi r27, 0x07 //mask for period divider bits
00178c f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00178d 93df                      	push r29
00178e 2ddf                      	mov r29, pulse2_sweep
00178f 95d2                      	swap r29
001790 70d7                      	andi r29, 0x07 //mask for shift bits
001791 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001792 91df                      	pop r29
001793 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001794 91a0 0a9c                 	lds r26, TCB1_CCMPL
001796 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
001798 95b6                      	lsr r27
001799 95a7                      	ror r26
00179a 95da                      	dec r29
00179b f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00179c fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
00179d c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
00179e 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
00179f 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
0017a0 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
0017a2 0fad                      	add r26, r29
0017a3 91d0 0a9d                 	lds r29, TCB1_CCMPH
0017a5 1fbd                      	adc r27, r29
                                 
0017a6 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
0017a8 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0017aa 91df                      	pop r29
0017ab c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
0017ac 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
0017ad ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0017ae 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0017af 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0017b1 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
0017b2 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0017b3 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0017b4 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0017b5 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0017b6 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0017b7 f011                      	breq PC+3 //if the divider == 0, check loop flag
0017b8 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0017b9 9508                      	ret
                                 
0017ba 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0017bc 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0017bd ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
0017be c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0017bf e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0017c0 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0017c1 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0017c2 f409                      	brne PC+2 //if decay != 0, go decrement
0017c3 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0017c4 953a                      	dec pulse2_volume_decay
0017c5 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0017c6 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
0017c7 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0017c9 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0017ca e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0017cb 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0017cc b7bf                      	in r27, CPU_SREG
0017cd 93bf                      	push r27
0017ce 94f8                      	cli
                                 
0017cf 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0017d0 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0017d1 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0017d2 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0017d4 91bf                      	pop r27
0017d5 bfbf                      	out CPU_SREG, r27
0017d6 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0017d7 b7bf                      	in r27, CPU_SREG
0017d8 93bf                      	push r27
0017d9 94f8                      	cli
                                 
0017da 2fa5                      	mov r26, noise_sequence_LOW
0017db fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0017dc c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0017dd 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0017de 27a5                      	eor r26, noise_sequence_LOW
0017df fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0017e0 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0017e1 9566                      	lsr noise_sequence_HIGH
0017e2 9557                      	ror noise_sequence_LOW
0017e3 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
0017e4 9566                      	lsr noise_sequence_HIGH
0017e5 9557                      	ror noise_sequence_LOW
0017e6 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
0017e7 c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
0017e8 0faa                      	lsl r26
0017e9 1faa                      	rol r26
0017ea 1faa                      	rol r26 //move the 6th bit to the 0th bit place
0017eb 27a5                      	eor r26, noise_sequence_LOW
0017ec fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0017ed c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
0017ee 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
0017ef 9566                      	lsr noise_sequence_HIGH
0017f0 9557                      	ror noise_sequence_LOW
0017f1 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0017f2 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
0017f3 9566                      	lsr noise_sequence_HIGH
0017f4 9557                      	ror noise_sequence_LOW
0017f5 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0017f6 c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
0017f7 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0017f8 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
0017fa 91bf                      	pop r27
0017fb bfbf                      	out CPU_SREG, r27
0017fc 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0017fd e7e8                      	ldi ZL, LOW(length << 1)
0017fe e6f4                      	ldi ZH, HIGH(length << 1)
0017ff 0fed                      	add ZL, r29
001800 1df2                      	adc ZH, zero
001801 91d4                      	lpm r29, Z
001802 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001803 e9e8                      	ldi ZL, LOW(sequences << 1)
001804 e6f4                      	ldi ZH, HIGH(sequences << 1)
001805 0fed                      	add ZL, r29
001806 1df2                      	adc ZH, zero
001807 91d4                      	lpm r29, Z
001808 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
001809 b7bf                      	in r27, CPU_SREG
00180a 93bf                      	push r27
00180b 94f8                      	cli
00180c 93cf                      	push r28
00180d 93df                      	push r29
00180e 93ef                      	push r30
00180f 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001810 91a0 281f                 	lds r26, song_fx_Bxx
001812 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001813 f4a9                      	brne sound_driver_fx_Bxx_routine
001814 91a0 2820                 	lds r26, song_fx_Cxx
001816 11a2                      	cpse r26, zero
001817 c08b                      	rjmp sound_driver_fx_Cxx_routine
001818 91a0 2821                 	lds r26, song_fx_Dxx
00181a 11a2                      	cpse r26, zero
00181b c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
00181c 91a0 281a                 	lds r26, song_frame_offset
00181e 91b0 281b                 	lds r27, song_frame_offset+1
001820 91c0 281c                 	lds r28, song_size
001822 91d0 281d                 	lds r29, song_size+1
001824 17ac                      	cp r26, r28
001825 07bd                      	cpc r27, r29
001826 f408                      	brsh sound_driver_fx_song_loop
001827 c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
001828 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001829 91e0 2818                 	lds ZL, song_frames
00182b 91f0 2819                 	lds ZH, song_frames+1
00182d 27cc                      	clr r28 //initialize r29:r28 to 0
00182e 27dd                      	clr r29
00182f 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001830 95aa                      	dec r26
001831 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001832 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001833 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
001834 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
001835 93c0 281a                 	sts song_frame_offset, r28
001837 93d0 281b                 	sts song_frame_offset+1, r29
001839 0fec                      	add ZL, r28
00183a 1ffd                      	adc ZH, r29
                                 
00183b 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
00183c 91b5                      	lpm r27, Z+
00183d 0faa                      	lsl r26
00183e 1fbb                      	rol r27
00183f 93a0 2822                 	sts pulse1_pattern, r26
001841 93b0 2823                 	sts pulse1_pattern+1, r27
001843 91a5                      	lpm r26, Z+
001844 91b5                      	lpm r27, Z+
001845 0faa                      	lsl r26
001846 1fbb                      	rol r27
001847 93a0 2871                 	sts pulse2_pattern, r26
001849 93b0 2872                 	sts pulse2_pattern+1, r27
00184b 91a5                      	lpm r26, Z+
00184c 91b5                      	lpm r27, Z+
00184d 0faa                      	lsl r26
00184e 1fbb                      	rol r27
00184f 93a0 28c0                 	sts triangle_pattern, r26
001851 93b0 28c1                 	sts triangle_pattern+1, r27
001853 91a5                      	lpm r26, Z+
001854 91b5                      	lpm r27, Z+
001855 0faa                      	lsl r26
001856 1fbb                      	rol r27
001857 93a0 290a                 	sts noise_pattern, r26
001859 93b0 290b                 	sts noise_pattern+1, r27
                                 
00185b 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00185d 9220 2827                 	sts pulse1_pattern_offset+1, zero
00185f 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001861 9220 2825                 	sts pulse1_pattern_delay_frames, zero
001863 9220 2875                 	sts pulse2_pattern_offset, zero
001865 9220 2876                 	sts pulse2_pattern_offset+1, zero
001867 9220 2873                 	sts pulse2_pattern_delay_rows, zero
001869 9220 2874                 	sts pulse2_pattern_delay_frames, zero
00186b 9220 28c4                 	sts triangle_pattern_offset, zero
00186d 9220 28c5                 	sts triangle_pattern_offset+1, zero
00186f 9220 28c2                 	sts triangle_pattern_delay_rows, zero
001871 9220 28c3                 	sts triangle_pattern_delay_frames, zero
001873 9220 290e                 	sts noise_pattern_offset, zero
001875 9220 290f                 	sts noise_pattern_offset+1, zero
001877 9220 290c                 	sts noise_pattern_delay_rows, zero
001879 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
00187b efaf                      	ldi r26, 0xFF
00187c 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
00187e 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
001880 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
001882 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
001884 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
001886 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
001888 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
00188a 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
00188c 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
00188e 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
001890 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
001892 93a0 2909                 	sts triangle_fx_Sxx_post, r26
001894 93a0 2947                 	sts noise_fx_Gxx_pre, r26
001896 93a0 2948                 	sts noise_fx_Gxx_post, r26
001898 93a0 2957                 	sts noise_fx_Sxx_pre, r26
00189a 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
00189c 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
00189e 9220 2820                 	sts song_fx_Cxx, zero
0018a0 9220 2821                 	sts song_fx_Dxx, zero
0018a2 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0018a3 91ff                      	pop r31
0018a4 91ef                      	pop r30
0018a5 91df                      	pop r29
0018a6 91cf                      	pop r28
0018a7 91bf                      	pop r27
0018a8 bfbf                      	out CPU_SREG, r27
0018a9 94f8                      	cli //disable global interrupts
                                 		
0018aa efaf                      	ldi r26, 0xFF
0018ab 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
0018ad 9220 2820                 	sts song_fx_Cxx, zero
0018af 9220 2821                 	sts song_fx_Dxx, zero
0018b1 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0018b2 91e0 2818                 	lds ZL, song_frames
0018b4 91f0 2819                 	lds ZH, song_frames+1
0018b6 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0018b8 91b0 281b                 	lds r27, song_frame_offset+1
0018ba 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0018bb 93a0 281a                 	sts song_frame_offset, r26
0018bd 93b0 281b                 	sts song_frame_offset+1, r27
0018bf 0fea                      	add ZL, r26
0018c0 1ffb                      	adc ZH, r27
                                 
0018c1 91a5                      	lpm r26, Z+ //load the address of the next pattern
0018c2 91b5                      	lpm r27, Z+
0018c3 0faa                      	lsl r26
0018c4 1fbb                      	rol r27
0018c5 93a0 2822                 	sts pulse1_pattern, r26
0018c7 93b0 2823                 	sts pulse1_pattern+1, r27
0018c9 91a5                      	lpm r26, Z+
0018ca 91b5                      	lpm r27, Z+
0018cb 0faa                      	lsl r26
0018cc 1fbb                      	rol r27
0018cd 93a0 2871                 	sts pulse2_pattern, r26
0018cf 93b0 2872                 	sts pulse2_pattern+1, r27
0018d1 91a5                      	lpm r26, Z+
0018d2 91b5                      	lpm r27, Z+
0018d3 0faa                      	lsl r26
0018d4 1fbb                      	rol r27
0018d5 93a0 28c0                 	sts triangle_pattern, r26
0018d7 93b0 28c1                 	sts triangle_pattern+1, r27
0018d9 91a5                      	lpm r26, Z+
0018da 91b5                      	lpm r27, Z+
0018db 0faa                      	lsl r26
0018dc 1fbb                      	rol r27
0018dd 93a0 290a                 	sts noise_pattern, r26
0018df 93b0 290b                 	sts noise_pattern+1, r27
                                 
0018e1 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0018e3 9220 2827                 	sts pulse1_pattern_offset+1, zero
0018e5 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0018e7 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0018e9 9220 2875                 	sts pulse2_pattern_offset, zero
0018eb 9220 2876                 	sts pulse2_pattern_offset+1, zero
0018ed 9220 2873                 	sts pulse2_pattern_delay_rows, zero
0018ef 9220 2874                 	sts pulse2_pattern_delay_frames, zero
0018f1 9220 28c4                 	sts triangle_pattern_offset, zero
0018f3 9220 28c5                 	sts triangle_pattern_offset+1, zero
0018f5 9220 28c2                 	sts triangle_pattern_delay_rows, zero
0018f7 9220 28c3                 	sts triangle_pattern_delay_frames, zero
0018f9 9220 290e                 	sts noise_pattern_offset, zero
0018fb 9220 290f                 	sts noise_pattern_offset+1, zero
0018fd 9220 290c                 	sts noise_pattern_delay_rows, zero
0018ff 9220 290d                 	sts noise_pattern_delay_frames, zero
                                 
001901 efaf                      	ldi r26, 0xFF
001902 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001904 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
001906 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26
001908 93a0 2870                 	sts pulse1_fx_Sxx_post, r26
00190a 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26
00190c 93a0 28af                 	sts pulse2_fx_Gxx_post, r26
00190e 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26
001910 93a0 28bf                 	sts pulse2_fx_Sxx_post, r26
001912 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26
001914 93a0 28f9                 	sts triangle_fx_Gxx_post, r26
001916 93a0 2908                 	sts triangle_fx_Sxx_pre, r26
001918 93a0 2909                 	sts triangle_fx_Sxx_post, r26
00191a 93a0 2947                 	sts noise_fx_Gxx_pre, r26
00191c 93a0 2948                 	sts noise_fx_Gxx_post, r26
00191e 93a0 2957                 	sts noise_fx_Sxx_pre, r26
001920 93a0 2958                 	sts noise_fx_Sxx_post, r26
                                 
001922 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001924 9220 2820                 	sts song_fx_Cxx, zero
001926 9220 2821                 	sts song_fx_Dxx, zero
001928 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001929 91a0 2824                 	lds r26, pulse1_pattern_delay_rows
00192b 91b0 2825                 	lds r27, pulse1_pattern_delay_frames
00192d 9610                      	adiw r27:r26, 0
00192e f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
00192f c2d7                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001930 91e0 2822                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001932 91f0 2823                 	lds ZH, pulse1_pattern+1
001934 91a0 2826                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001936 91b0 2827                 	lds r27, pulse1_pattern_offset+1
001938 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001939 1ffb                      	adc ZH, r27
00193a 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00193b 35b7                      	cpi r27, 0x57
00193c f408                      	brsh sound_driver_channel0_check_if_volume
00193d c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
00193e 36b7                      	cpi r27, 0x67
00193f f408                      	brsh sound_driver_channel0_check_if_delay
001940 c1b6                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001941 3eb3                      	cpi r27, 0xE3
001942 f408                      	brsh sound_driver_channel0_check_if_instrument
001943 c1bd                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001944 f409                      	brne sound_driver_channel0_check_if_release
001945 c1c0                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001946 3eb4                      	cpi r27, 0xE4
001947 f409                      	brne sound_driver_channel0_check_if_end
001948 c269                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001949 3fbf                      	cpi r27, 0xFF
00194a f409                      	brne sound_driver_channel0_check_if_fx
00194b c28b                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
00194c 9631                      	adiw Z, 1 //point Z to the byte next to the flag
00194d 91a4                      	lpm r26, Z //load the fx data into r26
00194e d2ae                      	rcall sound_driver_channel0_increment_offset_twice
                                 
00194f 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001950 e9ec                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001951 e6f4                      	ldi ZH, HIGH(channel0_fx << 1)
001952 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001953 0feb                      	add ZL, r27 //add offset
001954 1df2                      	adc ZH, zero
001955 91c5                      	lpm r28, Z+ //load address bytes
001956 91d4                      	lpm r29, Z
001957 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001958 2ffd                      	mov ZH, r29
001959 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
00195a 93a0 2845                 	sts pulse1_fx_0xy_sequence, r26
00195c 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
00195e cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00195f 9220 284b                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001961 9220 284c                 	sts pulse1_fx_2xx+1, zero
001963 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001965 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
001967 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001968 937f                      	push r23
001969 2f6a                      	mov r22, r26 //store the rate into r22
00196a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00196b 9f67                      	mul r22, r23
00196c 917f                      	pop r23
00196d 916f                      	pop r22
                                 
00196e 9416                      	lsr r1 //shift out the fractional bits
00196f 9407                      	ror r0
001970 9416                      	lsr r1
001971 9407                      	ror r0
001972 9416                      	lsr r1
001973 9407                      	ror r0
001974 9416                      	lsr r1
001975 9407                      	ror r0
001976 9200 2847                 	sts pulse1_fx_1xx, r0
001978 9210 2848                 	sts pulse1_fx_1xx+1, r1
00197a cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
00197b 9220 2847                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
00197d 9220 2848                 	sts pulse1_fx_1xx+1, zero
00197f 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001981 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
001983 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001984 937f                      	push r23
001985 2f6a                      	mov r22, r26 //store the rate into r22
001986 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001987 9f67                      	mul r22, r23
001988 917f                      	pop r23
001989 916f                      	pop r22
                                 
00198a 9416                      	lsr r1 //shift out the fractional bits
00198b 9407                      	ror r0
00198c 9416                      	lsr r1
00198d 9407                      	ror r0
00198e 9416                      	lsr r1
00198f 9407                      	ror r0
001990 9416                      	lsr r1
001991 9407                      	ror r0
001992 9200 284b                 	sts pulse1_fx_2xx, r0
001994 9210 284c                 	sts pulse1_fx_2xx+1, r1
001996 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
001997 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001998 937f                      	push r23
001999 2f6a                      	mov r22, r26 //store the rate into r22
00199a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00199b 9f67                      	mul r22, r23
00199c 917f                      	pop r23
00199d 916f                      	pop r22
                                 
00199e 9416                      	lsr r1 //shift out the fractional bits
00199f 9407                      	ror r0
0019a0 9416                      	lsr r1
0019a1 9407                      	ror r0
0019a2 9416                      	lsr r1
0019a3 9407                      	ror r0
0019a4 9416                      	lsr r1
0019a5 9407                      	ror r0
0019a6 9200 2853                 	sts pulse1_fx_3xx_speed, r0
0019a8 9210 2854                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0019aa 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0019ab c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0019ac cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0019ad 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0019af 91b0 0a8d                 	lds r27, TCB0_CCMPH
0019b1 93a0 284f                 	sts pulse1_fx_3xx_start, r26
0019b3 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
                                 
0019b5 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
0019b7 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
0019b9 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0019ba 2fba                      	mov r27, r26
0019bb 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019bc 95a2                      	swap r26
0019bd 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019be 93a0 2857                 	sts pulse1_fx_4xy_speed, r26
0019c0 93b0 2858                 	sts pulse1_fx_4xy_depth, r27
0019c2 9220 2859                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0019c4 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0019c5 2fba                      	mov r27, r26
0019c6 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019c7 95a2                      	swap r26
0019c8 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019c9 93a0 285a                 	sts pulse1_fx_7xy_speed, r26
0019cb 93b0 285b                 	sts pulse1_fx_7xy_depth, r27
0019cd 9220 285c                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0019cf 9220 285d                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0019d1 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0019d2 93a0 285e                 	sts pulse1_fx_Axy, r26
0019d4 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0019d5 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0019d7 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0019d8 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019da cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0019db 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019dd cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0019de 91b0 2800                 	lds r27, pulse1_param
0019e0 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0019e1 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0019e2 93b0 2800                 	sts pulse1_param, r27
0019e4 6096                      	sbr pulse_channel_flags, 6
0019e5 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
0019e6 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0019e8 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0019e9 15a2                      	cp r26, zero
0019ea f051                      	breq sound_driver_channel0_fx_Gxx_invalid
0019eb 91b0 281e                 	lds r27, song_speed
0019ed 17ab                      	cp r26, r27
0019ee f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
0019ef 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0019f1 e0b1                      	ldi r27, 0x01
0019f2 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
0019f4 c215                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
0019f5 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0019f6 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0019f7 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0019f8 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0019f9 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0019fa 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019fb 937f                      	push r23
0019fc 2f6a                      	mov r22, r26
0019fd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019fe 9f67                      	mul r22, r23
0019ff 917f                      	pop r23
001a00 916f                      	pop r22
001a01 9416                      	lsr r1 //shift out the fractional bits
001a02 9407                      	ror r0
001a03 9416                      	lsr r1
001a04 9407                      	ror r0
001a05 9416                      	lsr r1
001a06 9407                      	ror r0
001a07 9416                      	lsr r1
001a08 9407                      	ror r0
001a09 9200 2861                 	sts pulse1_fx_Pxx_total, r0
001a0b 9210 2862                 	sts pulse1_fx_Pxx_total+1, r1
001a0d cf22                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001a0e 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001a10 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
001a12 9630                      	adiw Z, 0
001a13 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001a14 cf1b                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001a15 91e0 2835                 	lds ZL, pulse1_pitch_macro
001a17 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001a19 9630                      	adiw Z, 0
001a1a f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001a1b cf14                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001a1c 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001a1e 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001a20 9630                      	adiw Z, 0
001a21 f009                      	breq sound_driver_channel0_fx_Qxy_process
001a22 cf0d                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001a23 2fba                      	mov r27, r26 //copy fx parameters into r27
001a24 70bf                      	andi r27, 0x0F //mask note index offset
001a25 91c0 2807                 	lds r28, pulse1_note //load current note index
001a27 0fbc                      	add r27, r28
001a28 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001a29 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001a2a e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001a2b e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a2c e0f0                      	ldi ZH, HIGH(note_table << 1)
001a2d 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001a2e 0feb                      	add ZL, r27 //add offset
001a2f 1df2                      	adc ZH, zero
001a30 91c5                      	lpm r28, Z+ //load bytes
001a31 91d4                      	lpm r29, Z
001a32 93c0 2863                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001a34 93d0 2864                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001a36 95a2                      	swap r26
001a37 70af                      	andi r26, 0x0F //mask effect speed
001a38 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a39 95a3                      	inc r26 //increment the speed by 1
                                 
001a3a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a3b 937f                      	push r23
001a3c 2f6a                      	mov r22, r26 //store the speed data into r27
001a3d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a3e 9f67                      	mul r22, r23
001a3f 917f                      	pop r23
001a40 916f                      	pop r22
                                 
001a41 9416                      	lsr r1 //shift out the fractional bits
001a42 9407                      	ror r0
001a43 9416                      	lsr r1
001a44 9407                      	ror r0
001a45 9416                      	lsr r1
001a46 9407                      	ror r0
001a47 9416                      	lsr r1
001a48 9407                      	ror r0
                                 
001a49 9200 2865                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001a4b 9210 2866                 	sts pulse1_fx_Qxy_speed+1, r1
001a4d 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001a4f 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001a51 cede                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001a52 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001a54 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
001a56 9630                      	adiw Z, 0
001a57 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001a58 ced7                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001a59 91e0 2835                 	lds ZL, pulse1_pitch_macro
001a5b 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001a5d 9630                      	adiw Z, 0
001a5e f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001a5f ced0                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001a60 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001a62 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001a64 9630                      	adiw Z, 0
001a65 f009                      	breq sound_driver_channel0_fx_Rxy_process
001a66 cec9                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001a67 2fba                      	mov r27, r26 //copy fx parameters into r27
001a68 70bf                      	andi r27, 0x0F //mask note index offset
001a69 91c0 2807                 	lds r28, pulse1_note //load current note index
001a6b 1bcb                      	sub r28, r27
001a6c f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001a6d e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001a6e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a6f e0f0                      	ldi ZH, HIGH(note_table << 1)
001a70 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001a71 0fec                      	add ZL, r28 //add offset
001a72 1df2                      	adc ZH, zero
001a73 91c5                      	lpm r28, Z+ //load bytes
001a74 91d4                      	lpm r29, Z
001a75 93c0 2869                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001a77 93d0 286a                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001a79 95a2                      	swap r26
001a7a 70af                      	andi r26, 0x0F //mask effect speed
001a7b 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a7c 95a3                      	inc r26 //increment the speed by 1
                                 
001a7d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a7e 937f                      	push r23
001a7f 2f6a                      	mov r22, r26 //store the speed data into r27
001a80 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a81 9f67                      	mul r22, r23
001a82 917f                      	pop r23
001a83 916f                      	pop r22
                                 
001a84 9416                      	lsr r1 //shift out the fractional bits
001a85 9407                      	ror r0
001a86 9416                      	lsr r1
001a87 9407                      	ror r0
001a88 9416                      	lsr r1
001a89 9407                      	ror r0
001a8a 9416                      	lsr r1
001a8b 9407                      	ror r0
                                 
001a8c 9200 286b                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001a8e 9210 286c                 	sts pulse1_fx_Rxy_speed+1, r1
001a90 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
001a92 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
001a94 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
001a95 15a2                      	cp r26, zero
001a96 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001a97 91b0 281e                 	lds r27, song_speed
001a99 17ab                      	cp r26, r27
001a9a f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001a9b 93a0 286f                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001a9d e0b1                      	ldi r27, 0x01
001a9e 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001aa0 c169                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
001aa1 ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001aa2 e9e8                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001aa3 e6f4                      	ldi ZH, HIGH(sequences << 1)
001aa4 0fea                      	add ZL, r26 //offset the pointer
001aa5 1df2                      	adc ZH, zero
                                 
001aa6 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001aa7 95a7                      	ror r26
001aa8 95a7                      	ror r26
001aa9 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001aab 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001aac 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001aad 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001aae c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001aaf ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001ab0 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001ab1 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001ab2 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001ab3 93c0 2800                 	sts pulse1_param, r28
001ab5 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001ab6 ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001ab7 ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001ab8 ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001ab9 ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001aba 93b0 2807                 	sts pulse1_note, r27 //store the note index
001abc e0a3                      	ldi r26, 0x03
001abd e0b2                      	ldi r27, 0x02
001abe 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001ac0 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
001ac2 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
001ac4 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
001ac6 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001ac8 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001aca 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001acc 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
001ace 9220 2849                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001ad0 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
001ad2 9220 284d                 	sts pulse1_fx_2xx_total, zero
001ad4 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
001ad6 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001ad8 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
001ada 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001adc 91b0 0a8d                 	lds r27, TCB0_CCMPH
001ade 93a0 284f                 	sts pulse1_fx_3xx_start, r26
001ae0 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
001ae2 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001ae4 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001ae5 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ae7 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001ae9 9220 2867                 	sts pulse1_fx_Qxy_total_offset, zero
001aeb 9220 2868                 	sts pulse1_fx_Qxy_total_offset+1, zero
001aed 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001aef 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001af1 9220 286d                 	sts pulse1_fx_Rxy_total_offset, zero
001af3 9220 286e                 	sts pulse1_fx_Rxy_total_offset+1, zero
001af5 d0fd                      	rcall sound_driver_channel0_increment_offset
001af6 ce39                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001af7 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001af8 91a0 2800                 	lds r26, pulse1_param
001afa 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001afb 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001afc 93a0 2800                 	sts pulse1_param, r26
001afe 6096                      	sbr pulse_channel_flags, 6
001aff d0f3                      	rcall sound_driver_channel0_increment_offset
001b00 ce2f                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001b01 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001b02 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001b04 d0ee                      	rcall sound_driver_channel0_increment_offset
001b05 c104                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001b06 9220 2828                 	sts pulse1_volume_macro, zero //reset all macro addresses
001b08 9220 2829                 	sts pulse1_volume_macro+1, zero
001b0a 9220 282d                 	sts pulse1_arpeggio_macro, zero
001b0c 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
001b0e 9220 2835                 	sts pulse1_pitch_macro, zero
001b10 9220 2836                 	sts pulse1_pitch_macro+1, zero
001b12 9220 283b                 	sts pulse1_hi_pitch_macro, zero
001b14 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
001b16 9220 2840                 	sts pulse1_duty_macro, zero
001b18 9220 2841                 	sts pulse1_duty_macro+1, zero
001b1a 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001b1c 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001b1e 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001b20 9631                      	adiw Z, 1 //point to the byte next to the flag
001b21 91b4                      	lpm r27, Z //store the instrument offset into r27
001b22 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
001b23 e1f1                      	ldi ZH, HIGH(instruments)
001b24 0feb                      	add ZL, r27 //point Z to offsetted instrument
001b25 1df2                      	adc ZH, zero
001b26 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001b27 1fff                      	rol ZH
001b28 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001b29 91b4                      	lpm r27, Z
                                 
001b2a 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001b2b 1fbb                      	rol r27
001b2c 2fea                      	mov ZL, r26
001b2d 2ffb                      	mov ZH, r27
001b2e 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001b2f 9632                      	adiw Z, 2 //point Z to the address of the macro
001b30 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001b31 95aa                      	dec r26
001b32 f019                      	breq sound_driver_channel0_instrument_change_exit
001b33 95b6                      	lsr r27
001b34 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001b35 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001b36 e0a3                      	ldi r26, 0x03
001b37 e0b2                      	ldi r27, 0x02
001b38 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001b3a 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
001b3c 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
001b3e 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
001b40 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001b42 d0ba                      	rcall sound_driver_channel0_increment_offset_twice
001b43 cdec                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001b44 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001b45 91d5                      	lpm r29, Z+
                                 
001b46 30a5                      	cpi r26, 5
001b47 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001b48 30a4                      	cpi r26, 4
001b49 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001b4a 30a3                      	cpi r26, 3
001b4b f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001b4c 30a2                      	cpi r26, 2
001b4d f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001b4e c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001b4f 93c0 2828                 	sts pulse1_volume_macro, r28
001b51 93d0 2829                 	sts pulse1_volume_macro+1, r29
001b53 d041                      	rcall sound_driver_channel0_instrument_change_read_header
001b54 93c0 282c                 	sts pulse1_volume_macro_release, r28
001b56 93d0 282b                 	sts pulse1_volume_macro_loop, r29
001b58 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001b59 93c0 282d                 	sts pulse1_arpeggio_macro, r28
001b5b 93d0 282e                 	sts pulse1_arpeggio_macro+1, r29
001b5d 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b5f 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b61 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b63 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b65 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001b66 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001b67 93c0 2835                 	sts pulse1_pitch_macro, r28
001b69 93d0 2836                 	sts pulse1_pitch_macro+1, r29
001b6b 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b6d 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b6f 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b71 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b73 d021                      	rcall sound_driver_channel0_instrument_change_read_header
001b74 93c0 2839                 	sts pulse1_pitch_macro_release, r28
001b76 93d0 2838                 	sts pulse1_pitch_macro_loop, r29
001b78 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001b79 93c0 283b                 	sts pulse1_hi_pitch_macro, r28
001b7b 93d0 283c                 	sts pulse1_hi_pitch_macro+1, r29
001b7d 9220 2863                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b7f 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
001b81 9220 2869                 	sts pulse1_fx_Rxy_target, zero
001b83 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
001b85 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001b86 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
001b88 93d0 283e                 	sts pulse1_hi_pitch_macro_loop, r29
001b8a cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001b8b 93c0 2840                 	sts pulse1_duty_macro, r28
001b8d 93d0 2841                 	sts pulse1_duty_macro+1, r29
001b8f d005                      	rcall sound_driver_channel0_instrument_change_read_header
001b90 93c0 2844                 	sts pulse1_duty_macro_release, r28
001b92 93d0 2843                 	sts pulse1_duty_macro_loop, r29
001b94 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001b95 93ef                      	push ZL
001b96 93ff                      	push ZH
001b97 2fec                      	mov ZL, r28
001b98 2ffd                      	mov ZH, r29
001b99 0fee                      	lsl ZL
001b9a 1fff                      	rol ZH
001b9b 91c5                      	lpm r28, Z+
001b9c 91d4                      	lpm r29, Z
001b9d 91ff                      	pop ZH
001b9e 91ef                      	pop ZL
001b9f 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001ba0 93ef                      	push ZL
001ba1 93ff                      	push ZH
001ba2 2fec                      	mov ZL, r28
001ba3 2ffd                      	mov ZH, r29
001ba4 0fee                      	lsl ZL
001ba5 1fff                      	rol ZH
001ba6 91c5                      	lpm r28, Z+
001ba7 91d5                      	lpm r29, Z+
001ba8 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
001baa 93d0 2830                 	sts pulse1_arpeggio_macro_loop, r29
001bac 91c4                      	lpm r28, Z
001bad 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
001baf 91ff                      	pop ZH
001bb0 91ef                      	pop ZL
001bb1 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001bb2 91b0 282c                 	lds r27, pulse1_volume_macro_release
001bb4 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001bb5 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001bb6 95b3                      	inc r27
001bb7 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001bb9 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
001bbb 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001bbc f019                      	breq sound_driver_channel0_release_pitch
001bbd 95b3                      	inc r27
001bbe 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001bc0 91b0 2839                 	lds r27, pulse1_pitch_macro_release
001bc2 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001bc3 f019                      	breq sound_driver_channel0_release_hi_pitch
001bc4 95b3                      	inc r27
001bc5 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001bc7 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
001bc9 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001bca f019                      	breq sound_driver_channel0_release_duty
001bcb 95b3                      	inc r27
001bcc 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001bce 91b0 2844                 	lds r27, pulse1_duty_macro_release
001bd0 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001bd1 f019                      	breq sound_driver_channel0_release_exit
001bd2 95b3                      	inc r27
001bd3 93b0 2842                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001bd5 d01d                      	rcall sound_driver_channel0_increment_offset
001bd6 cd59                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001bd7 91e0 2818                 	lds ZL, song_frames
001bd9 91f0 2819                 	lds ZH, song_frames+1
001bdb 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001bdd 91b0 281b                 	lds r27, song_frame_offset+1
001bdf 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001be0 93a0 281a                 	sts song_frame_offset, r26
001be2 93b0 281b                 	sts song_frame_offset+1, r27
001be4 0fea                      	add ZL, r26
001be5 1ffb                      	adc ZH, r27
                                 
001be6 91a5                      	lpm r26, Z+ //load the address of the next pattern
001be7 91b4                      	lpm r27, Z
001be8 0faa                      	lsl r26
001be9 1fbb                      	rol r27
001bea 93a0 2822                 	sts pulse1_pattern, r26
001bec 93b0 2823                 	sts pulse1_pattern+1, r27
                                 
001bee 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001bf0 9220 2827                 	sts pulse1_pattern_offset+1, zero
001bf2 cd3d                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001bf3 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001bf5 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001bf7 9631                      	adiw Z, 1
001bf8 93e0 2826                 	sts pulse1_pattern_offset, ZL
001bfa 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001bfc 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001bfd 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001bff 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001c01 9632                      	adiw Z, 2 //increment the pointer twice
001c02 93e0 2826                 	sts pulse1_pattern_offset, ZL
001c04 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001c06 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001c07 95ba                      	dec r27
001c08 93b0 2825                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001c0a 91a0 2873                 	lds r26, pulse2_pattern_delay_rows
001c0c 91b0 2874                 	lds r27, pulse2_pattern_delay_frames
001c0e 9610                      	adiw r27:r26, 0
001c0f f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001c10 c2d3                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001c11 91e0 2871                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001c13 91f0 2872                 	lds ZH, pulse2_pattern+1
001c15 91a0 2875                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001c17 91b0 2876                 	lds r27, pulse2_pattern_offset+1
001c19 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001c1a 1ffb                      	adc ZH, r27
001c1b 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001c1c 35b7                      	cpi r27, 0x57
001c1d f408                      	brsh sound_driver_channel1_check_if_volume
001c1e c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001c1f 36b7                      	cpi r27, 0x67
001c20 f408                      	brsh sound_driver_channel1_check_if_delay
001c21 c1b6                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001c22 3eb3                      	cpi r27, 0xE3
001c23 f408                      	brsh sound_driver_channel1_check_if_instrument
001c24 c1bd                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001c25 f409                      	brne sound_driver_channel1_check_if_release
001c26 c1c0                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001c27 3eb4                      	cpi r27, 0xE4
001c28 f409                      	brne sound_driver_channel1_check_if_end
001c29 c269                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001c2a 3fbf                      	cpi r27, 0xFF
001c2b f409                      	brne sound_driver_channel1_check_if_fx
001c2c c28b                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001c2d 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001c2e 91a4                      	lpm r26, Z //load the fx data into r26
001c2f d2aa                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001c30 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001c31 ede0                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001c32 e6f4                      	ldi ZH, HIGH(channel1_fx << 1)
001c33 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001c34 0feb                      	add ZL, r27 //add offset
001c35 1df2                      	adc ZH, zero
001c36 91c5                      	lpm r28, Z+ //load address bytes
001c37 91d4                      	lpm r29, Z
001c38 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001c39 2ffd                      	mov ZH, r29
001c3a 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001c3b 93a0 2894                 	sts pulse2_fx_0xy_sequence, r26
001c3d 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001c3f cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001c40 9220 289a                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001c42 9220 289b                 	sts pulse2_fx_2xx+1, zero
001c44 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c46 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001c48 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c49 937f                      	push r23
001c4a 2f6a                      	mov r22, r26 //store the rate into r22
001c4b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c4c 9f67                      	mul r22, r23
001c4d 917f                      	pop r23
001c4e 916f                      	pop r22
                                 
001c4f 9416                      	lsr r1 //shift out the fractional bits
001c50 9407                      	ror r0
001c51 9416                      	lsr r1
001c52 9407                      	ror r0
001c53 9416                      	lsr r1
001c54 9407                      	ror r0
001c55 9416                      	lsr r1
001c56 9407                      	ror r0
001c57 9200 2896                 	sts pulse2_fx_1xx, r0
001c59 9210 2897                 	sts pulse2_fx_1xx+1, r1
001c5b cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001c5c 9220 2896                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001c5e 9220 2897                 	sts pulse2_fx_1xx+1, zero
001c60 9220 2894                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c62 9220 2895                 	sts pulse2_fx_0xy_sequence+1, zero
001c64 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c65 937f                      	push r23
001c66 2f6a                      	mov r22, r26 //store the rate into r22
001c67 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c68 9f67                      	mul r22, r23
001c69 917f                      	pop r23
001c6a 916f                      	pop r22
                                 
001c6b 9416                      	lsr r1 //shift out the fractional bits
001c6c 9407                      	ror r0
001c6d 9416                      	lsr r1
001c6e 9407                      	ror r0
001c6f 9416                      	lsr r1
001c70 9407                      	ror r0
001c71 9416                      	lsr r1
001c72 9407                      	ror r0
001c73 9200 289a                 	sts pulse2_fx_2xx, r0
001c75 9210 289b                 	sts pulse2_fx_2xx+1, r1
001c77 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001c78 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c79 937f                      	push r23
001c7a 2f6a                      	mov r22, r26 //store the rate into r22
001c7b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c7c 9f67                      	mul r22, r23
001c7d 917f                      	pop r23
001c7e 916f                      	pop r22
                                 
001c7f 9416                      	lsr r1 //shift out the fractional bits
001c80 9407                      	ror r0
001c81 9416                      	lsr r1
001c82 9407                      	ror r0
001c83 9416                      	lsr r1
001c84 9407                      	ror r0
001c85 9416                      	lsr r1
001c86 9407                      	ror r0
001c87 9200 28a2                 	sts pulse2_fx_3xx_speed, r0
001c89 9210 28a3                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001c8b 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001c8c c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001c8d cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001c8e 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001c90 91b0 0a9d                 	lds r27, TCB1_CCMPH
001c92 93a0 289e                 	sts pulse2_fx_3xx_start, r26
001c94 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
                                 
001c96 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero
001c98 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001c9a cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001c9b 2fba                      	mov r27, r26
001c9c 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001c9d 95a2                      	swap r26
001c9e 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001c9f 93a0 28a6                 	sts pulse2_fx_4xy_speed, r26
001ca1 93b0 28a7                 	sts pulse2_fx_4xy_depth, r27
001ca3 9220 28a8                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001ca5 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001ca6 2fba                      	mov r27, r26
001ca7 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001ca8 95a2                      	swap r26
001ca9 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001caa 93a0 28a9                 	sts pulse2_fx_7xy_speed, r26
001cac 93b0 28aa                 	sts pulse2_fx_7xy_depth, r27
001cae 9220 28ab                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001cb0 9220 28ac                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001cb2 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001cb3 93a0 28ad                 	sts pulse2_fx_Axy, r26
001cb5 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001cb6 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001cb8 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001cb9 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001cbb cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001cbc 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001cbe cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001cbf 91b0 2808                 	lds r27, pulse2_param
001cc1 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001cc2 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001cc3 93b0 2808                 	sts pulse2_param, r27
001cc5 6092                      	sbr pulse_channel_flags, 2
001cc6 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001cc7 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001cc9 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001cca 15a2                      	cp r26, zero
001ccb f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001ccc 91b0 281e                 	lds r27, song_speed
001cce 17ab                      	cp r26, r27
001ccf f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001cd0 93a0 28ae                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001cd2 e0b1                      	ldi r27, 0x01
001cd3 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001cd5 c211                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001cd6 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001cd7 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001cd8 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001cd9 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001cda cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001cdb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001cdc 937f                      	push r23
001cdd 2f6a                      	mov r22, r26
001cde eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001cdf 9f67                      	mul r22, r23
001ce0 917f                      	pop r23
001ce1 916f                      	pop r22
001ce2 9416                      	lsr r1 //shift out the fractional bits
001ce3 9407                      	ror r0
001ce4 9416                      	lsr r1
001ce5 9407                      	ror r0
001ce6 9416                      	lsr r1
001ce7 9407                      	ror r0
001ce8 9416                      	lsr r1
001ce9 9407                      	ror r0
001cea 9200 28b0                 	sts pulse2_fx_Pxx_total, r0
001cec 9210 28b1                 	sts pulse2_fx_Pxx_total+1, r1
001cee cf22                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001cef 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
001cf1 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
001cf3 9630                      	adiw Z, 0
001cf4 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001cf5 cf1b                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001cf6 91e0 2884                 	lds ZL, pulse2_pitch_macro
001cf8 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
001cfa 9630                      	adiw Z, 0
001cfb f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001cfc cf14                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001cfd 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
001cff 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
001d01 9630                      	adiw Z, 0
001d02 f009                      	breq sound_driver_channel1_fx_Qxy_process
001d03 cf0d                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001d04 2fba                      	mov r27, r26 //copy fx parameters into r27
001d05 70bf                      	andi r27, 0x0F //mask note index offset
001d06 91c0 280f                 	lds r28, pulse2_note //load current note index
001d08 0fbc                      	add r27, r28
001d09 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001d0a f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001d0b e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001d0c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d0d e0f0                      	ldi ZH, HIGH(note_table << 1)
001d0e 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001d0f 0feb                      	add ZL, r27 //add offset
001d10 1df2                      	adc ZH, zero
001d11 91c5                      	lpm r28, Z+ //load bytes
001d12 91d4                      	lpm r29, Z
001d13 93c0 28b2                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001d15 93d0 28b3                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001d17 95a2                      	swap r26
001d18 70af                      	andi r26, 0x0F //mask effect speed
001d19 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d1a 95a3                      	inc r26 //increment the speed by 1
                                 
001d1b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d1c 937f                      	push r23
001d1d 2f6a                      	mov r22, r26 //store the speed data into r27
001d1e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d1f 9f67                      	mul r22, r23
001d20 917f                      	pop r23
001d21 916f                      	pop r22
                                 
001d22 9416                      	lsr r1 //shift out the fractional bits
001d23 9407                      	ror r0
001d24 9416                      	lsr r1
001d25 9407                      	ror r0
001d26 9416                      	lsr r1
001d27 9407                      	ror r0
001d28 9416                      	lsr r1
001d29 9407                      	ror r0
                                 
001d2a 9200 28b4                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001d2c 9210 28b5                 	sts pulse2_fx_Qxy_speed+1, r1
001d2e 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001d30 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001d32 cede                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001d33 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
001d35 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
001d37 9630                      	adiw Z, 0
001d38 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001d39 ced7                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001d3a 91e0 2884                 	lds ZL, pulse2_pitch_macro
001d3c 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
001d3e 9630                      	adiw Z, 0
001d3f f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001d40 ced0                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001d41 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
001d43 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
001d45 9630                      	adiw Z, 0
001d46 f009                      	breq sound_driver_channel1_fx_Rxy_process
001d47 cec9                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001d48 2fba                      	mov r27, r26 //copy fx parameters into r27
001d49 70bf                      	andi r27, 0x0F //mask note index offset
001d4a 91c0 280f                 	lds r28, pulse2_note //load current note index
001d4c 1bcb                      	sub r28, r27
001d4d f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001d4e e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001d4f e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d50 e0f0                      	ldi ZH, HIGH(note_table << 1)
001d51 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001d52 0fec                      	add ZL, r28 //add offset
001d53 1df2                      	adc ZH, zero
001d54 91c5                      	lpm r28, Z+ //load bytes
001d55 91d4                      	lpm r29, Z
001d56 93c0 28b8                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001d58 93d0 28b9                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001d5a 95a2                      	swap r26
001d5b 70af                      	andi r26, 0x0F //mask effect speed
001d5c 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d5d 95a3                      	inc r26 //increment the speed by 1
                                 
001d5e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d5f 937f                      	push r23
001d60 2f6a                      	mov r22, r26 //store the speed data into r27
001d61 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d62 9f67                      	mul r22, r23
001d63 917f                      	pop r23
001d64 916f                      	pop r22
                                 
001d65 9416                      	lsr r1 //shift out the fractional bits
001d66 9407                      	ror r0
001d67 9416                      	lsr r1
001d68 9407                      	ror r0
001d69 9416                      	lsr r1
001d6a 9407                      	ror r0
001d6b 9416                      	lsr r1
001d6c 9407                      	ror r0
                                 
001d6d 9200 28ba                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001d6f 9210 28bb                 	sts pulse2_fx_Rxy_speed+1, r1
001d71 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001d73 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001d75 ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001d76 15a2                      	cp r26, zero
001d77 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001d78 91b0 281e                 	lds r27, song_speed
001d7a 17ab                      	cp r26, r27
001d7b f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001d7c 93a0 28be                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001d7e e0b1                      	ldi r27, 0x01
001d7f 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001d81 c165                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001d82 ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001d83 e9e8                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001d84 e6f4                      	ldi ZH, HIGH(sequences << 1)
001d85 0fea                      	add ZL, r26 //offset the pointer
001d86 1df2                      	adc ZH, zero
                                 
001d87 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001d88 95a7                      	ror r26
001d89 95a7                      	ror r26
001d8a 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001d8c 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001d8d 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001d8e 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001d8f c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001d90 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001d91 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001d92 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001d93 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001d94 93c0 2808                 	sts pulse2_param, r28
001d96 ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001d97 ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001d98 ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001d99 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001d9a ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001d9b 93b0 280f                 	sts pulse2_note, r27 //store the note index
001d9d e0a3                      	ldi r26, 0x03
001d9e e0b2                      	ldi r27, 0x02
001d9f 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001da1 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001da3 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
001da5 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
001da7 93b0 2891                 	sts pulse2_duty_macro_offset, r27
001da9 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001dab 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001dad 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
001daf 9220 2898                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001db1 9220 2899                 	sts pulse2_fx_1xx_total+1, zero
001db3 9220 289c                 	sts pulse2_fx_2xx_total, zero
001db5 9220 289d                 	sts pulse2_fx_2xx_total+1, zero
001db7 9220 28a4                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001db9 9220 28a5                 	sts pulse2_fx_3xx_total_offset+1, zero
001dbb 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001dbd 91b0 0a9d                 	lds r27, TCB1_CCMPH
001dbf 93a0 289e                 	sts pulse2_fx_3xx_start, r26
001dc1 93b0 289f                 	sts pulse2_fx_3xx_start+1, r27
001dc3 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001dc5 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001dc6 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001dc8 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001dca 9220 28b6                 	sts pulse2_fx_Qxy_total_offset, zero
001dcc 9220 28b7                 	sts pulse2_fx_Qxy_total_offset+1, zero
001dce 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001dd0 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001dd2 9220 28bc                 	sts pulse2_fx_Rxy_total_offset, zero
001dd4 9220 28bd                 	sts pulse2_fx_Rxy_total_offset+1, zero
001dd6 d0f9                      	rcall sound_driver_channel1_increment_offset
001dd7 ce39                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001dd8 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001dd9 91a0 2808                 	lds r26, pulse2_param
001ddb 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001ddc 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001ddd 93a0 2808                 	sts pulse2_param, r26
001ddf 6092                      	sbr pulse_channel_flags, 2
001de0 d0ef                      	rcall sound_driver_channel1_increment_offset
001de1 ce2f                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001de2 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001de3 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
001de5 d0ea                      	rcall sound_driver_channel1_increment_offset
001de6 c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001de7 9220 2877                 	sts pulse2_volume_macro, zero //reset all macro addresses
001de9 9220 2878                 	sts pulse2_volume_macro+1, zero
001deb 9220 287c                 	sts pulse2_arpeggio_macro, zero
001ded 9220 287d                 	sts pulse2_arpeggio_macro+1, zero
001def 9220 2884                 	sts pulse2_pitch_macro, zero
001df1 9220 2885                 	sts pulse2_pitch_macro+1, zero
001df3 9220 288a                 	sts pulse2_hi_pitch_macro, zero
001df5 9220 288b                 	sts pulse2_hi_pitch_macro+1, zero
001df7 9220 288f                 	sts pulse2_duty_macro, zero
001df9 9220 2890                 	sts pulse2_duty_macro+1, zero
001dfb 9220 2882                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001dfd 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
001dff 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001e01 9631                      	adiw Z, 1 //point to the byte next to the flag
001e02 91b4                      	lpm r27, Z //store the instrument offset into r27
001e03 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
001e04 e1f1                      	ldi ZH, HIGH(instruments)
001e05 0feb                      	add ZL, r27 //point Z to offsetted instrument
001e06 1df2                      	adc ZH, zero
001e07 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001e08 1fff                      	rol ZH
001e09 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001e0a 91b4                      	lpm r27, Z
                                 
001e0b 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001e0c 1fbb                      	rol r27
001e0d 2fea                      	mov ZL, r26
001e0e 2ffb                      	mov ZH, r27
001e0f 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001e10 9632                      	adiw Z, 2 //point Z to the address of the macro
001e11 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001e12 95aa                      	dec r26
001e13 f019                      	breq sound_driver_channel1_instrument_change_exit
001e14 95b6                      	lsr r27
001e15 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001e16 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001e17 e0a3                      	ldi r26, 0x03
001e18 e0b2                      	ldi r27, 0x02
001e19 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001e1b 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
001e1d 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
001e1f 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
001e21 93b0 2891                 	sts pulse2_duty_macro_offset, r27
001e23 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001e24 cdec                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001e25 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001e26 91d5                      	lpm r29, Z+
                                 
001e27 30a5                      	cpi r26, 5
001e28 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001e29 30a4                      	cpi r26, 4
001e2a f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001e2b 30a3                      	cpi r26, 3
001e2c f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001e2d 30a2                      	cpi r26, 2
001e2e f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001e2f c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001e30 93c0 2877                 	sts pulse2_volume_macro, r28
001e32 93d0 2878                 	sts pulse2_volume_macro+1, r29
001e34 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001e35 93c0 287b                 	sts pulse2_volume_macro_release, r28
001e37 93d0 287a                 	sts pulse2_volume_macro_loop, r29
001e39 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001e3a 93c0 287c                 	sts pulse2_arpeggio_macro, r28
001e3c 93d0 287d                 	sts pulse2_arpeggio_macro+1, r29
001e3e 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e40 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001e42 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001e44 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001e46 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001e47 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001e48 93c0 2884                 	sts pulse2_pitch_macro, r28
001e4a 93d0 2885                 	sts pulse2_pitch_macro+1, r29
001e4c 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e4e 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001e50 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001e52 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001e54 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001e55 93c0 2888                 	sts pulse2_pitch_macro_release, r28
001e57 93d0 2887                 	sts pulse2_pitch_macro_loop, r29
001e59 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001e5a 93c0 288a                 	sts pulse2_hi_pitch_macro, r28
001e5c 93d0 288b                 	sts pulse2_hi_pitch_macro+1, r29
001e5e 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e60 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
001e62 9220 28b8                 	sts pulse2_fx_Rxy_target, zero
001e64 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
001e66 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001e67 93c0 288e                 	sts pulse2_hi_pitch_macro_release, r28
001e69 93d0 288d                 	sts pulse2_hi_pitch_macro_loop, r29
001e6b cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001e6c 93c0 288f                 	sts pulse2_duty_macro, r28
001e6e 93d0 2890                 	sts pulse2_duty_macro+1, r29
001e70 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001e71 93c0 2893                 	sts pulse2_duty_macro_release, r28
001e73 93d0 2892                 	sts pulse2_duty_macro_loop, r29
001e75 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001e76 93ef                      	push ZL
001e77 93ff                      	push ZH
001e78 2fec                      	mov ZL, r28
001e79 2ffd                      	mov ZH, r29
001e7a 0fee                      	lsl ZL
001e7b 1fff                      	rol ZH
001e7c 91c5                      	lpm r28, Z+
001e7d 91d4                      	lpm r29, Z
001e7e 91ff                      	pop ZH
001e7f 91ef                      	pop ZL
001e80 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001e81 93ef                      	push ZL
001e82 93ff                      	push ZH
001e83 2fec                      	mov ZL, r28
001e84 2ffd                      	mov ZH, r29
001e85 0fee                      	lsl ZL
001e86 1fff                      	rol ZH
001e87 91c5                      	lpm r28, Z+
001e88 91d5                      	lpm r29, Z+
001e89 93c0 2880                 	sts pulse2_arpeggio_macro_release, r28
001e8b 93d0 287f                 	sts pulse2_arpeggio_macro_loop, r29
001e8d 91c4                      	lpm r28, Z
001e8e 93c0 2881                 	sts pulse2_arpeggio_macro_mode, r28
001e90 91ff                      	pop ZH
001e91 91ef                      	pop ZL
001e92 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001e93 91b0 287b                 	lds r27, pulse2_volume_macro_release
001e95 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001e96 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001e97 95b3                      	inc r27
001e98 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001e9a 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
001e9c 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001e9d f019                      	breq sound_driver_channel1_release_pitch
001e9e 95b3                      	inc r27
001e9f 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001ea1 91b0 2888                 	lds r27, pulse2_pitch_macro_release
001ea3 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001ea4 f019                      	breq sound_driver_channel1_release_hi_pitch
001ea5 95b3                      	inc r27
001ea6 93b0 2886                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001ea8 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
001eaa 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001eab f019                      	breq sound_driver_channel1_release_duty
001eac 95b3                      	inc r27
001ead 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001eaf 91b0 2893                 	lds r27, pulse2_duty_macro_release
001eb1 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001eb2 f019                      	breq sound_driver_channel1_release_exit
001eb3 95b3                      	inc r27
001eb4 93b0 2891                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001eb6 d019                      	rcall sound_driver_channel1_increment_offset
001eb7 cd59                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001eb8 91e0 2818                 	lds ZL, song_frames
001eba 91f0 2819                 	lds ZH, song_frames+1
001ebc 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001ebe 91b0 281b                 	lds r27, song_frame_offset+1
001ec0 9612                      	adiw r27:r26, 2 //offset for channel 1
001ec1 0fea                      	add ZL, r26
001ec2 1ffb                      	adc ZH, r27
                                 
001ec3 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ec4 91b4                      	lpm r27, Z
001ec5 0faa                      	lsl r26
001ec6 1fbb                      	rol r27
001ec7 93a0 2871                 	sts pulse2_pattern, r26
001ec9 93b0 2872                 	sts pulse2_pattern+1, r27
                                 
001ecb 9220 2875                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ecd 9220 2876                 	sts pulse2_pattern_offset+1, zero
001ecf cd41                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001ed0 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001ed2 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
001ed4 9631                      	adiw Z, 1
001ed5 93e0 2875                 	sts pulse2_pattern_offset, ZL
001ed7 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
001ed9 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001eda 91e0 2875                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001edc 91f0 2876                 	lds ZH, pulse2_pattern_offset+1
001ede 9632                      	adiw Z, 2 //increment the pointer twice
001edf 93e0 2875                 	sts pulse2_pattern_offset, ZL
001ee1 93f0 2876                 	sts pulse2_pattern_offset+1, ZH
001ee3 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001ee4 95ba                      	dec r27
001ee5 93b0 2874                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001ee7 91a0 28c2                 	lds r26, triangle_pattern_delay_rows
001ee9 91b0 28c3                 	lds r27, triangle_pattern_delay_frames
001eeb 9610                      	adiw r27:r26, 0
001eec f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001eed c2bb                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001eee 91e0 28c0                 	lds ZL, triangle_pattern //current pattern for triangle
001ef0 91f0 28c1                 	lds ZH, triangle_pattern+1
001ef2 91a0 28c4                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001ef4 91b0 28c5                 	lds r27, triangle_pattern_offset+1
001ef6 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001ef7 1ffb                      	adc ZH, r27
001ef8 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001ef9 35b7                      	cpi r27, 0x57
001efa f408                      	brsh sound_driver_channel2_check_if_volume
001efb c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001efc 36b7                      	cpi r27, 0x67
001efd f408                      	brsh sound_driver_channel2_check_if_delay
001efe c19a                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001eff 3eb3                      	cpi r27, 0xE3
001f00 f408                      	brsh sound_driver_channel2_check_if_instrument
001f01 c1a5                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001f02 f409                      	brne sound_driver_channel2_check_if_release
001f03 c1a8                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001f04 3eb4                      	cpi r27, 0xE4
001f05 f409                      	brne sound_driver_channel2_check_if_end
001f06 c251                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001f07 3fbf                      	cpi r27, 0xFF
001f08 f409                      	brne sound_driver_channel2_check_if_fx
001f09 c273                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001f0a 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001f0b 91a4                      	lpm r26, Z //load the fx data into r26
001f0c d292                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001f0d 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001f0e e0e4                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001f0f e6f5                      	ldi ZH, HIGH(channel2_fx << 1)
001f10 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001f11 0feb                      	add ZL, r27 //add offset
001f12 1df2                      	adc ZH, zero
001f13 91c5                      	lpm r28, Z+ //load address bytes
001f14 91d4                      	lpm r29, Z
001f15 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001f16 2ffd                      	mov ZH, r29
001f17 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001f18 93a0 28e3                 	sts triangle_fx_0xy_sequence, r26
001f1a 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001f1c cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001f1d 9220 28e9                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001f1f 9220 28ea                 	sts triangle_fx_2xx+1, zero
001f21 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f23 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001f25 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f26 937f                      	push r23
001f27 2f6a                      	mov r22, r26 //store the rate into r22
001f28 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f29 9f67                      	mul r22, r23
001f2a 917f                      	pop r23
001f2b 916f                      	pop r22
                                 
001f2c 9416                      	lsr r1 //shift out the fractional bits
001f2d 9407                      	ror r0
001f2e 9416                      	lsr r1
001f2f 9407                      	ror r0
001f30 9416                      	lsr r1
001f31 9407                      	ror r0
001f32 9416                      	lsr r1
001f33 9407                      	ror r0
001f34 9200 28e5                 	sts triangle_fx_1xx, r0
001f36 9210 28e6                 	sts triangle_fx_1xx+1, r1
001f38 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001f39 9220 28e5                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001f3b 9220 28e6                 	sts triangle_fx_1xx+1, zero
001f3d 9220 28e3                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f3f 9220 28e4                 	sts triangle_fx_0xy_sequence+1, zero
001f41 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f42 937f                      	push r23
001f43 2f6a                      	mov r22, r26 //store the rate into r22
001f44 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f45 9f67                      	mul r22, r23
001f46 917f                      	pop r23
001f47 916f                      	pop r22
                                 
001f48 9416                      	lsr r1 //shift out the fractional bits
001f49 9407                      	ror r0
001f4a 9416                      	lsr r1
001f4b 9407                      	ror r0
001f4c 9416                      	lsr r1
001f4d 9407                      	ror r0
001f4e 9416                      	lsr r1
001f4f 9407                      	ror r0
001f50 9200 28e9                 	sts triangle_fx_2xx, r0
001f52 9210 28ea                 	sts triangle_fx_2xx+1, r1
001f54 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001f55 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f56 937f                      	push r23
001f57 2f6a                      	mov r22, r26 //store the rate into r22
001f58 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f59 9f67                      	mul r22, r23
001f5a 917f                      	pop r23
001f5b 916f                      	pop r22
                                 
001f5c 9416                      	lsr r1 //shift out the fractional bits
001f5d 9407                      	ror r0
001f5e 9416                      	lsr r1
001f5f 9407                      	ror r0
001f60 9416                      	lsr r1
001f61 9407                      	ror r0
001f62 9416                      	lsr r1
001f63 9407                      	ror r0
001f64 9200 28f1                 	sts triangle_fx_3xx_speed, r0
001f66 9210 28f2                 	sts triangle_fx_3xx_speed+1, r1
                                 
001f68 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001f69 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001f6a cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001f6b 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001f6d 91b0 0aad                 	lds r27, TCB2_CCMPH
001f6f 93a0 28ed                 	sts triangle_fx_3xx_start, r26
001f71 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
                                 
001f73 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero
001f75 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
001f77 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001f78 2fba                      	mov r27, r26
001f79 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001f7a 95a2                      	swap r26
001f7b 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001f7c 93a0 28f5                 	sts triangle_fx_4xy_speed, r26
001f7e 93b0 28f6                 	sts triangle_fx_4xy_depth, r27
001f80 9220 28f7                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001f82 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001f83 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001f84 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001f85 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001f87 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001f88 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001f8a cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001f8b 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001f8d cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001f8e 15a2                      	cp r26, zero
001f8f f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001f90 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001f91 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001f93 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001f94 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001f96 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001f98 9220 0aad                 	sts TCB2_CCMPH, zero
001f9a cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001f9b 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001f9d cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001f9e 15a2                      	cp r26, zero
001f9f f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001fa0 91b0 281e                 	lds r27, song_speed
001fa2 17ab                      	cp r26, r27
001fa3 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001fa4 93a0 28f8                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001fa6 e0b1                      	ldi r27, 0x01
001fa7 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
001fa9 c202                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001faa cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001fab cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001fac cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001fad cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001fae cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001faf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001fb0 937f                      	push r23
001fb1 2f6a                      	mov r22, r26
001fb2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001fb3 9f67                      	mul r22, r23
001fb4 917f                      	pop r23
001fb5 916f                      	pop r22
001fb6 9416                      	lsr r1 //shift out the fractional bits
001fb7 9407                      	ror r0
001fb8 9416                      	lsr r1
001fb9 9407                      	ror r0
001fba 9416                      	lsr r1
001fbb 9407                      	ror r0
001fbc 9416                      	lsr r1
001fbd 9407                      	ror r0
001fbe 9200 28fa                 	sts triangle_fx_Pxx_total, r0
001fc0 9210 28fb                 	sts triangle_fx_Pxx_total+1, r1
001fc2 cf2b                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001fc3 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
001fc5 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
001fc7 9630                      	adiw Z, 0
001fc8 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001fc9 cf24                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001fca 91e0 28d3                 	lds ZL, triangle_pitch_macro
001fcc 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
001fce 9630                      	adiw Z, 0
001fcf f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001fd0 cf1d                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001fd1 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
001fd3 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
001fd5 9630                      	adiw Z, 0
001fd6 f009                      	breq sound_driver_channel2_fx_Qxy_process
001fd7 cf16                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001fd8 2fba                      	mov r27, r26 //copy fx parameters into r27
001fd9 70bf                      	andi r27, 0x0F //mask note index offset
001fda 91c0 2812                 	lds r28, triangle_note //load current note index
001fdc 0fbc                      	add r27, r28
001fdd 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001fde f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001fdf e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001fe0 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001fe1 e0f0                      	ldi ZH, HIGH(note_table << 1)
001fe2 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001fe3 0feb                      	add ZL, r27 //add offset
001fe4 1df2                      	adc ZH, zero
001fe5 91c5                      	lpm r28, Z+ //load bytes
001fe6 91d4                      	lpm r29, Z
001fe7 93c0 28fc                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001fe9 93d0 28fd                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001feb 95a2                      	swap r26
001fec 70af                      	andi r26, 0x0F //mask effect speed
001fed 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001fee 95a3                      	inc r26 //increment the speed by 1
                                 
001fef 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ff0 937f                      	push r23
001ff1 2f6a                      	mov r22, r26 //store the speed data into r27
001ff2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ff3 9f67                      	mul r22, r23
001ff4 917f                      	pop r23
001ff5 916f                      	pop r22
                                 
001ff6 9416                      	lsr r1 //shift out the fractional bits
001ff7 9407                      	ror r0
001ff8 9416                      	lsr r1
001ff9 9407                      	ror r0
001ffa 9416                      	lsr r1
001ffb 9407                      	ror r0
001ffc 9416                      	lsr r1
001ffd 9407                      	ror r0
                                 
001ffe 9200 28fe                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
002000 9210 28ff                 	sts triangle_fx_Qxy_speed+1, r1
002002 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
002004 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
002006 cee7                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
002007 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
002009 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
00200b 9630                      	adiw Z, 0
00200c f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
00200d cee0                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
00200e 91e0 28d3                 	lds ZL, triangle_pitch_macro
002010 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
002012 9630                      	adiw Z, 0
002013 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
002014 ced9                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
002015 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
002017 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
002019 9630                      	adiw Z, 0
00201a f009                      	breq sound_driver_channel2_fx_Rxy_process
00201b ced2                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
00201c 2fba                      	mov r27, r26 //copy fx parameters into r27
00201d 70bf                      	andi r27, 0x0F //mask note index offset
00201e 91c0 2812                 	lds r28, triangle_note //load current note index
002020 1bcb                      	sub r28, r27
002021 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
002022 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
002023 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002024 e0f0                      	ldi ZH, HIGH(note_table << 1)
002025 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
002026 0fec                      	add ZL, r28 //add offset
002027 1df2                      	adc ZH, zero
002028 91c5                      	lpm r28, Z+ //load bytes
002029 91d4                      	lpm r29, Z
00202a 93c0 2902                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
00202c 93d0 2903                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
00202e 95a2                      	swap r26
00202f 70af                      	andi r26, 0x0F //mask effect speed
002030 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
002031 95a3                      	inc r26 //increment the speed by 1
                                 
002032 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002033 937f                      	push r23
002034 2f6a                      	mov r22, r26 //store the speed data into r27
002035 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002036 9f67                      	mul r22, r23
002037 917f                      	pop r23
002038 916f                      	pop r22
                                 
002039 9416                      	lsr r1 //shift out the fractional bits
00203a 9407                      	ror r0
00203b 9416                      	lsr r1
00203c 9407                      	ror r0
00203d 9416                      	lsr r1
00203e 9407                      	ror r0
00203f 9416                      	lsr r1
002040 9407                      	ror r0
                                 
002041 9200 2904                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
002043 9210 2905                 	sts triangle_fx_Rxy_speed+1, r1
002045 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
002047 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
002049 cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
00204a 15a2                      	cp r26, zero
00204b f051                      	breq sound_driver_channel2_fx_Sxx_invalid
00204c 91b0 281e                 	lds r27, song_speed
00204e 17ab                      	cp r26, r27
00204f f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
002050 93a0 2908                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002052 e0b1                      	ldi r27, 0x01
002053 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
002055 c156                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
002056 ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
002057 ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
002058 ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
002059 ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
00205a ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
00205b ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
00205c 93b0 2812                 	sts triangle_note, r27 //store the note index
00205e e0a3                      	ldi r26, 0x03
00205f e0b2                      	ldi r27, 0x02
002060 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
002062 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
002064 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
002066 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
002068 93b0 28e0                 	sts triangle_duty_macro_offset, r27
00206a 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
00206c 9220 28d1                 	sts triangle_total_pitch_offset, zero
00206e 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
002070 9220 28e7                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002072 9220 28e8                 	sts triangle_fx_1xx_total+1, zero
002074 9220 28eb                 	sts triangle_fx_2xx_total, zero
002076 9220 28ec                 	sts triangle_fx_2xx_total+1, zero
002078 9220 28f3                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
00207a 9220 28f4                 	sts triangle_fx_3xx_total_offset+1, zero
00207c 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00207e 91b0 0aad                 	lds r27, TCB2_CCMPH
002080 93a0 28ed                 	sts triangle_fx_3xx_start, r26
002082 93b0 28ee                 	sts triangle_fx_3xx_start+1, r27
002084 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002086 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002088 9220 2900                 	sts triangle_fx_Qxy_total_offset, zero
00208a 9220 2901                 	sts triangle_fx_Qxy_total_offset+1, zero
00208c 9220 2902                 	sts triangle_fx_Rxy_target, zero
00208e 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002090 9220 2906                 	sts triangle_fx_Rxy_total_offset, zero
002092 9220 2907                 	sts triangle_fx_Rxy_total_offset+1, zero
002094 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002095 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002097 d0fd                      	rcall sound_driver_channel2_increment_offset
002098 ce55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
002099 d0fb                      	rcall sound_driver_channel2_increment_offset
00209a 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00209b f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
00209c e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00209d 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00209f ce4e                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
0020a0 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
0020a2 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
0020a4 9220 0aad                 	sts TCB2_CCMPH, zero
0020a6 ce47                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
0020a7 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0020a8 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
0020aa d0ea                      	rcall sound_driver_channel2_increment_offset
0020ab c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
0020ac 9220 28c6                 	sts triangle_volume_macro, zero //reset all macro addresses
0020ae 9220 28c7                 	sts triangle_volume_macro+1, zero
0020b0 9220 28cb                 	sts triangle_arpeggio_macro, zero
0020b2 9220 28cc                 	sts triangle_arpeggio_macro+1, zero
0020b4 9220 28d3                 	sts triangle_pitch_macro, zero
0020b6 9220 28d4                 	sts triangle_pitch_macro+1, zero
0020b8 9220 28d9                 	sts triangle_hi_pitch_macro, zero
0020ba 9220 28da                 	sts triangle_hi_pitch_macro+1, zero
0020bc 9220 28de                 	sts triangle_duty_macro, zero
0020be 9220 28df                 	sts triangle_duty_macro+1, zero
0020c0 9220 28d1                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
0020c2 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
0020c4 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0020c6 9631                      	adiw Z, 1 //point to the byte next to the flag
0020c7 91b4                      	lpm r27, Z //store the instrument offset into r27
0020c8 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
0020c9 e1f1                      	ldi ZH, HIGH(instruments)
0020ca 0feb                      	add ZL, r27 //point Z to offsetted instrument
0020cb 1df2                      	adc ZH, zero
0020cc 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0020cd 1fff                      	rol ZH
0020ce 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0020cf 91b4                      	lpm r27, Z
                                 
0020d0 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0020d1 1fbb                      	rol r27
0020d2 2fea                      	mov ZL, r26
0020d3 2ffb                      	mov ZH, r27
0020d4 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0020d5 9632                      	adiw Z, 2 //point Z to the address of the macro
0020d6 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
0020d7 95aa                      	dec r26
0020d8 f019                      	breq sound_driver_channel2_instrument_change_exit
0020d9 95b6                      	lsr r27
0020da f078                      	brcs sound_driver_channel2_instrument_change_load_macro
0020db cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
0020dc e0a3                      	ldi r26, 0x03
0020dd e0b2                      	ldi r27, 0x02
0020de 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
0020e0 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
0020e2 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
0020e4 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
0020e6 93b0 28e0                 	sts triangle_duty_macro_offset, r27
0020e8 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
0020e9 ce04                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
0020ea 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0020eb 91d5                      	lpm r29, Z+
                                 
0020ec 30a5                      	cpi r26, 5
0020ed f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
0020ee 30a4                      	cpi r26, 4
0020ef f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
0020f0 30a3                      	cpi r26, 3
0020f1 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
0020f2 30a2                      	cpi r26, 2
0020f3 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
0020f4 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
0020f5 93c0 28c6                 	sts triangle_volume_macro, r28
0020f7 93d0 28c7                 	sts triangle_volume_macro+1, r29
0020f9 d041                      	rcall sound_driver_channel2_instrument_change_read_header
0020fa 93c0 28ca                 	sts triangle_volume_macro_release, r28
0020fc 93d0 28c9                 	sts triangle_volume_macro_loop, r29
0020fe cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
0020ff 93c0 28cb                 	sts triangle_arpeggio_macro, r28
002101 93d0 28cc                 	sts triangle_arpeggio_macro+1, r29
002103 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002105 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002107 9220 2902                 	sts triangle_fx_Rxy_target, zero
002109 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
00210b d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
00210c cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
00210d 93c0 28d3                 	sts triangle_pitch_macro, r28
00210f 93d0 28d4                 	sts triangle_pitch_macro+1, r29
002111 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002113 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002115 9220 2902                 	sts triangle_fx_Rxy_target, zero
002117 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002119 d021                      	rcall sound_driver_channel2_instrument_change_read_header
00211a 93c0 28d7                 	sts triangle_pitch_macro_release, r28
00211c 93d0 28d6                 	sts triangle_pitch_macro_loop, r29
00211e cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
00211f 93c0 28d9                 	sts triangle_hi_pitch_macro, r28
002121 93d0 28da                 	sts triangle_hi_pitch_macro+1, r29
002123 9220 28fc                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002125 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002127 9220 2902                 	sts triangle_fx_Rxy_target, zero
002129 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
00212b d00f                      	rcall sound_driver_channel2_instrument_change_read_header
00212c 93c0 28dd                 	sts triangle_hi_pitch_macro_release, r28
00212e 93d0 28dc                 	sts triangle_hi_pitch_macro_loop, r29
002130 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
002131 93c0 28de                 	sts triangle_duty_macro, r28
002133 93d0 28df                 	sts triangle_duty_macro+1, r29
002135 d005                      	rcall sound_driver_channel2_instrument_change_read_header
002136 93c0 28e2                 	sts triangle_duty_macro_release, r28
002138 93d0 28e1                 	sts triangle_duty_macro_loop, r29
00213a cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
00213b 93ef                      	push ZL
00213c 93ff                      	push ZH
00213d 2fec                      	mov ZL, r28
00213e 2ffd                      	mov ZH, r29
00213f 0fee                      	lsl ZL
002140 1fff                      	rol ZH
002141 91c5                      	lpm r28, Z+
002142 91d4                      	lpm r29, Z
002143 91ff                      	pop ZH
002144 91ef                      	pop ZL
002145 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
002146 93ef                      	push ZL
002147 93ff                      	push ZH
002148 2fec                      	mov ZL, r28
002149 2ffd                      	mov ZH, r29
00214a 0fee                      	lsl ZL
00214b 1fff                      	rol ZH
00214c 91c5                      	lpm r28, Z+
00214d 91d5                      	lpm r29, Z+
00214e 93c0 28cf                 	sts triangle_arpeggio_macro_release, r28
002150 93d0 28ce                 	sts triangle_arpeggio_macro_loop, r29
002152 91c4                      	lpm r28, Z
002153 93c0 28d0                 	sts triangle_arpeggio_macro_mode, r28
002155 91ff                      	pop ZH
002156 91ef                      	pop ZL
002157 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
002158 91b0 28ca                 	lds r27, triangle_volume_macro_release
00215a 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00215b f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
00215c 95b3                      	inc r27
00215d 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
00215f 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002161 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002162 f019                      	breq sound_driver_channel2_release_pitch
002163 95b3                      	inc r27
002164 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
002166 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002168 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002169 f019                      	breq sound_driver_channel2_release_hi_pitch
00216a 95b3                      	inc r27
00216b 93b0 28d5                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
00216d 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
00216f 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002170 f019                      	breq sound_driver_channel2_release_duty
002171 95b3                      	inc r27
002172 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
002174 91b0 28e2                 	lds r27, triangle_duty_macro_release
002176 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002177 f019                      	breq sound_driver_channel2_release_exit
002178 95b3                      	inc r27
002179 93b0 28e0                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
00217b d019                      	rcall sound_driver_channel2_increment_offset
00217c cd71                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
00217d 91e0 2818                 	lds ZL, song_frames
00217f 91f0 2819                 	lds ZH, song_frames+1
002181 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002183 91b0 281b                 	lds r27, song_frame_offset+1
002185 9614                      	adiw r27:r26, 4 //offset for channel 2
002186 0fea                      	add ZL, r26
002187 1ffb                      	adc ZH, r27
                                 
002188 91a5                      	lpm r26, Z+ //load the address of the next pattern
002189 91b4                      	lpm r27, Z
00218a 0faa                      	lsl r26
00218b 1fbb                      	rol r27
00218c 93a0 28c0                 	sts triangle_pattern, r26
00218e 93b0 28c1                 	sts triangle_pattern+1, r27
                                 
002190 9220 28c4                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002192 9220 28c5                 	sts triangle_pattern_offset+1, zero
002194 cd59                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
002195 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
002197 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
002199 9631                      	adiw Z, 1
00219a 93e0 28c4                 	sts triangle_pattern_offset, ZL
00219c 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
00219e 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00219f 91e0 28c4                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0021a1 91f0 28c5                 	lds ZH, triangle_pattern_offset+1
0021a3 9632                      	adiw Z, 2 //increment the pointer twice
0021a4 93e0 28c4                 	sts triangle_pattern_offset, ZL
0021a6 93f0 28c5                 	sts triangle_pattern_offset+1, ZH
0021a8 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
0021a9 95ba                      	dec r27
0021aa 93b0 28c3                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
0021ac 91a0 290c                 	lds r26, noise_pattern_delay_rows
0021ae 91b0 290d                 	lds r27, noise_pattern_delay_frames
0021b0 9610                      	adiw r27:r26, 0
0021b1 f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
0021b2 c2c9                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
0021b3 91e0 290a                 	lds ZL, noise_pattern //current pattern for noise
0021b5 91f0 290b                 	lds ZH, noise_pattern+1
0021b7 91a0 290e                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
0021b9 91b0 290f                 	lds r27, noise_pattern_offset+1
0021bb 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0021bc 1ffb                      	adc ZH, r27
0021bd 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
0021be 35b7                      	cpi r27, 0x57
0021bf f408                      	brsh sound_driver_channel3_check_if_volume
0021c0 c172                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
0021c1 36b7                      	cpi r27, 0x67
0021c2 f408                      	brsh sound_driver_channel3_check_if_delay
0021c3 c1a9                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0021c4 3eb3                      	cpi r27, 0xE3
0021c5 f408                      	brsh sound_driver_channel3_check_if_instrument
0021c6 c1af                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
0021c7 f409                      	brne sound_driver_channel3_check_if_release
0021c8 c1b2                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
0021c9 3eb4                      	cpi r27, 0xE4
0021ca f409                      	brne sound_driver_channel3_check_if_end
0021cb c25b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
0021cc 3fbf                      	cpi r27, 0xFF
0021cd f409                      	brne sound_driver_channel3_check_if_fx
0021ce c27d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
0021cf 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0021d0 91a4                      	lpm r26, Z //load the fx data into r26
0021d1 d2a0                      	rcall sound_driver_channel3_increment_offset_twice
                                 
0021d2 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0021d3 e3e8                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
0021d4 e6f5                      	ldi ZH, HIGH(channel3_fx << 1)
0021d5 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0021d6 0feb                      	add ZL, r27 //add offset
0021d7 1df2                      	adc ZH, zero
0021d8 91c5                      	lpm r28, Z+ //load address bytes
0021d9 91d4                      	lpm r29, Z
0021da 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0021db 2ffd                      	mov ZH, r29
0021dc 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
0021dd 93a0 292d                 	sts noise_fx_0xy_sequence, r26
0021df 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
0021e1 cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
0021e2 9220 2933                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
0021e4 9220 2934                 	sts noise_fx_2xx+1, zero
0021e6 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
0021e8 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
0021ea 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0021eb 937f                      	push r23
0021ec 2f6a                      	mov r22, r26 //store the rate into r22
0021ed eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0021ee 9f67                      	mul r22, r23
0021ef 917f                      	pop r23
0021f0 916f                      	pop r22
                                 
0021f1 9416                      	lsr r1 //shift out the fractional bits
0021f2 9407                      	ror r0
0021f3 9416                      	lsr r1
0021f4 9407                      	ror r0
0021f5 9416                      	lsr r1
0021f6 9407                      	ror r0
0021f7 9416                      	lsr r1
0021f8 9407                      	ror r0
0021f9 9200 292f                 	sts noise_fx_1xx, r0
0021fb 9210 2930                 	sts noise_fx_1xx+1, r1
0021fd cfb5                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
0021fe 9220 292f                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
002200 9220 2930                 	sts noise_fx_1xx+1, zero
002202 9220 292d                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002204 9220 292e                 	sts noise_fx_0xy_sequence+1, zero
002206 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002207 937f                      	push r23
002208 2f6a                      	mov r22, r26 //store the rate into r22
002209 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00220a 9f67                      	mul r22, r23
00220b 917f                      	pop r23
00220c 916f                      	pop r22
                                 
00220d 9416                      	lsr r1 //shift out the fractional bits
00220e 9407                      	ror r0
00220f 9416                      	lsr r1
002210 9407                      	ror r0
002211 9416                      	lsr r1
002212 9407                      	ror r0
002213 9416                      	lsr r1
002214 9407                      	ror r0
002215 9200 2933                 	sts noise_fx_2xx, r0
002217 9210 2934                 	sts noise_fx_2xx+1, r1
002219 cf99                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
00221a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00221b 937f                      	push r23
00221c 2f6a                      	mov r22, r26 //store the rate into r22
00221d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00221e 9f67                      	mul r22, r23
00221f 917f                      	pop r23
002220 916f                      	pop r22
                                 
002221 9416                      	lsr r1 //shift out the fractional bits
002222 9407                      	ror r0
002223 9416                      	lsr r1
002224 9407                      	ror r0
002225 9416                      	lsr r1
002226 9407                      	ror r0
002227 9416                      	lsr r1
002228 9407                      	ror r0
002229 9200 293b                 	sts noise_fx_3xx_speed, r0
00222b 9210 293c                 	sts noise_fx_3xx_speed+1, r1
                                 
00222d 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
00222e c001                      	rjmp sound_driver_channel3_fx_3xx_enabled
00222f cf83                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx_enabled:
002230 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002232 91b0 0abd                 	lds r27, TCB3_CCMPH
002234 93a0 2937                 	sts noise_fx_3xx_start, r26
002236 93b0 2938                 	sts noise_fx_3xx_start+1, r27
                                 
002238 9220 293d                 	sts noise_fx_3xx_total_offset, zero
00223a 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
00223c cf76                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
00223d 2fba                      	mov r27, r26
00223e 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00223f 95a2                      	swap r26
002240 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002241 93a0 293f                 	sts noise_fx_4xy_speed, r26
002243 93b0 2940                 	sts noise_fx_4xy_depth, r27
002245 9220 2941                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
002247 cf6b                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
002248 2fba                      	mov r27, r26
002249 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00224a 95a2                      	swap r26
00224b 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00224c 93a0 2942                 	sts noise_fx_7xy_speed, r26
00224e 93b0 2943                 	sts noise_fx_7xy_depth, r27
002250 9220 2944                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
002252 9220 2945                 	sts noise_fx_7xy_value, zero //reset the tremelo value
002254 cf5e                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
002255 93a0 2946                 	sts noise_fx_Axy, r26
002257 cf5b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002258 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00225a cf58                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
00225b 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00225d cf55                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
00225e 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002260 cf52                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
002261 91b0 2813                 	lds r27, noise_param
002263 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
002264 2bba                      	or r27, r26 //move new VVVV bits into noise_param
002265 93b0 2813                 	sts noise_param, r27
002267 cf4b                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002268 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00226a cf48                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
00226b 15a2                      	cp r26, zero
00226c f051                      	breq sound_driver_channel3_fx_Gxx_invalid
00226d 91b0 281e                 	lds r27, song_speed
00226f 17ab                      	cp r26, r27
002270 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
002271 93a0 2947                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002273 e0b1                      	ldi r27, 0x01
002274 93b0 290c                 	sts noise_pattern_delay_rows, r27
002276 c208                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
002277 cf3b                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
002278 cf3a                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
002279 cf39                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
00227a cf38                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
00227b cf37                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
00227c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00227d 937f                      	push r23
00227e 2f6a                      	mov r22, r26
00227f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002280 9f67                      	mul r22, r23
002281 917f                      	pop r23
002282 916f                      	pop r22
002283 9416                      	lsr r1 //shift out the fractional bits
002284 9407                      	ror r0
002285 9416                      	lsr r1
002286 9407                      	ror r0
002287 9416                      	lsr r1
002288 9407                      	ror r0
002289 9416                      	lsr r1
00228a 9407                      	ror r0
00228b 9200 2949                 	sts noise_fx_Pxx_total, r0
00228d 9210 294a                 	sts noise_fx_Pxx_total+1, r1
00228f cf23                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel3_fx_Qxy:
                                 sound_driver_channel3_fx_Qxy_check_arpeggio_macro:
002290 91e0 2915                 	lds ZL, noise_arpeggio_macro
002292 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
002294 9630                      	adiw Z, 0
002295 f009                      	breq sound_driver_channel3_fx_Qxy_check_pitch_macro
002296 cf1c                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_pitch_macro:
002297 91e0 291d                 	lds ZL, noise_pitch_macro
002299 91f0 291e                 	lds ZH, noise_pitch_macro+1
00229b 9630                      	adiw Z, 0
00229c f009                      	breq sound_driver_channel3_fx_Qxy_check_hi_pitch_macro
00229d cf15                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_hi_pitch_macro:
00229e 91e0 2923                 	lds ZL, noise_hi_pitch_macro
0022a0 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
0022a2 9630                      	adiw Z, 0
0022a3 f009                      	breq sound_driver_channel3_fx_Qxy_process
0022a4 cf0e                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_process:
0022a5 2fba                      	mov r27, r26 //copy fx parameters into r27
0022a6 70bf                      	andi r27, 0x0F //mask note index offset
0022a7 91c0 2817                 	lds r28, noise_note //load current note index
0022a9 0fbc                      	add r27, r28
0022aa 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0022ab f008                      	brlo sound_driver_channel3_fx_Qxy_process_continue
0022ac e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel3_fx_Qxy_process_continue:
0022ad e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0022ae e0f0                      	ldi ZH, HIGH(note_table << 1)
0022af 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0022b0 0feb                      	add ZL, r27 //add offset
0022b1 1df2                      	adc ZH, zero
0022b2 91c5                      	lpm r28, Z+ //load bytes
0022b3 91d4                      	lpm r29, Z
0022b4 93c0 294b                 	sts noise_fx_Qxy_target, r28 //load the LOW bits for the target period
0022b6 93d0 294c                 	sts noise_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0022b8 95a2                      	swap r26
0022b9 70af                      	andi r26, 0x0F //mask effect speed
0022ba 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0022bb 95a3                      	inc r26 //increment the speed by 1
                                 
0022bc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022bd 937f                      	push r23
0022be 2f6a                      	mov r22, r26 //store the speed data into r27
0022bf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022c0 9f67                      	mul r22, r23
0022c1 917f                      	pop r23
0022c2 916f                      	pop r22
                                 
0022c3 9416                      	lsr r1 //shift out the fractional bits
0022c4 9407                      	ror r0
0022c5 9416                      	lsr r1
0022c6 9407                      	ror r0
0022c7 9416                      	lsr r1
0022c8 9407                      	ror r0
0022c9 9416                      	lsr r1
0022ca 9407                      	ror r0
                                 
0022cb 9200 294d                 	sts noise_fx_Qxy_speed, r0 //store the effect speed
0022cd 9210 294e                 	sts noise_fx_Qxy_speed+1, r1
0022cf 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
0022d1 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
0022d3 cedf                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel3_fx_Rxy:
                                 sound_driver_channel3_fx_Rxy_check_arpeggio_macro:
0022d4 91e0 2915                 	lds ZL, noise_arpeggio_macro
0022d6 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
0022d8 9630                      	adiw Z, 0
0022d9 f009                      	breq sound_driver_channel3_fx_Rxy_check_pitch_macro
0022da ced8                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_pitch_macro:
0022db 91e0 291d                 	lds ZL, noise_pitch_macro
0022dd 91f0 291e                 	lds ZH, noise_pitch_macro+1
0022df 9630                      	adiw Z, 0
0022e0 f009                      	breq sound_driver_channel3_fx_Rxy_check_hi_pitch_macro
0022e1 ced1                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_hi_pitch_macro:
0022e2 91e0 2923                 	lds ZL, noise_hi_pitch_macro
0022e4 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
0022e6 9630                      	adiw Z, 0
0022e7 f009                      	breq sound_driver_channel3_fx_Rxy_process
0022e8 ceca                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_process:
0022e9 2fba                      	mov r27, r26 //copy fx parameters into r27
0022ea 70bf                      	andi r27, 0x0F //mask note index offset
0022eb 91c0 2817                 	lds r28, noise_note //load current note index
0022ed 1bcb                      	sub r28, r27
0022ee f408                      	brcc sound_driver_channel3_fx_Rxy_process_continue
0022ef e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel3_fx_Rxy_process_continue:
0022f0 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0022f1 e0f0                      	ldi ZH, HIGH(note_table << 1)
0022f2 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0022f3 0fec                      	add ZL, r28 //add offset
0022f4 1df2                      	adc ZH, zero
0022f5 91c5                      	lpm r28, Z+ //load bytes
0022f6 91d4                      	lpm r29, Z
0022f7 93c0 2951                 	sts noise_fx_Rxy_target, r28 //load the LOW bits for the target period
0022f9 93d0 2952                 	sts noise_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0022fb 95a2                      	swap r26
0022fc 70af                      	andi r26, 0x0F //mask effect speed
0022fd 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0022fe 95a3                      	inc r26 //increment the speed by 1
                                 
0022ff 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002300 937f                      	push r23
002301 2f6a                      	mov r22, r26 //store the speed data into r27
002302 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002303 9f67                      	mul r22, r23
002304 917f                      	pop r23
002305 916f                      	pop r22
                                 
002306 9416                      	lsr r1 //shift out the fractional bits
002307 9407                      	ror r0
002308 9416                      	lsr r1
002309 9407                      	ror r0
00230a 9416                      	lsr r1
00230b 9407                      	ror r0
00230c 9416                      	lsr r1
00230d 9407                      	ror r0
                                 
00230e 9200 2953                 	sts noise_fx_Rxy_speed, r0 //store the effect speed
002310 9210 2954                 	sts noise_fx_Rxy_speed+1, r1
002312 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
002314 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
002316 ce9c                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
002317 15a2                      	cp r26, zero
002318 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
002319 91b0 281e                 	lds r27, song_speed
00231b 17ab                      	cp r26, r27
00231c f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
00231d 93a0 2957                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00231f e0b1                      	ldi r27, 0x01
002320 93b0 290c                 	sts noise_pattern_delay_rows, r27
002322 c15c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
002323 ce8f                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
002324 95a6                      	lsr r26
002325 95a7                      	ror r26 //move mode bit to bit 7
002326 91b0 2814                 	lds r27, noise_period
002328 77bf                      	andi r27, 0b01111111
002329 2bba                      	or r27, r26 //store the new noise mode
00232a 93b0 2813                 	sts noise_param, r27
                                 
00232c 776f                      	andi noise_sequence_HIGH, 0b01111111
00232d 2b6a                      	or noise_sequence_HIGH, r26
00232e ce84                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
00232f ce83                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
002330 ce82                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
002331 ce81                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
002332 ce80                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
002333 93b0 2817                 	sts noise_note, r27 //store the note index
002335 e0a3                      	ldi r26, 0x03
002336 e0b2                      	ldi r27, 0x02
002337 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002339 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
00233b 93b0 291f                 	sts noise_pitch_macro_offset, r27
00233d 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
00233f 93b0 292a                 	sts noise_duty_macro_offset, r27
002341 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
002343 9220 291c                 	sts noise_total_pitch_offset+1, zero
002345 9220 2922                 	sts noise_total_hi_pitch_offset, zero
002347 9220 2931                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002349 9220 2932                 	sts noise_fx_1xx_total+1, zero
00234b 9220 2935                 	sts noise_fx_2xx_total, zero
00234d 9220 2936                 	sts noise_fx_2xx_total+1, zero
00234f 9220 293d                 	sts noise_fx_3xx_total_offset, zero //reset 3xx offset
002351 9220 293e                 	sts noise_fx_3xx_total_offset+1, zero
002353 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002355 91b0 0abd                 	lds r27, TCB3_CCMPH
002357 93a0 2937                 	sts noise_fx_3xx_start, r26
002359 93b0 2938                 	sts noise_fx_3xx_start+1, r27
00235b 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00235d 9220 294c                 	sts noise_fx_Qxy_target+1, zero
00235f 9220 294f                 	sts noise_fx_Qxy_total_offset, zero
002361 9220 2950                 	sts noise_fx_Qxy_total_offset+1, zero
002363 9220 2951                 	sts noise_fx_Rxy_target, zero
002365 9220 2952                 	sts noise_fx_Rxy_target+1, zero
002367 9220 2955                 	sts noise_fx_Rxy_total_offset, zero
002369 9220 2956                 	sts noise_fx_Rxy_total_offset+1, zero
00236b d0fc                      	rcall sound_driver_channel3_increment_offset
00236c ce46                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
00236d 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00236e 91a0 2813                 	lds r26, noise_param
002370 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
002371 2bab                      	or r26, r27 //move new VVVV bits into noise_param
002372 93a0 2813                 	sts noise_param, r26
002374 d0f3                      	rcall sound_driver_channel3_increment_offset
002375 ce3d                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
002376 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002377 93b0 290c                 	sts noise_pattern_delay_rows, r27
002379 d0ee                      	rcall sound_driver_channel3_increment_offset
00237a c104                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
00237b 9220 2910                 	sts noise_volume_macro, zero //reset all macro addresses
00237d 9220 2911                 	sts noise_volume_macro+1, zero
00237f 9220 2915                 	sts noise_arpeggio_macro, zero
002381 9220 2916                 	sts noise_arpeggio_macro+1, zero
002383 9220 291d                 	sts noise_pitch_macro, zero
002385 9220 291e                 	sts noise_pitch_macro+1, zero
002387 9220 2923                 	sts noise_hi_pitch_macro, zero
002389 9220 2924                 	sts noise_hi_pitch_macro+1, zero
00238b 9220 2928                 	sts noise_duty_macro, zero
00238d 9220 2929                 	sts noise_duty_macro+1, zero
00238f 9220 291b                 	sts noise_total_pitch_offset, zero //reset the pitch offset
002391 9220 291c                 	sts noise_total_pitch_offset+1, zero
002393 9220 2922                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
002395 9631                      	adiw Z, 1 //point to the byte next to the flag
002396 91b4                      	lpm r27, Z //store the instrument offset into r27
002397 e3eb                      	ldi ZL, LOW(instruments) //point Z to instruments table
002398 e1f1                      	ldi ZH, HIGH(instruments)
002399 0feb                      	add ZL, r27 //point Z to offsetted instrument
00239a 1df2                      	adc ZH, zero
00239b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00239c 1fff                      	rol ZH
00239d 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00239e 91b4                      	lpm r27, Z
                                 
00239f 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0023a0 1fbb                      	rol r27
0023a1 2fea                      	mov ZL, r26
0023a2 2ffb                      	mov ZH, r27
0023a3 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0023a4 9632                      	adiw Z, 2 //point Z to the address of the macro
0023a5 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
0023a6 95aa                      	dec r26
0023a7 f019                      	breq sound_driver_channel3_instrument_change_exit
0023a8 95b6                      	lsr r27
0023a9 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
0023aa cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
0023ab e0a3                      	ldi r26, 0x03
0023ac e0b2                      	ldi r27, 0x02
0023ad 93b0 2912                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0023af 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
0023b1 93b0 291f                 	sts noise_pitch_macro_offset, r27
0023b3 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
0023b5 93b0 292a                 	sts noise_duty_macro_offset, r27
0023b7 d0ba                      	rcall sound_driver_channel3_increment_offset_twice
0023b8 cdfa                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
0023b9 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0023ba 91d5                      	lpm r29, Z+
                                 
0023bb 30a5                      	cpi r26, 5
0023bc f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
0023bd 30a4                      	cpi r26, 4
0023be f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
0023bf 30a3                      	cpi r26, 3
0023c0 f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
0023c1 30a2                      	cpi r26, 2
0023c2 f159                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
0023c3 c03c                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
0023c4 93c0 2910                 	sts noise_volume_macro, r28
0023c6 93d0 2911                 	sts noise_volume_macro+1, r29
0023c8 d041                      	rcall sound_driver_channel3_instrument_change_read_header
0023c9 93c0 2914                 	sts noise_volume_macro_release, r28
0023cb 93d0 2913                 	sts noise_volume_macro_loop, r29
0023cd cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
0023ce 93c0 2915                 	sts noise_arpeggio_macro, r28
0023d0 93d0 2916                 	sts noise_arpeggio_macro+1, r29
0023d2 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0023d4 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0023d6 9220 2951                 	sts noise_fx_Rxy_target, zero
0023d8 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0023da d03a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
0023db cfca                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
0023dc 93c0 291d                 	sts noise_pitch_macro, r28
0023de 93d0 291e                 	sts noise_pitch_macro+1, r29
0023e0 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0023e2 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0023e4 9220 2951                 	sts noise_fx_Rxy_target, zero
0023e6 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0023e8 d021                      	rcall sound_driver_channel3_instrument_change_read_header
0023e9 93c0 2921                 	sts noise_pitch_macro_release, r28
0023eb 93d0 2920                 	sts noise_pitch_macro_loop, r29
0023ed cfb8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
0023ee 93c0 2923                 	sts noise_hi_pitch_macro, r28
0023f0 93d0 2924                 	sts noise_hi_pitch_macro+1, r29
0023f2 9220 294b                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0023f4 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0023f6 9220 2951                 	sts noise_fx_Rxy_target, zero
0023f8 9220 2952                 	sts noise_fx_Rxy_target+1, zero
0023fa d00f                      	rcall sound_driver_channel3_instrument_change_read_header
0023fb 93c0 2927                 	sts noise_hi_pitch_macro_release, r28
0023fd 93d0 2926                 	sts noise_hi_pitch_macro_loop, r29
0023ff cfa6                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
002400 93c0 2928                 	sts noise_duty_macro, r28
002402 93d0 2929                 	sts noise_duty_macro+1, r29
002404 d005                      	rcall sound_driver_channel3_instrument_change_read_header
002405 93c0 292c                 	sts noise_duty_macro_release, r28
002407 93d0 292b                 	sts noise_duty_macro_loop, r29
002409 cf9c                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
00240a 93ef                      	push ZL
00240b 93ff                      	push ZH
00240c 2fec                      	mov ZL, r28
00240d 2ffd                      	mov ZH, r29
00240e 0fee                      	lsl ZL
00240f 1fff                      	rol ZH
002410 91c5                      	lpm r28, Z+
002411 91d4                      	lpm r29, Z
002412 91ff                      	pop ZH
002413 91ef                      	pop ZL
002414 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
002415 93ef                      	push ZL
002416 93ff                      	push ZH
002417 2fec                      	mov ZL, r28
002418 2ffd                      	mov ZH, r29
002419 0fee                      	lsl ZL
00241a 1fff                      	rol ZH
00241b 91c5                      	lpm r28, Z+
00241c 91d5                      	lpm r29, Z+
00241d 93c0 2919                 	sts noise_arpeggio_macro_release, r28
00241f 93d0 2918                 	sts noise_arpeggio_macro_loop, r29
002421 91c4                      	lpm r28, Z
002422 93c0 291a                 	sts noise_arpeggio_macro_mode, r28
002424 91ff                      	pop ZH
002425 91ef                      	pop ZL
002426 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
002427 91b0 2914                 	lds r27, noise_volume_macro_release
002429 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00242a f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
00242b 95b3                      	inc r27
00242c 93b0 2912                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
00242e 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002430 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002431 f019                      	breq sound_driver_channel3_release_pitch
002432 95b3                      	inc r27
002433 93b0 2917                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
002435 91b0 2921                 	lds r27, noise_pitch_macro_release
002437 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002438 f019                      	breq sound_driver_channel3_release_hi_pitch
002439 95b3                      	inc r27
00243a 93b0 291f                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
00243c 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
00243e 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00243f f019                      	breq sound_driver_channel3_release_duty
002440 95b3                      	inc r27
002441 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
002443 91b0 292c                 	lds r27, noise_duty_macro_release
002445 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002446 f019                      	breq sound_driver_channel3_release_exit
002447 95b3                      	inc r27
002448 93b0 292a                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
00244a d01d                      	rcall sound_driver_channel3_increment_offset
00244b cd67                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
00244c 91e0 2818                 	lds ZL, song_frames
00244e 91f0 2819                 	lds ZH, song_frames+1
002450 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002452 91b0 281b                 	lds r27, song_frame_offset+1
002454 93a0 281a                 	sts song_frame_offset, r26
002456 93b0 281b                 	sts song_frame_offset+1, r27
002458 9616                      	adiw r27:r26, 6 //offset for channel 3
002459 0fea                      	add ZL, r26
00245a 1ffb                      	adc ZH, r27
                                 
00245b 91a5                      	lpm r26, Z+ //load the address of the next pattern
00245c 91b4                      	lpm r27, Z
00245d 0faa                      	lsl r26
00245e 1fbb                      	rol r27
00245f 93a0 290a                 	sts noise_pattern, r26
002461 93b0 290b                 	sts noise_pattern+1, r27
                                 
002463 9220 290e                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002465 9220 290f                 	sts noise_pattern_offset+1, zero
002467 cd4b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
002468 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
00246a 91f0 290f                 	lds ZH, noise_pattern_offset+1
00246c 9631                      	adiw Z, 1
00246d 93e0 290e                 	sts noise_pattern_offset, ZL
00246f 93f0 290f                 	sts noise_pattern_offset+1, ZH
002471 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002472 91e0 290e                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002474 91f0 290f                 	lds ZH, noise_pattern_offset+1
002476 9632                      	adiw Z, 2 //increment the pointer twice
002477 93e0 290e                 	sts noise_pattern_offset, ZL
002479 93f0 290f                 	sts noise_pattern_offset+1, ZH
00247b 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
00247c 95ba                      	dec r27
00247d 93b0 290d                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
00247f 91f0 281e                 	lds r31, song_speed
002481 2fef                      	mov r30, r31
002482 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
002483 91a0 2825                 	lds r26, pulse1_pattern_delay_frames
002485 11a2                      	cpse r26, zero
002486 c042                      	rjmp sound_driver_calculate_delays_pulse2
002487 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002488 2faf                      	mov r26, r31 //move the speed to r26
002489 91b0 2824                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
00248b 15b2                      	cp r27, zero
00248c f409                      	brne PC+2
00248d c03b                      	rjmp sound_driver_calculate_delays_pulse2
00248e 95ba                      	dec r27
00248f 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
002491 11b2                      	cpse r27, zero
002492 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
002493 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002494 efbf                      	ldi r27, 0xFF
002495 91c0 286f                 	lds r28, pulse1_fx_Sxx_pre
002497 91d0 2870                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002499 17cb                      	cp r28, r27
00249a f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
00249b c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
00249c 17db                      	cp r29, r27
00249d f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
00249e c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
00249f 91c0 285f                 	lds r28, pulse1_fx_Gxx_pre
0024a1 91d0 2860                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
0024a3 17cb                      	cp r28, r27
0024a4 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
0024a5 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
0024a6 17db                      	cp r29, r27
0024a7 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
0024a8 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
0024a9 93b0 286f                 	sts pulse1_fx_Sxx_pre, r27
0024ab 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024ac 93e0 2870                 	sts pulse1_fx_Sxx_post, r30
0024ae 95ca                      	dec r28
0024af 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
0024b1 2fef                      	mov r30, r31
0024b2 50e1                      	subi r30, 1
0024b3 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
0024b4 93b0 2870                 	sts pulse1_fx_Sxx_post, r27
0024b6 2fad                      	mov r26, r29
0024b7 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
0024b8 93b0 285f                 	sts pulse1_fx_Gxx_pre, r27
0024ba 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024bb 93e0 2860                 	sts pulse1_fx_Gxx_post, r30
0024bd 95ca                      	dec r28
0024be 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
0024c0 2fef                      	mov r30, r31
0024c1 50e1                      	subi r30, 1
0024c2 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
0024c3 93b0 2860                 	sts pulse1_fx_Gxx_post, r27
0024c5 2fad                      	mov r26, r29
0024c6 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
0024c7 93a0 2825                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
0024c9 91a0 2874                 	lds r26, pulse2_pattern_delay_frames
0024cb 11a2                      	cpse r26, zero
0024cc c042                      	rjmp sound_driver_calculate_delays_triangle
0024cd c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
0024ce 2faf                      	mov r26, r31 //move the speed to r26
0024cf 91b0 2873                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
0024d1 15b2                      	cp r27, zero
0024d2 f409                      	brne PC+2
0024d3 c03b                      	rjmp sound_driver_calculate_delays_triangle
0024d4 95ba                      	dec r27
0024d5 93b0 2873                 	sts pulse2_pattern_delay_rows, r27
0024d7 11b2                      	cpse r27, zero
0024d8 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
0024d9 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
0024da efbf                      	ldi r27, 0xFF
0024db 91c0 28be                 	lds r28, pulse2_fx_Sxx_pre
0024dd 91d0 28bf                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
0024df 17cb                      	cp r28, r27
0024e0 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
0024e1 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
0024e2 17db                      	cp r29, r27
0024e3 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
0024e4 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
0024e5 91c0 28ae                 	lds r28, pulse2_fx_Gxx_pre
0024e7 91d0 28af                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
0024e9 17cb                      	cp r28, r27
0024ea f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
0024eb c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
0024ec 17db                      	cp r29, r27
0024ed f0f9                      	breq sound_driver_calculate_delays_pulse2_store
0024ee c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
0024ef 93b0 28be                 	sts pulse2_fx_Sxx_pre, r27
0024f1 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0024f2 93e0 28bf                 	sts pulse2_fx_Sxx_post, r30
0024f4 95ca                      	dec r28
0024f5 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
0024f7 2fef                      	mov r30, r31
0024f8 50e1                      	subi r30, 1
0024f9 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
0024fa 93b0 28bf                 	sts pulse2_fx_Sxx_post, r27
0024fc 2fad                      	mov r26, r29
0024fd c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
0024fe 93b0 28ae                 	sts pulse2_fx_Gxx_pre, r27
002500 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002501 93e0 28af                 	sts pulse2_fx_Gxx_post, r30
002503 95ca                      	dec r28
002504 93c0 2874                 	sts pulse2_pattern_delay_frames, r28
002506 2fef                      	mov r30, r31
002507 50e1                      	subi r30, 1
002508 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
002509 93b0 28af                 	sts pulse2_fx_Gxx_post, r27
00250b 2fad                      	mov r26, r29
00250c c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
00250d 93a0 2874                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
00250f 91a0 28c3                 	lds r26, triangle_pattern_delay_frames
002511 11a2                      	cpse r26, zero
002512 c042                      	rjmp sound_driver_calculate_delays_noise
002513 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
002514 2faf                      	mov r26, r31 //move the speed to r26
002515 91b0 28c2                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
002517 15b2                      	cp r27, zero
002518 f409                      	brne PC+2
002519 c03b                      	rjmp sound_driver_calculate_delays_noise
00251a 95ba                      	dec r27
00251b 93b0 28c2                 	sts triangle_pattern_delay_rows, r27
00251d 11b2                      	cpse r27, zero
00251e c034                      	rjmp sound_driver_calculate_delays_triangle_store
00251f 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
002520 efbf                      	ldi r27, 0xFF
002521 91c0 2908                 	lds r28, triangle_fx_Sxx_pre
002523 91d0 2909                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
002525 17cb                      	cp r28, r27
002526 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
002527 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
002528 17db                      	cp r29, r27
002529 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
00252a c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
00252b 91c0 28f8                 	lds r28, triangle_fx_Gxx_pre
00252d 91d0 28f9                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
00252f 17cb                      	cp r28, r27
002530 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
002531 c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
002532 17db                      	cp r29, r27
002533 f0f9                      	breq sound_driver_calculate_delays_triangle_store
002534 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
002535 93b0 2908                 	sts triangle_fx_Sxx_pre, r27
002537 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002538 93e0 2909                 	sts triangle_fx_Sxx_post, r30
00253a 95ca                      	dec r28
00253b 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
00253d 2fef                      	mov r30, r31
00253e 50e1                      	subi r30, 1
00253f c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
002540 93b0 2909                 	sts triangle_fx_Sxx_post, r27
002542 2fad                      	mov r26, r29
002543 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002544 93b0 28f8                 	sts triangle_fx_Gxx_pre, r27
002546 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002547 93e0 28f9                 	sts triangle_fx_Gxx_post, r30
002549 95ca                      	dec r28
00254a 93c0 28c3                 	sts triangle_pattern_delay_frames, r28
00254c 2fef                      	mov r30, r31
00254d 50e1                      	subi r30, 1
00254e c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
00254f 93b0 28f9                 	sts triangle_fx_Gxx_post, r27
002551 2fad                      	mov r26, r29
002552 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
002553 93a0 28c3                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
002555 91a0 290d                 	lds r26, noise_pattern_delay_frames
002557 11a2                      	cpse r26, zero
002558 c042                      	rjmp sound_driver_calculate_delays_dpcm
002559 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
00255a 2faf                      	mov r26, r31 //move the speed to r26
00255b 91b0 290c                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
00255d 15b2                      	cp r27, zero
00255e f409                      	brne PC+2
00255f c03b                      	rjmp sound_driver_calculate_delays_dpcm
002560 95ba                      	dec r27
002561 93b0 290c                 	sts noise_pattern_delay_rows, r27
002563 11b2                      	cpse r27, zero
002564 c034                      	rjmp sound_driver_calculate_delays_noise_store
002565 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
002566 efbf                      	ldi r27, 0xFF
002567 91c0 2957                 	lds r28, noise_fx_Sxx_pre
002569 91d0 2958                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
00256b 17cb                      	cp r28, r27
00256c f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
00256d c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
00256e 17db                      	cp r29, r27
00256f f009                      	breq sound_driver_calculate_delays_noise_Gxx
002570 c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
002571 91c0 2947                 	lds r28, noise_fx_Gxx_pre
002573 91d0 2948                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
002575 17cb                      	cp r28, r27
002576 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002577 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002578 17db                      	cp r29, r27
002579 f0f9                      	breq sound_driver_calculate_delays_noise_store
00257a c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
00257b 93b0 2957                 	sts noise_fx_Sxx_pre, r27
00257d 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00257e 93e0 2958                 	sts noise_fx_Sxx_post, r30
002580 95ca                      	dec r28
002581 93c0 290d                 	sts noise_pattern_delay_frames, r28
002583 2fef                      	mov r30, r31
002584 50e1                      	subi r30, 1
002585 c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
002586 93b0 2958                 	sts noise_fx_Sxx_post, r27
002588 2fad                      	mov r26, r29
002589 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
00258a 93b0 2947                 	sts noise_fx_Gxx_pre, r27
00258c 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00258d 93e0 2948                 	sts noise_fx_Gxx_post, r30
00258f 95ca                      	dec r28
002590 93c0 290d                 	sts noise_pattern_delay_frames, r28
002592 2fef                      	mov r30, r31
002593 50e1                      	subi r30, 1
002594 c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
002595 93b0 2948                 	sts noise_fx_Gxx_post, r27
002597 2fad                      	mov r26, r29
002598 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
002599 93a0 290d                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
00259b 91e0 2828                 	lds ZL, pulse1_volume_macro
00259d 91f0 2829                 	lds ZH, pulse1_volume_macro+1
00259f 9630                      	adiw Z, 0
0025a0 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0025a1 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0025a2 1fff                      	rol ZH
0025a3 91a0 282a                 	lds r26, pulse1_volume_macro_offset
0025a5 0fea                      	add ZL, r26
0025a6 1df2                      	adc ZH, zero
                                 
0025a7 91b0 282c                 	lds r27, pulse1_volume_macro_release
0025a9 17ba                      	cp r27, r26
0025aa f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0025ab 91a0 282b                 	lds r26, pulse1_volume_macro_loop
0025ad 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025ae f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025af c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0025b0 95a3                      	inc r26 //increment the macro offset
0025b1 93a0 282a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0025b3 91b4                      	lpm r27, Z //load volume data into r27
0025b4 3fbf                      	cpi r27, 0xFF //check for macro end flag
0025b5 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0025b6 91b0 282c                 	lds r27, pulse1_volume_macro_release
0025b8 3fbf                      	cpi r27, 0xFF
0025b9 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0025ba 91b0 282b                 	lds r27, pulse1_volume_macro_loop //load the loop index
0025bc 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0025be cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0025bf 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0025c0 93a0 282a                 	sts pulse1_volume_macro_offset, r26
0025c2 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0025c3 e6ec                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0025c4 e6f5                      	ldi ZH, HIGH(volumes << 1)
0025c5 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0025c6 0feb                      	add ZL, r27 //add offset to the table
0025c7 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0025c8 91b0 2800                 	lds r27, pulse1_param //load main volume
0025ca 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0025cb 91a0 285d                 	lds r26, pulse1_fx_7xy_value
0025cd 30a0                      	cpi r26, 0x00
0025ce f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0025cf 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025d0 1df2                      	adc ZH, zero
0025d1 91b4                      	lpm r27, Z
0025d2 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025d4 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0025d5 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0025d7 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0025d8 91a0 285d                 	lds r26, pulse1_fx_7xy_value
0025da 30a0                      	cpi r26, 0x00
0025db f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
0025dc 93b0 2806                 	sts pulse1_output_volume, r27
0025de c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
0025df 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0025e0 f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0025e1 f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0025e2 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
0025e3 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025e4 1df2                      	adc ZH, zero
0025e5 91b4                      	lpm r27, Z
0025e6 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025e8 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
0025e9 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0025ea 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025eb 1df2                      	adc ZH, zero
0025ec 91b4                      	lpm r27, Z
0025ed 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025ef c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
0025f0 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0025f1 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0025f2 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0025f3 93b0 2806                 	sts pulse1_output_volume, r27
0025f5 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
0025f6 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0025f7 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0025f9 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
0025fb 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
0025fd 9630                      	adiw Z, 0
0025fe f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0025ff 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002600 1fff                      	rol ZH
002601 91a0 282f                 	lds r26, pulse1_arpeggio_macro_offset
002603 0fea                      	add ZL, r26
002604 1df2                      	adc ZH, zero
                                 
002605 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002607 17ba                      	cp r27, r26
002608 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002609 91a0 2830                 	lds r26, pulse1_arpeggio_macro_loop
00260b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00260c f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00260d c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00260e 95a3                      	inc r26 //increment the macro offset
00260f 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
002611 91b4                      	lpm r27, Z //load arpeggio data into r27
002612 38b0                      	cpi r27, 0x80 //check for macro end flag
002613 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002614 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002615 50a1                      	subi r26, 1 //keep the offset at the end flag
002616 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
002618 91b0 2832                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00261a 30b1                      	cpi r27, 0x01
00261b f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
00261c 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
00261e 3fbf                      	cpi r27, 0xFF
00261f f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
002620 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop
002622 3fbf                      	cpi r27, 0xFF
002623 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002624 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002625 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
002627 3fbf                      	cpi r27, 0xFF
002628 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
002629 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
00262b 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00262c f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
00262d 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
00262f 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
002631 9620                      	adiw r29:r28, 0
002632 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002633 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002634 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
002636 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002637 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
002639 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
00263a 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
00263c 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
00263e 9620                      	adiw r29:r28, 0 //check for 0xy effect
00263f f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
002640 95d6                      	lsr r29
002641 95c7                      	ror r28
002642 95d7                      	ror r29
002643 95c7                      	ror r28
002644 95d7                      	ror r29
002645 95c7                      	ror r28
002646 95d7                      	ror r29
002647 95c7                      	ror r28
002648 95d7                      	ror r29
002649 95d2                      	swap r29
                                 
00264a 93c0 2845                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
00264c 93d0 2846                 	sts pulse1_fx_0xy_sequence+1, r29
00264e 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00264f 91a0 2807                 	lds r26, pulse1_note //load the current note index
002651 0fac                      	add r26, r28 //add the note offset
002652 c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002653 91a0 2807                 	lds r26, pulse1_note //load the current note index
002655 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002656 9220 2833                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002658 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
00265a 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
00265c 91a0 2832                 	lds r26, pulse1_arpeggio_macro_mode
00265e 30a1                      	cpi r26, 0x01 //absolute mode
00265f f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
002660 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
002661 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
002662 91a0 2807                 	lds r26, pulse1_note //load the current note index
002664 0fab                      	add r26, r27 //offset the note with the arpeggio data
002665 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002666 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002667 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002668 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002669 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00266a c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
00266b fda7                      	sbrc r26, 7 //check if result is negative
00266c e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00266d c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
00266e 2fab                      	mov r26, r27 //move the arpeggio data into r26
00266f c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
002670 91a0 2807                 	lds r26, pulse1_note //load the current note index
002672 0fab                      	add r26, r27 //offset the note with the arpeggio data
002673 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002674 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002675 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002677 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002678 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002679 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00267a 93a0 2807                 	sts pulse1_note, r26
00267c c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
00267d fda7                      	sbrc r26, 7 //check if result is negative
00267e e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00267f 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
002681 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002682 e0f0                      	ldi ZH, HIGH(note_table << 1)
002683 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002684 0fea                      	add ZL, r26 //add offset
002685 1df2                      	adc ZH, zero
002686 91a5                      	lpm r26, Z+ //load bytes
002687 91b4                      	lpm r27, Z
002688 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
00268a 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
00268c 93a0 2851                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00268e 93b0 2852                 	sts pulse1_fx_3xx_target+1, r27
002690 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
002691 91e0 2835                 	lds ZL, pulse1_pitch_macro
002693 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
002695 9630                      	adiw Z, 0
002696 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002697 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002698 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002699 1fff                      	rol ZH
00269a 91a0 2837                 	lds r26, pulse1_pitch_macro_offset
00269c 0fea                      	add ZL, r26
00269d 1df2                      	adc ZH, zero
                                 
00269e 91b0 2839                 	lds r27, pulse1_pitch_macro_release
0026a0 17ba                      	cp r27, r26
0026a1 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0026a2 91a0 2838                 	lds r26, pulse1_pitch_macro_loop
0026a4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026a5 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026a6 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0026a7 95a3                      	inc r26 //increment the macro offset
0026a8 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0026aa 91b4                      	lpm r27, Z //load pitch data into r27
0026ab 38b0                      	cpi r27, 0x80 //check for macro end flag
0026ac f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0026ad 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0026ae 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
0026b0 91b0 2839                 	lds r27, pulse1_pitch_macro_release
0026b2 3fbf                      	cpi r27, 0xFF
0026b3 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0026b4 91b0 2838                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0026b6 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0026b7 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0026b8 93b0 2837                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0026ba cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0026bb e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0026bc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026bd 937f                      	push r23
0026be 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0026bf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026c0 0367                      	mulsu r22, r23
0026c1 917f                      	pop r23
0026c2 916f                      	pop r22
                                 
0026c3 9416                      	lsr r1 //shift out the fractional bits
0026c4 9407                      	ror r0
0026c5 9416                      	lsr r1
0026c6 9407                      	ror r0
0026c7 9416                      	lsr r1
0026c8 9407                      	ror r0
0026c9 9416                      	lsr r1
0026ca 9407                      	ror r0
0026cb fe13                      	sbrs r1, 3 //check if result was a negative number
0026cc c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0026cd efb0                      	ldi r27, 0xF0
0026ce 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0026cf 91a0 2833                 	lds r26, pulse1_total_pitch_offset
0026d1 91b0 2834                 	lds r27, pulse1_total_pitch_offset+1
0026d3 0e0a                      	add r0, r26
0026d4 1e1b                      	adc r1, r27
0026d5 9200 2833                 	sts pulse1_total_pitch_offset, r0
0026d7 9210 2834                 	sts pulse1_total_pitch_offset+1, r1
0026d9 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0026db 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0026dd 0da0                      	add r26, r0 //offset the timer values
0026de 1db1                      	adc r27, r1
                                 	
0026df 91c0 2849                 	lds r28, pulse1_fx_1xx_total
0026e1 91d0 284a                 	lds r29, pulse1_fx_1xx_total+1
0026e3 1bac                      	sub r26, r28
0026e4 0bbd                      	sbc r27, r29
0026e5 91c0 284d                 	lds r28, pulse1_fx_2xx_total
0026e7 91d0 284e                 	lds r29, pulse1_fx_2xx_total+1
0026e9 0fac                      	add r26, r28
0026ea 1fbd                      	adc r27, r29
0026eb 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0026ed 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
0026ef 0fac                      	add r26, r28
0026f0 1fbd                      	adc r27, r29
0026f1 91c0 2867                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0026f3 91d0 2868                 	lds r29, pulse1_fx_Qxy_total_offset+1
0026f5 1bac                      	sub r26, r28
0026f6 0bbd                      	sbc r27, r29
0026f7 91c0 286d                 	lds r28, pulse1_fx_Rxy_total_offset
0026f9 91d0 286e                 	lds r29, pulse1_fx_Rxy_total_offset+1
0026fb 0fac                      	add r26, r28
0026fc 1fbd                      	adc r27, r29
                                 
0026fd 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0026ff 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
002701 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
002703 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
002705 9630                      	adiw Z, 0
002706 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
002707 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
002708 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002709 1fff                      	rol ZH
00270a 91a0 283d                 	lds r26, pulse1_hi_pitch_macro_offset
00270c 0fea                      	add ZL, r26
00270d 1df2                      	adc ZH, zero
                                 
00270e 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
002710 17ba                      	cp r27, r26
002711 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002712 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_loop
002714 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002715 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002716 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
002717 95a3                      	inc r26 //increment the macro offset
002718 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
00271a 91b4                      	lpm r27, Z //load hi pitch data into r27
00271b 38b0                      	cpi r27, 0x80 //check for macro end flag
00271c f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
00271d 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00271e 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
002720 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
002722 3fbf                      	cpi r27, 0xFF
002723 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
002724 91b0 283e                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
002726 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002727 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002728 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
00272a cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
00272b 91b0 283a                 	lds r27, pulse1_total_hi_pitch_offset
00272d c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
00272e 91a0 283a                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
002730 0fba                      	add r27, r26
002731 93b0 283a                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
002733 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002734 937f                      	push r23
002735 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002736 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002737 0367                      	mulsu r22, r23
002738 917f                      	pop r23
002739 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
00273a 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00273c 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00273e 0da0                      	add r26, r0 //offset the timer values
00273f 1db1                      	adc r27, r1
002740 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002742 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
002744 91e0 2840                 	lds ZL, pulse1_duty_macro
002746 91f0 2841                 	lds ZH, pulse1_duty_macro+1
002748 9630                      	adiw Z, 0
002749 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
00274a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00274b 1fff                      	rol ZH
00274c 91a0 2842                 	lds r26, pulse1_duty_macro_offset
00274e 0fea                      	add ZL, r26
00274f 1df2                      	adc ZH, zero
                                 
002750 91b0 2844                 	lds r27, pulse1_duty_macro_release
002752 17ba                      	cp r27, r26
002753 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
002754 91a0 2843                 	lds r26, pulse1_duty_macro_loop
002756 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002757 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002758 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
002759 95a3                      	inc r26 //increment the macro offset
00275a 93a0 2842                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
00275c 91b4                      	lpm r27, Z //load pitch data into r27
00275d 3fbf                      	cpi r27, 0xFF //check for macro end flag
00275e f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
00275f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002760 93a0 2842                 	sts pulse1_duty_macro_offset, r26
002762 91b0 2844                 	lds r27, pulse1_duty_macro_release
002764 3fbf                      	cpi r27, 0xFF
002765 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
002766 91b0 2843                 	lds r27, pulse1_duty_macro_loop //load the loop index
002768 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002769 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00276a 93b0 2842                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
00276c cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
00276d e9e8                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00276e e6f4                      	ldi ZH, HIGH(sequences << 1)
00276f 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002770 1df2                      	adc ZH, zero
                                 
002771 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
002772 95b7                      	ror r27
002773 95b7                      	ror r27
002774 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
002776 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
002777 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002778 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002779 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
00277a c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
00277b 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00277c 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00277d 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00277e 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
002780 91e0 2847                 	lds ZL, pulse1_fx_1xx
002782 91f0 2848                 	lds ZH, pulse1_fx_1xx+1
002784 9630                      	adiw Z, 0
002785 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
002786 91a0 2849                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
002788 91b0 284a                 	lds r27, pulse1_fx_1xx_total+1
00278a 0fae                      	add r26, ZL //increase the total offset by the rate
00278b 1fbf                      	adc r27, ZH
00278c 93a0 2849                 	sts pulse1_fx_1xx_total, r26
00278e 93b0 284a                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
002790 91e0 284b                 	lds ZL, pulse1_fx_2xx
002792 91f0 284c                 	lds ZH, pulse1_fx_2xx+1
002794 9630                      	adiw Z, 0
002795 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
002796 91a0 284d                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
002798 91b0 284e                 	lds r27, pulse1_fx_2xx_total+1
00279a 0fae                      	add r26, ZL //increase the total offset by the rate
00279b 1fbf                      	adc r27, ZH
00279c 93a0 284d                 	sts pulse1_fx_2xx_total, r26
00279e 93b0 284e                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0027a0 91e0 2853                 	lds ZL, pulse1_fx_3xx_speed
0027a2 91f0 2854                 	lds ZH, pulse1_fx_3xx_speed+1
0027a4 9630                      	adiw Z, 0
0027a5 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0027a6 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0027a7 91a0 284f                 	lds r26, pulse1_fx_3xx_start
0027a9 91b0 2850                 	lds r27, pulse1_fx_3xx_start+1
0027ab 9610                      	adiw r26:r27, 0
0027ac f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0027ad c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0027ae 91c0 2851                 	lds r28, pulse1_fx_3xx_target
0027b0 91d0 2852                 	lds r29, pulse1_fx_3xx_target+1
                                 
0027b2 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0027b3 07bd                      	cpc r27, r29
0027b4 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0027b5 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0027b6 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0027b7 9220 284f                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0027b9 9220 2850                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0027bb c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0027bc 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0027bd 0bdb                      	sbc r29, r27
0027be 91a0 2855                 	lds r26, pulse1_fx_3xx_total_offset
0027c0 91b0 2856                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0027c2 0fae                      	add r26, ZL //add the speed to the total offset
0027c3 1fbf                      	adc r27, ZH
0027c4 1bca                      	sub r28, r26 //invert the total difference with the total offset
0027c5 0bdb                      	sbc r29, r27
0027c6 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0027c7 93a0 2855                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0027c9 93b0 2856                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0027cb 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0027cd 91b0 0a8d                 	lds r27, TCB0_CCMPH
0027cf 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0027d0 0bbd                      	sbc r27, r29
0027d1 93a0 0a8c                 	sts TCB0_CCMPL, r26
0027d3 93b0 0a8d                 	sts TCB0_CCMPH, r27
0027d5 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
0027d6 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0027d7 0bbd                      	sbc r27, r29
0027d8 91c0 2855                 	lds r28, pulse1_fx_3xx_total_offset
0027da 91d0 2856                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
0027dc 0fce                      	add r28, ZL //add the speed to the total offset
0027dd 1fdf                      	adc r29, ZH
0027de 1bac                      	sub r26, r28 //invert the total difference with the total offset
0027df 0bbd                      	sbc r27, r29
0027e0 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0027e1 93c0 2855                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
0027e3 93d0 2856                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
0027e5 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
0027e7 91d0 0a8d                 	lds r29, TCB0_CCMPH
0027e9 0fca                      	add r28, r26 //offset the current timer period with the total offset
0027ea 1fdb                      	adc r29, r27
0027eb 93c0 0a8c                 	sts TCB0_CCMPL, r28
0027ed 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
0027ef 91a0 2857                 	lds r26, pulse1_fx_4xy_speed
0027f1 15a2                      	cp r26, zero
0027f2 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
0027f3 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
0027f4 91b0 2858                 	lds r27, pulse1_fx_4xy_depth
0027f6 91c0 2859                 	lds r28, pulse1_fx_4xy_phase
0027f8 0fca                      	add r28, r26 //increase the phase by the speed
0027f9 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0027fa f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0027fb 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
0027fc 93c0 2859                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
0027fe 31c0                      	cpi r28, 16
0027ff f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
002800 32c0                      	cpi r28, 32
002801 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
002802 33c0                      	cpi r28, 48
002803 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
002804 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
002805 70cf                      	andi r28, 0x0F //mask for values 0-15
002806 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
002807 6fc0                      	ori r28, 0xF0
002808 95c0                      	com r28 //invert values 0-15
002809 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
00280a 70cf                      	andi r28, 0x0F //mask for values 0-15
00280b c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
00280c 6fc0                      	ori r28, 0xF0
00280d 95c0                      	com r28 //invert values 0-15
00280e c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
00280f 95b2                      	swap r27 //multiply depth by 16
002810 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002811 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002812 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002813 0fec                      	add ZL, r28 //offset the table by the depth+phase
002814 1df2                      	adc ZH, zero
002815 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002816 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002817 937f                      	push r23
002818 2f6c                      	mov r22, r28 //store the vibrato value into r22
002819 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00281a 9f67                      	mul r22, r23
00281b 917f                      	pop r23
00281c 916f                      	pop r22
                                 
00281d 9416                      	lsr r1 //shift out the fractional bits
00281e 9407                      	ror r0
00281f 9416                      	lsr r1
002820 9407                      	ror r0
002821 9416                      	lsr r1
002822 9407                      	ror r0
002823 9416                      	lsr r1
002824 9407                      	ror r0
                                 	
002825 91a0 0a8c                 	lds r26, TCB0_CCMPL
002827 91b0 0a8d                 	lds r27, TCB0_CCMPH
002829 0da0                      	add r26, r0
00282a 1db1                      	adc r27, r1
00282b 93a0 0a8c                 	sts TCB0_CCMPL, r26
00282d 93b0 0a8d                 	sts TCB0_CCMPH, r27
00282f c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
002830 95b2                      	swap r27 //multiply depth by 16
002831 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002832 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002833 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002834 0fec                      	add ZL, r28 //offset the table by the depth+phase
002835 1df2                      	adc ZH, zero
002836 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002837 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002838 937f                      	push r23
002839 2f6c                      	mov r22, r28 //store the vibrato value into r22
00283a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00283b 9f67                      	mul r22, r23
00283c 917f                      	pop r23
00283d 916f                      	pop r22
                                 
00283e 9416                      	lsr r1 //shift out the fractional bits
00283f 9407                      	ror r0
002840 9416                      	lsr r1
002841 9407                      	ror r0
002842 9416                      	lsr r1
002843 9407                      	ror r0
002844 9416                      	lsr r1
002845 9407                      	ror r0
                                 
002846 91a0 0a8c                 	lds r26, TCB0_CCMPL
002848 91b0 0a8d                 	lds r27, TCB0_CCMPH
00284a 19a0                      	sub r26, r0
00284b 09b1                      	sbc r27, r1
00284c 93a0 0a8c                 	sts TCB0_CCMPL, r26
00284e 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
002850 91a0 285a                 	lds r26, pulse1_fx_7xy_speed
002852 15a2                      	cp r26, zero
002853 f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002854 91b0 285b                 	lds r27, pulse1_fx_7xy_depth
002856 91c0 285c                 	lds r28, pulse1_fx_7xy_phase
002858 0fca                      	add r28, r26 //increase the phase by the speed
002859 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
00285a f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00285b e0c0                      	ldi r28, 0x00
00285c 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
00285d 93c0 285c                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
00285f 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002860 ffc4                      	sbrs r28, 4
002861 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
002862 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
002863 70cf                      	andi r28, 0x0F //mask for values 0-15
002864 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
002865 6fc0                      	ori r28, 0xF0
002866 95c0                      	com r28 //invert values 0-15
002867 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002868 95b2                      	swap r27 //multiply depth by 16
002869 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00286a e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00286b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00286c 0fec                      	add ZL, r28 //offset the table by the depth+phase
00286d 1df2                      	adc ZH, zero
00286e 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00286f 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002870 93c0 285d                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
002872 91b0 285e                 	lds r27, pulse1_fx_Axy
002874 15b2                      	cp r27, zero
002875 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002876 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
002878 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
00287a 2fda                      	mov r29, r26 //copy fractional volume into r29
00287b 2fec                      	mov r30, r28 //copy the pulse1_param into r30
00287c 95e2                      	swap r30
00287d 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
00287e 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
00287f 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002880 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
002881 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
002882 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002883 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
002884 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002885 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002886 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002887 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
002888 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002889 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00288a e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
00288b 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
00288d 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
00288e 95a2                      	swap r26
00288f 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002890 2bca                      	or r28, r26 //store the new volume back into pulse1_param
002891 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
002893 91e0 2863                 	lds ZL, pulse1_fx_Qxy_target
002895 91f0 2864                 	lds ZH, pulse1_fx_Qxy_target+1
002897 9630                      	adiw Z, 0
002898 f139                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002899 91a0 2867                 	lds r26, pulse1_fx_Qxy_total_offset
00289b 91b0 2868                 	lds r27, pulse1_fx_Qxy_total_offset+1
00289d 91c0 0a8c                 	lds r28, TCB0_CCMPL
00289f 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0028a1 1bec                      	sub ZL, r28 //calculate the difference to the target
0028a2 0bfd                      	sbc ZH, r29
0028a3 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0028a4 f088                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0028a5 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0028a6 0bbf                      	sbc r27, ZH
                                 
0028a7 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0028a9 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
0028ab 0fac                      	add r26, r28
0028ac 1fbd                      	adc r27, r29
                                 
0028ad 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0028af 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
0028b1 9220 2863                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0028b3 9220 2864                 	sts pulse1_fx_Qxy_target+1, zero
0028b5 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0028b6 91c0 2865                 	lds r28, pulse1_fx_Qxy_speed
0028b8 91d0 2866                 	lds r29, pulse1_fx_Qxy_speed+1
0028ba 0fac                      	add r26, r28 //increase the total offset by the speed
0028bb 1fbd                      	adc r27, r29
0028bc 93a0 2867                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0028be 93b0 2868                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0028c0 91e0 2869                 	lds ZL, pulse1_fx_Rxy_target
0028c2 91f0 286a                 	lds ZH, pulse1_fx_Rxy_target+1
0028c4 9630                      	adiw Z, 0
0028c5 f139                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0028c6 91a0 286d                 	lds r26, pulse1_fx_Rxy_total_offset
0028c8 91b0 286e                 	lds r27, pulse1_fx_Rxy_total_offset+1
0028ca 91c0 0a8c                 	lds r28, TCB0_CCMPL
0028cc 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0028ce 1bce                      	sub r28, ZL //calculate the difference to the target
0028cf 0bdf                      	sbc r29, ZH
0028d0 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0028d1 f088                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0028d2 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0028d3 0bbd                      	sbc r27, r29
                                 
0028d4 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
0028d6 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
                                 
0028d8 0fac                      	add r26, r28
0028d9 1fbd                      	adc r27, r29
                                 
0028da 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0028dc 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
0028de 9220 2869                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0028e0 9220 286a                 	sts pulse1_fx_Rxy_target+1, zero
0028e2 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0028e3 91c0 286b                 	lds r28, pulse1_fx_Rxy_speed
0028e5 91d0 286c                 	lds r29, pulse1_fx_Rxy_speed+1
0028e7 0fac                      	add r26, r28 //increase the total offset by the speed
0028e8 1fbd                      	adc r27, r29
0028e9 93a0 286d                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0028eb 93b0 286e                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
0028ed 91e0 2877                 	lds ZL, pulse2_volume_macro
0028ef 91f0 2878                 	lds ZH, pulse2_volume_macro+1
0028f1 9630                      	adiw Z, 0
0028f2 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
0028f3 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0028f4 1fff                      	rol ZH
0028f5 91a0 2879                 	lds r26, pulse2_volume_macro_offset
0028f7 0fea                      	add ZL, r26
0028f8 1df2                      	adc ZH, zero
                                 
0028f9 91b0 287b                 	lds r27, pulse2_volume_macro_release
0028fb 17ba                      	cp r27, r26
0028fc f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
0028fd 91a0 287a                 	lds r26, pulse2_volume_macro_loop
0028ff 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002900 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002901 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
002902 95a3                      	inc r26 //increment the macro offset
002903 93a0 2879                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002905 91b4                      	lpm r27, Z //load volume data into r27
002906 3fbf                      	cpi r27, 0xFF //check for macro end flag
002907 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002908 91b0 287b                 	lds r27, pulse2_volume_macro_release
00290a 3fbf                      	cpi r27, 0xFF
00290b f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
00290c 91b0 287a                 	lds r27, pulse2_volume_macro_loop //load the loop index
00290e 93b0 2879                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
002910 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
002911 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002912 93a0 2879                 	sts pulse2_volume_macro_offset, r26
002914 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
002915 e6ec                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002916 e6f5                      	ldi ZH, HIGH(volumes << 1)
002917 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002918 0feb                      	add ZL, r27 //add offset to the table
002919 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
00291a 91b0 2808                 	lds r27, pulse2_param //load main volume
00291c 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00291d 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
00291f 30a0                      	cpi r26, 0x00
002920 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
002921 0feb                      	add ZL, r27 //offset the volume table by the main volume
002922 1df2                      	adc ZH, zero
002923 91b4                      	lpm r27, Z
002924 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002926 c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
002927 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002929 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00292a 91a0 28ac                 	lds r26, pulse2_fx_7xy_value
00292c 30a0                      	cpi r26, 0x00
00292d f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
00292e 93b0 280e                 	sts pulse2_output_volume, r27
002930 c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
002931 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002932 f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002933 f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002934 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002935 0feb                      	add ZL, r27 //offset the volume table by the main volume
002936 1df2                      	adc ZH, zero
002937 91b4                      	lpm r27, Z
002938 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00293a c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
00293b e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00293c 0feb                      	add ZL, r27 //offset the volume table by the main volume
00293d 1df2                      	adc ZH, zero
00293e 91b4                      	lpm r27, Z
00293f 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002941 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
002942 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002943 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002944 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002945 93b0 280e                 	sts pulse2_output_volume, r27
002947 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002948 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002949 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00294b 91e0 287c                 	lds ZL, pulse2_arpeggio_macro
00294d 91f0 287d                 	lds ZH, pulse2_arpeggio_macro+1
00294f 9630                      	adiw Z, 0
002950 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002951 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002952 1fff                      	rol ZH
002953 91a0 287e                 	lds r26, pulse2_arpeggio_macro_offset
002955 0fea                      	add ZL, r26
002956 1df2                      	adc ZH, zero
                                 
002957 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
002959 17ba                      	cp r27, r26
00295a f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00295b 91a0 287f                 	lds r26, pulse2_arpeggio_macro_loop
00295d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00295e f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00295f c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
002960 95a3                      	inc r26 //increment the macro offset
002961 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
002963 91b4                      	lpm r27, Z //load arpeggio data into r27
002964 38b0                      	cpi r27, 0x80 //check for macro end flag
002965 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
002966 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
002967 50a1                      	subi r26, 1 //keep the offset at the end flag
002968 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26
00296a 91b0 2881                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00296c 30b1                      	cpi r27, 0x01
00296d f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
00296e 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
002970 3fbf                      	cpi r27, 0xFF
002971 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
002972 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop
002974 3fbf                      	cpi r27, 0xFF
002975 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002976 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002977 91b0 2880                 	lds r27, pulse2_arpeggio_macro_release
002979 3fbf                      	cpi r27, 0xFF
00297a f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
00297b 91b0 287f                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
00297d 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00297e f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
00297f 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002981 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
002983 9620                      	adiw r29:r28, 0
002984 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002985 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002986 93a0 287e                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002988 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002989 93b0 287e                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
00298b cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
00298c 91c0 2894                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
00298e 91d0 2895                 	lds r29, pulse2_fx_0xy_sequence+1
002990 9620                      	adiw r29:r28, 0 //check for 0xy effect
002991 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
002992 95d6                      	lsr r29
002993 95c7                      	ror r28
002994 95d7                      	ror r29
002995 95c7                      	ror r28
002996 95d7                      	ror r29
002997 95c7                      	ror r28
002998 95d7                      	ror r29
002999 95c7                      	ror r28
00299a 95d7                      	ror r29
00299b 95d2                      	swap r29
                                 
00299c 93c0 2894                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
00299e 93d0 2895                 	sts pulse2_fx_0xy_sequence+1, r29
0029a0 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0029a1 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029a3 0fac                      	add r26, r28 //add the note offset
0029a4 c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0029a5 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029a7 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0029a8 9220 2882                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0029aa 9220 2883                 	sts pulse2_total_pitch_offset+1, zero
0029ac 9220 2889                 	sts pulse2_total_hi_pitch_offset, zero
0029ae 91a0 2881                 	lds r26, pulse2_arpeggio_macro_mode
0029b0 30a1                      	cpi r26, 0x01 //absolute mode
0029b1 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0029b2 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0029b3 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0029b4 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029b6 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029b7 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029b8 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0029b9 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029ba f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0029bb e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029bc c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0029bd fda7                      	sbrc r26, 7 //check if result is negative
0029be e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029bf c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0029c0 2fab                      	mov r26, r27 //move the arpeggio data into r26
0029c1 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0029c2 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029c4 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029c5 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029c6 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0029c7 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0029c9 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029ca f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0029cb e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029cc 93a0 280f                 	sts pulse2_note, r26
0029ce c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0029cf fda7                      	sbrc r26, 7 //check if result is negative
0029d0 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029d1 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
0029d3 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0029d4 e0f0                      	ldi ZH, HIGH(note_table << 1)
0029d5 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0029d6 0fea                      	add ZL, r26 //add offset
0029d7 1df2                      	adc ZH, zero
0029d8 91a5                      	lpm r26, Z+ //load bytes
0029d9 91b4                      	lpm r27, Z
0029da 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
0029dc 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
0029de 93a0 28a0                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0029e0 93b0 28a1                 	sts pulse2_fx_3xx_target+1, r27
0029e2 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
0029e3 91e0 2884                 	lds ZL, pulse2_pitch_macro
0029e5 91f0 2885                 	lds ZH, pulse2_pitch_macro+1
0029e7 9630                      	adiw Z, 0
0029e8 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
0029e9 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
0029ea 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0029eb 1fff                      	rol ZH
0029ec 91a0 2886                 	lds r26, pulse2_pitch_macro_offset
0029ee 0fea                      	add ZL, r26
0029ef 1df2                      	adc ZH, zero
                                 
0029f0 91b0 2888                 	lds r27, pulse2_pitch_macro_release
0029f2 17ba                      	cp r27, r26
0029f3 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
0029f4 91a0 2887                 	lds r26, pulse2_pitch_macro_loop
0029f6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0029f7 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0029f8 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
0029f9 95a3                      	inc r26 //increment the macro offset
0029fa 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
0029fc 91b4                      	lpm r27, Z //load pitch data into r27
0029fd 38b0                      	cpi r27, 0x80 //check for macro end flag
0029fe f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
0029ff 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a00 93a0 2886                 	sts pulse2_pitch_macro_offset, r26
002a02 91b0 2888                 	lds r27, pulse2_pitch_macro_release
002a04 3fbf                      	cpi r27, 0xFF
002a05 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002a06 91b0 2887                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002a08 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a09 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002a0a 93b0 2886                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002a0c cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002a0d e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002a0e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a0f 937f                      	push r23
002a10 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002a11 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a12 0367                      	mulsu r22, r23
002a13 917f                      	pop r23
002a14 916f                      	pop r22
                                 
002a15 9416                      	lsr r1 //shift out the fractional bits
002a16 9407                      	ror r0
002a17 9416                      	lsr r1
002a18 9407                      	ror r0
002a19 9416                      	lsr r1
002a1a 9407                      	ror r0
002a1b 9416                      	lsr r1
002a1c 9407                      	ror r0
002a1d fe13                      	sbrs r1, 3 //check if result was a negative number
002a1e c002                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002a1f efb0                      	ldi r27, 0xF0
002a20 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002a21 91a0 2882                 	lds r26, pulse2_total_pitch_offset
002a23 91b0 2883                 	lds r27, pulse2_total_pitch_offset+1
002a25 0e0a                      	add r0, r26
002a26 1e1b                      	adc r1, r27
002a27 9200 2882                 	sts pulse2_total_pitch_offset, r0
002a29 9210 2883                 	sts pulse2_total_pitch_offset+1, r1
002a2b 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002a2d 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002a2f 0da0                      	add r26, r0 //offset the timer values
002a30 1db1                      	adc r27, r1
                                 	
002a31 91c0 2898                 	lds r28, pulse2_fx_1xx_total
002a33 91d0 2899                 	lds r29, pulse2_fx_1xx_total+1
002a35 1bac                      	sub r26, r28
002a36 0bbd                      	sbc r27, r29
002a37 91c0 289c                 	lds r28, pulse2_fx_2xx_total
002a39 91d0 289d                 	lds r29, pulse2_fx_2xx_total+1
002a3b 0fac                      	add r26, r28
002a3c 1fbd                      	adc r27, r29
002a3d 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002a3f 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
002a41 0fac                      	add r26, r28
002a42 1fbd                      	adc r27, r29
002a43 91c0 28b6                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002a45 91d0 28b7                 	lds r29, pulse2_fx_Qxy_total_offset+1
002a47 1bac                      	sub r26, r28
002a48 0bbd                      	sbc r27, r29
002a49 91c0 28bc                 	lds r28, pulse2_fx_Rxy_total_offset
002a4b 91d0 28bd                 	lds r29, pulse2_fx_Rxy_total_offset+1
002a4d 0fac                      	add r26, r28
002a4e 1fbd                      	adc r27, r29
                                 
002a4f 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a51 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002a53 91e0 288a                 	lds ZL, pulse2_hi_pitch_macro
002a55 91f0 288b                 	lds ZH, pulse2_hi_pitch_macro+1
002a57 9630                      	adiw Z, 0
002a58 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002a59 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002a5a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a5b 1fff                      	rol ZH
002a5c 91a0 288c                 	lds r26, pulse2_hi_pitch_macro_offset
002a5e 0fea                      	add ZL, r26
002a5f 1df2                      	adc ZH, zero
                                 
002a60 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
002a62 17ba                      	cp r27, r26
002a63 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a64 91a0 288d                 	lds r26, pulse2_hi_pitch_macro_loop
002a66 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a67 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a68 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002a69 95a3                      	inc r26 //increment the macro offset
002a6a 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002a6c 91b4                      	lpm r27, Z //load hi pitch data into r27
002a6d 38b0                      	cpi r27, 0x80 //check for macro end flag
002a6e f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002a6f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a70 93a0 288c                 	sts pulse2_hi_pitch_macro_offset, r26
002a72 91b0 288e                 	lds r27, pulse2_hi_pitch_macro_release
002a74 3fbf                      	cpi r27, 0xFF
002a75 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002a76 91b0 288d                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002a78 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a79 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002a7a 93b0 288c                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002a7c cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002a7d 91b0 2889                 	lds r27, pulse2_total_hi_pitch_offset
002a7f c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002a80 91a0 2889                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002a82 0fba                      	add r27, r26
002a83 93b0 2889                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002a85 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a86 937f                      	push r23
002a87 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002a88 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a89 0367                      	mulsu r22, r23
002a8a 917f                      	pop r23
002a8b 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002a8c 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002a8e 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002a90 0da0                      	add r26, r0 //offset the timer values
002a91 1db1                      	adc r27, r1
002a92 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a94 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002a96 91e0 288f                 	lds ZL, pulse2_duty_macro
002a98 91f0 2890                 	lds ZH, pulse2_duty_macro+1
002a9a 9630                      	adiw Z, 0
002a9b f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002a9c 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a9d 1fff                      	rol ZH
002a9e 91a0 2891                 	lds r26, pulse2_duty_macro_offset
002aa0 0fea                      	add ZL, r26
002aa1 1df2                      	adc ZH, zero
                                 
002aa2 91b0 2893                 	lds r27, pulse2_duty_macro_release
002aa4 17ba                      	cp r27, r26
002aa5 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002aa6 91a0 2892                 	lds r26, pulse2_duty_macro_loop
002aa8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002aa9 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002aaa c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002aab 95a3                      	inc r26 //increment the macro offset
002aac 93a0 2891                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002aae 91b4                      	lpm r27, Z //load pitch data into r27
002aaf 3fbf                      	cpi r27, 0xFF //check for macro end flag
002ab0 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002ab1 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002ab2 93a0 2891                 	sts pulse2_duty_macro_offset, r26
002ab4 91b0 2893                 	lds r27, pulse2_duty_macro_release
002ab6 3fbf                      	cpi r27, 0xFF
002ab7 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002ab8 91b0 2892                 	lds r27, pulse2_duty_macro_loop //load the loop index
002aba 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002abb f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002abc 93b0 2891                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002abe cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002abf e9e8                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002ac0 e6f4                      	ldi ZH, HIGH(sequences << 1)
002ac1 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002ac2 1df2                      	adc ZH, zero
                                 
002ac3 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002ac4 95b7                      	ror r27
002ac5 95b7                      	ror r27
002ac6 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002ac8 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002ac9 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002aca 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002acb c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002acc c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002acd 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002ace 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002acf 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002ad0 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002ad2 91e0 2896                 	lds ZL, pulse2_fx_1xx
002ad4 91f0 2897                 	lds ZH, pulse2_fx_1xx+1
002ad6 9630                      	adiw Z, 0
002ad7 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002ad8 91a0 2898                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002ada 91b0 2899                 	lds r27, pulse2_fx_1xx_total+1
002adc 0fae                      	add r26, ZL //increase the total offset by the rate
002add 1fbf                      	adc r27, ZH
002ade 93a0 2898                 	sts pulse2_fx_1xx_total, r26
002ae0 93b0 2899                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002ae2 91e0 289a                 	lds ZL, pulse2_fx_2xx
002ae4 91f0 289b                 	lds ZH, pulse2_fx_2xx+1
002ae6 9630                      	adiw Z, 0
002ae7 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002ae8 91a0 289c                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002aea 91b0 289d                 	lds r27, pulse2_fx_2xx_total+1
002aec 0fae                      	add r26, ZL //increase the total offset by the rate
002aed 1fbf                      	adc r27, ZH
002aee 93a0 289c                 	sts pulse2_fx_2xx_total, r26
002af0 93b0 289d                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002af2 91e0 28a2                 	lds ZL, pulse2_fx_3xx_speed
002af4 91f0 28a3                 	lds ZH, pulse2_fx_3xx_speed+1
002af6 9630                      	adiw Z, 0
002af7 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002af8 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002af9 91a0 289e                 	lds r26, pulse2_fx_3xx_start
002afb 91b0 289f                 	lds r27, pulse2_fx_3xx_start+1
002afd 9610                      	adiw r26:r27, 0
002afe f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002aff c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002b00 91c0 28a0                 	lds r28, pulse2_fx_3xx_target
002b02 91d0 28a1                 	lds r29, pulse2_fx_3xx_target+1
                                 
002b04 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002b05 07bd                      	cpc r27, r29
002b06 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002b07 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002b08 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002b09 9220 289e                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002b0b 9220 289f                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002b0d c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002b0e 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002b0f 0bdb                      	sbc r29, r27
002b10 91a0 28a4                 	lds r26, pulse2_fx_3xx_total_offset
002b12 91b0 28a5                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002b14 0fae                      	add r26, ZL //add the speed to the total offset
002b15 1fbf                      	adc r27, ZH
002b16 1bca                      	sub r28, r26 //invert the total difference with the total offset
002b17 0bdb                      	sbc r29, r27
002b18 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b19 93a0 28a4                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002b1b 93b0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002b1d 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002b1f 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b21 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002b22 0bbd                      	sbc r27, r29
002b23 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b25 93b0 0a9d                 	sts TCB1_CCMPH, r27
002b27 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002b28 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002b29 0bbd                      	sbc r27, r29
002b2a 91c0 28a4                 	lds r28, pulse2_fx_3xx_total_offset
002b2c 91d0 28a5                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002b2e 0fce                      	add r28, ZL //add the speed to the total offset
002b2f 1fdf                      	adc r29, ZH
002b30 1bac                      	sub r26, r28 //invert the total difference with the total offset
002b31 0bbd                      	sbc r27, r29
002b32 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b33 93c0 28a4                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002b35 93d0 28a5                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002b37 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002b39 91d0 0a9d                 	lds r29, TCB1_CCMPH
002b3b 0fca                      	add r28, r26 //offset the current timer period with the total offset
002b3c 1fdb                      	adc r29, r27
002b3d 93c0 0a9c                 	sts TCB1_CCMPL, r28
002b3f 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002b41 91a0 28a6                 	lds r26, pulse2_fx_4xy_speed
002b43 15a2                      	cp r26, zero
002b44 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002b45 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002b46 91b0 28a7                 	lds r27, pulse2_fx_4xy_depth
002b48 91c0 28a8                 	lds r28, pulse2_fx_4xy_phase
002b4a 0fca                      	add r28, r26 //increase the phase by the speed
002b4b 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002b4c f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002b4d 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002b4e 93c0 28a8                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002b50 31c0                      	cpi r28, 16
002b51 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002b52 32c0                      	cpi r28, 32
002b53 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002b54 33c0                      	cpi r28, 48
002b55 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002b56 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002b57 70cf                      	andi r28, 0x0F //mask for values 0-15
002b58 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002b59 6fc0                      	ori r28, 0xF0
002b5a 95c0                      	com r28 //invert values 0-15
002b5b c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002b5c 70cf                      	andi r28, 0x0F //mask for values 0-15
002b5d c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002b5e 6fc0                      	ori r28, 0xF0
002b5f 95c0                      	com r28 //invert values 0-15
002b60 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002b61 95b2                      	swap r27 //multiply depth by 16
002b62 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b63 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b64 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b65 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b66 1df2                      	adc ZH, zero
002b67 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002b68 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b69 937f                      	push r23
002b6a 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b6b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b6c 9f67                      	mul r22, r23
002b6d 917f                      	pop r23
002b6e 916f                      	pop r22
                                 
002b6f 9416                      	lsr r1 //shift out the fractional bits
002b70 9407                      	ror r0
002b71 9416                      	lsr r1
002b72 9407                      	ror r0
002b73 9416                      	lsr r1
002b74 9407                      	ror r0
002b75 9416                      	lsr r1
002b76 9407                      	ror r0
                                 	
002b77 91a0 0a9c                 	lds r26, TCB1_CCMPL
002b79 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b7b 0da0                      	add r26, r0
002b7c 1db1                      	adc r27, r1
002b7d 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b7f 93b0 0a9d                 	sts TCB1_CCMPH, r27
002b81 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002b82 95b2                      	swap r27 //multiply depth by 16
002b83 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002b84 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b85 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b86 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b87 1df2                      	adc ZH, zero
002b88 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002b89 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b8a 937f                      	push r23
002b8b 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b8c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b8d 9f67                      	mul r22, r23
002b8e 917f                      	pop r23
002b8f 916f                      	pop r22
                                 
002b90 9416                      	lsr r1 //shift out the fractional bits
002b91 9407                      	ror r0
002b92 9416                      	lsr r1
002b93 9407                      	ror r0
002b94 9416                      	lsr r1
002b95 9407                      	ror r0
002b96 9416                      	lsr r1
002b97 9407                      	ror r0
                                 
002b98 91a0 0a9c                 	lds r26, TCB1_CCMPL
002b9a 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b9c 19a0                      	sub r26, r0
002b9d 09b1                      	sbc r27, r1
002b9e 93a0 0a9c                 	sts TCB1_CCMPL, r26
002ba0 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002ba2 91a0 28a9                 	lds r26, pulse2_fx_7xy_speed
002ba4 15a2                      	cp r26, zero
002ba5 f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002ba6 91b0 28aa                 	lds r27, pulse2_fx_7xy_depth
002ba8 91c0 28ab                 	lds r28, pulse2_fx_7xy_phase
002baa 0fca                      	add r28, r26 //increase the phase by the speed
002bab 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002bac f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002bad e0c0                      	ldi r28, 0x00
002bae 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002baf 93c0 28ab                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002bb1 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002bb2 ffc4                      	sbrs r28, 4
002bb3 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002bb4 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002bb5 70cf                      	andi r28, 0x0F //mask for values 0-15
002bb6 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002bb7 6fc0                      	ori r28, 0xF0
002bb8 95c0                      	com r28 //invert values 0-15
002bb9 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002bba 95b2                      	swap r27 //multiply depth by 16
002bbb 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002bbc e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002bbd e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002bbe 0fec                      	add ZL, r28 //offset the table by the depth+phase
002bbf 1df2                      	adc ZH, zero
002bc0 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002bc1 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002bc2 93c0 28ac                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002bc4 91b0 28ad                 	lds r27, pulse2_fx_Axy
002bc6 15b2                      	cp r27, zero
002bc7 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002bc8 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002bca 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002bcc 2fda                      	mov r29, r26 //copy fractional volume into r29
002bcd 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002bce 95e2                      	swap r30
002bcf 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002bd0 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002bd1 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002bd2 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002bd3 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002bd4 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002bd5 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002bd6 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002bd7 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002bd8 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002bd9 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002bda 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002bdb f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002bdc e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002bdd 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002bdf 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002be0 95a2                      	swap r26
002be1 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002be2 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002be3 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002be5 91e0 28b2                 	lds ZL, pulse2_fx_Qxy_target
002be7 91f0 28b3                 	lds ZH, pulse2_fx_Qxy_target+1
002be9 9630                      	adiw Z, 0
002bea f139                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002beb 91a0 28b6                 	lds r26, pulse2_fx_Qxy_total_offset
002bed 91b0 28b7                 	lds r27, pulse2_fx_Qxy_total_offset+1
002bef 91c0 0a9c                 	lds r28, TCB1_CCMPL
002bf1 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002bf3 1bec                      	sub ZL, r28 //calculate the difference to the target
002bf4 0bfd                      	sbc ZH, r29
002bf5 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002bf6 f088                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002bf7 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002bf8 0bbf                      	sbc r27, ZH
                                 
002bf9 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002bfb 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002bfd 0fac                      	add r26, r28
002bfe 1fbd                      	adc r27, r29
                                 
002bff 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002c01 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
002c03 9220 28b2                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002c05 9220 28b3                 	sts pulse2_fx_Qxy_target+1, zero
002c07 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002c08 91c0 28b4                 	lds r28, pulse2_fx_Qxy_speed
002c0a 91d0 28b5                 	lds r29, pulse2_fx_Qxy_speed+1
002c0c 0fac                      	add r26, r28 //increase the total offset by the speed
002c0d 1fbd                      	adc r27, r29
002c0e 93a0 28b6                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002c10 93b0 28b7                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002c12 91e0 28b8                 	lds ZL, pulse2_fx_Rxy_target
002c14 91f0 28b9                 	lds ZH, pulse2_fx_Rxy_target+1
002c16 9630                      	adiw Z, 0
002c17 f139                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002c18 91a0 28bc                 	lds r26, pulse2_fx_Rxy_total_offset
002c1a 91b0 28bd                 	lds r27, pulse2_fx_Rxy_total_offset+1
002c1c 91c0 0a9c                 	lds r28, TCB1_CCMPL
002c1e 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002c20 1bce                      	sub r28, ZL //calculate the difference to the target
002c21 0bdf                      	sbc r29, ZH
002c22 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002c23 f088                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002c24 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002c25 0bbd                      	sbc r27, r29
                                 
002c26 91c0 28b0                 	lds r28, pulse2_fx_Pxx_total
002c28 91d0 28b1                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002c2a 0fac                      	add r26, r28
002c2b 1fbd                      	adc r27, r29
                                 
002c2c 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002c2e 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
002c30 9220 28b8                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002c32 9220 28b9                 	sts pulse2_fx_Rxy_target+1, zero
002c34 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002c35 91c0 28ba                 	lds r28, pulse2_fx_Rxy_speed
002c37 91d0 28bb                 	lds r29, pulse2_fx_Rxy_speed+1
002c39 0fac                      	add r26, r28 //increase the total offset by the speed
002c3a 1fbd                      	adc r27, r29
002c3b 93a0 28bc                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002c3d 93b0 28bd                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002c3f 91e0 28c6                 	lds ZL, triangle_volume_macro
002c41 91f0 28c7                 	lds ZH, triangle_volume_macro+1
002c43 9630                      	adiw Z, 0
002c44 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002c45 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c46 1fff                      	rol ZH
002c47 91a0 28c8                 	lds r26, triangle_volume_macro_offset
002c49 0fea                      	add ZL, r26
002c4a 1df2                      	adc ZH, zero
                                 
002c4b 91b0 28ca                 	lds r27, triangle_volume_macro_release
002c4d 17ba                      	cp r27, r26
002c4e f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002c4f 91a0 28c9                 	lds r26, triangle_volume_macro_loop
002c51 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c52 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c53 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002c54 95a3                      	inc r26 //increment the macro offset
002c55 93a0 28c8                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002c57 91b4                      	lpm r27, Z //load volume data into r27
002c58 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c59 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002c5a 91b0 28ca                 	lds r27, triangle_volume_macro_release
002c5c 3fbf                      	cpi r27, 0xFF
002c5d f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002c5e 91b0 28c9                 	lds r27, triangle_volume_macro_loop //load the loop index
002c60 93b0 28c8                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002c62 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002c63 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002c64 93a0 28c8                 	sts triangle_volume_macro_offset, r26
002c66 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002c67 15b2                      	cp r27, zero
002c68 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002c69 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002c6b 30b1                      	cpi r27, TCB_CAPT_bm
002c6c f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002c6d e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002c6e 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002c70 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002c71 9220 0aa5                 	sts TCB2_INTCTRL, zero
002c73 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002c75 9220 0aad                 	sts TCB2_CCMPH, zero
002c77 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002c78 91e0 28cb                 	lds ZL, triangle_arpeggio_macro
002c7a 91f0 28cc                 	lds ZH, triangle_arpeggio_macro+1
002c7c 9630                      	adiw Z, 0
002c7d f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002c7e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c7f 1fff                      	rol ZH
002c80 91a0 28cd                 	lds r26, triangle_arpeggio_macro_offset
002c82 0fea                      	add ZL, r26
002c83 1df2                      	adc ZH, zero
                                 
002c84 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002c86 17ba                      	cp r27, r26
002c87 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002c88 91a0 28ce                 	lds r26, triangle_arpeggio_macro_loop
002c8a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c8b f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002c8c c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002c8d 95a3                      	inc r26 //increment the macro offset
002c8e 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002c90 91b4                      	lpm r27, Z //load arpeggio data into r27
002c91 38b0                      	cpi r27, 0x80 //check for macro end flag
002c92 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002c93 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002c94 50a1                      	subi r26, 1 //keep the offset at the end flag
002c95 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26
002c97 91b0 28d0                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002c99 30b1                      	cpi r27, 0x01
002c9a f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002c9b 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002c9d 3fbf                      	cpi r27, 0xFF
002c9e f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002c9f 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop
002ca1 3fbf                      	cpi r27, 0xFF
002ca2 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002ca3 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002ca4 91b0 28cf                 	lds r27, triangle_arpeggio_macro_release
002ca6 3fbf                      	cpi r27, 0xFF
002ca7 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002ca8 91b0 28ce                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002caa 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002cab f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002cac 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002cae 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
002cb0 9620                      	adiw r29:r28, 0
002cb1 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002cb2 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002cb3 93a0 28cd                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002cb5 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002cb6 93b0 28cd                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002cb8 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002cb9 91c0 28e3                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002cbb 91d0 28e4                 	lds r29, triangle_fx_0xy_sequence+1
002cbd 9620                      	adiw r29:r28, 0 //check for 0xy effect
002cbe f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
002cbf 95d6                      	lsr r29
002cc0 95c7                      	ror r28
002cc1 95d7                      	ror r29
002cc2 95c7                      	ror r28
002cc3 95d7                      	ror r29
002cc4 95c7                      	ror r28
002cc5 95d7                      	ror r29
002cc6 95c7                      	ror r28
002cc7 95d7                      	ror r29
002cc8 95d2                      	swap r29
                                 
002cc9 93c0 28e3                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002ccb 93d0 28e4                 	sts triangle_fx_0xy_sequence+1, r29
002ccd 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002cce 91a0 2812                 	lds r26, triangle_note //load the current note index
002cd0 0fac                      	add r26, r28 //add the note offset
002cd1 c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002cd2 91a0 2812                 	lds r26, triangle_note //load the current note index
002cd4 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002cd5 9220 28d1                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002cd7 9220 28d2                 	sts triangle_total_pitch_offset+1, zero
002cd9 9220 28d8                 	sts triangle_total_hi_pitch_offset, zero
002cdb 91a0 28d0                 	lds r26, triangle_arpeggio_macro_mode
002cdd 30a1                      	cpi r26, 0x01 //absolute mode
002cde f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002cdf f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002ce0 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002ce1 91a0 2812                 	lds r26, triangle_note //load the current note index
002ce3 0fab                      	add r26, r27 //offset the note with the arpeggio data
002ce4 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002ce5 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002ce6 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002ce7 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002ce8 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002ce9 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002cea fda7                      	sbrc r26, 7 //check if result is negative
002ceb e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002cec c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002ced 2fab                      	mov r26, r27 //move the arpeggio data into r26
002cee c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002cef 91a0 2812                 	lds r26, triangle_note //load the current note index
002cf1 0fab                      	add r26, r27 //offset the note with the arpeggio data
002cf2 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002cf3 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002cf4 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002cf6 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002cf7 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002cf8 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002cf9 93a0 2812                 	sts triangle_note, r26
002cfb c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002cfc fda7                      	sbrc r26, 7 //check if result is negative
002cfd e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002cfe 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002d00 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002d01 e0f0                      	ldi ZH, HIGH(note_table << 1)
002d02 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002d03 0fea                      	add ZL, r26 //add offset
002d04 1df2                      	adc ZH, zero
002d05 91a5                      	lpm r26, Z+ //load bytes
002d06 91b4                      	lpm r27, Z
002d07 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002d09 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002d0b 93a0 28ef                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002d0d 93b0 28f0                 	sts triangle_fx_3xx_target+1, r27
002d0f c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002d10 91e0 28d3                 	lds ZL, triangle_pitch_macro
002d12 91f0 28d4                 	lds ZH, triangle_pitch_macro+1
002d14 9630                      	adiw Z, 0
002d15 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002d16 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002d17 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d18 1fff                      	rol ZH
002d19 91a0 28d5                 	lds r26, triangle_pitch_macro_offset
002d1b 0fea                      	add ZL, r26
002d1c 1df2                      	adc ZH, zero
                                 
002d1d 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002d1f 17ba                      	cp r27, r26
002d20 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d21 91a0 28d6                 	lds r26, triangle_pitch_macro_loop
002d23 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d24 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d25 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002d26 95a3                      	inc r26 //increment the macro offset
002d27 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002d29 91b4                      	lpm r27, Z //load pitch data into r27
002d2a 38b0                      	cpi r27, 0x80 //check for macro end flag
002d2b f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002d2c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d2d 93a0 28d5                 	sts triangle_pitch_macro_offset, r26
002d2f 91b0 28d7                 	lds r27, triangle_pitch_macro_release
002d31 3fbf                      	cpi r27, 0xFF
002d32 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002d33 91b0 28d6                 	lds r27, triangle_pitch_macro_loop //load the loop index
002d35 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d36 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002d37 93b0 28d5                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002d39 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002d3a e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002d3b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d3c 937f                      	push r23
002d3d 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002d3e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d3f 0367                      	mulsu r22, r23
002d40 917f                      	pop r23
002d41 916f                      	pop r22
                                 
002d42 9416                      	lsr r1 //shift out the fractional bits
002d43 9407                      	ror r0
002d44 9416                      	lsr r1
002d45 9407                      	ror r0
002d46 9416                      	lsr r1
002d47 9407                      	ror r0
002d48 9416                      	lsr r1
002d49 9407                      	ror r0
002d4a fe13                      	sbrs r1, 3 //check if result was a negative number
002d4b c002                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002d4c efb0                      	ldi r27, 0xF0
002d4d 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002d4e 91a0 28d1                 	lds r26, triangle_total_pitch_offset
002d50 91b0 28d2                 	lds r27, triangle_total_pitch_offset+1
002d52 0e0a                      	add r0, r26
002d53 1e1b                      	adc r1, r27
002d54 9200 28d1                 	sts triangle_total_pitch_offset, r0
002d56 9210 28d2                 	sts triangle_total_pitch_offset+1, r1
002d58 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002d5a 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002d5c 0da0                      	add r26, r0 //offset the timer values
002d5d 1db1                      	adc r27, r1
                                 	
002d5e 91c0 28e7                 	lds r28, triangle_fx_1xx_total
002d60 91d0 28e8                 	lds r29, triangle_fx_1xx_total+1
002d62 1bac                      	sub r26, r28
002d63 0bbd                      	sbc r27, r29
002d64 91c0 28eb                 	lds r28, triangle_fx_2xx_total
002d66 91d0 28ec                 	lds r29, triangle_fx_2xx_total+1
002d68 0fac                      	add r26, r28
002d69 1fbd                      	adc r27, r29
002d6a 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002d6c 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
002d6e 0fac                      	add r26, r28
002d6f 1fbd                      	adc r27, r29
002d70 91c0 2900                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002d72 91d0 2901                 	lds r29, triangle_fx_Qxy_total_offset+1
002d74 1bac                      	sub r26, r28
002d75 0bbd                      	sbc r27, r29
002d76 91c0 2906                 	lds r28, triangle_fx_Rxy_total_offset
002d78 91d0 2907                 	lds r29, triangle_fx_Rxy_total_offset+1
002d7a 0fac                      	add r26, r28
002d7b 1fbd                      	adc r27, r29
                                 
002d7c 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002d7e 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002d80 91e0 28d9                 	lds ZL, triangle_hi_pitch_macro
002d82 91f0 28da                 	lds ZH, triangle_hi_pitch_macro+1
002d84 9630                      	adiw Z, 0
002d85 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002d86 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002d87 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d88 1fff                      	rol ZH
002d89 91a0 28db                 	lds r26, triangle_hi_pitch_macro_offset
002d8b 0fea                      	add ZL, r26
002d8c 1df2                      	adc ZH, zero
                                 
002d8d 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002d8f 17ba                      	cp r27, r26
002d90 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d91 91a0 28dc                 	lds r26, triangle_hi_pitch_macro_loop
002d93 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d94 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d95 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002d96 95a3                      	inc r26 //increment the macro offset
002d97 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002d99 91b4                      	lpm r27, Z //load hi pitch data into r27
002d9a 38b0                      	cpi r27, 0x80 //check for macro end flag
002d9b f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002d9c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d9d 93a0 28db                 	sts triangle_hi_pitch_macro_offset, r26
002d9f 91b0 28dd                 	lds r27, triangle_hi_pitch_macro_release
002da1 3fbf                      	cpi r27, 0xFF
002da2 f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002da3 91b0 28dc                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002da5 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002da6 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002da7 93b0 28db                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002da9 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002daa 91b0 28d8                 	lds r27, triangle_total_hi_pitch_offset
002dac c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002dad 91a0 28d8                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002daf 0fba                      	add r27, r26
002db0 93b0 28d8                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002db2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002db3 937f                      	push r23
002db4 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002db5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002db6 0367                      	mulsu r22, r23
002db7 917f                      	pop r23
002db8 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002db9 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002dbb 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002dbd 0da0                      	add r26, r0 //offset the timer values
002dbe 1db1                      	adc r27, r1
002dbf 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002dc1 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002dc3 91e0 28e5                 	lds ZL, triangle_fx_1xx
002dc5 91f0 28e6                 	lds ZH, triangle_fx_1xx+1
002dc7 9630                      	adiw Z, 0
002dc8 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002dc9 91a0 28e7                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002dcb 91b0 28e8                 	lds r27, triangle_fx_1xx_total+1
002dcd 0fae                      	add r26, ZL //increase the total offset by the rate
002dce 1fbf                      	adc r27, ZH
002dcf 93a0 28e7                 	sts triangle_fx_1xx_total, r26
002dd1 93b0 28e8                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002dd3 91e0 28e9                 	lds ZL, triangle_fx_2xx
002dd5 91f0 28ea                 	lds ZH, triangle_fx_2xx+1
002dd7 9630                      	adiw Z, 0
002dd8 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002dd9 91a0 28eb                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002ddb 91b0 28ec                 	lds r27, triangle_fx_2xx_total+1
002ddd 0fae                      	add r26, ZL //increase the total offset by the rate
002dde 1fbf                      	adc r27, ZH
002ddf 93a0 28eb                 	sts triangle_fx_2xx_total, r26
002de1 93b0 28ec                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002de3 91e0 28f1                 	lds ZL, triangle_fx_3xx_speed
002de5 91f0 28f2                 	lds ZH, triangle_fx_3xx_speed+1
002de7 9630                      	adiw Z, 0
002de8 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002de9 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002dea 91a0 28ed                 	lds r26, triangle_fx_3xx_start
002dec 91b0 28ee                 	lds r27, triangle_fx_3xx_start+1
002dee 9610                      	adiw r26:r27, 0
002def f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002df0 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002df1 91c0 28ef                 	lds r28, triangle_fx_3xx_target
002df3 91d0 28f0                 	lds r29, triangle_fx_3xx_target+1
                                 
002df5 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002df6 07bd                      	cpc r27, r29
002df7 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002df8 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002df9 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002dfa 9220 28ed                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002dfc 9220 28ee                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002dfe c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002dff 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002e00 0bdb                      	sbc r29, r27
002e01 91a0 28f3                 	lds r26, triangle_fx_3xx_total_offset
002e03 91b0 28f4                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002e05 0fae                      	add r26, ZL //add the speed to the total offset
002e06 1fbf                      	adc r27, ZH
002e07 1bca                      	sub r28, r26 //invert the total difference with the total offset
002e08 0bdb                      	sbc r29, r27
002e09 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e0a 93a0 28f3                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002e0c 93b0 28f4                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002e0e 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002e10 91b0 0aad                 	lds r27, TCB2_CCMPH
002e12 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002e13 0bbd                      	sbc r27, r29
002e14 93a0 0aac                 	sts TCB2_CCMPL, r26
002e16 93b0 0aad                 	sts TCB2_CCMPH, r27
002e18 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002e19 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002e1a 0bbd                      	sbc r27, r29
002e1b 91c0 28f3                 	lds r28, triangle_fx_3xx_total_offset
002e1d 91d0 28f4                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002e1f 0fce                      	add r28, ZL //add the speed to the total offset
002e20 1fdf                      	adc r29, ZH
002e21 1bac                      	sub r26, r28 //invert the total difference with the total offset
002e22 0bbd                      	sbc r27, r29
002e23 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e24 93c0 28f3                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002e26 93d0 28f4                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002e28 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002e2a 91d0 0aad                 	lds r29, TCB2_CCMPH
002e2c 0fca                      	add r28, r26 //offset the current timer period with the total offset
002e2d 1fdb                      	adc r29, r27
002e2e 93c0 0aac                 	sts TCB2_CCMPL, r28
002e30 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002e32 91a0 28f5                 	lds r26, triangle_fx_4xy_speed
002e34 15a2                      	cp r26, zero
002e35 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002e36 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002e37 91b0 28f6                 	lds r27, triangle_fx_4xy_depth
002e39 91c0 28f7                 	lds r28, triangle_fx_4xy_phase
002e3b 0fca                      	add r28, r26 //increase the phase by the speed
002e3c 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002e3d f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002e3e 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002e3f 93c0 28f7                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002e41 31c0                      	cpi r28, 16
002e42 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002e43 32c0                      	cpi r28, 32
002e44 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002e45 33c0                      	cpi r28, 48
002e46 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002e47 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002e48 70cf                      	andi r28, 0x0F //mask for values 0-15
002e49 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002e4a 6fc0                      	ori r28, 0xF0
002e4b 95c0                      	com r28 //invert values 0-15
002e4c c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002e4d 70cf                      	andi r28, 0x0F //mask for values 0-15
002e4e c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002e4f 6fc0                      	ori r28, 0xF0
002e50 95c0                      	com r28 //invert values 0-15
002e51 c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002e52 95b2                      	swap r27 //multiply depth by 16
002e53 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002e54 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e55 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e56 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e57 1df2                      	adc ZH, zero
002e58 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002e59 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e5a 937f                      	push r23
002e5b 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e5c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e5d 9f67                      	mul r22, r23
002e5e 917f                      	pop r23
002e5f 916f                      	pop r22
                                 
002e60 9416                      	lsr r1 //shift out the fractional bits
002e61 9407                      	ror r0
002e62 9416                      	lsr r1
002e63 9407                      	ror r0
002e64 9416                      	lsr r1
002e65 9407                      	ror r0
002e66 9416                      	lsr r1
002e67 9407                      	ror r0
                                 	
002e68 91a0 0aac                 	lds r26, TCB2_CCMPL
002e6a 91b0 0aad                 	lds r27, TCB2_CCMPH
002e6c 0da0                      	add r26, r0
002e6d 1db1                      	adc r27, r1
002e6e 93a0 0aac                 	sts TCB2_CCMPL, r26
002e70 93b0 0aad                 	sts TCB2_CCMPH, r27
002e72 c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002e73 95b2                      	swap r27 //multiply depth by 16
002e74 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002e75 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e76 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e77 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e78 1df2                      	adc ZH, zero
002e79 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002e7a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e7b 937f                      	push r23
002e7c 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e7d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e7e 9f67                      	mul r22, r23
002e7f 917f                      	pop r23
002e80 916f                      	pop r22
                                 
002e81 9416                      	lsr r1 //shift out the fractional bits
002e82 9407                      	ror r0
002e83 9416                      	lsr r1
002e84 9407                      	ror r0
002e85 9416                      	lsr r1
002e86 9407                      	ror r0
002e87 9416                      	lsr r1
002e88 9407                      	ror r0
                                 
002e89 91a0 0aac                 	lds r26, TCB2_CCMPL
002e8b 91b0 0aad                 	lds r27, TCB2_CCMPH
002e8d 19a0                      	sub r26, r0
002e8e 09b1                      	sbc r27, r1
002e8f 93a0 0aac                 	sts TCB2_CCMPL, r26
002e91 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002e93 91e0 28fc                 	lds ZL, triangle_fx_Qxy_target
002e95 91f0 28fd                 	lds ZH, triangle_fx_Qxy_target+1
002e97 9630                      	adiw Z, 0
002e98 f139                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002e99 91a0 2900                 	lds r26, triangle_fx_Qxy_total_offset
002e9b 91b0 2901                 	lds r27, triangle_fx_Qxy_total_offset+1
002e9d 91c0 0aac                 	lds r28, TCB2_CCMPL
002e9f 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002ea1 1bec                      	sub ZL, r28 //calculate the difference to the target
002ea2 0bfd                      	sbc ZH, r29
002ea3 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002ea4 f088                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002ea5 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002ea6 0bbf                      	sbc r27, ZH
                                 
002ea7 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002ea9 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
002eab 0fac                      	add r26, r28
002eac 1fbd                      	adc r27, r29
                                 
002ead 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002eaf 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
002eb1 9220 28fc                 	sts triangle_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002eb3 9220 28fd                 	sts triangle_fx_Qxy_target+1, zero
002eb5 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002eb6 91c0 28fe                 	lds r28, triangle_fx_Qxy_speed
002eb8 91d0 28ff                 	lds r29, triangle_fx_Qxy_speed+1
002eba 0fac                      	add r26, r28 //increase the total offset by the speed
002ebb 1fbd                      	adc r27, r29
002ebc 93a0 2900                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002ebe 93b0 2901                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002ec0 91e0 2902                 	lds ZL, triangle_fx_Rxy_target
002ec2 91f0 2903                 	lds ZH, triangle_fx_Rxy_target+1
002ec4 9630                      	adiw Z, 0
002ec5 f139                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002ec6 91a0 2906                 	lds r26, triangle_fx_Rxy_total_offset
002ec8 91b0 2907                 	lds r27, triangle_fx_Rxy_total_offset+1
002eca 91c0 0aac                 	lds r28, TCB2_CCMPL
002ecc 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002ece 1bce                      	sub r28, ZL //calculate the difference to the target
002ecf 0bdf                      	sbc r29, ZH
002ed0 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002ed1 f088                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002ed2 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002ed3 0bbd                      	sbc r27, r29
                                 
002ed4 91c0 28fa                 	lds r28, triangle_fx_Pxx_total
002ed6 91d0 28fb                 	lds r29, triangle_fx_Pxx_total+1
                                 
002ed8 0fac                      	add r26, r28
002ed9 1fbd                      	adc r27, r29
                                 
002eda 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002edc 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
002ede 9220 2902                 	sts triangle_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002ee0 9220 2903                 	sts triangle_fx_Rxy_target+1, zero
002ee2 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002ee3 91c0 2904                 	lds r28, triangle_fx_Rxy_speed
002ee5 91d0 2905                 	lds r29, triangle_fx_Rxy_speed+1
002ee7 0fac                      	add r26, r28 //increase the total offset by the speed
002ee8 1fbd                      	adc r27, r29
002ee9 93a0 2906                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002eeb 93b0 2907                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002eed 91e0 2910                 	lds ZL, noise_volume_macro
002eef 91f0 2911                 	lds ZH, noise_volume_macro+1
002ef1 9630                      	adiw Z, 0
002ef2 f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002ef3 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002ef4 1fff                      	rol ZH
002ef5 91a0 2912                 	lds r26, noise_volume_macro_offset
002ef7 0fea                      	add ZL, r26
002ef8 1df2                      	adc ZH, zero
                                 
002ef9 91b0 2914                 	lds r27, noise_volume_macro_release
002efb 17ba                      	cp r27, r26
002efc f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002efd 91a0 2913                 	lds r26, noise_volume_macro_loop
002eff 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f00 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f01 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002f02 95a3                      	inc r26 //increment the macro offset
002f03 93a0 2912                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002f05 91b4                      	lpm r27, Z //load volume data into r27
002f06 3fbf                      	cpi r27, 0xFF //check for macro end flag
002f07 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002f08 91b0 2914                 	lds r27, noise_volume_macro_release
002f0a 3fbf                      	cpi r27, 0xFF
002f0b f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002f0c 91b0 2913                 	lds r27, noise_volume_macro_loop //load the loop index
002f0e 93b0 2912                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002f10 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002f11 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002f12 93a0 2912                 	sts noise_volume_macro_offset, r26
002f14 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002f15 e6ec                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002f16 e6f5                      	ldi ZH, HIGH(volumes << 1)
002f17 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002f18 0feb                      	add ZL, r27 //add offset to the table
002f19 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002f1a 91b0 2813                 	lds r27, noise_param //load main volume
002f1c 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f1d 91a0 2945                 	lds r26, noise_fx_7xy_value
002f1f 30a0                      	cpi r26, 0x00
002f20 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002f21 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f22 1df2                      	adc ZH, zero
002f23 91b4                      	lpm r27, Z
002f24 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f26 c024                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002f27 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002f29 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f2a 91a0 2945                 	lds r26, noise_fx_7xy_value
002f2c 30a0                      	cpi r26, 0x00
002f2d f4a1                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002f2e 93b0 2816                 	sts noise_output_volume, r27
002f30 c01a                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002f31 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f32 f040                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002f33 f039                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002f34 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002f35 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f36 1df2                      	adc ZH, zero
002f37 91b4                      	lpm r27, Z
002f38 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f3a c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002f3b e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f3c 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f3d 1df2                      	adc ZH, zero
002f3e 91b4                      	lpm r27, Z
002f3f 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f41 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002f42 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f43 f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f44 f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f45 93b0 2816                 	sts noise_output_volume, r27
002f47 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002f48 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f49 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002f4b 91e0 2915                 	lds ZL, noise_arpeggio_macro
002f4d 91f0 2916                 	lds ZH, noise_arpeggio_macro+1
002f4f 9630                      	adiw Z, 0
002f50 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002f51 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f52 1fff                      	rol ZH
002f53 91a0 2917                 	lds r26, noise_arpeggio_macro_offset
002f55 0fea                      	add ZL, r26
002f56 1df2                      	adc ZH, zero
                                 
002f57 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002f59 17ba                      	cp r27, r26
002f5a f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002f5b 91a0 2918                 	lds r26, noise_arpeggio_macro_loop
002f5d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f5e f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002f5f c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002f60 95a3                      	inc r26 //increment the macro offset
002f61 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002f63 91b4                      	lpm r27, Z //load arpeggio data into r27
002f64 38b0                      	cpi r27, 0x80 //check for macro end flag
002f65 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002f66 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002f67 50a1                      	subi r26, 1 //keep the offset at the end flag
002f68 93a0 2917                 	sts noise_arpeggio_macro_offset, r26
002f6a 91b0 291a                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002f6c 30b1                      	cpi r27, 0x01
002f6d f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002f6e 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002f70 3fbf                      	cpi r27, 0xFF
002f71 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002f72 91b0 2918                 	lds r27, noise_arpeggio_macro_loop
002f74 3fbf                      	cpi r27, 0xFF
002f75 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002f76 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002f77 91b0 2919                 	lds r27, noise_arpeggio_macro_release
002f79 3fbf                      	cpi r27, 0xFF
002f7a f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002f7b 91b0 2918                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002f7d 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002f7e f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002f7f 91c0 292d                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002f81 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
002f83 9620                      	adiw r29:r28, 0
002f84 f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002f85 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002f86 93a0 2917                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002f88 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002f89 93b0 2917                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002f8b cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002f8c 91c0 292d                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002f8e 91d0 292e                 	lds r29, noise_fx_0xy_sequence+1
002f90 9620                      	adiw r29:r28, 0 //check for 0xy effect
002f91 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_xy:
002f92 95d6                      	lsr r29
002f93 95c7                      	ror r28
002f94 95d7                      	ror r29
002f95 95c7                      	ror r28
002f96 95d7                      	ror r29
002f97 95c7                      	ror r28
002f98 95d7                      	ror r29
002f99 95c7                      	ror r28
002f9a 95d7                      	ror r29
002f9b 95d2                      	swap r29
                                 
002f9c 93c0 292d                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002f9e 93d0 292e                 	sts noise_fx_0xy_sequence+1, r29
002fa0 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002fa1 91a0 2817                 	lds r26, noise_note //load the current note index
002fa3 0fac                      	add r26, r28 //add the note offset
002fa4 c02e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002fa5 91a0 2817                 	lds r26, noise_note //load the current note index
002fa7 c02b                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002fa8 9220 291b                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002faa 9220 291c                 	sts noise_total_pitch_offset+1, zero
002fac 9220 2922                 	sts noise_total_hi_pitch_offset, zero
002fae 91a0 291a                 	lds r26, noise_arpeggio_macro_mode
002fb0 30a1                      	cpi r26, 0x01 //absolute mode
002fb1 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002fb2 f069                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002fb3 c00e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002fb4 91a0 2817                 	lds r26, noise_note //load the current note index
002fb6 0fab                      	add r26, r27 //offset the note with the arpeggio data
002fb7 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002fb8 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_add:
002fb9 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002fba f0c0                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002fbb e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002fbc c016                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract:
002fbd fda7                      	sbrc r26, 7 //check if result is negative
002fbe e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002fbf c013                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002fc0 2fab                      	mov r26, r27 //move the arpeggio data into r26
002fc1 c011                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002fc2 91a0 2817                 	lds r26, noise_note //load the current note index
002fc4 0fab                      	add r26, r27 //offset the note with the arpeggio data
002fc5 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002fc6 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_add:
002fc7 93a0 2817                 	sts noise_note, r26 //NOTE: relative mode modifies the original note index
002fc9 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002fca f040                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002fcb e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002fcc 93a0 2817                 	sts noise_note, r26
002fce c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract:
002fcf fda7                      	sbrc r26, 7 //check if result is negative
002fd0 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002fd1 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002fd3 e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002fd4 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002fd5 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002fd6 0fea                      	add ZL, r26 //add offset
002fd7 1df2                      	adc ZH, zero
002fd8 91a5                      	lpm r26, Z+ //load bytes
002fd9 91b4                      	lpm r27, Z
002fda 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002fdc 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
002fde 93a0 2939                 	sts noise_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002fe0 93b0 293a                 	sts noise_fx_3xx_target+1, r27
002fe2 c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002fe3 91e0 291d                 	lds ZL, noise_pitch_macro
002fe5 91f0 291e                 	lds ZH, noise_pitch_macro+1
002fe7 9630                      	adiw Z, 0
002fe8 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002fe9 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002fea 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002feb 1fff                      	rol ZH
002fec 91a0 291f                 	lds r26, noise_pitch_macro_offset
002fee 0fea                      	add ZL, r26
002fef 1df2                      	adc ZH, zero
                                 
002ff0 91b0 2921                 	lds r27, noise_pitch_macro_release
002ff2 17ba                      	cp r27, r26
002ff3 f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002ff4 91a0 2920                 	lds r26, noise_pitch_macro_loop
002ff6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ff7 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ff8 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002ff9 95a3                      	inc r26 //increment the macro offset
002ffa 93a0 291f                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002ffc 91b4                      	lpm r27, Z //load pitch data into r27
002ffd 38b0                      	cpi r27, 0x80 //check for macro end flag
002ffe f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002fff 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003000 93a0 291f                 	sts noise_pitch_macro_offset, r26
003002 91b0 2921                 	lds r27, noise_pitch_macro_release
003004 3fbf                      	cpi r27, 0xFF
003005 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
003006 91b0 2920                 	lds r27, noise_pitch_macro_loop //load the loop index
003008 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003009 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00300a 93b0 291f                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
00300c cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
00300d e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
00300e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00300f 937f                      	push r23
003010 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
003011 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003012 0367                      	mulsu r22, r23
003013 917f                      	pop r23
003014 916f                      	pop r22
                                 
003015 9416                      	lsr r1 //shift out the fractional bits
003016 9407                      	ror r0
003017 9416                      	lsr r1
003018 9407                      	ror r0
003019 9416                      	lsr r1
00301a 9407                      	ror r0
00301b 9416                      	lsr r1
00301c 9407                      	ror r0
00301d fe13                      	sbrs r1, 3 //check if result was a negative number
00301e c002                      	rjmp sound_driver_instrument_routine_channel3_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_negative:
00301f efb0                      	ldi r27, 0xF0
003020 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
003021 91a0 291b                 	lds r26, noise_total_pitch_offset
003023 91b0 291c                 	lds r27, noise_total_pitch_offset+1
003025 0e0a                      	add r0, r26
003026 1e1b                      	adc r1, r27
003027 9200 291b                 	sts noise_total_pitch_offset, r0
003029 9210 291c                 	sts noise_total_pitch_offset+1, r1
00302b 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
00302d 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
00302f 0da0                      	add r26, r0 //offset the timer values
003030 1db1                      	adc r27, r1
                                 	
003031 91c0 2931                 	lds r28, noise_fx_1xx_total
003033 91d0 2932                 	lds r29, noise_fx_1xx_total+1
003035 1bac                      	sub r26, r28
003036 0bbd                      	sbc r27, r29
003037 91c0 2935                 	lds r28, noise_fx_2xx_total
003039 91d0 2936                 	lds r29, noise_fx_2xx_total+1
00303b 0fac                      	add r26, r28
00303c 1fbd                      	adc r27, r29
00303d 91c0 2949                 	lds r28, noise_fx_Pxx_total
00303f 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
003041 0fac                      	add r26, r28
003042 1fbd                      	adc r27, r29
003043 91c0 294f                 	lds r28, noise_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
003045 91d0 2950                 	lds r29, noise_fx_Qxy_total_offset+1
003047 1bac                      	sub r26, r28
003048 0bbd                      	sbc r27, r29
003049 91c0 2955                 	lds r28, noise_fx_Rxy_total_offset
00304b 91d0 2956                 	lds r29, noise_fx_Rxy_total_offset+1
00304d 0fac                      	add r26, r28
00304e 1fbd                      	adc r27, r29
                                 
00304f 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
003051 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
003053 91e0 2923                 	lds ZL, noise_hi_pitch_macro
003055 91f0 2924                 	lds ZH, noise_hi_pitch_macro+1
003057 9630                      	adiw Z, 0
003058 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
003059 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
00305a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00305b 1fff                      	rol ZH
00305c 91a0 2925                 	lds r26, noise_hi_pitch_macro_offset
00305e 0fea                      	add ZL, r26
00305f 1df2                      	adc ZH, zero
                                 
003060 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
003062 17ba                      	cp r27, r26
003063 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
003064 91a0 2926                 	lds r26, noise_hi_pitch_macro_loop
003066 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003067 f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003068 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
003069 95a3                      	inc r26 //increment the macro offset
00306a 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
00306c 91b4                      	lpm r27, Z //load hi pitch data into r27
00306d 38b0                      	cpi r27, 0x80 //check for macro end flag
00306e f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
00306f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003070 93a0 2925                 	sts noise_hi_pitch_macro_offset, r26
003072 91b0 2927                 	lds r27, noise_hi_pitch_macro_release
003074 3fbf                      	cpi r27, 0xFF
003075 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
003076 91b0 2926                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
003078 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003079 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00307a 93b0 2925                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
00307c cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
00307d 91b0 2922                 	lds r27, noise_total_hi_pitch_offset
00307f c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
003080 91a0 2922                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
003082 0fba                      	add r27, r26
003083 93b0 2922                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
003085 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003086 937f                      	push r23
003087 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
003088 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003089 0367                      	mulsu r22, r23
00308a 917f                      	pop r23
00308b 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
00308c 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
00308e 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
003090 0da0                      	add r26, r0 //offset the timer values
003091 1db1                      	adc r27, r1
003092 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
003094 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
003096 91e0 2928                 	lds ZL, noise_duty_macro
003098 91f0 2929                 	lds ZH, noise_duty_macro+1
00309a 9630                      	adiw Z, 0
00309b f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
00309c 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00309d 1fff                      	rol ZH
00309e 91a0 292a                 	lds r26, noise_duty_macro_offset
0030a0 0fea                      	add ZL, r26
0030a1 1df2                      	adc ZH, zero
                                 
0030a2 91b0 292c                 	lds r27, noise_duty_macro_release
0030a4 17ba                      	cp r27, r26
0030a5 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
0030a6 91a0 292b                 	lds r26, noise_duty_macro_loop
0030a8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0030a9 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0030aa c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
0030ab 95a3                      	inc r26 //increment the macro offset
0030ac 93a0 292a                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
0030ae 91b4                      	lpm r27, Z //load pitch data into r27
0030af 3fbf                      	cpi r27, 0xFF //check for macro end flag
0030b0 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
0030b1 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0030b2 93a0 292a                 	sts noise_duty_macro_offset, r26
0030b4 91b0 292c                 	lds r27, noise_duty_macro_release
0030b6 3fbf                      	cpi r27, 0xFF
0030b7 f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
0030b8 91b0 292b                 	lds r27, noise_duty_macro_loop //load the loop index
0030ba 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0030bb f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0030bc 93b0 292a                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
0030be cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
0030bf 95b6                      	lsr r27
0030c0 95b7                      	ror r27 //move mode bit to bit 7
0030c1 91c0 2814                 	lds r28, noise_period
0030c3 77cf                      	andi r28, 0b01111111
0030c4 2bcb                      	or r28, r27 //store the new noise mode
0030c5 93c0 2813                 	sts noise_param, r28
                                 
0030c7 776f                      	andi noise_sequence_HIGH, 0b01111111
0030c8 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
0030c9 91e0 292f                 	lds ZL, noise_fx_1xx
0030cb 91f0 2930                 	lds ZH, noise_fx_1xx+1
0030cd 9630                      	adiw Z, 0
0030ce f051                      	breq sound_driver_channel3_fx_2xx_routine
                                 
0030cf 91a0 2931                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
0030d1 91b0 2932                 	lds r27, noise_fx_1xx_total+1
0030d3 0fae                      	add r26, ZL //increase the total offset by the rate
0030d4 1fbf                      	adc r27, ZH
0030d5 93a0 2931                 	sts noise_fx_1xx_total, r26
0030d7 93b0 2932                 	sts noise_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
0030d9 91e0 2933                 	lds ZL, noise_fx_2xx
0030db 91f0 2934                 	lds ZH, noise_fx_2xx+1
0030dd 9630                      	adiw Z, 0
0030de f051                      	breq sound_driver_channel3_fx_3xx_routine
                                 
0030df 91a0 2935                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
0030e1 91b0 2936                 	lds r27, noise_fx_2xx_total+1
0030e3 0fae                      	add r26, ZL //increase the total offset by the rate
0030e4 1fbf                      	adc r27, ZH
0030e5 93a0 2935                 	sts noise_fx_2xx_total, r26
0030e7 93b0 2936                 	sts noise_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
0030e9 91e0 293b                 	lds ZL, noise_fx_3xx_speed
0030eb 91f0 293c                 	lds ZH, noise_fx_3xx_speed+1
0030ed 9630                      	adiw Z, 0
0030ee f409                      	brne sound_driver_channel3_fx_3xx_routine_check_start
0030ef c048                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_check_start:
0030f0 91a0 2937                 	lds r26, noise_fx_3xx_start
0030f2 91b0 2938                 	lds r27, noise_fx_3xx_start+1
0030f4 9610                      	adiw r26:r27, 0
0030f5 f409                      	brne sound_driver_channel3_fx_3xx_routine_main
0030f6 c041                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_main:
0030f7 91c0 2939                 	lds r28, noise_fx_3xx_target
0030f9 91d0 293a                 	lds r29, noise_fx_3xx_target+1
                                 
0030fb 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0030fc 07bd                      	cpc r27, r29
0030fd f011                      	breq sound_driver_channel3_fx_3xx_routine_disable
0030fe f030                      	brlo sound_driver_channel3_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0030ff c01f                      	rjmp sound_driver_channel3_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel3_fx_3xx_routine_disable:
003100 9220 2937                 	sts noise_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
003102 9220 2938                 	sts noise_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
003104 c033                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_subtract:
003105 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
003106 0bdb                      	sbc r29, r27
003107 91a0 293d                 	lds r26, noise_fx_3xx_total_offset
003109 91b0 293e                 	lds r27, noise_fx_3xx_total_offset+1
                                 
00310b 0fae                      	add r26, ZL //add the speed to the total offset
00310c 1fbf                      	adc r27, ZH
00310d 1bca                      	sub r28, r26 //invert the total difference with the total offset
00310e 0bdb                      	sbc r29, r27
00310f f380                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
003110 93a0 293d                 	sts noise_fx_3xx_total_offset, r26 //store the new total offset
003112 93b0 293e                 	sts noise_fx_3xx_total_offset+1, r27
                                 
003114 91a0 0abc                 	lds r26, TCB3_CCMPL //load the current timer period
003116 91b0 0abd                 	lds r27, TCB3_CCMPH
003118 1bac                      	sub r26, r28 //offset the current timer period with the total offset
003119 0bbd                      	sbc r27, r29
00311a 93a0 0abc                 	sts TCB3_CCMPL, r26
00311c 93b0 0abd                 	sts TCB3_CCMPH, r27
00311e c019                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_add:
00311f 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
003120 0bbd                      	sbc r27, r29
003121 91c0 293d                 	lds r28, noise_fx_3xx_total_offset
003123 91d0 293e                 	lds r29, noise_fx_3xx_total_offset+1
                                 
003125 0fce                      	add r28, ZL //add the speed to the total offset
003126 1fdf                      	adc r29, ZH
003127 1bac                      	sub r26, r28 //invert the total difference with the total offset
003128 0bbd                      	sbc r27, r29
003129 f2b0                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00312a 93c0 293d                 	sts noise_fx_3xx_total_offset, r28 //store the new total offset
00312c 93d0 293e                 	sts noise_fx_3xx_total_offset+1, r29
                                 
00312e 91c0 0abc                 	lds r28, TCB3_CCMPL //load the current timer period
003130 91d0 0abd                 	lds r29, TCB3_CCMPH
003132 0fca                      	add r28, r26 //offset the current timer period with the total offset
003133 1fdb                      	adc r29, r27
003134 93c0 0abc                 	sts TCB3_CCMPL, r28
003136 93d0 0abd                 	sts TCB3_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
003138 91a0 293f                 	lds r26, noise_fx_4xy_speed
00313a 15a2                      	cp r26, zero
00313b f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
00313c c05c                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
00313d 91b0 2940                 	lds r27, noise_fx_4xy_depth
00313f 91c0 2941                 	lds r28, noise_fx_4xy_phase
003141 0fca                      	add r28, r26 //increase the phase by the speed
003142 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
003143 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
003144 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
003145 93c0 2941                 	sts noise_fx_4xy_phase, r28 //store the new phase
003147 31c0                      	cpi r28, 16
003148 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
003149 32c0                      	cpi r28, 32
00314a f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
00314b 33c0                      	cpi r28, 48
00314c f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
00314d c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
00314e 70cf                      	andi r28, 0x0F //mask for values 0-15
00314f c029                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
003150 6fc0                      	ori r28, 0xF0
003151 95c0                      	com r28 //invert values 0-15
003152 c026                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
003153 70cf                      	andi r28, 0x0F //mask for values 0-15
003154 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
003155 6fc0                      	ori r28, 0xF0
003156 95c0                      	com r28 //invert values 0-15
003157 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
003158 95b2                      	swap r27 //multiply depth by 16
003159 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00315a e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00315b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00315c 0fec                      	add ZL, r28 //offset the table by the depth+phase
00315d 1df2                      	adc ZH, zero
00315e 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00315f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003160 937f                      	push r23
003161 2f6c                      	mov r22, r28 //store the vibrato value into r22
003162 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003163 9f67                      	mul r22, r23
003164 917f                      	pop r23
003165 916f                      	pop r22
                                 
003166 9416                      	lsr r1 //shift out the fractional bits
003167 9407                      	ror r0
003168 9416                      	lsr r1
003169 9407                      	ror r0
00316a 9416                      	lsr r1
00316b 9407                      	ror r0
00316c 9416                      	lsr r1
00316d 9407                      	ror r0
                                 	
00316e 91a0 0abc                 	lds r26, TCB3_CCMPL
003170 91b0 0abd                 	lds r27, TCB3_CCMPH
003172 0da0                      	add r26, r0
003173 1db1                      	adc r27, r1
003174 93a0 0abc                 	sts TCB3_CCMPL, r26
003176 93b0 0abd                 	sts TCB3_CCMPH, r27
003178 c020                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
003179 95b2                      	swap r27 //multiply depth by 16
00317a 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00317b e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00317c e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00317d 0fec                      	add ZL, r28 //offset the table by the depth+phase
00317e 1df2                      	adc ZH, zero
00317f 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003180 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003181 937f                      	push r23
003182 2f6c                      	mov r22, r28 //store the vibrato value into r22
003183 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003184 9f67                      	mul r22, r23
003185 917f                      	pop r23
003186 916f                      	pop r22
                                 
003187 9416                      	lsr r1 //shift out the fractional bits
003188 9407                      	ror r0
003189 9416                      	lsr r1
00318a 9407                      	ror r0
00318b 9416                      	lsr r1
00318c 9407                      	ror r0
00318d 9416                      	lsr r1
00318e 9407                      	ror r0
                                 
00318f 91a0 0abc                 	lds r26, TCB3_CCMPL
003191 91b0 0abd                 	lds r27, TCB3_CCMPH
003193 19a0                      	sub r26, r0
003194 09b1                      	sbc r27, r1
003195 93a0 0abc                 	sts TCB3_CCMPL, r26
003197 93b0 0abd                 	sts TCB3_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
003199 91a0 2942                 	lds r26, noise_fx_7xy_speed
00319b 15a2                      	cp r26, zero
00319c f0f1                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00319d 91b0 2943                 	lds r27, noise_fx_7xy_depth
00319f 91c0 2944                 	lds r28, noise_fx_7xy_phase
0031a1 0fca                      	add r28, r26 //increase the phase by the speed
0031a2 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0031a3 f010                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0031a4 e0c0                      	ldi r28, 0x00
0031a5 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
0031a6 93c0 2944                 	sts noise_fx_7xy_phase, r28 //store the new phase
0031a8 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0031a9 ffc4                      	sbrs r28, 4
0031aa c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
0031ab c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
0031ac 70cf                      	andi r28, 0x0F //mask for values 0-15
0031ad c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
0031ae 6fc0                      	ori r28, 0xF0
0031af 95c0                      	com r28 //invert values 0-15
0031b0 c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
0031b1 95b2                      	swap r27 //multiply depth by 16
0031b2 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0031b3 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0031b4 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0031b5 0fec                      	add ZL, r28 //offset the table by the depth+phase
0031b6 1df2                      	adc ZH, zero
0031b7 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0031b8 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0031b9 93c0 2945                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
0031bb 91b0 2946                 	lds r27, noise_fx_Axy
0031bd 15b2                      	cp r27, zero
0031be f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0031bf 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
0031c1 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
0031c3 2fda                      	mov r29, r26 //copy fractional volume into r29
0031c4 2fec                      	mov r30, r28 //copy the noise_param into r30
0031c5 95e2                      	swap r30
0031c6 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0031c7 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0031c8 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0031c9 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
0031ca 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
0031cb fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0031cc c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
0031cd 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0031ce f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0031cf efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0031d0 c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
0031d1 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0031d2 f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0031d3 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
0031d4 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
0031d6 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0031d7 95a2                      	swap r26
0031d8 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0031d9 2bca                      	or r28, r26 //store the new volume back into noise_param
0031da 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel3_fx_Qxy_routine:
0031dc 91e0 294b                 	lds ZL, noise_fx_Qxy_target
0031de 91f0 294c                 	lds ZH, noise_fx_Qxy_target+1
0031e0 9630                      	adiw Z, 0
0031e1 f139                      	breq sound_driver_channel3_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0031e2 91a0 294f                 	lds r26, noise_fx_Qxy_total_offset
0031e4 91b0 2950                 	lds r27, noise_fx_Qxy_total_offset+1
0031e6 91c0 0abc                 	lds r28, TCB3_CCMPL
0031e8 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
0031ea 1bec                      	sub ZL, r28 //calculate the difference to the target
0031eb 0bfd                      	sbc ZH, r29
0031ec f408                      	brsh sound_driver_channel3_fx_Qxy_routine_end //if the target has been reached (or passed)
0031ed f088                      	brlo sound_driver_channel3_fx_Qxy_routine_add
                                 
                                 sound_driver_channel3_fx_Qxy_routine_end:
0031ee 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0031ef 0bbf                      	sbc r27, ZH
                                 
0031f0 91c0 2949                 	lds r28, noise_fx_Pxx_total
0031f2 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
0031f4 0fac                      	add r26, r28
0031f5 1fbd                      	adc r27, r29
                                 
0031f6 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
0031f8 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
0031fa 9220 294b                 	sts noise_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0031fc 9220 294c                 	sts noise_fx_Qxy_target+1, zero
0031fe c00a                      	rjmp sound_driver_channel3_fx_Rxy_routine
                                 
                                 sound_driver_channel3_fx_Qxy_routine_add:
0031ff 91c0 294d                 	lds r28, noise_fx_Qxy_speed
003201 91d0 294e                 	lds r29, noise_fx_Qxy_speed+1
003203 0fac                      	add r26, r28 //increase the total offset by the speed
003204 1fbd                      	adc r27, r29
003205 93a0 294f                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
003207 93b0 2950                 	sts noise_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
003209 91e0 2951                 	lds ZL, noise_fx_Rxy_target
00320b 91f0 2952                 	lds ZH, noise_fx_Rxy_target+1
00320d 9630                      	adiw Z, 0
00320e f139                      	breq sound_driver_instrument_routine_channel4_volume //if the effect is not enabled, skip the routine
                                 
00320f 91a0 2955                 	lds r26, noise_fx_Rxy_total_offset
003211 91b0 2956                 	lds r27, noise_fx_Rxy_total_offset+1
003213 91c0 0abc                 	lds r28, TCB3_CCMPL
003215 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
003217 1bce                      	sub r28, ZL //calculate the difference to the target
003218 0bdf                      	sbc r29, ZH
003219 f408                      	brsh sound_driver_channel3_fx_Rxy_routine_end //if the target has been reached (or passed)
00321a f088                      	brlo sound_driver_channel3_fx_Rxy_routine_add
                                 
                                 sound_driver_channel3_fx_Rxy_routine_end:
00321b 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
00321c 0bbd                      	sbc r27, r29
                                 
00321d 91c0 2949                 	lds r28, noise_fx_Pxx_total
00321f 91d0 294a                 	lds r29, noise_fx_Pxx_total+1
                                 
003221 0fac                      	add r26, r28
003222 1fbd                      	adc r27, r29
                                 
003223 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
003225 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
003227 9220 2951                 	sts noise_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
003229 9220 2952                 	sts noise_fx_Rxy_target+1, zero
00322b c00a                      	rjmp sound_driver_instrument_routine_channel4_volume
                                 
                                 sound_driver_channel3_fx_Rxy_routine_add:
00322c 91c0 2953                 	lds r28, noise_fx_Rxy_speed
00322e 91d0 2954                 	lds r29, noise_fx_Rxy_speed+1
003230 0fac                      	add r26, r28 //increase the total offset by the speed
003231 1fbd                      	adc r27, r29
003232 93a0 2955                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
003234 93b0 2956                 	sts noise_fx_Rxy_total_offset+1, r27
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
003236 91ff                      	pop r31
003237 91ef                      	pop r30
003238 91df                      	pop r29
003239 91cf                      	pop r28
00323a 940c 171e                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
00323c 7f05
00323d 010a
00323e 0214
00323f 0328
003240 0450
003241 051e
003242 0607
003243 070d
003244 0806
003245 090c
003246 0a18
003247 0b30
003248 0c60
003249 0d24
00324a 0e08
00324b 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
00324c 0301
00324d fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
00324e 195a
00324f 195f
003250 197b
003251 1997
003252 19ba                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
003253 19c5
003254 19d2
003255 19d5
003256 19d8
003257 19db                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
003258 19de
003259 19e6
00325a 19e9
00325b 19f6
00325c 19f7                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
00325d 19f8
00325e 19f9
00325f 19fa
003260 1a0e
003261 1a52                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
003262 1a95
003263 1aa2
003264 1ab6
003265 1ab7
003266 1ab8                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
003267 1ab9                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
003268 1c3b
003269 1c40
00326a 1c5c
00326b 1c78
00326c 1c9b                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
00326d 1ca6
00326e 1cb3
00326f 1cb6
003270 1cb9
003271 1cbc                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
003272 1cbf
003273 1cc7
003274 1cca
003275 1cd7
003276 1cd8                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
003277 1cd9
003278 1cda
003279 1cdb
00327a 1cef
00327b 1d33                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
00327c 1d76
00327d 1d83
00327e 1d97
00327f 1d98
003280 1d99                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
003281 1d9a                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
003282 1f18
003283 1f1d
003284 1f39
003285 1f55
003286 1f78                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
003287 1f83
003288 1f84
003289 1f85
00328a 1f88
00328b 1f8b                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
00328c 1f8e
00328d 1f9b
00328e 1f9e
00328f 1fab
003290 1fac                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
003291 1fad
003292 1fae
003293 1faf
003294 1fc3
003295 2007                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
003296 204a
003297 2057
003298 2058
003299 2059
00329a 205a                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
00329b 205b                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
00329c 21dd
00329d 21e2
00329e 21fe
00329f 221a
0032a0 223d                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
0032a1 2248
0032a2 2255
0032a3 2258
0032a4 225b
0032a5 225e                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
0032a6 2261
0032a7 2268
0032a8 226b
0032a9 2278
0032aa 2279                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
0032ab 227a
0032ac 227b
0032ad 227c
0032ae 2290
0032af 22d4                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
0032b0 2317
0032b1 2324
0032b2 232f
0032b3 2330
0032b4 2331                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
0032b5 2332                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0032b6 0000
0032b7 0000
0032b8 0000
0032b9 0000
0032ba 0000
0032bb 0000
0032bc 0000
0032bd 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0032be 0100
0032bf 0101
0032c0 0101
0032c1 0101
0032c2 0101
0032c3 0101
0032c4 0101
0032c5 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0032c6 0100
0032c7 0101
0032c8 0101
0032c9 0101
0032ca 0101
0032cb 0101
0032cc 0101
0032cd 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0032ce 0100
0032cf 0101
0032d0 0101
0032d1 0101
0032d2 0101
0032d3 0202
0032d4 0202
0032d5 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
0032d6 0100
0032d7 0101
0032d8 0101
0032d9 0101
0032da 0202
0032db 0202
0032dc 0303
0032dd 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
0032de 0100
0032df 0101
0032e0 0101
0032e1 0202
0032e2 0302
0032e3 0303
0032e4 0404
0032e5 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
0032e6 0100
0032e7 0101
0032e8 0201
0032e9 0202
0032ea 0303
0032eb 0404
0032ec 0504
0032ed 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
0032ee 0100
0032ef 0101
0032f0 0201
0032f1 0302
0032f2 0403
0032f3 0504
0032f4 0605
0032f5 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
0032f6 0100
0032f7 0101
0032f8 0202
0032f9 0303
0032fa 0404
0032fb 0505
0032fc 0606
0032fd 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
0032fe 0100
0032ff 0101
003300 0302
003301 0403
003302 0504
003303 0606
003304 0707
003305 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
003306 0100
003307 0201
003308 0302
003309 0404
00330a 0605
00330b 0706
00330c 0808
00330d 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
00330e 0100
00330f 0201
003310 0302
003311 0504
003312 0605
003313 0807
003314 0908
003315 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
003316 0100
003317 0201
003318 0403
003319 0504
00331a 0706
00331b 0808
00331c 0a09
00331d 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
00331e 0100
00331f 0201
003320 0403
003321 0605
003322 0706
003323 0908
003324 0b0a
003325 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
003326 0100
003327 0201
003328 0403
003329 0605
00332a 0807
00332b 0a09
00332c 0c0b
00332d 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
00332e 0100
00332f 0302
003330 0504
003331 0706
003332 0908
003333 0b0a
003334 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 248 r0 : 192 r1 : 200 r2 : 697 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 174 r23: 160 r24:   0 r25:  24 r26: 978 r27:1184 r28: 695 
r29: 376 r30: 378 r31: 337 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 148 add   : 194 adiw  : 106 and   :   0 
andi  :  95 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :  13 break :   0 breq  : 169 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  80 brlt  :   0 brmi  :   0 
brne  : 121 brpl  :   0 brsh  :  31 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   6 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 100 cpc   :   9 
cpi   : 168 cpse  :  20 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  48 
jmp   :  10 ld    :   0 ldd   :   0 ldi   : 285 lds   : 725 lpm   : 260 
lsl   :  79 lsr   : 171 mov   : 140 movw  :   0 mul   :  32 muls  :   0 
mulsu :   8 neg   :   0 nop   :   0 or    :  22 ori   :  12 out   :   9 
pop   : 115 push  : 109 rcall :  50 ret   :  32 reti  :   7 rjmp  : 514 
rol   :  53 ror   : 192 sbc   :  48 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  30 sbrs  :  15 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1398 sub   :  66 subi  :  52 swap  :  46 tst   :   0 wdr   :   0 

Instructions used: 52 out of 114 (45.6%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00666c  15846  10262  26108   49152  53.1%
[.dseg] 0x002800 0x00295a      0    346    346    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 103 warnings
