
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Thu May 20 18:03:31 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
002818                           noise_adjusted_note: .byte 1 //the resultant note index after the arpeggio macro
                                 
002819                           song_frames: .byte 2
00281b                           song_frame_offset: .byte 2
00281d                           song_size: .byte 2
00281f                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002820                           song_fx_Bxx: .byte 1
002821                           song_fx_Cxx: .byte 1
002822                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002823                           pulse1_pattern: .byte 2
002825                           pulse1_pattern_delay_rows: .byte 1
002826                           pulse1_pattern_delay_frames: .byte 1
002827                           pulse1_pattern_offset: .byte 2
                                 
002829                           pulse1_volume_macro: .byte 2
00282b                           pulse1_volume_macro_offset: .byte 1
00282c                           pulse1_volume_macro_loop: .byte 1
00282d                           pulse1_volume_macro_release: .byte 1
                                 
00282e                           pulse1_arpeggio_macro: .byte 2
002830                           pulse1_arpeggio_macro_offset: .byte 1
002831                           pulse1_arpeggio_macro_loop: .byte 1
002832                           pulse1_arpeggio_macro_release: .byte 1
002833                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002834                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002836                           pulse1_pitch_macro: .byte 2
002838                           pulse1_pitch_macro_offset: .byte 1
002839                           pulse1_pitch_macro_loop: .byte 1
00283a                           pulse1_pitch_macro_release: .byte 1
                                 
00283b                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283c                           pulse1_hi_pitch_macro: .byte 2
00283e                           pulse1_hi_pitch_macro_offset: .byte 1
00283f                           pulse1_hi_pitch_macro_loop: .byte 1
002840                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002841                           pulse1_duty_macro: .byte 2
002843                           pulse1_duty_macro_offset: .byte 1
002844                           pulse1_duty_macro_loop: .byte 1
002845                           pulse1_duty_macro_release: .byte 1
                                 
002846                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002848                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00284a                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284c                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284e                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002850                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002852                           pulse1_fx_3xx_target: .byte 2 //target note period
002854                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002856                           pulse1_fx_3xx_total_offset: .byte 2
002858                           pulse1_fx_4xy_speed: .byte 1
002859                           pulse1_fx_4xy_depth: .byte 1
00285a                           pulse1_fx_4xy_phase: .byte 1
00285b                           pulse1_fx_7xy_speed: .byte 1
00285c                           pulse1_fx_7xy_depth: .byte 1
00285d                           pulse1_fx_7xy_phase: .byte 1
00285e                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285f                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002860                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002861                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002862                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002864                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002865                           pulse1_fx_Qxy_target: .byte 2 //target note period
002867                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002869                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286b                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286c                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286e                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002870                           pulse1_fx_Rxy_total_offset: .byte 2
002872                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002873                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002874                           pulse2_pattern: .byte 2
002876                           pulse2_pattern_delay_rows: .byte 1
002877                           pulse2_pattern_delay_frames: .byte 1
002878                           pulse2_pattern_offset: .byte 2
                                 
00287a                           pulse2_volume_macro: .byte 2
00287c                           pulse2_volume_macro_offset: .byte 1
00287d                           pulse2_volume_macro_loop: .byte 1
00287e                           pulse2_volume_macro_release: .byte 1
                                 
00287f                           pulse2_arpeggio_macro: .byte 2
002881                           pulse2_arpeggio_macro_offset: .byte 1
002882                           pulse2_arpeggio_macro_loop: .byte 1
002883                           pulse2_arpeggio_macro_release: .byte 1
002884                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002885                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002887                           pulse2_pitch_macro: .byte 2
002889                           pulse2_pitch_macro_offset: .byte 1
00288a                           pulse2_pitch_macro_loop: .byte 1
00288b                           pulse2_pitch_macro_release: .byte 1
                                 
00288c                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288d                           pulse2_hi_pitch_macro: .byte 2
00288f                           pulse2_hi_pitch_macro_offset: .byte 1
002890                           pulse2_hi_pitch_macro_loop: .byte 1
002891                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002892                           pulse2_duty_macro: .byte 2
002894                           pulse2_duty_macro_offset: .byte 1
002895                           pulse2_duty_macro_loop: .byte 1
002896                           pulse2_duty_macro_release: .byte 1
                                 
002897                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002899                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289b                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289d                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289f                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a1                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a3                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a5                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a7                           pulse2_fx_3xx_total_offset: .byte 2
0028a9                           pulse2_fx_4xy_speed: .byte 1
0028aa                           pulse2_fx_4xy_depth: .byte 1
0028ab                           pulse2_fx_4xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_speed: .byte 1
0028ad                           pulse2_fx_7xy_depth: .byte 1
0028ae                           pulse2_fx_7xy_phase: .byte 1
0028af                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028b0                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b1                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b2                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b3                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b5                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b6                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b8                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028ba                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028bc                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bd                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028bf                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c1                           pulse2_fx_Rxy_total_offset: .byte 2
0028c3                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c4                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c5                           triangle_pattern: .byte 2
0028c7                           triangle_pattern_delay_rows: .byte 1
0028c8                           triangle_pattern_delay_frames: .byte 1
0028c9                           triangle_pattern_offset: .byte 2
                                 
0028cb                           triangle_volume_macro: .byte 2
0028cd                           triangle_volume_macro_offset: .byte 1
0028ce                           triangle_volume_macro_loop: .byte 1
0028cf                           triangle_volume_macro_release: .byte 1
                                 
0028d0                           triangle_arpeggio_macro: .byte 2
0028d2                           triangle_arpeggio_macro_offset: .byte 1
0028d3                           triangle_arpeggio_macro_loop: .byte 1
0028d4                           triangle_arpeggio_macro_release: .byte 1
0028d5                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d6                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d8                           triangle_pitch_macro: .byte 2
0028da                           triangle_pitch_macro_offset: .byte 1
0028db                           triangle_pitch_macro_loop: .byte 1
0028dc                           triangle_pitch_macro_release: .byte 1
                                 
0028dd                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028de                           triangle_hi_pitch_macro: .byte 2
0028e0                           triangle_hi_pitch_macro_offset: .byte 1
0028e1                           triangle_hi_pitch_macro_loop: .byte 1
0028e2                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e3                           triangle_duty_macro: .byte 2
0028e5                           triangle_duty_macro_offset: .byte 1
0028e6                           triangle_duty_macro_loop: .byte 1
0028e7                           triangle_duty_macro_release: .byte 1
                                 
0028e8                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028ea                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028ec                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028ee                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028f0                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f2                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f4                           triangle_fx_3xx_target: .byte 2 //target note period
0028f6                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f8                           triangle_fx_3xx_total_offset: .byte 2
0028fa                           triangle_fx_4xy_speed: .byte 1
0028fb                           triangle_fx_4xy_depth: .byte 1
0028fc                           triangle_fx_4xy_phase: .byte 1
0028fd                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028fe                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028ff                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002901                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002902                           triangle_fx_Qxy_target: .byte 2 //target note period
002904                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002908                           triangle_fx_Rxy_target_note: .byte 1 //target note index
002909                           triangle_fx_Rxy_target: .byte 2 //target note period
00290b                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290d                           triangle_fx_Rxy_total_offset: .byte 2
00290f                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002910                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002911                           noise_pattern: .byte 2
002913                           noise_pattern_delay_rows: .byte 1
002914                           noise_pattern_delay_frames: .byte 1
002915                           noise_pattern_offset: .byte 2
                                 
002917                           noise_volume_macro: .byte 2
002919                           noise_volume_macro_offset: .byte 1
00291a                           noise_volume_macro_loop: .byte 1
00291b                           noise_volume_macro_release: .byte 1
                                 
00291c                           noise_arpeggio_macro: .byte 2
00291e                           noise_arpeggio_macro_offset: .byte 1
00291f                           noise_arpeggio_macro_loop: .byte 1
002920                           noise_arpeggio_macro_release: .byte 1
002921                           noise_arpeggio_macro_mode: .byte 1
                                 
002922                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002924                           noise_pitch_macro: .byte 2
002926                           noise_pitch_macro_offset: .byte 1
002927                           noise_pitch_macro_loop: .byte 1
002928                           noise_pitch_macro_release: .byte 1
                                 
002929                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00292a                           noise_hi_pitch_macro: .byte 2
00292c                           noise_hi_pitch_macro_offset: .byte 1
00292d                           noise_hi_pitch_macro_loop: .byte 1
00292e                           noise_hi_pitch_macro_release: .byte 1
                                 
00292f                           noise_duty_macro: .byte 2
002931                           noise_duty_macro_offset: .byte 1
002932                           noise_duty_macro_loop: .byte 1
002933                           noise_duty_macro_release: .byte 1
                                 
002934                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002936                           noise_fx_1xx: .byte 1 //refers to the rate in which to subtract the pitch from by the 1xx
002937                           noise_fx_1xx_total: .byte 1 //the total pitch offset for 1xx
002938                           noise_fx_2xx: .byte 1 //refers to the rate in which to add to the pitch by the 2xx
002939                           noise_fx_2xx_total: .byte 1 //the total pitch offset for 2xx
00293a                           noise_fx_4xy_speed: .byte 1
00293b                           noise_fx_4xy_depth: .byte 1
00293c                           noise_fx_4xy_phase: .byte 1
00293d                           noise_fx_4xy_offset: .byte 1
00293e                           noise_fx_7xy_speed: .byte 1
00293f                           noise_fx_7xy_depth: .byte 1
002940                           noise_fx_7xy_phase: .byte 1
002941                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002942                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002943                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002944                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002945                           noise_fx_Pxx_total: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002946                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002947                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002948                           dpcm_pattern: .byte 2
00294a                           dpcm_pattern_delay_rows: .byte 1
00294b                           dpcm_pattern_delay_frames: .byte 1
00294c                           dpcm_pattern_offset: .byte 2
                                 
00294e                           dpcm_sample: .byte 2
002950                           dpcm_sample_offset: .byte 2
                                 
002952                           dpcm_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002953                           dpcm_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002954                           dpcm_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002955                           dpcm_fx_Sxx_post: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 //NOTE: same idea with one
                                 .def zero = r2
                                 .def one = r3
                                 .def frame_sequence = r4
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r7
                                 .def pulse1_length_counter = r8
                                 .def pulse1_sweep = r9 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r10
                                 .def pulse2_length_counter = r11
                                 .def pulse2_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 .def dpcm_shift = r13
                                 .def dpcm_bit_counter = r14
                                 .def dpcm_period = r15
                                 .def dpcm_length_LOW = r23
                                 .def dpcm_length_HIGH = r24
                                 
                                 
                                 reset:
000000 940c 1383                 	jmp init
                                 
                                 .org RTC_CNT_vect
000006 940c 1727                 	jmp frame_counter_routine
                                 
                                 .org TCB0_INT_vect
000018 940c 174f                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 179c                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 17e9                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 17f4                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(120): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(133): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(141): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(143): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(153): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(159): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(160): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(166): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(173): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(187): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(189): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(246): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(285): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(287): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(288): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(289): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(292): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(293): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(294): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(297): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(299): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(305): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(306): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(311): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(318): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(357): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
001383 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
001384 93c0 0034                 	sts CPU_CCP, r28
001386 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
001387 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001389 2422                      	clr zero
                                 	//ONE
00138a e0c1                      	ldi r28, 1
00138b 2e3c                      	mov one, r28
                                 	//FRAME SEQUENCE
00138c 2c42                      	mov frame_sequence, zero
                                 
                                 	//MEMORY
00138d e3c0                      	ldi r28, 0b00110000
00138e 93c0 2800                 	sts pulse1_param, r28
001390 e8c0                      	ldi r28, 0b10000000
001391 93c0 2801                 	sts pulse1_sweep_param, r28
001393 efcf                      	ldi r28, 0xFF
001394 93c0 2802                 	sts pulse1_timerL, r28
001396 93c0 2803                 	sts pulse1_timerH, r28
001398 93c0 2804                 	sts pulse1_length, r28
                                 
00139a e3c0                      	ldi r28, 0b00110000
00139b 93c0 2808                 	sts pulse2_param, r28
00139d e8c0                      	ldi r28, 0b10000000
00139e 93c0 2809                 	sts pulse2_sweep_param, r28
0013a0 efcf                      	ldi r28, 0xFF
0013a1 93c0 280a                 	sts pulse2_timerL, r28
0013a3 93c0 280b                 	sts pulse2_timerH, r28
0013a5 93c0 280c                 	sts pulse2_length, r28
                                 
0013a7 efcf                      	ldi r28, 0xFF
0013a8 93c0 2810                 	sts triangle_timerL, r28
0013aa 93c0 2811                 	sts triangle_timerH, r28
                                 
0013ac e3c0                      	ldi r28, 0b00110000
0013ad 93c0 2813                 	sts noise_param, r28
0013af e0cf                      	ldi r28, 0b00001111
0013b0 93c0 2814                 	sts noise_period, r28
                                 
0013b2 e0c2                      	ldi r28, 0x02
0013b3 93c0 281b                 	sts song_frame_offset, r28
0013b5 9220 281c                 	sts song_frame_offset+1, zero
0013b7 efcf                      	ldi r28, 0xFF
0013b8 93c0 2820                 	sts song_fx_Bxx, r28
0013ba 9220 2821                 	sts song_fx_Cxx, zero
0013bc 9220 2822                 	sts song_fx_Dxx, zero
0013be e4ee                      	ldi ZL, LOW(song0_frames << 1)
0013bf e0f3                      	ldi ZH, HIGH(song0_frames << 1)
0013c0 93e0 2819                 	sts song_frames, ZL
0013c2 93f0 281a                 	sts song_frames+1, ZH
0013c4 91c5                      	lpm r28, Z+ //load the song size
0013c5 91d5                      	lpm r29, Z+
0013c6 93c0 281d                 	sts song_size, r28
0013c8 93d0 281e                 	sts song_size+1, r29
0013ca 9220 281f                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0013cc 91c5                      	lpm r28, Z+
0013cd 91d5                      	lpm r29, Z+
0013ce 0fcc                      	lsl r28
0013cf 1fdd                      	rol r29
0013d0 93c0 2823                 	sts pulse1_pattern, r28
0013d2 93d0 2824                 	sts pulse1_pattern+1, r29
0013d4 9220 2825                 	sts pulse1_pattern_delay_rows, zero
0013d6 9220 2826                 	sts pulse1_pattern_delay_frames, zero
0013d8 9220 2827                 	sts pulse1_pattern_offset, zero
0013da 9220 2828                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0013dc 91c5                      	lpm r28, Z+
0013dd 91d5                      	lpm r29, Z+
0013de 0fcc                      	lsl r28
0013df 1fdd                      	rol r29
0013e0 93c0 2874                 	sts pulse2_pattern, r28
0013e2 93d0 2875                 	sts pulse2_pattern+1, r29
0013e4 9220 2876                 	sts pulse2_pattern_delay_rows, zero
0013e6 9220 2877                 	sts pulse2_pattern_delay_frames, zero
0013e8 9220 2878                 	sts pulse2_pattern_offset, zero
0013ea 9220 2879                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0013ec 91c5                      	lpm r28, Z+
0013ed 91d5                      	lpm r29, Z+
0013ee 0fcc                      	lsl r28
0013ef 1fdd                      	rol r29
0013f0 93c0 28c5                 	sts triangle_pattern, r28
0013f2 93d0 28c6                 	sts triangle_pattern+1, r29
0013f4 9220 28c7                 	sts triangle_pattern_delay_rows, zero
0013f6 9220 28c8                 	sts triangle_pattern_delay_frames, zero
0013f8 9220 28c9                 	sts triangle_pattern_offset, zero
0013fa 9220 28ca                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0013fc 91c5                      	lpm r28, Z+
0013fd 91d5                      	lpm r29, Z+
0013fe 0fcc                      	lsl r28
0013ff 1fdd                      	rol r29
001400 93c0 2911                 	sts noise_pattern, r28
001402 93d0 2912                 	sts noise_pattern+1, r29
001404 9220 2913                 	sts noise_pattern_delay_rows, zero
001406 9220 2914                 	sts noise_pattern_delay_frames, zero
001408 9220 2915                 	sts noise_pattern_offset, zero
00140a 9220 2916                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 4
00140c 91c5                      	lpm r28, Z+
00140d 91d5                      	lpm r29, Z+
00140e 0fcc                      	lsl r28
00140f 1fdd                      	rol r29
001410 93c0 2948                 	sts dpcm_pattern, r28
001412 93d0 2949                 	sts dpcm_pattern+1, r29
001414 9220 294a                 	sts dpcm_pattern_delay_rows, zero
001416 9220 294b                 	sts dpcm_pattern_delay_frames, zero
001418 9220 294c                 	sts dpcm_pattern_offset, zero
00141a 9220 294d                 	sts dpcm_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
00141c efcf                      	ldi r28, 0xFF
00141d 9220 282b                 	sts pulse1_volume_macro_offset, zero
00141f 93c0 282c                 	sts pulse1_volume_macro_loop, r28
001421 93c0 282d                 	sts pulse1_volume_macro_release, r28
001423 9220 2830                 	sts pulse1_arpeggio_macro_offset, zero
001425 93c0 2831                 	sts pulse1_arpeggio_macro_loop, r28
001427 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
001429 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
00142b 9220 2838                 	sts pulse1_pitch_macro_offset, zero
00142d 93c0 2839                 	sts pulse1_pitch_macro_loop, r28
00142f 93c0 283a                 	sts pulse1_pitch_macro_release, r28
001431 9220 283e                 	sts pulse1_hi_pitch_macro_offset, zero
001433 93c0 283f                 	sts pulse1_hi_pitch_macro_loop, r28
001435 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
001437 9220 2843                 	sts pulse1_duty_macro_offset, zero
001439 93c0 2844                 	sts pulse1_duty_macro_loop, r28
00143b 93c0 2845                 	sts pulse1_duty_macro_release, r28
                                 
00143d 9220 2829                 	sts pulse1_volume_macro, zero
00143f 9220 282a                 	sts pulse1_volume_macro+1, zero
001441 9220 282e                 	sts pulse1_arpeggio_macro, zero
001443 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
001445 9220 2834                 	sts pulse1_total_pitch_offset, zero
001447 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
001449 9220 2836                 	sts pulse1_pitch_macro, zero
00144b 9220 2837                 	sts pulse1_pitch_macro+1, zero
00144d 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
00144f 9220 283c                 	sts pulse1_hi_pitch_macro, zero
001451 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
001453 9220 2841                 	sts pulse1_duty_macro, zero
001455 9220 2842                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001457 e00f                      	ldi pulse1_volume_divider, 0x0F
001458 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00145a 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
00145b 9190 2800                 	lds pulse_channel_flags, pulse1_param
00145d 7390                      	andi pulse_channel_flags, 0b00110000
00145e 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
00145f 9220 2806                 	sts pulse1_output_volume, zero
001461 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001463 2e8c                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001464 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001465 2e7c                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001466 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param
001468 9492                      	swap pulse1_sweep //swap data from high byte and low byte
001469 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
00146a efcf                      	ldi r28, 0xFF
00146b 9220 2846                 	sts pulse1_fx_0xy_sequence, zero
00146d 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
00146f 9220 2848                 	sts pulse1_fx_1xx, zero
001471 9220 2849                 	sts pulse1_fx_1xx+1, zero
001473 9220 284a                 	sts pulse1_fx_1xx_total, zero
001475 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
001477 9220 284c                 	sts pulse1_fx_2xx, zero
001479 9220 284d                 	sts pulse1_fx_2xx+1, zero
00147b 9220 284e                 	sts pulse1_fx_2xx_total, zero
00147d 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
00147f 9220 2850                 	sts pulse1_fx_3xx_start, zero
001481 9220 2851                 	sts pulse1_fx_3xx_start+1, zero
001483 9220 2852                 	sts pulse1_fx_3xx_target, zero
001485 9220 2853                 	sts pulse1_fx_3xx_target+1, zero
001487 9220 2854                 	sts pulse1_fx_3xx_speed, zero
001489 9220 2855                 	sts pulse1_fx_3xx_speed+1, zero
00148b 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
00148d 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
00148f 9220 2858                 	sts pulse1_fx_4xy_speed, zero
001491 9220 2859                 	sts pulse1_fx_4xy_depth, zero
001493 9220 285a                 	sts pulse1_fx_4xy_phase, zero
001495 9220 285b                 	sts pulse1_fx_7xy_speed, zero
001497 9220 285c                 	sts pulse1_fx_7xy_depth, zero
001499 9220 285d                 	sts pulse1_fx_7xy_phase, zero
00149b 9220 285e                 	sts pulse1_fx_7xy_value, zero
00149d 9220 285f                 	sts pulse1_fx_Axy, zero
00149f 93c0 2860                 	sts pulse1_fx_Gxx_pre, r28
0014a1 93c0 2861                 	sts pulse1_fx_Gxx_post, r28
0014a3 9220 2862                 	sts pulse1_fx_Pxx_total, zero
0014a5 9220 2863                 	sts pulse1_fx_Pxx_total+1, zero
0014a7 9220 2864                 	sts pulse1_fx_Qxy_target_note, zero
0014a9 9220 2865                 	sts pulse1_fx_Qxy_target, zero
0014ab 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
0014ad 9220 2867                 	sts pulse1_fx_Qxy_speed, zero
0014af 9220 2868                 	sts pulse1_fx_Qxy_speed+1, zero
0014b1 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
0014b3 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
0014b5 9220 286b                 	sts pulse1_fx_Rxy_target_note, zero
0014b7 9220 286c                 	sts pulse1_fx_Rxy_target, zero
0014b9 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
0014bb 9220 286e                 	sts pulse1_fx_Rxy_speed, zero
0014bd 9220 286f                 	sts pulse1_fx_Rxy_speed+1, zero
0014bf 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
0014c1 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
0014c3 93c0 2872                 	sts pulse1_fx_Sxx_pre, r28
0014c5 93c0 2873                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
0014c7 efcf                      	ldi r28, 0xFF
0014c8 9220 287c                 	sts pulse2_volume_macro_offset, zero
0014ca 93c0 287d                 	sts pulse2_volume_macro_loop, r28
0014cc 93c0 287e                 	sts pulse2_volume_macro_release, r28
0014ce 9220 2881                 	sts pulse2_arpeggio_macro_offset, zero
0014d0 93c0 2882                 	sts pulse2_arpeggio_macro_loop, r28
0014d2 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
0014d4 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
0014d6 9220 2889                 	sts pulse2_pitch_macro_offset, zero
0014d8 93c0 288a                 	sts pulse2_pitch_macro_loop, r28
0014da 93c0 288b                 	sts pulse2_pitch_macro_release, r28
0014dc 9220 288f                 	sts pulse2_hi_pitch_macro_offset, zero
0014de 93c0 2890                 	sts pulse2_hi_pitch_macro_loop, r28
0014e0 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
0014e2 9220 2894                 	sts pulse2_duty_macro_offset, zero
0014e4 93c0 2895                 	sts pulse2_duty_macro_loop, r28
0014e6 93c0 2896                 	sts pulse2_duty_macro_release, r28
                                 
0014e8 9220 287a                 	sts pulse2_volume_macro, zero
0014ea 9220 287b                 	sts pulse2_volume_macro+1, zero
0014ec 9220 287f                 	sts pulse2_arpeggio_macro, zero
0014ee 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
0014f0 9220 2885                 	sts pulse2_total_pitch_offset, zero
0014f2 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
0014f4 9220 2887                 	sts pulse2_pitch_macro, zero
0014f6 9220 2888                 	sts pulse2_pitch_macro+1, zero
0014f8 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
0014fa 9220 288d                 	sts pulse2_hi_pitch_macro, zero
0014fc 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
0014fe 9220 2892                 	sts pulse2_duty_macro, zero
001500 9220 2893                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
001502 e02f                      	ldi pulse2_volume_divider, 0x0F
001503 9130 2808                 	lds pulse2_volume_decay, pulse2_param
001505 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
001506 91d0 2808                 	lds r29, pulse2_param
001508 73d0                      	andi r29, 0b00110000
001509 62d0                      	sbr r29, 0b0100000 //set start flag
00150a 95d2                      	swap r29
00150b 2b9d                      	or pulse_channel_flags, r29
00150c 9220 280e                 	sts pulse2_output_volume, zero
00150e 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
001510 2ebc                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
001511 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001512 2eac                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
001513 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param
001515 94c2                      	swap pulse2_sweep //swap data from high byte and low byte
001516 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001517 efcf                      	ldi r28, 0xFF
001518 9220 2897                 	sts pulse2_fx_0xy_sequence, zero
00151a 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
00151c 9220 2899                 	sts pulse2_fx_1xx, zero
00151e 9220 289a                 	sts pulse2_fx_1xx+1, zero
001520 9220 289b                 	sts pulse2_fx_1xx_total, zero
001522 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
001524 9220 289d                 	sts pulse2_fx_2xx, zero
001526 9220 289e                 	sts pulse2_fx_2xx+1, zero
001528 9220 289f                 	sts pulse2_fx_2xx_total, zero
00152a 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
00152c 9220 28a1                 	sts pulse2_fx_3xx_start, zero
00152e 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero
001530 9220 28a3                 	sts pulse2_fx_3xx_target, zero
001532 9220 28a4                 	sts pulse2_fx_3xx_target+1, zero
001534 9220 28a5                 	sts pulse2_fx_3xx_speed, zero
001536 9220 28a6                 	sts pulse2_fx_3xx_speed+1, zero
001538 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
00153a 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
00153c 9220 28a9                 	sts pulse2_fx_4xy_speed, zero
00153e 9220 28aa                 	sts pulse2_fx_4xy_depth, zero
001540 9220 28ab                 	sts pulse2_fx_4xy_phase, zero
001542 9220 28ac                 	sts pulse2_fx_7xy_speed, zero
001544 9220 28ad                 	sts pulse2_fx_7xy_depth, zero
001546 9220 28ae                 	sts pulse2_fx_7xy_phase, zero
001548 9220 28af                 	sts pulse2_fx_7xy_value, zero
00154a 9220 28b0                 	sts pulse2_fx_Axy, zero
00154c 93c0 28b1                 	sts pulse2_fx_Gxx_pre, r28
00154e 93c0 28b2                 	sts pulse2_fx_Gxx_post, r28
001550 9220 28b3                 	sts pulse2_fx_Pxx_total, zero
001552 9220 28b4                 	sts pulse2_fx_Pxx_total+1, zero
001554 9220 28b5                 	sts pulse2_fx_Qxy_target_note, zero
001556 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
001558 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
00155a 9220 28b8                 	sts pulse2_fx_Qxy_speed, zero
00155c 9220 28b9                 	sts pulse2_fx_Qxy_speed+1, zero
00155e 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
001560 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
001562 9220 28bc                 	sts pulse2_fx_Rxy_target_note, zero
001564 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001566 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001568 9220 28bf                 	sts pulse2_fx_Rxy_speed, zero
00156a 9220 28c0                 	sts pulse2_fx_Rxy_speed+1, zero
00156c 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
00156e 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
001570 93c0 28c3                 	sts pulse2_fx_Sxx_pre, r28
001572 93c0 28c4                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001574 efcf                      	ldi r28, 0xFF
001575 9220 28cd                 	sts triangle_volume_macro_offset, zero
001577 93c0 28ce                 	sts triangle_volume_macro_loop, r28
001579 93c0 28cf                 	sts triangle_volume_macro_release, r28
00157b 9220 28d2                 	sts triangle_arpeggio_macro_offset, zero
00157d 93c0 28d3                 	sts triangle_arpeggio_macro_loop, r28
00157f 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
001581 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
001583 9220 28da                 	sts triangle_pitch_macro_offset, zero
001585 93c0 28db                 	sts triangle_pitch_macro_loop, r28
001587 93c0 28dc                 	sts triangle_pitch_macro_release, r28
001589 9220 28e0                 	sts triangle_hi_pitch_macro_offset, zero
00158b 93c0 28e1                 	sts triangle_hi_pitch_macro_loop, r28
00158d 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
00158f 9220 28e5                 	sts triangle_duty_macro_offset, zero
001591 93c0 28e6                 	sts triangle_duty_macro_loop, r28
001593 93c0 28e7                 	sts triangle_duty_macro_release, r28
                                 
001595 9220 28cb                 	sts triangle_volume_macro, zero
001597 9220 28cc                 	sts triangle_volume_macro+1, zero
001599 9220 28d0                 	sts triangle_arpeggio_macro, zero
00159b 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
00159d 9220 28d6                 	sts triangle_total_pitch_offset, zero
00159f 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
0015a1 9220 28d8                 	sts triangle_pitch_macro, zero
0015a3 9220 28d9                 	sts triangle_pitch_macro+1, zero
0015a5 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
0015a7 9220 28de                 	sts triangle_hi_pitch_macro, zero
0015a9 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
0015ab 9220 28e3                 	sts triangle_duty_macro, zero
0015ad 9220 28e4                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
0015af e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
0015b0 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
0015b1 efcf                      	ldi r28, 0xFF
0015b2 9220 28e8                 	sts triangle_fx_0xy_sequence, zero
0015b4 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
0015b6 9220 28ea                 	sts triangle_fx_1xx, zero
0015b8 9220 28eb                 	sts triangle_fx_1xx+1, zero
0015ba 9220 28ec                 	sts triangle_fx_1xx_total, zero
0015bc 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
0015be 9220 28ee                 	sts triangle_fx_2xx, zero
0015c0 9220 28ef                 	sts triangle_fx_2xx+1, zero
0015c2 9220 28f0                 	sts triangle_fx_2xx_total, zero
0015c4 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
0015c6 9220 28f2                 	sts triangle_fx_3xx_start, zero
0015c8 9220 28f3                 	sts triangle_fx_3xx_start+1, zero
0015ca 9220 28f4                 	sts triangle_fx_3xx_target, zero
0015cc 9220 28f5                 	sts triangle_fx_3xx_target+1, zero
0015ce 9220 28f6                 	sts triangle_fx_3xx_speed, zero
0015d0 9220 28f7                 	sts triangle_fx_3xx_speed+1, zero
0015d2 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
0015d4 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
0015d6 9220 28fa                 	sts triangle_fx_4xy_speed, zero
0015d8 9220 28fb                 	sts triangle_fx_4xy_depth, zero
0015da 9220 28fc                 	sts triangle_fx_4xy_phase, zero
0015dc 93c0 28fd                 	sts triangle_fx_Gxx_pre, r28
0015de 93c0 28fe                 	sts triangle_fx_Gxx_post, r28
0015e0 9220 28ff                 	sts triangle_fx_Pxx_total, zero
0015e2 9220 2900                 	sts triangle_fx_Pxx_total+1, zero
0015e4 9220 2901                 	sts triangle_fx_Qxy_target_note, zero
0015e6 9220 2902                 	sts triangle_fx_Qxy_target, zero
0015e8 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
0015ea 9220 2904                 	sts triangle_fx_Qxy_speed, zero
0015ec 9220 2905                 	sts triangle_fx_Qxy_speed+1, zero
0015ee 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
0015f0 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
0015f2 9220 2908                 	sts triangle_fx_Rxy_target_note, zero
0015f4 9220 2909                 	sts triangle_fx_Rxy_target, zero
0015f6 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
0015f8 9220 290b                 	sts triangle_fx_Rxy_speed, zero
0015fa 9220 290c                 	sts triangle_fx_Rxy_speed+1, zero
0015fc 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
0015fe 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
001600 93c0 290f                 	sts triangle_fx_Sxx_pre, r28
001602 93c0 2910                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
001604 efcf                      	ldi r28, 0xFF
001605 9220 2919                 	sts noise_volume_macro_offset, zero
001607 93c0 291a                 	sts noise_volume_macro_loop, r28
001609 93c0 291b                 	sts noise_volume_macro_release, r28
00160b 9220 291e                 	sts noise_arpeggio_macro_offset, zero
00160d 93c0 291f                 	sts noise_arpeggio_macro_loop, r28
00160f 93c0 2920                 	sts noise_arpeggio_macro_release, r28
001611 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
001613 9220 2926                 	sts noise_pitch_macro_offset, zero
001615 93c0 2927                 	sts noise_pitch_macro_loop, r28
001617 93c0 2928                 	sts noise_pitch_macro_release, r28
001619 9220 292c                 	sts noise_hi_pitch_macro_offset, zero
00161b 93c0 292d                 	sts noise_hi_pitch_macro_loop, r28
00161d 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
00161f 9220 2931                 	sts noise_duty_macro_offset, zero
001621 93c0 2932                 	sts noise_duty_macro_loop, r28
001623 93c0 2933                 	sts noise_duty_macro_release, r28
                                 
001625 9220 2917                 	sts noise_volume_macro, zero
001627 9220 2918                 	sts noise_volume_macro+1, zero
001629 9220 291c                 	sts noise_arpeggio_macro, zero
00162b 9220 291d                 	sts noise_arpeggio_macro+1, zero
00162d 9220 2922                 	sts noise_total_pitch_offset, zero
00162f 9220 2923                 	sts noise_total_pitch_offset+1, zero
001631 9220 2924                 	sts noise_pitch_macro, zero
001633 9220 2925                 	sts noise_pitch_macro+1, zero
001635 9220 2929                 	sts noise_total_hi_pitch_offset, zero
001637 9220 292a                 	sts noise_hi_pitch_macro, zero
001639 9220 292b                 	sts noise_hi_pitch_macro+1, zero
00163b 9220 292f                 	sts noise_duty_macro, zero
00163d 9220 2930                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
00163f 9220 2816                 	sts noise_output_volume, zero
001641 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001643 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001644 2f5c                      	mov noise_sequence_LOW, r28
001645 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
001646 efcf                      	ldi r28, 0xFF
001647 9220 2934                 	sts noise_fx_0xy_sequence, zero
001649 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
00164b 9220 2936                 	sts noise_fx_1xx, zero
00164d 9220 2937                 	sts noise_fx_1xx_total, zero
00164f 9220 2938                 	sts noise_fx_2xx, zero
001651 9220 2939                 	sts noise_fx_2xx_total, zero
001653 9220 293a                 	sts noise_fx_4xy_speed, zero
001655 9220 293b                 	sts noise_fx_4xy_depth, zero
001657 9220 293c                 	sts noise_fx_4xy_phase, zero
001659 9220 293d                 	sts noise_fx_4xy_offset, zero
00165b 9220 293e                 	sts noise_fx_7xy_speed, zero
00165d 9220 293f                 	sts noise_fx_7xy_depth, zero
00165f 9220 2940                 	sts noise_fx_7xy_phase, zero
001661 9220 2941                 	sts noise_fx_7xy_value, zero
001663 9220 2942                 	sts noise_fx_Axy, zero
001665 93c0 2943                 	sts noise_fx_Gxx_pre, r28
001667 93c0 2944                 	sts noise_fx_Gxx_post, r28
001669 9220 2945                 	sts noise_fx_Pxx_total, zero
00166b 93c0 2946                 	sts noise_fx_Sxx_pre, r28
00166d 93c0 2947                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 4 SAMPLE
00166f 9220 294e                 	sts dpcm_sample, zero
001671 9220 294f                 	sts dpcm_sample+1, zero
001673 9220 2950                 	sts dpcm_sample_offset, zero
001675 9220 2951                 	sts dpcm_sample_offset+1, zero
001677 2cd2                      	mov dpcm_shift, zero
001678 2ce2                      	mov dpcm_bit_counter, zero
001679 2cf2                      	mov dpcm_period, zero
00167a 2d72                      	mov dpcm_length_LOW, zero
00167b 2d82                      	mov dpcm_length_HIGH, zero
                                 
                                 	//CHANNEL 4 FX
00167c 93c0 2943                 	sts noise_fx_Gxx_pre, r28
00167e 93c0 2944                 	sts noise_fx_Gxx_post, r28
001680 93c0 2946                 	sts noise_fx_Sxx_pre, r28
001682 93c0 2947                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
001684 efcf                      	ldi r28, 0xFF
001685 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
001686 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
001687 93c0 0a81                 	sts TCB0_CTRLB, r28
001689 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
00168a 93c0 0a85                 	sts TCB0_INTCTRL, r28
00168c 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
00168e 93c0 0a8c                 	sts TCB0_CCMPL, r28
001690 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001692 93c0 0a8d                 	sts TCB0_CCMPH, r28
001694 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001695 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001697 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001698 93b0 0a91                 	sts TCB1_CTRLB, r27
00169a e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00169b 93b0 0a95                 	sts TCB1_INTCTRL, r27
00169d 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00169f 93b0 0a9c                 	sts TCB1_CCMPL, r27
0016a1 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0016a3 93b0 0a9d                 	sts TCB1_CCMPH, r27
0016a5 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0016a6 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
0016a8 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0016a9 93b0 0aa1                 	sts TCB2_CTRLB, r27
0016ab e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
0016ac 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
0016ae 93b0 0aac                 	sts TCB2_CCMPL, r27
0016b0 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
0016b2 93b0 0aad                 	sts TCB2_CCMPH, r27
0016b4 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
0016b5 93b0 0aa0                 	sts TCB2_CTRLA, r27
0016b7 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
0016b8 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0016b9 93b0 0ab1                 	sts TCB3_CTRLB, r27
0016bb e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0016bc 93b0 0ab5                 	sts TCB3_INTCTRL, r27
0016be 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0016c0 93b0 0abc                 	sts TCB3_CCMPL, r27
0016c2 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0016c4 93b0 0abd                 	sts TCB3_CCMPH, r27
0016c6 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0016c7 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 	//DPCM
                                 /*	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
                                 	sts TCA0_SINGLE_CTRLB, r28
                                 	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
                                 	sts TCA0_SINGLE_INTCTRL, r28
                                 	ldi r28, 0x15 //set the period for CMP0
                                 	sts TCA0_SINGLE_CMP0, r28
                                 	ldi r28, 0x05
                                 	sts TCA0_SINGLE_CMP0 + 1, r28
                                 	ldi r28, 0x2B //set the period for CMP1
                                 	sts TCA0_SINGLE_CMP1, r28
                                 	ldi r28, 0x0A
                                 	sts TCA0_SINGLE_CMP1 + 1, r28
                                 	ldi r28, 0x41 //set the period for CMP2
                                 	sts TCA0_SINGLE_CMP2, r28
                                 	ldi r28, 0x0F
                                 	sts TCA0_SINGLE_CMP2 + 1, r28
                                 	ldi r28, 0x57 //set the period for OVF
                                 	sts TCA0_SINGLE_PER, r28
                                 	ldi r28, 0x14
                                 	sts TCA0_SINGLE_PER + 1, r28
                                 	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
                                 	sts TCA0_SINGLE_CTRLA, r28*/
                                 
                                 	//RTC
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Interrupts will be setup to interrupt every 240 Hz clock
                                 	//The 4th consecutive interrupt will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//1st and 2nd interrupt will execute sequence 0 and 2. 3rd and 4th interrupt will execute sequence 1 and 3.
                                 	//Timer period Calculation: (0.00416666666 * 32768/8)-1 = 16.0666666394 = 0x0010
                                 	//The RTC timer is clocked at 32768 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /8 comes from the prescaler divider used
0016c9 e0b0                      	ldi r27, RTC_CLKSEL_INT32K_gc //internal 32kHz oscillator
0016ca 93b0 0147                 	sts RTC_CLKSEL, r27
0016cc e1b0                      	ldi r27, 0x10
0016cd e0c0                      	ldi r28, 0x00
0016ce 93b0 014a                 	sts RTC_PER, r27
0016d0 93c0 014b                 	sts RTC_PER + 1, r28
0016d2 e0b1                      	ldi r27, RTC_OVF_bm //overflow interrupts
0016d3 93b0 0142                 	sts RTC_INTCTRL, r27
0016d5 e1b9                      	ldi r27, RTC_PRESCALER_DIV8_gc | RTC_PITEN_bm //use prescaler divider of 2 and enable RTC
0016d6 93b0 0140                 	sts RTC_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0016d8 91c0 2806                 	lds r28, pulse1_output_volume
0016da 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0016dc fe70                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0016dd c015                      	rjmp volume_mixer_pulse1_off
                                 
0016de 1482                      	cp pulse1_length_counter, zero //if length is zero, return
0016df f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0016e0 91e0 0a8c                 	lds r30, TCB0_CCMPL
0016e2 e5f9                      	ldi r31, 0x59
0016e3 17ef                      	cp r30, r31
0016e4 91e0 0a8d                 	lds r30, TCB0_CCMPH
0016e6 e0f0                      	ldi r31, 0x00
0016e7 07ef                      	cpc r30, r31
0016e8 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $595A
0016e9 91e0 0a8c                 	lds r30, TCB0_CCMPL
0016eb e5fa                      	ldi r31, 0x5A
0016ec 17ef                      	cp r30, r31
0016ed 91e0 0a8d                 	lds r30, TCB0_CCMPH
0016ef e5f9                      	ldi r31, 0x59
0016f0 07ef                      	cpc r30, r31
0016f1 f408                      	brsh volume_mixer_pulse1_off
0016f2 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0016f3 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0016f4 fea0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0016f5 c015                      	rjmp volume_mixer_pulse2_off
                                 
0016f6 14b2                      	cp pulse2_length_counter, zero //if length is zero, return
0016f7 f099                      	breq volume_mixer_pulse2_off
                                 
0016f8 91e0 0a9c                 	lds r30, TCB1_CCMPL
0016fa e5f9                      	ldi r31, 0x59
0016fb 17ef                      	cp r30, r31
0016fc 91e0 0a9d                 	lds r30, TCB1_CCMPH
0016fe e0f0                      	ldi r31, 0x00
0016ff 07ef                      	cpc r30, r31
001700 f050                      	brlo volume_mixer_pulse2_off
                                 
001701 91e0 0a9c                 	lds r30, TCB1_CCMPL
001703 e5fa                      	ldi r31, 0x5A
001704 17ef                      	cp r30, r31
001705 91e0 0a9d                 	lds r30, TCB1_CCMPH
001707 e5f9                      	ldi r31, 0x59
001708 07ef                      	cpc r30, r31
001709 f408                      	brsh volume_mixer_pulse2_off
00170a c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
00170b 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
00170c 0fcd                      	add r28, r29
00170d e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
00170e e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
00170f 0fec                      	add ZL, r28
001710 1df2                      	adc ZH, zero
001711 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001712 2fd4                      	mov r29, triangle_sequence
001713 fdd4                      	sbrc r29, 4 //check 5th bit
001714 95d0                      	com r29
001715 70df                      	andi r29, 0x0F
001716 2fed                      	mov r30, r29
001717 0fde                      	add r29, r30 //multiply the triangle volume by 3
001718 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
001719 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
00171a c004                      	rjmp volume_mixer_tnd_out
00171b 91e0 2816                 	lds r30, noise_output_volume
00171d 0fee                      	lsl r30 //multiply noise volume by 2
00171e 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
00171f e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
001720 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
001721 0fed                      	add ZL, r29
001722 1df2                      	adc ZH, zero
001723 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001724 0fcd                      	add r28, r29
001725 b9c1                      	out VPORTA_OUT, r28
001726 cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 frame_counter_routine:
001727 b7bf                      	in r27, CPU_SREG
001728 93bf                      	push r27
001729 94f8                      	cli
                                 
00172a 2da4                      	mov r26, frame_sequence
00172b 0c43                      	add frame_sequence, one
00172c 30a0                      	cpi r26, 0x00
00172d f029                      	breq sequence_0_2
00172e 30a1                      	cpi r26, 0x01
00172f f059                      	breq sequence_1_3
001730 30a2                      	cpi r26, 0x02
001731 f009                      	breq sequence_0_2
001732 c0f3                      	rjmp sound_driver
                                 
                                 sequence_0_2:
                                 	//ENVELOPE
001733 d050                      	rcall pulse1_envelope_routine
001734 d09c                      	rcall pulse2_envelope_routine
                                 
001735 e0b3                      	ldi r27, RTC_CMP_bm | RTC_OVF_bm //clear OVF flag
001736 93b0 0143                 	sts RTC_INTFLAGS, r27
001738 91bf                      	pop r27
001739 bfbf                      	out CPU_SREG, r27
00173a 9518                      	reti
                                 
                                 sequence_1_3:
                                 	//ENVELOPE
00173b d048                      	rcall pulse1_envelope_routine
00173c d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
00173d fc93                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
00173e d01b                      	rcall pulse1_sweep_routine
00173f fcc3                      	sbrc pulse2_sweep, 3
001740 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001741 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001742 c002                      	rjmp sequence_1_3_pulse2_length
001743 1082                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001744 948a                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001745 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001746 c002                      	rjmp sequence_1_3_exit
001747 10b2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001748 94ba                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001749 e0b1                      	ldi r27, RTC_OVF_bm //clear OVF flag
00174a 93b0 0143                 	sts RTC_INTFLAGS, r27
00174c 91bf                      	pop r27
00174d bfbf                      	out CPU_SREG, r27
00174e 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
00174f b7bf                      	in r27, CPU_SREG
001750 93bf                      	push r27
001751 94f8                      	cli
                                 
001752 0c77                      	lsl pulse1_sequence //shifts sequence to the left
001753 1c72                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001754 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001755 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001757 91bf                      	pop r27
001758 bfbf                      	out CPU_SREG, r27
001759 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00175a 2db9                      	mov r27, pulse1_sweep
00175b 70b7                      	andi r27, 0x07 //mask for period divider bits
00175c f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00175d 93df                      	push r29
00175e 2dd9                      	mov r29, pulse1_sweep
00175f 95d2                      	swap r29
001760 70d7                      	andi r29, 0x07 //mask for shift bits
001761 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001762 91df                      	pop r29
001763 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001764 91a0 0a8c                 	lds r26, TCB0_CCMPL
001766 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001768 95b6                      	lsr r27
001769 95a7                      	ror r26
00176a 95da                      	dec r29
00176b f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00176c fe97                      	sbrs pulse1_sweep, 7 //check the negate flag
00176d c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
00176e 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
00176f 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001770 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001772 0fad                      	add r26, r29
001773 91d0 0a8d                 	lds r29, TCB0_CCMPH
001775 1fbd                      	adc r27, r29
                                 
001776 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001778 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00177a 91df                      	pop r29
00177b c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
00177c 949a                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
00177d ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
00177e 9508                      	ret
                                 
                                 pulse1_sweep_reload:
00177f 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001781 9492                      	swap pulse1_sweep //bring data from high byte to low byte
001782 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
001783 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001784 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
001785 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001786 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001787 f011                      	breq PC+3 //if the divider == 0, check loop flag
001788 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001789 9508                      	ret
                                 
00178a 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
00178c 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00178d ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
00178e c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
00178f e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001790 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001791 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001792 f409                      	brne PC+2 //if decay != 0, go decrement
001793 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001794 951a                      	dec pulse1_volume_decay
001795 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001796 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
001797 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001799 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00179a e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
00179b 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
00179c b7bf                      	in r27, CPU_SREG
00179d 93bf                      	push r27
00179e 94f8                      	cli
                                 
00179f 0caa                      	lsl pulse2_sequence //shifts sequence to the left
0017a0 1ca2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0017a1 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0017a2 93b0 0a96                 	sts TCB1_INTFLAGS, r27
0017a4 91bf                      	pop r27
0017a5 bfbf                      	out CPU_SREG, r27
0017a6 9518                      	reti
                                 
                                 pulse2_sweep_routine:
0017a7 2dbc                      	mov r27, pulse2_sweep
0017a8 70b7                      	andi r27, 0x07 //mask for period divider bits
0017a9 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0017aa 93df                      	push r29
0017ab 2ddc                      	mov r29, pulse2_sweep
0017ac 95d2                      	swap r29
0017ad 70d7                      	andi r29, 0x07 //mask for shift bits
0017ae f411                      	brne pulse2_sweep_routine_action_main //shift != 0
0017af 91df                      	pop r29
0017b0 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
0017b1 91a0 0a9c                 	lds r26, TCB1_CCMPL
0017b3 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
0017b5 95b6                      	lsr r27
0017b6 95a7                      	ror r26
0017b7 95da                      	dec r29
0017b8 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0017b9 fec7                      	sbrs pulse2_sweep, 7 //check the negate flag
0017ba c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0017bb 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
0017bc 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
0017bd 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
0017bf 0fad                      	add r26, r29
0017c0 91d0 0a9d                 	lds r29, TCB1_CCMPH
0017c2 1fbd                      	adc r27, r29
                                 
0017c3 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
0017c5 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0017c7 91df                      	pop r29
0017c8 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
0017c9 94ca                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
0017ca ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0017cb 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0017cc 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0017ce 94c2                      	swap pulse2_sweep //bring data from high byte to low byte
0017cf 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0017d0 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0017d1 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0017d2 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0017d3 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0017d4 f011                      	breq PC+3 //if the divider == 0, check loop flag
0017d5 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0017d6 9508                      	ret
                                 
0017d7 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0017d9 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0017da ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
0017db c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0017dc e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0017dd 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0017de 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0017df f409                      	brne PC+2 //if decay != 0, go decrement
0017e0 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0017e1 953a                      	dec pulse2_volume_decay
0017e2 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0017e3 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
0017e4 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0017e6 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0017e7 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0017e8 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0017e9 b7bf                      	in r27, CPU_SREG
0017ea 93bf                      	push r27
0017eb 94f8                      	cli
                                 
0017ec 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0017ed 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0017ee e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0017ef 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0017f1 91bf                      	pop r27
0017f2 bfbf                      	out CPU_SREG, r27
0017f3 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0017f4 b7bf                      	in r27, CPU_SREG
0017f5 93bf                      	push r27
0017f6 94f8                      	cli
                                 
0017f7 2fa5                      	mov r26, noise_sequence_LOW
0017f8 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0017f9 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0017fa 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0017fb 27a5                      	eor r26, noise_sequence_LOW
0017fc fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0017fd c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0017fe 9566                      	lsr noise_sequence_HIGH
0017ff 9557                      	ror noise_sequence_LOW
001800 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
001801 9566                      	lsr noise_sequence_HIGH
001802 9557                      	ror noise_sequence_LOW
001803 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
001804 c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
001805 0faa                      	lsl r26
001806 1faa                      	rol r26
001807 1faa                      	rol r26 //move the 6th bit to the 0th bit place
001808 27a5                      	eor r26, noise_sequence_LOW
001809 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
00180a c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
00180b 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
00180c 9566                      	lsr noise_sequence_HIGH
00180d 9557                      	ror noise_sequence_LOW
00180e 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
00180f c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
001810 9566                      	lsr noise_sequence_HIGH
001811 9557                      	ror noise_sequence_LOW
001812 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
001813 c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
001814 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001815 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
001817 91bf                      	pop r27
001818 bfbf                      	out CPU_SREG, r27
001819 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
00181a ede2                      	ldi ZL, LOW(length << 1)
00181b e6f2                      	ldi ZH, HIGH(length << 1)
00181c 0fed                      	add ZL, r29
00181d 1df2                      	adc ZH, zero
00181e 91d4                      	lpm r29, Z
00181f 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001820 efe2                      	ldi ZL, LOW(sequences << 1)
001821 e6f2                      	ldi ZH, HIGH(sequences << 1)
001822 0fed                      	add ZL, r29
001823 1df2                      	adc ZH, zero
001824 91d4                      	lpm r29, Z
001825 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
001826 2c42                      	mov frame_sequence, zero
001827 93cf                      	push r28
001828 93df                      	push r29
001829 93ef                      	push r30
00182a 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
00182b 91a0 2820                 	lds r26, song_fx_Bxx
00182d 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
00182e f4a9                      	brne sound_driver_fx_Bxx_routine
00182f 91a0 2821                 	lds r26, song_fx_Cxx
001831 11a2                      	cpse r26, zero
001832 c08b                      	rjmp sound_driver_fx_Cxx_routine
001833 91a0 2822                 	lds r26, song_fx_Dxx
001835 11a2                      	cpse r26, zero
001836 c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
001837 91a0 281b                 	lds r26, song_frame_offset
001839 91b0 281c                 	lds r27, song_frame_offset+1
00183b 91c0 281d                 	lds r28, song_size
00183d 91d0 281e                 	lds r29, song_size+1
00183f 17ac                      	cp r26, r28
001840 07bd                      	cpc r27, r29
001841 f408                      	brsh sound_driver_fx_song_loop
001842 c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
001843 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001844 91e0 2819                 	lds ZL, song_frames
001846 91f0 281a                 	lds ZH, song_frames+1
001848 27cc                      	clr r28 //initialize r29:r28 to 0
001849 27dd                      	clr r29
00184a 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
00184b 95aa                      	dec r26
00184c f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
00184d 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
00184e cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
00184f 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
001850 93c0 281b                 	sts song_frame_offset, r28
001852 93d0 281c                 	sts song_frame_offset+1, r29
001854 0fec                      	add ZL, r28
001855 1ffd                      	adc ZH, r29
                                 
001856 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
001857 91b5                      	lpm r27, Z+
001858 0faa                      	lsl r26
001859 1fbb                      	rol r27
00185a 93a0 2823                 	sts pulse1_pattern, r26
00185c 93b0 2824                 	sts pulse1_pattern+1, r27
00185e 91a5                      	lpm r26, Z+
00185f 91b5                      	lpm r27, Z+
001860 0faa                      	lsl r26
001861 1fbb                      	rol r27
001862 93a0 2874                 	sts pulse2_pattern, r26
001864 93b0 2875                 	sts pulse2_pattern+1, r27
001866 91a5                      	lpm r26, Z+
001867 91b5                      	lpm r27, Z+
001868 0faa                      	lsl r26
001869 1fbb                      	rol r27
00186a 93a0 28c5                 	sts triangle_pattern, r26
00186c 93b0 28c6                 	sts triangle_pattern+1, r27
00186e 91a5                      	lpm r26, Z+
00186f 91b5                      	lpm r27, Z+
001870 0faa                      	lsl r26
001871 1fbb                      	rol r27
001872 93a0 2911                 	sts noise_pattern, r26
001874 93b0 2912                 	sts noise_pattern+1, r27
                                 
001876 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001878 9220 2828                 	sts pulse1_pattern_offset+1, zero
00187a 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00187c 9220 2826                 	sts pulse1_pattern_delay_frames, zero
00187e 9220 2878                 	sts pulse2_pattern_offset, zero
001880 9220 2879                 	sts pulse2_pattern_offset+1, zero
001882 9220 2876                 	sts pulse2_pattern_delay_rows, zero
001884 9220 2877                 	sts pulse2_pattern_delay_frames, zero
001886 9220 28c9                 	sts triangle_pattern_offset, zero
001888 9220 28ca                 	sts triangle_pattern_offset+1, zero
00188a 9220 28c7                 	sts triangle_pattern_delay_rows, zero
00188c 9220 28c8                 	sts triangle_pattern_delay_frames, zero
00188e 9220 2915                 	sts noise_pattern_offset, zero
001890 9220 2916                 	sts noise_pattern_offset+1, zero
001892 9220 2913                 	sts noise_pattern_delay_rows, zero
001894 9220 2914                 	sts noise_pattern_delay_frames, zero
                                 
001896 efaf                      	ldi r26, 0xFF
001897 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001899 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
00189b 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
00189d 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
00189f 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
0018a1 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
0018a3 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
0018a5 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
0018a7 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
0018a9 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
0018ab 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
0018ad 93a0 2910                 	sts triangle_fx_Sxx_post, r26
0018af 93a0 2943                 	sts noise_fx_Gxx_pre, r26
0018b1 93a0 2944                 	sts noise_fx_Gxx_post, r26
0018b3 93a0 2946                 	sts noise_fx_Sxx_pre, r26
0018b5 93a0 2947                 	sts noise_fx_Sxx_post, r26
                                 
0018b7 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
0018b9 9220 2821                 	sts song_fx_Cxx, zero
0018bb 9220 2822                 	sts song_fx_Dxx, zero
0018bd c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0018be 91ff                      	pop r31
0018bf 91ef                      	pop r30
0018c0 91df                      	pop r29
0018c1 91cf                      	pop r28
0018c2 91bf                      	pop r27
0018c3 bfbf                      	out CPU_SREG, r27
0018c4 94f8                      	cli //disable global interrupts
                                 		
0018c5 efaf                      	ldi r26, 0xFF
0018c6 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
0018c8 9220 2821                 	sts song_fx_Cxx, zero
0018ca 9220 2822                 	sts song_fx_Dxx, zero
0018cc 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0018cd 91e0 2819                 	lds ZL, song_frames
0018cf 91f0 281a                 	lds ZH, song_frames+1
0018d1 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0018d3 91b0 281c                 	lds r27, song_frame_offset+1
0018d5 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0018d6 93a0 281b                 	sts song_frame_offset, r26
0018d8 93b0 281c                 	sts song_frame_offset+1, r27
0018da 0fea                      	add ZL, r26
0018db 1ffb                      	adc ZH, r27
                                 
0018dc 91a5                      	lpm r26, Z+ //load the address of the next pattern
0018dd 91b5                      	lpm r27, Z+
0018de 0faa                      	lsl r26
0018df 1fbb                      	rol r27
0018e0 93a0 2823                 	sts pulse1_pattern, r26
0018e2 93b0 2824                 	sts pulse1_pattern+1, r27
0018e4 91a5                      	lpm r26, Z+
0018e5 91b5                      	lpm r27, Z+
0018e6 0faa                      	lsl r26
0018e7 1fbb                      	rol r27
0018e8 93a0 2874                 	sts pulse2_pattern, r26
0018ea 93b0 2875                 	sts pulse2_pattern+1, r27
0018ec 91a5                      	lpm r26, Z+
0018ed 91b5                      	lpm r27, Z+
0018ee 0faa                      	lsl r26
0018ef 1fbb                      	rol r27
0018f0 93a0 28c5                 	sts triangle_pattern, r26
0018f2 93b0 28c6                 	sts triangle_pattern+1, r27
0018f4 91a5                      	lpm r26, Z+
0018f5 91b5                      	lpm r27, Z+
0018f6 0faa                      	lsl r26
0018f7 1fbb                      	rol r27
0018f8 93a0 2911                 	sts noise_pattern, r26
0018fa 93b0 2912                 	sts noise_pattern+1, r27
                                 
0018fc 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0018fe 9220 2828                 	sts pulse1_pattern_offset+1, zero
001900 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001902 9220 2826                 	sts pulse1_pattern_delay_frames, zero
001904 9220 2878                 	sts pulse2_pattern_offset, zero
001906 9220 2879                 	sts pulse2_pattern_offset+1, zero
001908 9220 2876                 	sts pulse2_pattern_delay_rows, zero
00190a 9220 2877                 	sts pulse2_pattern_delay_frames, zero
00190c 9220 28c9                 	sts triangle_pattern_offset, zero
00190e 9220 28ca                 	sts triangle_pattern_offset+1, zero
001910 9220 28c7                 	sts triangle_pattern_delay_rows, zero
001912 9220 28c8                 	sts triangle_pattern_delay_frames, zero
001914 9220 2915                 	sts noise_pattern_offset, zero
001916 9220 2916                 	sts noise_pattern_offset+1, zero
001918 9220 2913                 	sts noise_pattern_delay_rows, zero
00191a 9220 2914                 	sts noise_pattern_delay_frames, zero
                                 
00191c efaf                      	ldi r26, 0xFF
00191d 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
00191f 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
001921 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
001923 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
001925 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
001927 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
001929 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
00192b 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
00192d 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
00192f 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
001931 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
001933 93a0 2910                 	sts triangle_fx_Sxx_post, r26
001935 93a0 2943                 	sts noise_fx_Gxx_pre, r26
001937 93a0 2944                 	sts noise_fx_Gxx_post, r26
001939 93a0 2946                 	sts noise_fx_Sxx_pre, r26
00193b 93a0 2947                 	sts noise_fx_Sxx_post, r26
                                 
00193d 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
00193f 9220 2821                 	sts song_fx_Cxx, zero
001941 9220 2822                 	sts song_fx_Dxx, zero
001943 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001944 91a0 2825                 	lds r26, pulse1_pattern_delay_rows
001946 91b0 2826                 	lds r27, pulse1_pattern_delay_frames
001948 9610                      	adiw r27:r26, 0
001949 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
00194a c2e4                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
00194b 91e0 2823                 	lds ZL, pulse1_pattern //current pattern for pulse 1
00194d 91f0 2824                 	lds ZH, pulse1_pattern+1
00194f 91a0 2827                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001951 91b0 2828                 	lds r27, pulse1_pattern_offset+1
001953 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001954 1ffb                      	adc ZH, r27
001955 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
001956 35b7                      	cpi r27, 0x57
001957 f408                      	brsh sound_driver_channel0_check_if_volume
001958 c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001959 36b7                      	cpi r27, 0x67
00195a f408                      	brsh sound_driver_channel0_check_if_delay
00195b c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
00195c 3eb3                      	cpi r27, 0xE3
00195d f408                      	brsh sound_driver_channel0_check_if_instrument
00195e c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
00195f f409                      	brne sound_driver_channel0_check_if_release
001960 c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001961 3eb4                      	cpi r27, 0xE4
001962 f409                      	brne sound_driver_channel0_check_if_end
001963 c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001964 3fbf                      	cpi r27, 0xFF
001965 f409                      	brne sound_driver_channel0_check_if_fx
001966 c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001967 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001968 91a4                      	lpm r26, Z //load the fx data into r26
001969 d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
00196a 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
00196b efe6                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
00196c e6f2                      	ldi ZH, HIGH(channel0_fx << 1)
00196d 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00196e 0feb                      	add ZL, r27 //add offset
00196f 1df2                      	adc ZH, zero
001970 91c5                      	lpm r28, Z+ //load address bytes
001971 91d4                      	lpm r29, Z
001972 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001973 2ffd                      	mov ZH, r29
001974 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001975 93a0 2846                 	sts pulse1_fx_0xy_sequence, r26
001977 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001979 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00197a 9220 284c                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
00197c 9220 284d                 	sts pulse1_fx_2xx+1, zero
00197e 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001980 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001982 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001983 937f                      	push r23
001984 2f6a                      	mov r22, r26 //store the rate into r22
001985 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001986 9f67                      	mul r22, r23
001987 917f                      	pop r23
001988 916f                      	pop r22
                                 
001989 9416                      	lsr r1 //shift out the fractional bits
00198a 9407                      	ror r0
00198b 9416                      	lsr r1
00198c 9407                      	ror r0
00198d 9416                      	lsr r1
00198e 9407                      	ror r0
00198f 9416                      	lsr r1
001990 9407                      	ror r0
001991 9200 2848                 	sts pulse1_fx_1xx, r0
001993 9210 2849                 	sts pulse1_fx_1xx+1, r1
001995 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001996 9220 2848                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001998 9220 2849                 	sts pulse1_fx_1xx+1, zero
00199a 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00199c 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
00199e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00199f 937f                      	push r23
0019a0 2f6a                      	mov r22, r26 //store the rate into r22
0019a1 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019a2 9f67                      	mul r22, r23
0019a3 917f                      	pop r23
0019a4 916f                      	pop r22
                                 
0019a5 9416                      	lsr r1 //shift out the fractional bits
0019a6 9407                      	ror r0
0019a7 9416                      	lsr r1
0019a8 9407                      	ror r0
0019a9 9416                      	lsr r1
0019aa 9407                      	ror r0
0019ab 9416                      	lsr r1
0019ac 9407                      	ror r0
0019ad 9200 284c                 	sts pulse1_fx_2xx, r0
0019af 9210 284d                 	sts pulse1_fx_2xx+1, r1
0019b1 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0019b2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019b3 937f                      	push r23
0019b4 2f6a                      	mov r22, r26 //store the rate into r22
0019b5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019b6 9f67                      	mul r22, r23
0019b7 917f                      	pop r23
0019b8 916f                      	pop r22
                                 
0019b9 9416                      	lsr r1 //shift out the fractional bits
0019ba 9407                      	ror r0
0019bb 9416                      	lsr r1
0019bc 9407                      	ror r0
0019bd 9416                      	lsr r1
0019be 9407                      	ror r0
0019bf 9416                      	lsr r1
0019c0 9407                      	ror r0
0019c1 9200 2854                 	sts pulse1_fx_3xx_speed, r0
0019c3 9210 2855                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0019c5 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0019c6 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0019c7 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0019c8 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0019ca 91b0 0a8d                 	lds r27, TCB0_CCMPH
0019cc 93a0 2850                 	sts pulse1_fx_3xx_start, r26
0019ce 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
                                 
0019d0 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
0019d2 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
0019d4 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0019d5 2fba                      	mov r27, r26
0019d6 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019d7 95a2                      	swap r26
0019d8 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019d9 93a0 2858                 	sts pulse1_fx_4xy_speed, r26
0019db 93b0 2859                 	sts pulse1_fx_4xy_depth, r27
0019dd 9220 285a                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0019df cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0019e0 2fba                      	mov r27, r26
0019e1 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019e2 95a2                      	swap r26
0019e3 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019e4 93a0 285b                 	sts pulse1_fx_7xy_speed, r26
0019e6 93b0 285c                 	sts pulse1_fx_7xy_depth, r27
0019e8 9220 285d                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0019ea 9220 285e                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0019ec cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0019ed 93a0 285f                 	sts pulse1_fx_Axy, r26
0019ef cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0019f0 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0019f2 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0019f3 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019f5 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0019f6 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019f8 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0019f9 91b0 2800                 	lds r27, pulse1_param
0019fb 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0019fc 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0019fd 93b0 2800                 	sts pulse1_param, r27
0019ff 6096                      	sbr pulse_channel_flags, 6
001a00 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
001a01 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001a03 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
001a04 15a2                      	cp r26, zero
001a05 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
001a06 91b0 281f                 	lds r27, song_speed
001a08 17ab                      	cp r26, r27
001a09 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
001a0a 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001a0c e0b1                      	ldi r27, 0x01
001a0d 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001a0f c222                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
001a10 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001a11 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
001a12 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
001a13 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
001a14 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
001a15 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a16 937f                      	push r23
001a17 2f6a                      	mov r22, r26
001a18 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a19 0367                      	mulsu r22, r23
001a1a 917f                      	pop r23
001a1b 916f                      	pop r22
001a1c 9416                      	lsr r1 //shift out the fractional bits
001a1d 9407                      	ror r0
001a1e 9416                      	lsr r1
001a1f 9407                      	ror r0
001a20 9416                      	lsr r1
001a21 9407                      	ror r0
001a22 9416                      	lsr r1
001a23 9407                      	ror r0
001a24 fe13                      	sbrs r1, 3 //check if result was a negative number
001a25 c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
001a26 efb0                      	ldi r27, 0xF0
001a27 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
001a28 9200 2862                 	sts pulse1_fx_Pxx_total, r0
001a2a 9210 2863                 	sts pulse1_fx_Pxx_total+1, r1
001a2c cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001a2d 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
001a2f 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
001a31 9630                      	adiw Z, 0
001a32 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001a33 cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001a34 91e0 2836                 	lds ZL, pulse1_pitch_macro
001a36 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
001a38 9630                      	adiw Z, 0
001a39 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001a3a cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001a3b 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
001a3d 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
001a3f 9630                      	adiw Z, 0
001a40 f009                      	breq sound_driver_channel0_fx_Qxy_process
001a41 cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001a42 2fba                      	mov r27, r26 //copy fx parameters into r27
001a43 70bf                      	andi r27, 0x0F //mask note index offset
001a44 91c0 2864                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
001a46 0fbc                      	add r27, r28
001a47 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001a48 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001a49 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001a4a 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
001a4c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a4d e0f0                      	ldi ZH, HIGH(note_table << 1)
001a4e 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001a4f 0feb                      	add ZL, r27 //add offset
001a50 1df2                      	adc ZH, zero
001a51 91c5                      	lpm r28, Z+ //load bytes
001a52 91d4                      	lpm r29, Z
001a53 93c0 2865                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001a55 93d0 2866                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
001a57 95a2                      	swap r26
001a58 70af                      	andi r26, 0x0F //mask effect speed
001a59 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a5a 95a3                      	inc r26 //increment the speed by 1
                                 
001a5b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a5c 937f                      	push r23
001a5d 2f6a                      	mov r22, r26 //store the speed data into r27
001a5e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a5f 9f67                      	mul r22, r23
001a60 917f                      	pop r23
001a61 916f                      	pop r22
                                 
001a62 9416                      	lsr r1 //shift out the fractional bits
001a63 9407                      	ror r0
001a64 9416                      	lsr r1
001a65 9407                      	ror r0
001a66 9416                      	lsr r1
001a67 9407                      	ror r0
001a68 9416                      	lsr r1
001a69 9407                      	ror r0
                                 
001a6a 9200 2867                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001a6c 9210 2868                 	sts pulse1_fx_Qxy_speed+1, r1
001a6e cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001a6f 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
001a71 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
001a73 9630                      	adiw Z, 0
001a74 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001a75 ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001a76 91e0 2836                 	lds ZL, pulse1_pitch_macro
001a78 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
001a7a 9630                      	adiw Z, 0
001a7b f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001a7c cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001a7d 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
001a7f 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
001a81 9630                      	adiw Z, 0
001a82 f009                      	breq sound_driver_channel0_fx_Rxy_process
001a83 cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001a84 2fba                      	mov r27, r26 //copy fx parameters into r27
001a85 70bf                      	andi r27, 0x0F //mask note index offset
001a86 91c0 286b                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
001a88 1bcb                      	sub r28, r27
001a89 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001a8a e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001a8b 93c0 286b                 	sts pulse1_fx_Rxy_target_note, r28
001a8d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a8e e0f0                      	ldi ZH, HIGH(note_table << 1)
001a8f 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001a90 0fec                      	add ZL, r28 //add offset
001a91 1df2                      	adc ZH, zero
001a92 91c5                      	lpm r28, Z+ //load bytes
001a93 91d4                      	lpm r29, Z
001a94 93c0 286c                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001a96 93d0 286d                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
001a98 95a2                      	swap r26
001a99 70af                      	andi r26, 0x0F //mask effect speed
001a9a 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a9b 95a3                      	inc r26 //increment the speed by 1
                                 
001a9c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a9d 937f                      	push r23
001a9e 2f6a                      	mov r22, r26 //store the speed data into r27
001a9f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001aa0 9f67                      	mul r22, r23
001aa1 917f                      	pop r23
001aa2 916f                      	pop r22
                                 
001aa3 9416                      	lsr r1 //shift out the fractional bits
001aa4 9407                      	ror r0
001aa5 9416                      	lsr r1
001aa6 9407                      	ror r0
001aa7 9416                      	lsr r1
001aa8 9407                      	ror r0
001aa9 9416                      	lsr r1
001aaa 9407                      	ror r0
                                 
001aab 9200 286e                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001aad 9210 286f                 	sts pulse1_fx_Rxy_speed+1, r1
001aaf ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
001ab0 15a2                      	cp r26, zero
001ab1 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001ab2 91b0 281f                 	lds r27, song_speed
001ab4 17ab                      	cp r26, r27
001ab5 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001ab6 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ab8 e0b1                      	ldi r27, 0x01
001ab9 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001abb c176                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
001abc ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001abd efe2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001abe e6f2                      	ldi ZH, HIGH(sequences << 1)
001abf 0fea                      	add ZL, r26 //offset the pointer
001ac0 1df2                      	adc ZH, zero
                                 
001ac1 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001ac2 95a7                      	ror r26
001ac3 95a7                      	ror r26
001ac4 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001ac6 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001ac7 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001ac8 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001ac9 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001aca ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001acb 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
001acc 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001acd 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001ace 93c0 2800                 	sts pulse1_param, r28
001ad0 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001ad1 ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001ad2 ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001ad3 ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001ad4 ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001ad5 93b0 2807                 	sts pulse1_note, r27 //store the note index
001ad7 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
001ad9 93b0 286b                 	sts pulse1_fx_Rxy_target_note, r27
001adb e0a3                      	ldi r26, 0x03
001adc e0b2                      	ldi r27, 0x02
001add 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001adf 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
001ae1 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
001ae3 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
001ae5 93b0 2843                 	sts pulse1_duty_macro_offset, r27
001ae7 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001ae9 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
001aeb 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
001aed 9220 284a                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001aef 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
001af1 9220 284e                 	sts pulse1_fx_2xx_total, zero
001af3 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
001af5 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001af7 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
001af9 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001afb 91b0 0a8d                 	lds r27, TCB0_CCMPH
001afd 93a0 2850                 	sts pulse1_fx_3xx_start, r26
001aff 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
001b01 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001b03 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001b04 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b06 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001b08 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
001b0a 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
001b0c 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001b0e 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001b10 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
001b12 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
001b14 d106                      	rcall sound_driver_channel0_increment_offset
001b15 ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001b16 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001b17 91a0 2800                 	lds r26, pulse1_param
001b19 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001b1a 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001b1b 93a0 2800                 	sts pulse1_param, r26
001b1d 6096                      	sbr pulse_channel_flags, 6
001b1e d0fc                      	rcall sound_driver_channel0_increment_offset
001b1f ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001b20 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001b21 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001b23 d0f7                      	rcall sound_driver_channel0_increment_offset
001b24 c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001b25 9220 2829                 	sts pulse1_volume_macro, zero //reset all macro addresses
001b27 9220 282a                 	sts pulse1_volume_macro+1, zero
001b29 9220 282e                 	sts pulse1_arpeggio_macro, zero
001b2b 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
001b2d 9220 2836                 	sts pulse1_pitch_macro, zero
001b2f 9220 2837                 	sts pulse1_pitch_macro+1, zero
001b31 9220 283c                 	sts pulse1_hi_pitch_macro, zero
001b33 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
001b35 9220 2841                 	sts pulse1_duty_macro, zero
001b37 9220 2842                 	sts pulse1_duty_macro+1, zero
001b39 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001b3b 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
001b3d 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001b3f 9631                      	adiw Z, 1 //point to the byte next to the flag
001b40 91b4                      	lpm r27, Z //store the instrument offset into r27
001b41 e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001b42 e1f2                      	ldi ZH, HIGH(instruments)
001b43 0feb                      	add ZL, r27 //point Z to offsetted instrument
001b44 1df2                      	adc ZH, zero
001b45 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001b46 1fff                      	rol ZH
001b47 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001b48 91b4                      	lpm r27, Z
                                 
001b49 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001b4a 1fbb                      	rol r27
001b4b 2fea                      	mov ZL, r26
001b4c 2ffb                      	mov ZH, r27
001b4d 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001b4e 9632                      	adiw Z, 2 //point Z to the address of the macro
001b4f e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001b50 95aa                      	dec r26
001b51 f019                      	breq sound_driver_channel0_instrument_change_exit
001b52 95b6                      	lsr r27
001b53 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001b54 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001b55 e0a3                      	ldi r26, 0x03
001b56 e0b2                      	ldi r27, 0x02
001b57 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001b59 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
001b5b 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
001b5d 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
001b5f 93b0 2843                 	sts pulse1_duty_macro_offset, r27
001b61 d0c3                      	rcall sound_driver_channel0_increment_offset_twice
001b62 cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001b63 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001b64 91d5                      	lpm r29, Z+
                                 
001b65 30a5                      	cpi r26, 5
001b66 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001b67 30a4                      	cpi r26, 4
001b68 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001b69 30a3                      	cpi r26, 3
001b6a f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001b6b 30a2                      	cpi r26, 2
001b6c f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001b6d c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001b6e 93c0 2829                 	sts pulse1_volume_macro, r28
001b70 93d0 282a                 	sts pulse1_volume_macro+1, r29
001b72 d041                      	rcall sound_driver_channel0_instrument_change_read_header
001b73 93c0 282d                 	sts pulse1_volume_macro_release, r28
001b75 93d0 282c                 	sts pulse1_volume_macro_loop, r29
001b77 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001b78 93c0 282e                 	sts pulse1_arpeggio_macro, r28
001b7a 93d0 282f                 	sts pulse1_arpeggio_macro+1, r29
001b7c 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b7e 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001b80 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001b82 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001b84 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001b85 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001b86 93c0 2836                 	sts pulse1_pitch_macro, r28
001b88 93d0 2837                 	sts pulse1_pitch_macro+1, r29
001b8a 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b8c 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001b8e 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001b90 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001b92 d021                      	rcall sound_driver_channel0_instrument_change_read_header
001b93 93c0 283a                 	sts pulse1_pitch_macro_release, r28
001b95 93d0 2839                 	sts pulse1_pitch_macro_loop, r29
001b97 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001b98 93c0 283c                 	sts pulse1_hi_pitch_macro, r28
001b9a 93d0 283d                 	sts pulse1_hi_pitch_macro+1, r29
001b9c 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b9e 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
001ba0 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001ba2 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001ba4 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001ba5 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
001ba7 93d0 283f                 	sts pulse1_hi_pitch_macro_loop, r29
001ba9 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001baa 93c0 2841                 	sts pulse1_duty_macro, r28
001bac 93d0 2842                 	sts pulse1_duty_macro+1, r29
001bae d005                      	rcall sound_driver_channel0_instrument_change_read_header
001baf 93c0 2845                 	sts pulse1_duty_macro_release, r28
001bb1 93d0 2844                 	sts pulse1_duty_macro_loop, r29
001bb3 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001bb4 93ef                      	push ZL
001bb5 93ff                      	push ZH
001bb6 2fec                      	mov ZL, r28
001bb7 2ffd                      	mov ZH, r29
001bb8 0fee                      	lsl ZL
001bb9 1fff                      	rol ZH
001bba 91c5                      	lpm r28, Z+
001bbb 91d4                      	lpm r29, Z
001bbc 91ff                      	pop ZH
001bbd 91ef                      	pop ZL
001bbe 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001bbf 93ef                      	push ZL
001bc0 93ff                      	push ZH
001bc1 2fec                      	mov ZL, r28
001bc2 2ffd                      	mov ZH, r29
001bc3 0fee                      	lsl ZL
001bc4 1fff                      	rol ZH
001bc5 91c5                      	lpm r28, Z+
001bc6 91d5                      	lpm r29, Z+
001bc7 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
001bc9 93d0 2831                 	sts pulse1_arpeggio_macro_loop, r29
001bcb 91c4                      	lpm r28, Z
001bcc 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
001bce 91ff                      	pop ZH
001bcf 91ef                      	pop ZL
001bd0 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001bd1 91b0 282d                 	lds r27, pulse1_volume_macro_release
001bd3 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001bd4 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001bd5 95b3                      	inc r27
001bd6 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001bd8 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
001bda 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001bdb f019                      	breq sound_driver_channel0_release_pitch
001bdc 95b3                      	inc r27
001bdd 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001bdf 91b0 283a                 	lds r27, pulse1_pitch_macro_release
001be1 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001be2 f019                      	breq sound_driver_channel0_release_hi_pitch
001be3 95b3                      	inc r27
001be4 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001be6 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
001be8 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001be9 f019                      	breq sound_driver_channel0_release_duty
001bea 95b3                      	inc r27
001beb 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001bed 91b0 2845                 	lds r27, pulse1_duty_macro_release
001bef 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001bf0 f019                      	breq sound_driver_channel0_release_exit
001bf1 95b3                      	inc r27
001bf2 93b0 2843                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001bf4 d026                      	rcall sound_driver_channel0_increment_offset
001bf5 cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001bf6 91e0 2819                 	lds ZL, song_frames
001bf8 91f0 281a                 	lds ZH, song_frames+1
001bfa 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001bfc 91b0 281c                 	lds r27, song_frame_offset+1
001bfe 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001bff 93a0 281b                 	sts song_frame_offset, r26
001c01 93b0 281c                 	sts song_frame_offset+1, r27
                                 
001c03 91c0 281d                 	lds r28, song_size
001c05 91d0 281e                 	lds r29, song_size+1
001c07 17ac                      	cp r26, r28
001c08 07bd                      	cpc r27, r29
001c09 f010                      	brlo sound_driver_channel0_next_pattern_exists
001c0a 940c 3163                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001c0c 0fea                      	add ZL, r26
001c0d 1ffb                      	adc ZH, r27
                                 
001c0e 91a5                      	lpm r26, Z+ //load the address of the next pattern
001c0f 91b4                      	lpm r27, Z
001c10 0faa                      	lsl r26
001c11 1fbb                      	rol r27
001c12 93a0 2823                 	sts pulse1_pattern, r26
001c14 93b0 2824                 	sts pulse1_pattern+1, r27
                                 
001c16 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001c18 9220 2828                 	sts pulse1_pattern_offset+1, zero
001c1a cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001c1b 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001c1d 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
001c1f 9631                      	adiw Z, 1
001c20 93e0 2827                 	sts pulse1_pattern_offset, ZL
001c22 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
001c24 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001c25 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001c27 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
001c29 9632                      	adiw Z, 2 //increment the pointer twice
001c2a 93e0 2827                 	sts pulse1_pattern_offset, ZL
001c2c 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
001c2e 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001c2f 95ba                      	dec r27
001c30 93b0 2826                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001c32 91a0 2876                 	lds r26, pulse2_pattern_delay_rows
001c34 91b0 2877                 	lds r27, pulse2_pattern_delay_frames
001c36 9610                      	adiw r27:r26, 0
001c37 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001c38 c2d7                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001c39 91e0 2874                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001c3b 91f0 2875                 	lds ZH, pulse2_pattern+1
001c3d 91a0 2878                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001c3f 91b0 2879                 	lds r27, pulse2_pattern_offset+1
001c41 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001c42 1ffb                      	adc ZH, r27
001c43 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001c44 35b7                      	cpi r27, 0x57
001c45 f408                      	brsh sound_driver_channel1_check_if_volume
001c46 c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001c47 36b7                      	cpi r27, 0x67
001c48 f408                      	brsh sound_driver_channel1_check_if_delay
001c49 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001c4a 3eb3                      	cpi r27, 0xE3
001c4b f408                      	brsh sound_driver_channel1_check_if_instrument
001c4c c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001c4d f409                      	brne sound_driver_channel1_check_if_release
001c4e c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001c4f 3eb4                      	cpi r27, 0xE4
001c50 f409                      	brne sound_driver_channel1_check_if_end
001c51 c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001c52 3fbf                      	cpi r27, 0xFF
001c53 f409                      	brne sound_driver_channel1_check_if_fx
001c54 c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001c55 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001c56 91a4                      	lpm r26, Z //load the fx data into r26
001c57 d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001c58 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001c59 e2ea                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001c5a e6f3                      	ldi ZH, HIGH(channel1_fx << 1)
001c5b 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001c5c 0feb                      	add ZL, r27 //add offset
001c5d 1df2                      	adc ZH, zero
001c5e 91c5                      	lpm r28, Z+ //load address bytes
001c5f 91d4                      	lpm r29, Z
001c60 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001c61 2ffd                      	mov ZH, r29
001c62 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001c63 93a0 2897                 	sts pulse2_fx_0xy_sequence, r26
001c65 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001c67 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001c68 9220 289d                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001c6a 9220 289e                 	sts pulse2_fx_2xx+1, zero
001c6c 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c6e 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001c70 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c71 937f                      	push r23
001c72 2f6a                      	mov r22, r26 //store the rate into r22
001c73 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c74 9f67                      	mul r22, r23
001c75 917f                      	pop r23
001c76 916f                      	pop r22
                                 
001c77 9416                      	lsr r1 //shift out the fractional bits
001c78 9407                      	ror r0
001c79 9416                      	lsr r1
001c7a 9407                      	ror r0
001c7b 9416                      	lsr r1
001c7c 9407                      	ror r0
001c7d 9416                      	lsr r1
001c7e 9407                      	ror r0
001c7f 9200 2899                 	sts pulse2_fx_1xx, r0
001c81 9210 289a                 	sts pulse2_fx_1xx+1, r1
001c83 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001c84 9220 2899                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001c86 9220 289a                 	sts pulse2_fx_1xx+1, zero
001c88 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c8a 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001c8c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c8d 937f                      	push r23
001c8e 2f6a                      	mov r22, r26 //store the rate into r22
001c8f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c90 9f67                      	mul r22, r23
001c91 917f                      	pop r23
001c92 916f                      	pop r22
                                 
001c93 9416                      	lsr r1 //shift out the fractional bits
001c94 9407                      	ror r0
001c95 9416                      	lsr r1
001c96 9407                      	ror r0
001c97 9416                      	lsr r1
001c98 9407                      	ror r0
001c99 9416                      	lsr r1
001c9a 9407                      	ror r0
001c9b 9200 289d                 	sts pulse2_fx_2xx, r0
001c9d 9210 289e                 	sts pulse2_fx_2xx+1, r1
001c9f cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001ca0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ca1 937f                      	push r23
001ca2 2f6a                      	mov r22, r26 //store the rate into r22
001ca3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ca4 9f67                      	mul r22, r23
001ca5 917f                      	pop r23
001ca6 916f                      	pop r22
                                 
001ca7 9416                      	lsr r1 //shift out the fractional bits
001ca8 9407                      	ror r0
001ca9 9416                      	lsr r1
001caa 9407                      	ror r0
001cab 9416                      	lsr r1
001cac 9407                      	ror r0
001cad 9416                      	lsr r1
001cae 9407                      	ror r0
001caf 9200 28a5                 	sts pulse2_fx_3xx_speed, r0
001cb1 9210 28a6                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001cb3 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001cb4 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001cb5 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001cb6 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001cb8 91b0 0a9d                 	lds r27, TCB1_CCMPH
001cba 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001cbc 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
                                 
001cbe 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
001cc0 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001cc2 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001cc3 2fba                      	mov r27, r26
001cc4 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001cc5 95a2                      	swap r26
001cc6 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001cc7 93a0 28a9                 	sts pulse2_fx_4xy_speed, r26
001cc9 93b0 28aa                 	sts pulse2_fx_4xy_depth, r27
001ccb 9220 28ab                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001ccd cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001cce 2fba                      	mov r27, r26
001ccf 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001cd0 95a2                      	swap r26
001cd1 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001cd2 93a0 28ac                 	sts pulse2_fx_7xy_speed, r26
001cd4 93b0 28ad                 	sts pulse2_fx_7xy_depth, r27
001cd6 9220 28ae                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001cd8 9220 28af                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001cda cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001cdb 93a0 28b0                 	sts pulse2_fx_Axy, r26
001cdd cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001cde 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001ce0 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001ce1 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001ce3 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001ce4 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001ce6 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001ce7 91b0 2808                 	lds r27, pulse2_param
001ce9 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001cea 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001ceb 93b0 2808                 	sts pulse2_param, r27
001ced 6092                      	sbr pulse_channel_flags, 2
001cee cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001cef 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001cf1 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001cf2 15a2                      	cp r26, zero
001cf3 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001cf4 91b0 281f                 	lds r27, song_speed
001cf6 17ab                      	cp r26, r27
001cf7 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001cf8 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001cfa e0b1                      	ldi r27, 0x01
001cfb 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001cfd c215                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001cfe cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001cff cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001d00 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001d01 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001d02 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001d03 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d04 937f                      	push r23
001d05 2f6a                      	mov r22, r26
001d06 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d07 0367                      	mulsu r22, r23
001d08 917f                      	pop r23
001d09 916f                      	pop r22
001d0a 9416                      	lsr r1 //shift out the fractional bits
001d0b 9407                      	ror r0
001d0c 9416                      	lsr r1
001d0d 9407                      	ror r0
001d0e 9416                      	lsr r1
001d0f 9407                      	ror r0
001d10 9416                      	lsr r1
001d11 9407                      	ror r0
001d12 fe13                      	sbrs r1, 3 //check if result was a negative number
001d13 c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
001d14 efb0                      	ldi r27, 0xF0
001d15 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001d16 9200 28b3                 	sts pulse2_fx_Pxx_total, r0
001d18 9210 28b4                 	sts pulse2_fx_Pxx_total+1, r1
001d1a cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001d1b 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001d1d 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001d1f 9630                      	adiw Z, 0
001d20 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001d21 cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001d22 91e0 2887                 	lds ZL, pulse2_pitch_macro
001d24 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
001d26 9630                      	adiw Z, 0
001d27 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001d28 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001d29 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001d2b 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001d2d 9630                      	adiw Z, 0
001d2e f009                      	breq sound_driver_channel1_fx_Qxy_process
001d2f cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001d30 2fba                      	mov r27, r26 //copy fx parameters into r27
001d31 70bf                      	andi r27, 0x0F //mask note index offset
001d32 91c0 28b5                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
001d34 0fbc                      	add r27, r28
001d35 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001d36 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001d37 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001d38 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001d3a e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d3b e0f0                      	ldi ZH, HIGH(note_table << 1)
001d3c 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001d3d 0feb                      	add ZL, r27 //add offset
001d3e 1df2                      	adc ZH, zero
001d3f 91c5                      	lpm r28, Z+ //load bytes
001d40 91d4                      	lpm r29, Z
001d41 93c0 28b6                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001d43 93d0 28b7                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
001d45 95a2                      	swap r26
001d46 70af                      	andi r26, 0x0F //mask effect speed
001d47 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d48 95a3                      	inc r26 //increment the speed by 1
                                 
001d49 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d4a 937f                      	push r23
001d4b 2f6a                      	mov r22, r26 //store the speed data into r27
001d4c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d4d 9f67                      	mul r22, r23
001d4e 917f                      	pop r23
001d4f 916f                      	pop r22
                                 
001d50 9416                      	lsr r1 //shift out the fractional bits
001d51 9407                      	ror r0
001d52 9416                      	lsr r1
001d53 9407                      	ror r0
001d54 9416                      	lsr r1
001d55 9407                      	ror r0
001d56 9416                      	lsr r1
001d57 9407                      	ror r0
                                 
001d58 9200 28b8                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001d5a 9210 28b9                 	sts pulse2_fx_Qxy_speed+1, r1
001d5c cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001d5d 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001d5f 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001d61 9630                      	adiw Z, 0
001d62 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001d63 ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001d64 91e0 2887                 	lds ZL, pulse2_pitch_macro
001d66 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
001d68 9630                      	adiw Z, 0
001d69 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001d6a cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001d6b 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001d6d 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001d6f 9630                      	adiw Z, 0
001d70 f009                      	breq sound_driver_channel1_fx_Rxy_process
001d71 cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001d72 2fba                      	mov r27, r26 //copy fx parameters into r27
001d73 70bf                      	andi r27, 0x0F //mask note index offset
001d74 91c0 28bc                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
001d76 1bcb                      	sub r28, r27
001d77 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001d78 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001d79 93c0 28bc                 	sts pulse2_fx_Rxy_target_note, r28
001d7b e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d7c e0f0                      	ldi ZH, HIGH(note_table << 1)
001d7d 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001d7e 0fec                      	add ZL, r28 //add offset
001d7f 1df2                      	adc ZH, zero
001d80 91c5                      	lpm r28, Z+ //load bytes
001d81 91d4                      	lpm r29, Z
001d82 93c0 28bd                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001d84 93d0 28be                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
001d86 95a2                      	swap r26
001d87 70af                      	andi r26, 0x0F //mask effect speed
001d88 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d89 95a3                      	inc r26 //increment the speed by 1
                                 
001d8a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d8b 937f                      	push r23
001d8c 2f6a                      	mov r22, r26 //store the speed data into r27
001d8d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d8e 9f67                      	mul r22, r23
001d8f 917f                      	pop r23
001d90 916f                      	pop r22
                                 
001d91 9416                      	lsr r1 //shift out the fractional bits
001d92 9407                      	ror r0
001d93 9416                      	lsr r1
001d94 9407                      	ror r0
001d95 9416                      	lsr r1
001d96 9407                      	ror r0
001d97 9416                      	lsr r1
001d98 9407                      	ror r0
                                 
001d99 9200 28bf                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001d9b 9210 28c0                 	sts pulse2_fx_Rxy_speed+1, r1
001d9d ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001d9e 15a2                      	cp r26, zero
001d9f f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001da0 91b0 281f                 	lds r27, song_speed
001da2 17ab                      	cp r26, r27
001da3 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001da4 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001da6 e0b1                      	ldi r27, 0x01
001da7 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001da9 c169                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001daa ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001dab efe2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001dac e6f2                      	ldi ZH, HIGH(sequences << 1)
001dad 0fea                      	add ZL, r26 //offset the pointer
001dae 1df2                      	adc ZH, zero
                                 
001daf 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001db0 95a7                      	ror r26
001db1 95a7                      	ror r26
001db2 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001db4 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001db5 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001db6 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001db7 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001db8 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001db9 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001dba 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001dbb 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001dbc 93c0 2808                 	sts pulse2_param, r28
001dbe ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001dbf ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001dc0 ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001dc1 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001dc2 ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001dc3 93b0 280f                 	sts pulse2_note, r27 //store the note index
001dc5 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001dc7 93b0 28bc                 	sts pulse2_fx_Rxy_target_note, r27
001dc9 e0a3                      	ldi r26, 0x03
001dca e0b2                      	ldi r27, 0x02
001dcb 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001dcd 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
001dcf 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001dd1 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001dd3 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001dd5 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001dd7 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001dd9 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
001ddb 9220 289b                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001ddd 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
001ddf 9220 289f                 	sts pulse2_fx_2xx_total, zero
001de1 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
001de3 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001de5 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001de7 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001de9 91b0 0a9d                 	lds r27, TCB1_CCMPH
001deb 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001ded 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
001def 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001df1 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001df2 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001df4 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001df6 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
001df8 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
001dfa 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001dfc 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001dfe 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
001e00 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
001e02 d0f9                      	rcall sound_driver_channel1_increment_offset
001e03 ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001e04 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001e05 91a0 2808                 	lds r26, pulse2_param
001e07 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001e08 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001e09 93a0 2808                 	sts pulse2_param, r26
001e0b 6092                      	sbr pulse_channel_flags, 2
001e0c d0ef                      	rcall sound_driver_channel1_increment_offset
001e0d ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001e0e 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001e0f 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001e11 d0ea                      	rcall sound_driver_channel1_increment_offset
001e12 c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001e13 9220 287a                 	sts pulse2_volume_macro, zero //reset all macro addresses
001e15 9220 287b                 	sts pulse2_volume_macro+1, zero
001e17 9220 287f                 	sts pulse2_arpeggio_macro, zero
001e19 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
001e1b 9220 2887                 	sts pulse2_pitch_macro, zero
001e1d 9220 2888                 	sts pulse2_pitch_macro+1, zero
001e1f 9220 288d                 	sts pulse2_hi_pitch_macro, zero
001e21 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
001e23 9220 2892                 	sts pulse2_duty_macro, zero
001e25 9220 2893                 	sts pulse2_duty_macro+1, zero
001e27 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001e29 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001e2b 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001e2d 9631                      	adiw Z, 1 //point to the byte next to the flag
001e2e 91b4                      	lpm r27, Z //store the instrument offset into r27
001e2f e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001e30 e1f2                      	ldi ZH, HIGH(instruments)
001e31 0feb                      	add ZL, r27 //point Z to offsetted instrument
001e32 1df2                      	adc ZH, zero
001e33 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001e34 1fff                      	rol ZH
001e35 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001e36 91b4                      	lpm r27, Z
                                 
001e37 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001e38 1fbb                      	rol r27
001e39 2fea                      	mov ZL, r26
001e3a 2ffb                      	mov ZH, r27
001e3b 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001e3c 9632                      	adiw Z, 2 //point Z to the address of the macro
001e3d e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001e3e 95aa                      	dec r26
001e3f f019                      	breq sound_driver_channel1_instrument_change_exit
001e40 95b6                      	lsr r27
001e41 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001e42 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001e43 e0a3                      	ldi r26, 0x03
001e44 e0b2                      	ldi r27, 0x02
001e45 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001e47 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
001e49 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001e4b 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001e4d 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001e4f d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001e50 cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001e51 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001e52 91d5                      	lpm r29, Z+
                                 
001e53 30a5                      	cpi r26, 5
001e54 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001e55 30a4                      	cpi r26, 4
001e56 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001e57 30a3                      	cpi r26, 3
001e58 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001e59 30a2                      	cpi r26, 2
001e5a f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001e5b c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001e5c 93c0 287a                 	sts pulse2_volume_macro, r28
001e5e 93d0 287b                 	sts pulse2_volume_macro+1, r29
001e60 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001e61 93c0 287e                 	sts pulse2_volume_macro_release, r28
001e63 93d0 287d                 	sts pulse2_volume_macro_loop, r29
001e65 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001e66 93c0 287f                 	sts pulse2_arpeggio_macro, r28
001e68 93d0 2880                 	sts pulse2_arpeggio_macro+1, r29
001e6a 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e6c 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001e6e 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001e70 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001e72 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001e73 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001e74 93c0 2887                 	sts pulse2_pitch_macro, r28
001e76 93d0 2888                 	sts pulse2_pitch_macro+1, r29
001e78 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e7a 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001e7c 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001e7e 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001e80 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001e81 93c0 288b                 	sts pulse2_pitch_macro_release, r28
001e83 93d0 288a                 	sts pulse2_pitch_macro_loop, r29
001e85 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001e86 93c0 288d                 	sts pulse2_hi_pitch_macro, r28
001e88 93d0 288e                 	sts pulse2_hi_pitch_macro+1, r29
001e8a 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e8c 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001e8e 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001e90 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001e92 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001e93 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
001e95 93d0 2890                 	sts pulse2_hi_pitch_macro_loop, r29
001e97 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001e98 93c0 2892                 	sts pulse2_duty_macro, r28
001e9a 93d0 2893                 	sts pulse2_duty_macro+1, r29
001e9c d005                      	rcall sound_driver_channel1_instrument_change_read_header
001e9d 93c0 2896                 	sts pulse2_duty_macro_release, r28
001e9f 93d0 2895                 	sts pulse2_duty_macro_loop, r29
001ea1 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001ea2 93ef                      	push ZL
001ea3 93ff                      	push ZH
001ea4 2fec                      	mov ZL, r28
001ea5 2ffd                      	mov ZH, r29
001ea6 0fee                      	lsl ZL
001ea7 1fff                      	rol ZH
001ea8 91c5                      	lpm r28, Z+
001ea9 91d4                      	lpm r29, Z
001eaa 91ff                      	pop ZH
001eab 91ef                      	pop ZL
001eac 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001ead 93ef                      	push ZL
001eae 93ff                      	push ZH
001eaf 2fec                      	mov ZL, r28
001eb0 2ffd                      	mov ZH, r29
001eb1 0fee                      	lsl ZL
001eb2 1fff                      	rol ZH
001eb3 91c5                      	lpm r28, Z+
001eb4 91d5                      	lpm r29, Z+
001eb5 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
001eb7 93d0 2882                 	sts pulse2_arpeggio_macro_loop, r29
001eb9 91c4                      	lpm r28, Z
001eba 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
001ebc 91ff                      	pop ZH
001ebd 91ef                      	pop ZL
001ebe 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001ebf 91b0 287e                 	lds r27, pulse2_volume_macro_release
001ec1 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001ec2 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001ec3 95b3                      	inc r27
001ec4 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001ec6 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
001ec8 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001ec9 f019                      	breq sound_driver_channel1_release_pitch
001eca 95b3                      	inc r27
001ecb 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001ecd 91b0 288b                 	lds r27, pulse2_pitch_macro_release
001ecf 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001ed0 f019                      	breq sound_driver_channel1_release_hi_pitch
001ed1 95b3                      	inc r27
001ed2 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001ed4 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
001ed6 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001ed7 f019                      	breq sound_driver_channel1_release_duty
001ed8 95b3                      	inc r27
001ed9 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001edb 91b0 2896                 	lds r27, pulse2_duty_macro_release
001edd 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001ede f019                      	breq sound_driver_channel1_release_exit
001edf 95b3                      	inc r27
001ee0 93b0 2894                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001ee2 d019                      	rcall sound_driver_channel1_increment_offset
001ee3 cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001ee4 91e0 2819                 	lds ZL, song_frames
001ee6 91f0 281a                 	lds ZH, song_frames+1
001ee8 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001eea 91b0 281c                 	lds r27, song_frame_offset+1
001eec 9612                      	adiw r27:r26, 2 //offset for channel 1
001eed 0fea                      	add ZL, r26
001eee 1ffb                      	adc ZH, r27
                                 
001eef 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ef0 91b4                      	lpm r27, Z
001ef1 0faa                      	lsl r26
001ef2 1fbb                      	rol r27
001ef3 93a0 2874                 	sts pulse2_pattern, r26
001ef5 93b0 2875                 	sts pulse2_pattern+1, r27
                                 
001ef7 9220 2878                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ef9 9220 2879                 	sts pulse2_pattern_offset+1, zero
001efb cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001efc 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001efe 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001f00 9631                      	adiw Z, 1
001f01 93e0 2878                 	sts pulse2_pattern_offset, ZL
001f03 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001f05 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001f06 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001f08 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001f0a 9632                      	adiw Z, 2 //increment the pointer twice
001f0b 93e0 2878                 	sts pulse2_pattern_offset, ZL
001f0d 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001f0f 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001f10 95ba                      	dec r27
001f11 93b0 2877                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001f13 91a0 28c7                 	lds r26, triangle_pattern_delay_rows
001f15 91b0 28c8                 	lds r27, triangle_pattern_delay_frames
001f17 9610                      	adiw r27:r26, 0
001f18 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001f19 c2bf                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001f1a 91e0 28c5                 	lds ZL, triangle_pattern //current pattern for triangle
001f1c 91f0 28c6                 	lds ZH, triangle_pattern+1
001f1e 91a0 28c9                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001f20 91b0 28ca                 	lds r27, triangle_pattern_offset+1
001f22 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001f23 1ffb                      	adc ZH, r27
001f24 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001f25 35b7                      	cpi r27, 0x57
001f26 f408                      	brsh sound_driver_channel2_check_if_volume
001f27 c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001f28 36b7                      	cpi r27, 0x67
001f29 f408                      	brsh sound_driver_channel2_check_if_delay
001f2a c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001f2b 3eb3                      	cpi r27, 0xE3
001f2c f408                      	brsh sound_driver_channel2_check_if_instrument
001f2d c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001f2e f409                      	brne sound_driver_channel2_check_if_release
001f2f c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001f30 3eb4                      	cpi r27, 0xE4
001f31 f409                      	brne sound_driver_channel2_check_if_end
001f32 c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001f33 3fbf                      	cpi r27, 0xFF
001f34 f409                      	brne sound_driver_channel2_check_if_fx
001f35 c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001f36 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001f37 91a4                      	lpm r26, Z //load the fx data into r26
001f38 d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001f39 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001f3a e5ee                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001f3b e6f3                      	ldi ZH, HIGH(channel2_fx << 1)
001f3c 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001f3d 0feb                      	add ZL, r27 //add offset
001f3e 1df2                      	adc ZH, zero
001f3f 91c5                      	lpm r28, Z+ //load address bytes
001f40 91d4                      	lpm r29, Z
001f41 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001f42 2ffd                      	mov ZH, r29
001f43 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001f44 93a0 28e8                 	sts triangle_fx_0xy_sequence, r26
001f46 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001f48 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001f49 9220 28ee                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001f4b 9220 28ef                 	sts triangle_fx_2xx+1, zero
001f4d 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f4f 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001f51 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f52 937f                      	push r23
001f53 2f6a                      	mov r22, r26 //store the rate into r22
001f54 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f55 9f67                      	mul r22, r23
001f56 917f                      	pop r23
001f57 916f                      	pop r22
                                 
001f58 9416                      	lsr r1 //shift out the fractional bits
001f59 9407                      	ror r0
001f5a 9416                      	lsr r1
001f5b 9407                      	ror r0
001f5c 9416                      	lsr r1
001f5d 9407                      	ror r0
001f5e 9416                      	lsr r1
001f5f 9407                      	ror r0
001f60 9200 28ea                 	sts triangle_fx_1xx, r0
001f62 9210 28eb                 	sts triangle_fx_1xx+1, r1
001f64 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001f65 9220 28ea                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001f67 9220 28eb                 	sts triangle_fx_1xx+1, zero
001f69 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f6b 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001f6d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f6e 937f                      	push r23
001f6f 2f6a                      	mov r22, r26 //store the rate into r22
001f70 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f71 9f67                      	mul r22, r23
001f72 917f                      	pop r23
001f73 916f                      	pop r22
                                 
001f74 9416                      	lsr r1 //shift out the fractional bits
001f75 9407                      	ror r0
001f76 9416                      	lsr r1
001f77 9407                      	ror r0
001f78 9416                      	lsr r1
001f79 9407                      	ror r0
001f7a 9416                      	lsr r1
001f7b 9407                      	ror r0
001f7c 9200 28ee                 	sts triangle_fx_2xx, r0
001f7e 9210 28ef                 	sts triangle_fx_2xx+1, r1
001f80 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001f81 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f82 937f                      	push r23
001f83 2f6a                      	mov r22, r26 //store the rate into r22
001f84 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f85 9f67                      	mul r22, r23
001f86 917f                      	pop r23
001f87 916f                      	pop r22
                                 
001f88 9416                      	lsr r1 //shift out the fractional bits
001f89 9407                      	ror r0
001f8a 9416                      	lsr r1
001f8b 9407                      	ror r0
001f8c 9416                      	lsr r1
001f8d 9407                      	ror r0
001f8e 9416                      	lsr r1
001f8f 9407                      	ror r0
001f90 9200 28f6                 	sts triangle_fx_3xx_speed, r0
001f92 9210 28f7                 	sts triangle_fx_3xx_speed+1, r1
                                 
001f94 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001f95 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001f96 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001f97 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001f99 91b0 0aad                 	lds r27, TCB2_CCMPH
001f9b 93a0 28f2                 	sts triangle_fx_3xx_start, r26
001f9d 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
                                 
001f9f 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
001fa1 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001fa3 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001fa4 2fba                      	mov r27, r26
001fa5 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001fa6 95a2                      	swap r26
001fa7 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001fa8 93a0 28fa                 	sts triangle_fx_4xy_speed, r26
001faa 93b0 28fb                 	sts triangle_fx_4xy_depth, r27
001fac 9220 28fc                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001fae cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001faf cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001fb0 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001fb1 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001fb3 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001fb4 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001fb6 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001fb7 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001fb9 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001fba 15a2                      	cp r26, zero
001fbb f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001fbc e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001fbd 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001fbf cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001fc0 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001fc2 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001fc4 9220 0aad                 	sts TCB2_CCMPH, zero
001fc6 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001fc7 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001fc9 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001fca 15a2                      	cp r26, zero
001fcb f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001fcc 91b0 281f                 	lds r27, song_speed
001fce 17ab                      	cp r26, r27
001fcf f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001fd0 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001fd2 e0b1                      	ldi r27, 0x01
001fd3 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001fd5 c206                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001fd6 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001fd7 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001fd8 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001fd9 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001fda cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001fdb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001fdc 937f                      	push r23
001fdd 2f6a                      	mov r22, r26
001fde eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001fdf 0367                      	mulsu r22, r23
001fe0 917f                      	pop r23
001fe1 916f                      	pop r22
001fe2 9416                      	lsr r1 //shift out the fractional bits
001fe3 9407                      	ror r0
001fe4 9416                      	lsr r1
001fe5 9407                      	ror r0
001fe6 9416                      	lsr r1
001fe7 9407                      	ror r0
001fe8 9416                      	lsr r1
001fe9 9407                      	ror r0
001fea fe13                      	sbrs r1, 3 //check if result was a negative number
001feb c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001fec efb0                      	ldi r27, 0xF0
001fed 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001fee 9200 28ff                 	sts triangle_fx_Pxx_total, r0
001ff0 9210 2900                 	sts triangle_fx_Pxx_total+1, r1
001ff2 cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001ff3 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
001ff5 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
001ff7 9630                      	adiw Z, 0
001ff8 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001ff9 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001ffa 91e0 28d8                 	lds ZL, triangle_pitch_macro
001ffc 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
001ffe 9630                      	adiw Z, 0
001fff f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
002000 cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
002001 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
002003 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
002005 9630                      	adiw Z, 0
002006 f009                      	breq sound_driver_channel2_fx_Qxy_process
002007 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
002008 2fba                      	mov r27, r26 //copy fx parameters into r27
002009 70bf                      	andi r27, 0x0F //mask note index offset
00200a 91c0 2901                 	lds r28, triangle_fx_Qxy_target_note //load current note index
00200c 0fbc                      	add r27, r28
00200d 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00200e f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
00200f e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
002010 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
002012 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002013 e0f0                      	ldi ZH, HIGH(note_table << 1)
002014 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
002015 0feb                      	add ZL, r27 //add offset
002016 1df2                      	adc ZH, zero
002017 91c5                      	lpm r28, Z+ //load bytes
002018 91d4                      	lpm r29, Z
002019 93c0 2902                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
00201b 93d0 2903                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
00201d 95a2                      	swap r26
00201e 70af                      	andi r26, 0x0F //mask effect speed
00201f 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
002020 95a3                      	inc r26 //increment the speed by 1
                                 
002021 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002022 937f                      	push r23
002023 2f6a                      	mov r22, r26 //store the speed data into r27
002024 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002025 9f67                      	mul r22, r23
002026 917f                      	pop r23
002027 916f                      	pop r22
                                 
002028 9416                      	lsr r1 //shift out the fractional bits
002029 9407                      	ror r0
00202a 9416                      	lsr r1
00202b 9407                      	ror r0
00202c 9416                      	lsr r1
00202d 9407                      	ror r0
00202e 9416                      	lsr r1
00202f 9407                      	ror r0
                                 
002030 9200 2904                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
002032 9210 2905                 	sts triangle_fx_Qxy_speed+1, r1
002034 cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
002035 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
002037 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
002039 9630                      	adiw Z, 0
00203a f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
00203b cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
00203c 91e0 28d8                 	lds ZL, triangle_pitch_macro
00203e 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
002040 9630                      	adiw Z, 0
002041 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
002042 ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
002043 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
002045 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
002047 9630                      	adiw Z, 0
002048 f009                      	breq sound_driver_channel2_fx_Rxy_process
002049 ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
00204a 2fba                      	mov r27, r26 //copy fx parameters into r27
00204b 70bf                      	andi r27, 0x0F //mask note index offset
00204c 91c0 2908                 	lds r28, triangle_fx_Rxy_target_note //load current note index
00204e 1bcb                      	sub r28, r27
00204f f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
002050 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
002051 93c0 2908                 	sts triangle_fx_Rxy_target_note, r28
002053 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002054 e0f0                      	ldi ZH, HIGH(note_table << 1)
002055 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
002056 0fec                      	add ZL, r28 //add offset
002057 1df2                      	adc ZH, zero
002058 91c5                      	lpm r28, Z+ //load bytes
002059 91d4                      	lpm r29, Z
00205a 93c0 2909                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
00205c 93d0 290a                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
00205e 95a2                      	swap r26
00205f 70af                      	andi r26, 0x0F //mask effect speed
002060 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
002061 95a3                      	inc r26 //increment the speed by 1
                                 
002062 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002063 937f                      	push r23
002064 2f6a                      	mov r22, r26 //store the speed data into r27
002065 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002066 9f67                      	mul r22, r23
002067 917f                      	pop r23
002068 916f                      	pop r22
                                 
002069 9416                      	lsr r1 //shift out the fractional bits
00206a 9407                      	ror r0
00206b 9416                      	lsr r1
00206c 9407                      	ror r0
00206d 9416                      	lsr r1
00206e 9407                      	ror r0
00206f 9416                      	lsr r1
002070 9407                      	ror r0
                                 
002071 9200 290b                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
002073 9210 290c                 	sts triangle_fx_Rxy_speed+1, r1
002075 cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
002076 15a2                      	cp r26, zero
002077 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
002078 91b0 281f                 	lds r27, song_speed
00207a 17ab                      	cp r26, r27
00207b f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
00207c 93a0 290f                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00207e e0b1                      	ldi r27, 0x01
00207f 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
002081 c15a                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
002082 ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
002083 ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
002084 ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
002085 ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
002086 ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
002087 ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
002088 93b0 2812                 	sts triangle_note, r27 //store the note index
00208a 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
00208c 93b0 2908                 	sts triangle_fx_Rxy_target_note, r27
00208e e0a3                      	ldi r26, 0x03
00208f e0b2                      	ldi r27, 0x02
002090 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
002092 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
002094 93b0 28da                 	sts triangle_pitch_macro_offset, r27
002096 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
002098 93b0 28e5                 	sts triangle_duty_macro_offset, r27
00209a 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
00209c 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
00209e 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
0020a0 9220 28ec                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0020a2 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
0020a4 9220 28f0                 	sts triangle_fx_2xx_total, zero
0020a6 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
0020a8 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
0020aa 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
0020ac 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0020ae 91b0 0aad                 	lds r27, TCB2_CCMPH
0020b0 93a0 28f2                 	sts triangle_fx_3xx_start, r26
0020b2 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
0020b4 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0020b6 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
0020b8 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
0020ba 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
0020bc 9220 2909                 	sts triangle_fx_Rxy_target, zero
0020be 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
0020c0 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
0020c2 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
0020c4 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0020c5 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0020c7 d0fd                      	rcall sound_driver_channel2_increment_offset
0020c8 ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
0020c9 d0fb                      	rcall sound_driver_channel2_increment_offset
0020ca 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0020cb f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
0020cc e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0020cd 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0020cf ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
0020d0 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
0020d2 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
0020d4 9220 0aad                 	sts TCB2_CCMPH, zero
0020d6 ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
0020d7 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0020d8 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
0020da d0ea                      	rcall sound_driver_channel2_increment_offset
0020db c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
0020dc 9220 28cb                 	sts triangle_volume_macro, zero //reset all macro addresses
0020de 9220 28cc                 	sts triangle_volume_macro+1, zero
0020e0 9220 28d0                 	sts triangle_arpeggio_macro, zero
0020e2 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
0020e4 9220 28d8                 	sts triangle_pitch_macro, zero
0020e6 9220 28d9                 	sts triangle_pitch_macro+1, zero
0020e8 9220 28de                 	sts triangle_hi_pitch_macro, zero
0020ea 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
0020ec 9220 28e3                 	sts triangle_duty_macro, zero
0020ee 9220 28e4                 	sts triangle_duty_macro+1, zero
0020f0 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
0020f2 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
0020f4 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0020f6 9631                      	adiw Z, 1 //point to the byte next to the flag
0020f7 91b4                      	lpm r27, Z //store the instrument offset into r27
0020f8 e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
0020f9 e1f2                      	ldi ZH, HIGH(instruments)
0020fa 0feb                      	add ZL, r27 //point Z to offsetted instrument
0020fb 1df2                      	adc ZH, zero
0020fc 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0020fd 1fff                      	rol ZH
0020fe 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0020ff 91b4                      	lpm r27, Z
                                 
002100 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
002101 1fbb                      	rol r27
002102 2fea                      	mov ZL, r26
002103 2ffb                      	mov ZH, r27
002104 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
002105 9632                      	adiw Z, 2 //point Z to the address of the macro
002106 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
002107 95aa                      	dec r26
002108 f019                      	breq sound_driver_channel2_instrument_change_exit
002109 95b6                      	lsr r27
00210a f078                      	brcs sound_driver_channel2_instrument_change_load_macro
00210b cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
00210c e0a3                      	ldi r26, 0x03
00210d e0b2                      	ldi r27, 0x02
00210e 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
002110 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
002112 93b0 28da                 	sts triangle_pitch_macro_offset, r27
002114 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
002116 93b0 28e5                 	sts triangle_duty_macro_offset, r27
002118 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
002119 ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
00211a 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
00211b 91d5                      	lpm r29, Z+
                                 
00211c 30a5                      	cpi r26, 5
00211d f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
00211e 30a4                      	cpi r26, 4
00211f f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
002120 30a3                      	cpi r26, 3
002121 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
002122 30a2                      	cpi r26, 2
002123 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
002124 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
002125 93c0 28cb                 	sts triangle_volume_macro, r28
002127 93d0 28cc                 	sts triangle_volume_macro+1, r29
002129 d041                      	rcall sound_driver_channel2_instrument_change_read_header
00212a 93c0 28cf                 	sts triangle_volume_macro_release, r28
00212c 93d0 28ce                 	sts triangle_volume_macro_loop, r29
00212e cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
00212f 93c0 28d0                 	sts triangle_arpeggio_macro, r28
002131 93d0 28d1                 	sts triangle_arpeggio_macro+1, r29
002133 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002135 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002137 9220 2909                 	sts triangle_fx_Rxy_target, zero
002139 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
00213b d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
00213c cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
00213d 93c0 28d8                 	sts triangle_pitch_macro, r28
00213f 93d0 28d9                 	sts triangle_pitch_macro+1, r29
002141 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002143 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002145 9220 2909                 	sts triangle_fx_Rxy_target, zero
002147 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002149 d021                      	rcall sound_driver_channel2_instrument_change_read_header
00214a 93c0 28dc                 	sts triangle_pitch_macro_release, r28
00214c 93d0 28db                 	sts triangle_pitch_macro_loop, r29
00214e cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
00214f 93c0 28de                 	sts triangle_hi_pitch_macro, r28
002151 93d0 28df                 	sts triangle_hi_pitch_macro+1, r29
002153 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002155 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002157 9220 2909                 	sts triangle_fx_Rxy_target, zero
002159 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
00215b d00f                      	rcall sound_driver_channel2_instrument_change_read_header
00215c 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
00215e 93d0 28e1                 	sts triangle_hi_pitch_macro_loop, r29
002160 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
002161 93c0 28e3                 	sts triangle_duty_macro, r28
002163 93d0 28e4                 	sts triangle_duty_macro+1, r29
002165 d005                      	rcall sound_driver_channel2_instrument_change_read_header
002166 93c0 28e7                 	sts triangle_duty_macro_release, r28
002168 93d0 28e6                 	sts triangle_duty_macro_loop, r29
00216a cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
00216b 93ef                      	push ZL
00216c 93ff                      	push ZH
00216d 2fec                      	mov ZL, r28
00216e 2ffd                      	mov ZH, r29
00216f 0fee                      	lsl ZL
002170 1fff                      	rol ZH
002171 91c5                      	lpm r28, Z+
002172 91d4                      	lpm r29, Z
002173 91ff                      	pop ZH
002174 91ef                      	pop ZL
002175 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
002176 93ef                      	push ZL
002177 93ff                      	push ZH
002178 2fec                      	mov ZL, r28
002179 2ffd                      	mov ZH, r29
00217a 0fee                      	lsl ZL
00217b 1fff                      	rol ZH
00217c 91c5                      	lpm r28, Z+
00217d 91d5                      	lpm r29, Z+
00217e 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
002180 93d0 28d3                 	sts triangle_arpeggio_macro_loop, r29
002182 91c4                      	lpm r28, Z
002183 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
002185 91ff                      	pop ZH
002186 91ef                      	pop ZL
002187 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
002188 91b0 28cf                 	lds r27, triangle_volume_macro_release
00218a 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00218b f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
00218c 95b3                      	inc r27
00218d 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
00218f 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002191 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002192 f019                      	breq sound_driver_channel2_release_pitch
002193 95b3                      	inc r27
002194 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
002196 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002198 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002199 f019                      	breq sound_driver_channel2_release_hi_pitch
00219a 95b3                      	inc r27
00219b 93b0 28da                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
00219d 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
00219f 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
0021a0 f019                      	breq sound_driver_channel2_release_duty
0021a1 95b3                      	inc r27
0021a2 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
0021a4 91b0 28e7                 	lds r27, triangle_duty_macro_release
0021a6 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0021a7 f019                      	breq sound_driver_channel2_release_exit
0021a8 95b3                      	inc r27
0021a9 93b0 28e5                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
0021ab d019                      	rcall sound_driver_channel2_increment_offset
0021ac cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
0021ad 91e0 2819                 	lds ZL, song_frames
0021af 91f0 281a                 	lds ZH, song_frames+1
0021b1 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0021b3 91b0 281c                 	lds r27, song_frame_offset+1
0021b5 9614                      	adiw r27:r26, 4 //offset for channel 2
0021b6 0fea                      	add ZL, r26
0021b7 1ffb                      	adc ZH, r27
                                 
0021b8 91a5                      	lpm r26, Z+ //load the address of the next pattern
0021b9 91b4                      	lpm r27, Z
0021ba 0faa                      	lsl r26
0021bb 1fbb                      	rol r27
0021bc 93a0 28c5                 	sts triangle_pattern, r26
0021be 93b0 28c6                 	sts triangle_pattern+1, r27
                                 
0021c0 9220 28c9                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0021c2 9220 28ca                 	sts triangle_pattern_offset+1, zero
0021c4 cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
0021c5 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0021c7 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
0021c9 9631                      	adiw Z, 1
0021ca 93e0 28c9                 	sts triangle_pattern_offset, ZL
0021cc 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
0021ce 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0021cf 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0021d1 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
0021d3 9632                      	adiw Z, 2 //increment the pointer twice
0021d4 93e0 28c9                 	sts triangle_pattern_offset, ZL
0021d6 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
0021d8 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
0021d9 95ba                      	dec r27
0021da 93b0 28c8                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
0021dc 91a0 2913                 	lds r26, noise_pattern_delay_rows
0021de 91b0 2914                 	lds r27, noise_pattern_delay_frames
0021e0 9610                      	adiw r27:r26, 0
0021e1 f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
0021e2 c1b9                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
0021e3 91e0 2911                 	lds ZL, noise_pattern //current pattern for noise
0021e5 91f0 2912                 	lds ZH, noise_pattern+1
0021e7 91a0 2915                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
0021e9 91b0 2916                 	lds r27, noise_pattern_offset+1
0021eb 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0021ec 1ffb                      	adc ZH, r27
0021ed 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
0021ee 35b7                      	cpi r27, 0x57
0021ef f408                      	brsh sound_driver_channel3_check_if_volume
0021f0 c096                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
0021f1 36b7                      	cpi r27, 0x67
0021f2 f408                      	brsh sound_driver_channel3_check_if_delay
0021f3 c0b1                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0021f4 3eb3                      	cpi r27, 0xE3
0021f5 f408                      	brsh sound_driver_channel3_check_if_instrument
0021f6 c0b7                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
0021f7 f409                      	brne sound_driver_channel3_check_if_release
0021f8 c0ba                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
0021f9 3eb4                      	cpi r27, 0xE4
0021fa f409                      	brne sound_driver_channel3_check_if_end
0021fb c14b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
0021fc 3fbf                      	cpi r27, 0xFF
0021fd f409                      	brne sound_driver_channel3_check_if_fx
0021fe c16d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
0021ff 9631                      	adiw Z, 1 //point Z to the byte next to the flag
002200 91a4                      	lpm r26, Z //load the fx data into r26
002201 d190                      	rcall sound_driver_channel3_increment_offset_twice
                                 
002202 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
002203 e9e2                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
002204 e6f3                      	ldi ZH, HIGH(channel3_fx << 1)
002205 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
002206 0feb                      	add ZL, r27 //add offset
002207 1df2                      	adc ZH, zero
002208 91c5                      	lpm r28, Z+ //load address bytes
002209 91d4                      	lpm r29, Z
00220a 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00220b 2ffd                      	mov ZH, r29
00220c 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
00220d 93a0 2934                 	sts noise_fx_0xy_sequence, r26
00220f 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
002211 cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
002212 9220 2938                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
002214 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002216 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
002218 93a0 2936                 	sts noise_fx_1xx, r26
00221a cfc8                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
00221b 9220 2936                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
00221d 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
00221f 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
002221 93a0 2938                 	sts noise_fx_2xx, r26
002223 cfbf                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
002224 cfbe                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
002225 2fba                      	mov r27, r26
002226 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002227 95a2                      	swap r26
002228 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002229 93a0 293a                 	sts noise_fx_4xy_speed, r26
00222b 93b0 293b                 	sts noise_fx_4xy_depth, r27
00222d 9220 293c                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
00222f 9220 293d                 	sts noise_fx_4xy_offset, zero
002231 cfb1                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
002232 2fba                      	mov r27, r26
002233 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002234 95a2                      	swap r26
002235 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002236 93a0 293e                 	sts noise_fx_7xy_speed, r26
002238 93b0 293f                 	sts noise_fx_7xy_depth, r27
00223a 9220 2940                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
00223c 9220 2941                 	sts noise_fx_7xy_value, zero //reset the tremelo value
00223e cfa4                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
00223f 93a0 2942                 	sts noise_fx_Axy, r26
002241 cfa1                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002242 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002244 cf9e                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
002245 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002247 cf9b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
002248 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00224a cf98                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
00224b 91b0 2813                 	lds r27, noise_param
00224d 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
00224e 2bba                      	or r27, r26 //move new VVVV bits into noise_param
00224f 93b0 2813                 	sts noise_param, r27
002251 cf91                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002252 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002254 cf8e                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
002255 15a2                      	cp r26, zero
002256 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
002257 91b0 281f                 	lds r27, song_speed
002259 17ab                      	cp r26, r27
00225a f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
00225b 93a0 2943                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00225d e0b1                      	ldi r27, 0x01
00225e 93b0 2913                 	sts noise_pattern_delay_rows, r27
002260 c13e                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
002261 cf81                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
002262 cf80                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
002263 cf7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
002264 cf7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
002265 cf7d                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
002266 93a0 2945                 	sts noise_fx_Pxx_total, r26
002268 cf7a                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Qxy: //note slide up
002269 cf79                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Rxy: //note slide down
00226a cf78                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
00226b 15a2                      	cp r26, zero
00226c f051                      	breq sound_driver_channel3_fx_Sxx_invalid
00226d 91b0 281f                 	lds r27, song_speed
00226f 17ab                      	cp r26, r27
002270 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
002271 93a0 2946                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002273 e0b1                      	ldi r27, 0x01
002274 93b0 2913                 	sts noise_pattern_delay_rows, r27
002276 c128                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
002277 cf6b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
002278 95a6                      	lsr r26
002279 95a7                      	ror r26 //move mode bit to bit 7
00227a 91b0 2814                 	lds r27, noise_period
00227c 77bf                      	andi r27, 0b01111111
00227d 2bba                      	or r27, r26 //store the new noise mode
00227e 93b0 2813                 	sts noise_param, r27
                                 
002280 776f                      	andi noise_sequence_HIGH, 0b01111111
002281 2b6a                      	or noise_sequence_HIGH, r26
002282 cf60                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
002283 cf5f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
002284 cf5e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
002285 cf5d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
002286 cf5c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
002287 93b0 2817                 	sts noise_note, r27
002289 93b0 2818                 	sts noise_adjusted_note, r27
00228b e0a3                      	ldi r26, 0x03
00228c e0b2                      	ldi r27, 0x02
00228d 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
00228f 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
002291 93b0 2926                 	sts noise_pitch_macro_offset, r27
002293 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
002295 93b0 2931                 	sts noise_duty_macro_offset, r27
002297 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
002299 9220 2923                 	sts noise_total_pitch_offset+1, zero
00229b 9220 2929                 	sts noise_total_hi_pitch_offset, zero
00229d 9220 2937                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00229f 9220 2939                 	sts noise_fx_2xx_total, zero
0022a1 9220 293d                 	sts noise_fx_4xy_offset, zero
0022a3 d0e4                      	rcall sound_driver_channel3_increment_offset
0022a4 cf3e                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
0022a5 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0022a6 91a0 2813                 	lds r26, noise_param
0022a8 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0022a9 2bab                      	or r26, r27 //move new VVVV bits into noise_param
0022aa 93a0 2813                 	sts noise_param, r26
0022ac d0db                      	rcall sound_driver_channel3_increment_offset
0022ad cf35                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
0022ae 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0022af 93b0 2913                 	sts noise_pattern_delay_rows, r27
0022b1 d0d6                      	rcall sound_driver_channel3_increment_offset
0022b2 c0ec                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
0022b3 9220 2917                 	sts noise_volume_macro, zero //reset all macro addresses
0022b5 9220 2918                 	sts noise_volume_macro+1, zero
0022b7 9220 291c                 	sts noise_arpeggio_macro, zero
0022b9 9220 291d                 	sts noise_arpeggio_macro+1, zero
0022bb 9220 2924                 	sts noise_pitch_macro, zero
0022bd 9220 2925                 	sts noise_pitch_macro+1, zero
0022bf 9220 292a                 	sts noise_hi_pitch_macro, zero
0022c1 9220 292b                 	sts noise_hi_pitch_macro+1, zero
0022c3 9220 292f                 	sts noise_duty_macro, zero
0022c5 9220 2930                 	sts noise_duty_macro+1, zero
0022c7 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch offset
0022c9 9220 2923                 	sts noise_total_pitch_offset+1, zero
0022cb 9220 2929                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0022cd 9631                      	adiw Z, 1 //point to the byte next to the flag
0022ce 91b4                      	lpm r27, Z //store the instrument offset into r27
0022cf e9ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
0022d0 e1f2                      	ldi ZH, HIGH(instruments)
0022d1 0feb                      	add ZL, r27 //point Z to offsetted instrument
0022d2 1df2                      	adc ZH, zero
0022d3 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0022d4 1fff                      	rol ZH
0022d5 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0022d6 91b4                      	lpm r27, Z
                                 
0022d7 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0022d8 1fbb                      	rol r27
0022d9 2fea                      	mov ZL, r26
0022da 2ffb                      	mov ZH, r27
0022db 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0022dc 9632                      	adiw Z, 2 //point Z to the address of the macro
0022dd e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
0022de 95aa                      	dec r26
0022df f019                      	breq sound_driver_channel3_instrument_change_exit
0022e0 95b6                      	lsr r27
0022e1 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
0022e2 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
0022e3 e0a3                      	ldi r26, 0x03
0022e4 e0b2                      	ldi r27, 0x02
0022e5 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0022e7 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
0022e9 93b0 2926                 	sts noise_pitch_macro_offset, r27
0022eb 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
0022ed 93b0 2931                 	sts noise_duty_macro_offset, r27
0022ef d0a2                      	rcall sound_driver_channel3_increment_offset_twice
0022f0 cef2                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
0022f1 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0022f2 91d5                      	lpm r29, Z+
                                 
0022f3 30a5                      	cpi r26, 5
0022f4 f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
0022f5 30a4                      	cpi r26, 4
0022f6 f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
0022f7 30a3                      	cpi r26, 3
0022f8 f099                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
0022f9 30a2                      	cpi r26, 2
0022fa f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
0022fb c024                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
0022fc 93c0 2917                 	sts noise_volume_macro, r28
0022fe 93d0 2918                 	sts noise_volume_macro+1, r29
002300 d029                      	rcall sound_driver_channel3_instrument_change_read_header
002301 93c0 291b                 	sts noise_volume_macro_release, r28
002303 93d0 291a                 	sts noise_volume_macro_loop, r29
002305 cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
002306 93c0 291c                 	sts noise_arpeggio_macro, r28
002308 93d0 291d                 	sts noise_arpeggio_macro+1, r29
00230a d02a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
00230b cfd2                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
00230c 93c0 2924                 	sts noise_pitch_macro, r28
00230e 93d0 2925                 	sts noise_pitch_macro+1, r29
002310 d019                      	rcall sound_driver_channel3_instrument_change_read_header
002311 93c0 2928                 	sts noise_pitch_macro_release, r28
002313 93d0 2927                 	sts noise_pitch_macro_loop, r29
002315 cfc8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
002316 93c0 292a                 	sts noise_hi_pitch_macro, r28
002318 93d0 292b                 	sts noise_hi_pitch_macro+1, r29
00231a d00f                      	rcall sound_driver_channel3_instrument_change_read_header
00231b 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
00231d 93d0 292d                 	sts noise_hi_pitch_macro_loop, r29
00231f cfbe                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
002320 93c0 292f                 	sts noise_duty_macro, r28
002322 93d0 2930                 	sts noise_duty_macro+1, r29
002324 d005                      	rcall sound_driver_channel3_instrument_change_read_header
002325 93c0 2933                 	sts noise_duty_macro_release, r28
002327 93d0 2932                 	sts noise_duty_macro_loop, r29
002329 cfb4                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
00232a 93ef                      	push ZL
00232b 93ff                      	push ZH
00232c 2fec                      	mov ZL, r28
00232d 2ffd                      	mov ZH, r29
00232e 0fee                      	lsl ZL
00232f 1fff                      	rol ZH
002330 91c5                      	lpm r28, Z+
002331 91d4                      	lpm r29, Z
002332 91ff                      	pop ZH
002333 91ef                      	pop ZL
002334 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
002335 93ef                      	push ZL
002336 93ff                      	push ZH
002337 2fec                      	mov ZL, r28
002338 2ffd                      	mov ZH, r29
002339 0fee                      	lsl ZL
00233a 1fff                      	rol ZH
00233b 91c5                      	lpm r28, Z+
00233c 91d5                      	lpm r29, Z+
00233d 93c0 2920                 	sts noise_arpeggio_macro_release, r28
00233f 93d0 291f                 	sts noise_arpeggio_macro_loop, r29
002341 91c4                      	lpm r28, Z
002342 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
002344 91ff                      	pop ZH
002345 91ef                      	pop ZL
002346 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
002347 91b0 291b                 	lds r27, noise_volume_macro_release
002349 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00234a f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
00234b 95b3                      	inc r27
00234c 93b0 2919                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
00234e 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002350 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002351 f019                      	breq sound_driver_channel3_release_pitch
002352 95b3                      	inc r27
002353 93b0 291e                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
002355 91b0 2928                 	lds r27, noise_pitch_macro_release
002357 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002358 f019                      	breq sound_driver_channel3_release_hi_pitch
002359 95b3                      	inc r27
00235a 93b0 2926                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
00235c 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
00235e 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00235f f019                      	breq sound_driver_channel3_release_duty
002360 95b3                      	inc r27
002361 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
002363 91b0 2933                 	lds r27, noise_duty_macro_release
002365 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002366 f019                      	breq sound_driver_channel3_release_exit
002367 95b3                      	inc r27
002368 93b0 2931                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
00236a d01d                      	rcall sound_driver_channel3_increment_offset
00236b ce77                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
00236c 91e0 2819                 	lds ZL, song_frames
00236e 91f0 281a                 	lds ZH, song_frames+1
002370 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002372 91b0 281c                 	lds r27, song_frame_offset+1
002374 93a0 281b                 	sts song_frame_offset, r26
002376 93b0 281c                 	sts song_frame_offset+1, r27
002378 9616                      	adiw r27:r26, 6 //offset for channel 3
002379 0fea                      	add ZL, r26
00237a 1ffb                      	adc ZH, r27
                                 
00237b 91a5                      	lpm r26, Z+ //load the address of the next pattern
00237c 91b4                      	lpm r27, Z
00237d 0faa                      	lsl r26
00237e 1fbb                      	rol r27
00237f 93a0 2911                 	sts noise_pattern, r26
002381 93b0 2912                 	sts noise_pattern+1, r27
                                 
002383 9220 2915                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002385 9220 2916                 	sts noise_pattern_offset+1, zero
002387 ce5b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
002388 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
00238a 91f0 2916                 	lds ZH, noise_pattern_offset+1
00238c 9631                      	adiw Z, 1
00238d 93e0 2915                 	sts noise_pattern_offset, ZL
00238f 93f0 2916                 	sts noise_pattern_offset+1, ZH
002391 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002392 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002394 91f0 2916                 	lds ZH, noise_pattern_offset+1
002396 9632                      	adiw Z, 2 //increment the pointer twice
002397 93e0 2915                 	sts noise_pattern_offset, ZL
002399 93f0 2916                 	sts noise_pattern_offset+1, ZH
00239b 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
00239c 95ba                      	dec r27
00239d 93b0 2914                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
00239f 91a0 294a                 	lds r26, dpcm_pattern_delay_rows
0023a1 91b0 294b                 	lds r27, dpcm_pattern_delay_frames
0023a3 9610                      	adiw r27:r26, 0
0023a4 f009                      	breq sound_driver_channel4_main //if the pattern delay is 0, proceed with sound driver procedures
0023a5 c0bd                      	rjmp sound_driver_channel4_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel4_main:
0023a6 91e0 2948                 	lds ZL, dpcm_pattern //current pattern for dpcm
0023a8 91f0 2949                 	lds ZH, dpcm_pattern+1
0023aa 91a0 294c                 	lds r26, dpcm_pattern_offset //current offset in the pattern for dpcm
0023ac 91b0 294d                 	lds r27, dpcm_pattern_offset+1
0023ae 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0023af 1ffb                      	adc ZH, r27
0023b0 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel4_check_if_note: //check if data is a note (0x00 - 0x56)
0023b1 35b7                      	cpi r27, 0x57
0023b2 f408                      	brsh sound_driver_channel4_check_if_volume
0023b3 c056                      	rjmp sound_driver_channel4_note
                                 sound_driver_channel4_check_if_volume: //check if data is volume (0x57-0x66)
0023b4 36b7                      	cpi r27, 0x67
0023b5 f408                      	brsh sound_driver_channel4_check_if_delay
0023b6 c071                      	rjmp sound_driver_channel4_volume
                                 sound_driver_channel4_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0023b7 3eb3                      	cpi r27, 0xE3
0023b8 f408                      	brsh sound_driver_channel4_check_if_instrument
0023b9 c070                      	rjmp sound_driver_channel4_delay
                                 sound_driver_channel4_check_if_instrument: //check for instrument flag (0xE3)
0023ba f409                      	brne sound_driver_channel4_check_if_release
0023bb c073                      	rjmp sound_driver_channel4_instrument_change 
                                 sound_driver_channel4_check_if_release: //check for note release flag (0xE4)
0023bc 3eb4                      	cpi r27, 0xE4
0023bd f409                      	brne sound_driver_channel4_check_if_end
0023be c072                      	rjmp sound_driver_channel4_release
                                 sound_driver_channel4_check_if_end:
0023bf 3fbf                      	cpi r27, 0xFF
0023c0 f409                      	brne sound_driver_channel4_check_if_fx
0023c1 c071                      	rjmp sound_driver_channel4_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel4_check_if_fx: //fx flags (0xE5 - 0xFE)
0023c2 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0023c3 91a4                      	lpm r26, Z //load the fx data into r26
0023c4 d094                      	rcall sound_driver_channel4_increment_offset_twice
                                 
0023c5 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0023c6 ece6                      	ldi ZL, LOW(channel4_fx << 1) //load in note table
0023c7 e6f3                      	ldi ZH, HIGH(channel4_fx << 1)
0023c8 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0023c9 0feb                      	add ZL, r27 //add offset
0023ca 1df2                      	adc ZH, zero
0023cb 91c5                      	lpm r28, Z+ //load address bytes
0023cc 91d4                      	lpm r29, Z
0023cd 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0023ce 2ffd                      	mov ZH, r29
0023cf 9409                      	ijmp
                                 
                                 
                                 
                                 sound_driver_channel4_fx_0xy: //arpeggio
0023d0 cfd5                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_1xx: //pitch slide up
0023d1 cfd4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_2xx: //pitch slide down
0023d2 cfd3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_3xx: //automatic portamento
0023d3 cfd2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_4xy: //vibrato
0023d4 cfd1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_7xy: //tremelo
0023d5 cfd0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Axy: //volume slide
0023d6 cfcf                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel4_fx_Bxx:
0023d7 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0023d9 cfcc                      	rjmp sound_driver_channel4_main
                                 
                                 //HALT
                                 sound_driver_channel4_fx_Cxx:
0023da 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0023dc cfc9                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel4_fx_Dxx:
0023dd 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0023df cfc6                      	rjmp sound_driver_channel4_main
                                 
                                 sound_driver_channel4_fx_Exx: //volume
0023e0 cfc5                      	rjmp sound_driver_channel4_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel4_fx_Fxx:
0023e1 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0023e3 cfc2                      	rjmp sound_driver_channel4_main
                                 
                                 //DELAY
                                 sound_driver_channel4_fx_Gxx:
0023e4 15a2                      	cp r26, zero
0023e5 f051                      	breq sound_driver_channel4_fx_Gxx_invalid
0023e6 91b0 281f                 	lds r27, song_speed
0023e8 17ab                      	cp r26, r27
0023e9 f430                      	brsh sound_driver_channel4_fx_Gxx_invalid
0023ea 93a0 2952                 	sts dpcm_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0023ec e0b1                      	ldi r27, 0x01
0023ed 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
0023ef c076                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Gxx_invalid:
0023f0 cfb5                      	rjmp sound_driver_channel4_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Hxy: //hardware sweep up
0023f1 cfb4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixy: //hardware sweep down
0023f2 cfb3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Hxx: //FDS modulation depth
0023f3 cfb2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixx: //FDS modulation speed
0023f4 cfb1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Pxx: //fine pitch
0023f5 cfb0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Qxy: //note slide up
0023f6 cfaf                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Rxy: //note slide down
0023f7 cfae                      	rjmp sound_driver_channel4_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel4_fx_Sxx:
0023f8 15a2                      	cp r26, zero
0023f9 f051                      	breq sound_driver_channel4_fx_Sxx_invalid
0023fa 91b0 281f                 	lds r27, song_speed
0023fc 17ab                      	cp r26, r27
0023fd f430                      	brsh sound_driver_channel4_fx_Sxx_invalid
0023fe 93a0 2954                 	sts dpcm_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002400 e0b1                      	ldi r27, 0x01
002401 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
002403 c062                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Sxx_invalid:
002404 cfa1                      	rjmp sound_driver_channel4_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Vxx: //duty
002405 cfa0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Wxx: //DPCM sample speed
002406 cf9f                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Xxx: //DPCM sample retrigger
002407 cf9e                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Yxx: //DPCM sample offset
002408 cf9d                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Zxx: //DPCM sample delta counter
002409 cf9c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_note:
00240a 9631                      	adiw Z, 1 //point to the byte next to the flag
00240b 90f4                      	lpm dpcm_period, Z //store the DPCM sample rate
00240c e7e1                      	ldi ZL, LOW(dpcm_samples) //point Z to dpcm_samples table
00240d e1f0                      	ldi ZH, HIGH(dpcm_samples)
00240e 0feb                      	add ZL, r27 //point Z to offsetted sample
00240f 1df2                      	adc ZH, zero
002410 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the samples's address
002411 1fff                      	rol ZH
002412 91a5                      	lpm r26, Z+ //r26:r27 now points to the sample
002413 91b4                      	lpm r27, Z
                                 
002414 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the sample's data
002415 1fbb                      	rol r27
002416 2fea                      	mov ZL, r26
002417 2ffb                      	mov ZH, r27
002418 91b4                      	lpm r27, Z //get sample length
002419 ef70                      	ldi dpcm_length_LOW, 0b11110000
00241a e08f                      	ldi dpcm_length_HIGH, 0b00001111
00241b 95b2                      	swap r27
00241c 237b                      	and dpcm_length_LOW, r27
00241d 238b                      	and dpcm_length_HIGH, r27
                                 
00241e 93e0 294e                 	sts dpcm_sample, ZL //store address to sample
002420 93f0 294f                 	sts dpcm_sample+1, ZH
002422 9230 2950                 	sts dpcm_sample_offset, one //start sample offset at 1 (0th byte was used for sample length)
002424 9220 2951                 	sts dpcm_sample_offset+1, zero
                                 
002426 d032                      	rcall sound_driver_channel4_increment_offset_twice
002427 cf7e                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_volume:
002428 d026                      	rcall sound_driver_channel4_increment_offset
002429 cf7c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_delay:
00242a 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00242b 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
00242d d021                      	rcall sound_driver_channel4_increment_offset
00242e c037                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel4_instrument_change:
00242f d029                      	rcall sound_driver_channel4_increment_offset_twice
002430 cf75                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_release:
002431 d01d                      	rcall sound_driver_channel4_increment_offset
002432 cf73                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_next_pattern:
002433 91e0 2819                 	lds ZL, song_frames
002435 91f0 281a                 	lds ZH, song_frames+1
002437 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002439 91b0 281c                 	lds r27, song_frame_offset+1
00243b 93a0 281b                 	sts song_frame_offset, r26
00243d 93b0 281c                 	sts song_frame_offset+1, r27
00243f 9618                      	adiw r27:r26, 8 //offset for channel 4
002440 0fea                      	add ZL, r26
002441 1ffb                      	adc ZH, r27
                                 
002442 91a5                      	lpm r26, Z+ //load the address of the next pattern
002443 91b4                      	lpm r27, Z
002444 0faa                      	lsl r26
002445 1fbb                      	rol r27
002446 93a0 2948                 	sts dpcm_pattern, r26
002448 93b0 2949                 	sts dpcm_pattern+1, r27
                                 
00244a 9220 294c                 	sts dpcm_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00244c 9220 294d                 	sts dpcm_pattern_offset+1, zero
00244e cf57                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_increment_offset:
00244f 91e0 294c                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002451 91f0 294d                 	lds ZH, dpcm_pattern_offset+1
002453 9631                      	adiw Z, 1
002454 93e0 294c                 	sts dpcm_pattern_offset, ZL
002456 93f0 294d                 	sts dpcm_pattern_offset+1, ZH
002458 9508                      	ret
                                 
                                 sound_driver_channel4_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002459 91e0 294c                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
00245b 91f0 294d                 	lds ZH, dpcm_pattern_offset+1
00245d 9632                      	adiw Z, 2 //increment the pointer twice
00245e 93e0 294c                 	sts dpcm_pattern_offset, ZL
002460 93f0 294d                 	sts dpcm_pattern_offset+1, ZH
002462 9508                      	ret
                                 
                                 sound_driver_channel4_decrement_frame_delay:
002463 95ba                      	dec r27
002464 93b0 294b                 	sts dpcm_pattern_delay_frames, r27
                                 sound_driver_calculate_delays:
002466 91f0 281f                 	lds r31, song_speed
002468 2fef                      	mov r30, r31
002469 50e1                      	subi r30, 1
                                 
                                 sound_driver_calculate_delays_pulse1:
00246a 91a0 2826                 	lds r26, pulse1_pattern_delay_frames
00246c 11a2                      	cpse r26, zero
00246d c042                      	rjmp sound_driver_calculate_delays_pulse2
00246e c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
00246f 2faf                      	mov r26, r31 //move the speed to r26
002470 91b0 2825                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002472 15b2                      	cp r27, zero
002473 f409                      	brne PC+2
002474 c03b                      	rjmp sound_driver_calculate_delays_pulse2
002475 95ba                      	dec r27
002476 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
002478 11b2                      	cpse r27, zero
002479 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
00247a 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
00247b efbf                      	ldi r27, 0xFF
00247c 91c0 2872                 	lds r28, pulse1_fx_Sxx_pre
00247e 91d0 2873                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002480 17cb                      	cp r28, r27
002481 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002482 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
002483 17db                      	cp r29, r27
002484 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
002485 c012                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
002486 91c0 2860                 	lds r28, pulse1_fx_Gxx_pre
002488 91d0 2861                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
00248a 17cb                      	cp r28, r27
00248b f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
00248c c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
00248d 17db                      	cp r29, r27
00248e f0f9                      	breq sound_driver_calculate_delays_pulse1_store
00248f c017                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
002490 93b0 2872                 	sts pulse1_fx_Sxx_pre, r27
002492 93c0 2873                 	sts pulse1_fx_Sxx_post, r28
002494 95ca                      	dec r28
002495 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
002497 c018                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
002498 93b0 2873                 	sts pulse1_fx_Sxx_post, r27
00249a 1bed                      	sub r30, r29 //(song speed)-1-Sxx
00249b 2fae                      	mov r26, r30
00249c 2fef                      	mov r30, r31
00249d 50e1                      	subi r30, 1
00249e c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
00249f 93b0 2860                 	sts pulse1_fx_Gxx_pre, r27
0024a1 93c0 2861                 	sts pulse1_fx_Gxx_post, r28
0024a3 95ca                      	dec r28
0024a4 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
0024a6 c009                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
0024a7 93b0 2861                 	sts pulse1_fx_Gxx_post, r27
0024a9 1bed                      	sub r30, r29 //(song speed)-1-Gxx
0024aa 2fae                      	mov r26, r30
0024ab 2fef                      	mov r30, r31
0024ac 50e1                      	subi r30, 1
0024ad c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
0024ae 93a0 2826                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
0024b0 91a0 2877                 	lds r26, pulse2_pattern_delay_frames
0024b2 11a2                      	cpse r26, zero
0024b3 c042                      	rjmp sound_driver_calculate_delays_triangle
0024b4 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
0024b5 2faf                      	mov r26, r31 //move the speed to r26
0024b6 91b0 2876                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
0024b8 15b2                      	cp r27, zero
0024b9 f409                      	brne PC+2
0024ba c03b                      	rjmp sound_driver_calculate_delays_triangle
0024bb 95ba                      	dec r27
0024bc 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
0024be 11b2                      	cpse r27, zero
0024bf c034                      	rjmp sound_driver_calculate_delays_pulse2_store
0024c0 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
0024c1 efbf                      	ldi r27, 0xFF
0024c2 91c0 28c3                 	lds r28, pulse2_fx_Sxx_pre
0024c4 91d0 28c4                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
0024c6 17cb                      	cp r28, r27
0024c7 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
0024c8 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
0024c9 17db                      	cp r29, r27
0024ca f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
0024cb c012                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
0024cc 91c0 28b1                 	lds r28, pulse2_fx_Gxx_pre
0024ce 91d0 28b2                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
0024d0 17cb                      	cp r28, r27
0024d1 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
0024d2 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
0024d3 17db                      	cp r29, r27
0024d4 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
0024d5 c017                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
0024d6 93b0 28c3                 	sts pulse2_fx_Sxx_pre, r27
0024d8 93c0 28c4                 	sts pulse2_fx_Sxx_post, r28
0024da 95ca                      	dec r28
0024db 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
0024dd cfd2                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
0024de 93b0 28c4                 	sts pulse2_fx_Sxx_post, r27
0024e0 1bed                      	sub r30, r29 //(song speed)-1-Sxx
0024e1 2fae                      	mov r26, r30
0024e2 2fef                      	mov r30, r31
0024e3 50e1                      	subi r30, 1
0024e4 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
0024e5 93b0 28b1                 	sts pulse2_fx_Gxx_pre, r27
0024e7 93c0 28b2                 	sts pulse2_fx_Gxx_post, r28
0024e9 95ca                      	dec r28
0024ea 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
0024ec cfc3                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
0024ed 93b0 28b2                 	sts pulse2_fx_Gxx_post, r27 //(song speed)-1-Gxx
0024ef 1bed                      	sub r30, r29
0024f0 2fae                      	mov r26, r30
0024f1 2fef                      	mov r30, r31
0024f2 50e1                      	subi r30, 1
0024f3 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
0024f4 93a0 2877                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
0024f6 91a0 28c8                 	lds r26, triangle_pattern_delay_frames
0024f8 11a2                      	cpse r26, zero
0024f9 c042                      	rjmp sound_driver_calculate_delays_noise
0024fa c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
0024fb 2faf                      	mov r26, r31 //move the speed to r26
0024fc 91b0 28c7                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
0024fe 15b2                      	cp r27, zero
0024ff f409                      	brne PC+2
002500 c03b                      	rjmp sound_driver_calculate_delays_noise
002501 95ba                      	dec r27
002502 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
002504 11b2                      	cpse r27, zero
002505 c034                      	rjmp sound_driver_calculate_delays_triangle_store
002506 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
002507 efbf                      	ldi r27, 0xFF
002508 91c0 290f                 	lds r28, triangle_fx_Sxx_pre
00250a 91d0 2910                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
00250c 17cb                      	cp r28, r27
00250d f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
00250e c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
00250f 17db                      	cp r29, r27
002510 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
002511 c012                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
002512 91c0 28fd                 	lds r28, triangle_fx_Gxx_pre
002514 91d0 28fe                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
002516 17cb                      	cp r28, r27
002517 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
002518 c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
002519 17db                      	cp r29, r27
00251a f0f9                      	breq sound_driver_calculate_delays_triangle_store
00251b c017                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
00251c 93b0 290f                 	sts triangle_fx_Sxx_pre, r27
00251e 93c0 2910                 	sts triangle_fx_Sxx_post, r28
002520 95ca                      	dec r28
002521 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
002523 c018                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
002524 93b0 2910                 	sts triangle_fx_Sxx_post, r27
002526 1bed                      	sub r30, r29 //(song speed)-1-Sxx
002527 2fae                      	mov r26, r30
002528 2fef                      	mov r30, r31
002529 50e1                      	subi r30, 1
00252a c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
00252b 93b0 28fd                 	sts triangle_fx_Gxx_pre, r27
00252d 93c0 28fe                 	sts triangle_fx_Gxx_post, r28
00252f 95ca                      	dec r28
002530 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
002532 c009                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
002533 93b0 28fe                 	sts triangle_fx_Gxx_post, r27 //(song speed)-1-Gxx
002535 1bed                      	sub r30, r29
002536 2fae                      	mov r26, r30
002537 2fef                      	mov r30, r31
002538 50e1                      	subi r30, 1
002539 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
00253a 93a0 28c8                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
00253c 91a0 2914                 	lds r26, noise_pattern_delay_frames
00253e 11a2                      	cpse r26, zero
00253f c042                      	rjmp sound_driver_calculate_delays_dpcm
002540 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
002541 2faf                      	mov r26, r31 //move the speed to r26
002542 91b0 2913                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
002544 15b2                      	cp r27, zero
002545 f409                      	brne PC+2
002546 c03b                      	rjmp sound_driver_calculate_delays_dpcm
002547 95ba                      	dec r27
002548 93b0 2913                 	sts noise_pattern_delay_rows, r27
00254a 11b2                      	cpse r27, zero
00254b c034                      	rjmp sound_driver_calculate_delays_noise_store
00254c 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
00254d efbf                      	ldi r27, 0xFF
00254e 91c0 2946                 	lds r28, noise_fx_Sxx_pre
002550 91d0 2947                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
002552 17cb                      	cp r28, r27
002553 f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
002554 c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
002555 17db                      	cp r29, r27
002556 f009                      	breq sound_driver_calculate_delays_noise_Gxx
002557 c012                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
002558 91c0 2943                 	lds r28, noise_fx_Gxx_pre
00255a 91d0 2944                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
00255c 17cb                      	cp r28, r27
00255d f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
00255e c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
00255f 17db                      	cp r29, r27
002560 f0f9                      	breq sound_driver_calculate_delays_noise_store
002561 c017                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
002562 93b0 2946                 	sts noise_fx_Sxx_pre, r27
002564 93c0 2947                 	sts noise_fx_Sxx_post, r28
002566 95ca                      	dec r28
002567 93c0 2914                 	sts noise_pattern_delay_frames, r28
002569 c018                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
00256a 93b0 2947                 	sts noise_fx_Sxx_post, r27
00256c 1bed                      	sub r30, r29 //(song speed)-1-Sxx
00256d 2fae                      	mov r26, r30
00256e 2fef                      	mov r30, r31
00256f 50e1                      	subi r30, 1
002570 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002571 93b0 2943                 	sts noise_fx_Gxx_pre, r27
002573 93c0 2944                 	sts noise_fx_Gxx_post, r28
002575 95ca                      	dec r28
002576 93c0 2914                 	sts noise_pattern_delay_frames, r28
002578 c009                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
002579 93b0 2944                 	sts noise_fx_Gxx_post, r27 //(song speed)-1-Gxx
00257b 1bed                      	sub r30, r29
00257c 2fae                      	mov r26, r30
00257d 2fef                      	mov r30, r31
00257e 50e1                      	subi r30, 1
00257f c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
002580 93a0 2914                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
002582 91a0 294b                 	lds r26, dpcm_pattern_delay_frames
002584 11a2                      	cpse r26, zero
002585 c042                      	rjmp sound_driver_instrument_fx_routine
002586 c000                      	rjmp sound_driver_calculate_delays_dpcm_main
                                 
                                 sound_driver_calculate_delays_dpcm_main:
002587 2faf                      	mov r26, r31 //move the speed to r26
002588 91b0 294a                 	lds r27, dpcm_pattern_delay_rows //decrement the delay rows
00258a 15b2                      	cp r27, zero
00258b f409                      	brne PC+2
00258c c03b                      	rjmp sound_driver_instrument_fx_routine
00258d 95ba                      	dec r27
00258e 93b0 294a                 	sts dpcm_pattern_delay_rows, r27
002590 11b2                      	cpse r27, zero
002591 c034                      	rjmp sound_driver_calculate_delays_dpcm_store
002592 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx:
002593 efbf                      	ldi r27, 0xFF
002594 91c0 2954                 	lds r28, dpcm_fx_Sxx_pre
002596 91d0 2955                 	lds r29, dpcm_fx_Sxx_post
                                 sound_driver_calculate_delays_dpcm_Sxx_check_pre:
002598 17cb                      	cp r28, r27
002599 f009                      	breq sound_driver_calculate_delays_dpcm_Sxx_check_post
00259a c00d                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_pre
                                 sound_driver_calculate_delays_dpcm_Sxx_check_post:
00259b 17db                      	cp r29, r27
00259c f009                      	breq sound_driver_calculate_delays_dpcm_Gxx
00259d c012                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx:
00259e 91c0 2952                 	lds r28, dpcm_fx_Gxx_pre
0025a0 91d0 2953                 	lds r29, dpcm_fx_Gxx_post
                                 sound_driver_calculate_delays_dpcm_Gxx_check_pre:
0025a2 17cb                      	cp r28, r27
0025a3 f009                      	breq sound_driver_calculate_delays_dpcm_Gxx_check_post
0025a4 c012                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_pre
                                 sound_driver_calculate_delays_dpcm_Gxx_check_post:
0025a5 17db                      	cp r29, r27
0025a6 f0f9                      	breq sound_driver_calculate_delays_dpcm_store
0025a7 c017                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_pre:
0025a8 93b0 2954                 	sts dpcm_fx_Sxx_pre, r27
0025aa 93c0 2955                 	sts dpcm_fx_Sxx_post, r28
0025ac 95ca                      	dec r28
0025ad 93c0 294b                 	sts dpcm_pattern_delay_frames, r28
0025af c018                      	rjmp sound_driver_instrument_fx_routine
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_post:
0025b0 93b0 2955                 	sts dpcm_fx_Sxx_post, r27
0025b2 1bed                      	sub r30, r29 //(song speed)-1-Sxx
0025b3 2fae                      	mov r26, r30
0025b4 2fef                      	mov r30, r31
0025b5 50e1                      	subi r30, 1
0025b6 c00f                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx_pre:
0025b7 93b0 2952                 	sts dpcm_fx_Gxx_pre, r27
0025b9 93c0 2953                 	sts dpcm_fx_Gxx_post, r28
0025bb 95ca                      	dec r28
0025bc 93c0 294b                 	sts dpcm_pattern_delay_frames, r28
0025be c009                      	rjmp sound_driver_instrument_fx_routine
                                 	
                                 sound_driver_calculate_delays_dpcm_Gxx_post:
0025bf 93b0 2953                 	sts dpcm_fx_Gxx_post, r27 //(song speed)-1-Gxx
0025c1 1bed                      	sub r30, r29
0025c2 2fae                      	mov r26, r30
0025c3 2fef                      	mov r30, r31
0025c4 50e1                      	subi r30, 1
0025c5 c000                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_store:
0025c6 93a0 294b                 	sts dpcm_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
0025c8 91e0 2829                 	lds ZL, pulse1_volume_macro
0025ca 91f0 282a                 	lds ZH, pulse1_volume_macro+1
0025cc 9630                      	adiw Z, 0
0025cd f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0025ce 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0025cf 1fff                      	rol ZH
0025d0 91a0 282b                 	lds r26, pulse1_volume_macro_offset
0025d2 0fea                      	add ZL, r26
0025d3 1df2                      	adc ZH, zero
                                 
0025d4 91b0 282d                 	lds r27, pulse1_volume_macro_release
0025d6 17ba                      	cp r27, r26
0025d7 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0025d8 91a0 282c                 	lds r26, pulse1_volume_macro_loop
0025da 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025db f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025dc c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0025dd 95a3                      	inc r26 //increment the macro offset
0025de 93a0 282b                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0025e0 91b4                      	lpm r27, Z //load volume data into r27
0025e1 3fbf                      	cpi r27, 0xFF //check for macro end flag
0025e2 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0025e3 91b0 282d                 	lds r27, pulse1_volume_macro_release
0025e5 3fbf                      	cpi r27, 0xFF
0025e6 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0025e7 91b0 282c                 	lds r27, pulse1_volume_macro_loop //load the loop index
0025e9 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0025eb cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0025ec 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0025ed 93a0 282b                 	sts pulse1_volume_macro_offset, r26
0025ef cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0025f0 efea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0025f1 e6f3                      	ldi ZH, HIGH(volumes << 1)
0025f2 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0025f3 0feb                      	add ZL, r27 //add offset to the table
0025f4 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0025f5 91b0 2800                 	lds r27, pulse1_param //load main volume
0025f7 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0025f8 91a0 285e                 	lds r26, pulse1_fx_7xy_value
0025fa 30a0                      	cpi r26, 0x00
0025fb f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0025fc 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025fd 1df2                      	adc ZH, zero
0025fe 91b4                      	lpm r27, Z
0025ff 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002601 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002602 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002604 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002605 91a0 285e                 	lds r26, pulse1_fx_7xy_value
002607 30a0                      	cpi r26, 0x00
002608 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
002609 93b0 2806                 	sts pulse1_output_volume, r27
00260b c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
00260c 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00260d f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00260e f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
00260f 0feb                      	add ZL, r27 //offset the volume table by the main volume
002610 1df2                      	adc ZH, zero
002611 91b4                      	lpm r27, Z
002612 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002614 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002615 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002616 0feb                      	add ZL, r27 //offset the volume table by the main volume
002617 1df2                      	adc ZH, zero
002618 91b4                      	lpm r27, Z
002619 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00261b c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
00261c 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00261d f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
00261e f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
00261f 93b0 2806                 	sts pulse1_output_volume, r27
002621 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002622 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002623 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002625 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
002627 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
002629 9630                      	adiw Z, 0
00262a f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00262b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00262c 1fff                      	rol ZH
00262d 91a0 2830                 	lds r26, pulse1_arpeggio_macro_offset
00262f 0fea                      	add ZL, r26
002630 1df2                      	adc ZH, zero
                                 
002631 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
002633 17ba                      	cp r27, r26
002634 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002635 91a0 2831                 	lds r26, pulse1_arpeggio_macro_loop
002637 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002638 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002639 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00263a 95a3                      	inc r26 //increment the macro offset
00263b 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00263d 91b4                      	lpm r27, Z //load arpeggio data into r27
00263e 38b0                      	cpi r27, 0x80 //check for macro end flag
00263f f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002640 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002641 50a1                      	subi r26, 1 //keep the offset at the end flag
002642 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
002644 91b0 2833                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002646 30b1                      	cpi r27, 0x01
002647 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
002648 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
00264a 3fbf                      	cpi r27, 0xFF
00264b f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
00264c 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop
00264e 3fbf                      	cpi r27, 0xFF
00264f f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002650 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002651 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
002653 3fbf                      	cpi r27, 0xFF
002654 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
002655 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
002657 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002658 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
002659 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
00265b 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
00265d 9620                      	adiw r29:r28, 0
00265e f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00265f 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002660 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
002662 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002663 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
002665 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
002666 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
002668 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
00266a 9620                      	adiw r29:r28, 0 //check for 0xy effect
00266b f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
00266c 95d6                      	lsr r29
00266d 95c7                      	ror r28
00266e 95d7                      	ror r29
00266f 95c7                      	ror r28
002670 95d7                      	ror r29
002671 95c7                      	ror r28
002672 95d7                      	ror r29
002673 95c7                      	ror r28
002674 95d7                      	ror r29
002675 95d2                      	swap r29
                                 
002676 93c0 2846                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
002678 93d0 2847                 	sts pulse1_fx_0xy_sequence+1, r29
00267a 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00267b 91a0 2807                 	lds r26, pulse1_note //load the current note index
00267d 0fac                      	add r26, r28 //add the note offset
00267e c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00267f 91a0 2807                 	lds r26, pulse1_note //load the current note index
002681 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002682 9220 2834                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002684 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
002686 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
002688 91a0 2833                 	lds r26, pulse1_arpeggio_macro_mode
00268a 30a1                      	cpi r26, 0x01 //absolute mode
00268b f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
00268c f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
00268d c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
00268e 91a0 2807                 	lds r26, pulse1_note //load the current note index
002690 0fab                      	add r26, r27 //offset the note with the arpeggio data
002691 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002692 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002693 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002694 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002695 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002696 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
002697 fda7                      	sbrc r26, 7 //check if result is negative
002698 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002699 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
00269a 2fab                      	mov r26, r27 //move the arpeggio data into r26
00269b c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
00269c 91a0 2807                 	lds r26, pulse1_note //load the current note index
00269e 0fab                      	add r26, r27 //offset the note with the arpeggio data
00269f fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0026a0 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0026a1 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0026a3 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0026a4 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0026a5 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0026a6 93a0 2807                 	sts pulse1_note, r26
0026a8 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
0026a9 fda7                      	sbrc r26, 7 //check if result is negative
0026aa e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0026ab 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
0026ad e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0026ae e0f0                      	ldi ZH, HIGH(note_table << 1)
0026af 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0026b0 0fea                      	add ZL, r26 //add offset
0026b1 1df2                      	adc ZH, zero
0026b2 91a5                      	lpm r26, Z+ //load bytes
0026b3 91b4                      	lpm r27, Z
0026b4 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
0026b6 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
0026b8 93a0 2852                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0026ba 93b0 2853                 	sts pulse1_fx_3xx_target+1, r27
0026bc c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
0026bd 91e0 2836                 	lds ZL, pulse1_pitch_macro
0026bf 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
0026c1 9630                      	adiw Z, 0
0026c2 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
0026c3 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
0026c4 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0026c5 1fff                      	rol ZH
0026c6 91a0 2838                 	lds r26, pulse1_pitch_macro_offset
0026c8 0fea                      	add ZL, r26
0026c9 1df2                      	adc ZH, zero
                                 
0026ca 91b0 283a                 	lds r27, pulse1_pitch_macro_release
0026cc 17ba                      	cp r27, r26
0026cd f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0026ce 91a0 2839                 	lds r26, pulse1_pitch_macro_loop
0026d0 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026d1 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026d2 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0026d3 95a3                      	inc r26 //increment the macro offset
0026d4 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0026d6 91b4                      	lpm r27, Z //load pitch data into r27
0026d7 38b0                      	cpi r27, 0x80 //check for macro end flag
0026d8 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0026d9 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0026da 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
0026dc 91b0 283a                 	lds r27, pulse1_pitch_macro_release
0026de 3fbf                      	cpi r27, 0xFF
0026df f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0026e0 91b0 2839                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0026e2 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0026e3 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0026e4 93b0 2838                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0026e6 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0026e7 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0026e8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026e9 937f                      	push r23
0026ea 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0026eb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026ec 0367                      	mulsu r22, r23
0026ed 917f                      	pop r23
0026ee 916f                      	pop r22
                                 
0026ef 9416                      	lsr r1 //shift out the fractional bits
0026f0 9407                      	ror r0
0026f1 9416                      	lsr r1
0026f2 9407                      	ror r0
0026f3 9416                      	lsr r1
0026f4 9407                      	ror r0
0026f5 9416                      	lsr r1
0026f6 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
0026f7 fe13                      	sbrs r1, 3 //check if result was a negative number
0026f8 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0026f9 efc0                      	ldi r28, 0xF0
0026fa 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
0026fb 70b7                      	andi r27, 0b00000111
0026fc f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
0026fd e0b1                      	ldi r27, 0x01
0026fe 0e0b                      	add r0, r27
0026ff 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002700 91a0 2834                 	lds r26, pulse1_total_pitch_offset
002702 91b0 2835                 	lds r27, pulse1_total_pitch_offset+1
002704 0e0a                      	add r0, r26
002705 1e1b                      	adc r1, r27
002706 9200 2834                 	sts pulse1_total_pitch_offset, r0
002708 9210 2835                 	sts pulse1_total_pitch_offset+1, r1
00270a 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00270c 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00270e 0da0                      	add r26, r0 //offset the timer values
00270f 1db1                      	adc r27, r1
                                 	
002710 91c0 284a                 	lds r28, pulse1_fx_1xx_total
002712 91d0 284b                 	lds r29, pulse1_fx_1xx_total+1
002714 1bac                      	sub r26, r28
002715 0bbd                      	sbc r27, r29
002716 91c0 284e                 	lds r28, pulse1_fx_2xx_total
002718 91d0 284f                 	lds r29, pulse1_fx_2xx_total+1
00271a 0fac                      	add r26, r28
00271b 1fbd                      	adc r27, r29
00271c 91c0 2862                 	lds r28, pulse1_fx_Pxx_total
00271e 91d0 2863                 	lds r29, pulse1_fx_Pxx_total+1
002720 0fac                      	add r26, r28
002721 1fbd                      	adc r27, r29
002722 91c0 2869                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002724 91d0 286a                 	lds r29, pulse1_fx_Qxy_total_offset+1
002726 1bac                      	sub r26, r28
002727 0bbd                      	sbc r27, r29
002728 91c0 2870                 	lds r28, pulse1_fx_Rxy_total_offset
00272a 91d0 2871                 	lds r29, pulse1_fx_Rxy_total_offset+1
00272c 0fac                      	add r26, r28
00272d 1fbd                      	adc r27, r29
                                 
00272e e5c9                      	ldi r28, 0x59
00272f e0d0                      	ldi r29, 0x00
002730 17ac                      	cp r26, r28
002731 07bd                      	cpc r27, r29
002732 f030                      	brlo sound_driver_instrument_routine_channel0_pitch_min
                                 
002733 e5ca                      	ldi r28, 0x5A
002734 e5d9                      	ldi r29, 0x59
002735 17ac                      	cp r26, r28
002736 07bd                      	cpc r27, r29
002737 f420                      	brsh sound_driver_instrument_routine_channel0_pitch_max
002738 c006                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_min:
002739 e5c9                      	ldi r28, 0x59
00273a e0d0                      	ldi r29, 0x00
00273b c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_max:
00273c e5c9                      	ldi r28, 0x59
00273d e5d9                      	ldi r29, 0x59
00273e c000                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_store:
00273f 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002741 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
002743 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
002745 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
002747 9630                      	adiw Z, 0
002748 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
002749 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
00274a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00274b 1fff                      	rol ZH
00274c 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_offset
00274e 0fea                      	add ZL, r26
00274f 1df2                      	adc ZH, zero
                                 
002750 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
002752 17ba                      	cp r27, r26
002753 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002754 91a0 283f                 	lds r26, pulse1_hi_pitch_macro_loop
002756 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002757 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002758 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
002759 95a3                      	inc r26 //increment the macro offset
00275a 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
00275c 91b4                      	lpm r27, Z //load hi pitch data into r27
00275d 38b0                      	cpi r27, 0x80 //check for macro end flag
00275e f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
00275f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002760 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
002762 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
002764 3fbf                      	cpi r27, 0xFF
002765 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
002766 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
002768 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002769 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00276a 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
00276c cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
00276d 91b0 283b                 	lds r27, pulse1_total_hi_pitch_offset
00276f c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
002770 91a0 283b                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
002772 0fba                      	add r27, r26
002773 93b0 283b                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
002775 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002776 937f                      	push r23
002777 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002778 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002779 0367                      	mulsu r22, r23
00277a 917f                      	pop r23
00277b 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
00277c 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00277e 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002780 0da0                      	add r26, r0 //offset the timer values
002781 1db1                      	adc r27, r1
002782 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002784 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
002786 91e0 2841                 	lds ZL, pulse1_duty_macro
002788 91f0 2842                 	lds ZH, pulse1_duty_macro+1
00278a 9630                      	adiw Z, 0
00278b f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
00278c 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00278d 1fff                      	rol ZH
00278e 91a0 2843                 	lds r26, pulse1_duty_macro_offset
002790 0fea                      	add ZL, r26
002791 1df2                      	adc ZH, zero
                                 
002792 91b0 2845                 	lds r27, pulse1_duty_macro_release
002794 17ba                      	cp r27, r26
002795 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
002796 91a0 2844                 	lds r26, pulse1_duty_macro_loop
002798 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002799 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00279a c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
00279b 95a3                      	inc r26 //increment the macro offset
00279c 93a0 2843                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
00279e 91b4                      	lpm r27, Z //load pitch data into r27
00279f 3fbf                      	cpi r27, 0xFF //check for macro end flag
0027a0 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0027a1 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0027a2 93a0 2843                 	sts pulse1_duty_macro_offset, r26
0027a4 91b0 2845                 	lds r27, pulse1_duty_macro_release
0027a6 3fbf                      	cpi r27, 0xFF
0027a7 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0027a8 91b0 2844                 	lds r27, pulse1_duty_macro_loop //load the loop index
0027aa 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0027ab f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0027ac 93b0 2843                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0027ae cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0027af efe2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0027b0 e6f2                      	ldi ZH, HIGH(sequences << 1)
0027b1 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0027b2 1df2                      	adc ZH, zero
                                 
0027b3 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0027b4 95b7                      	ror r27
0027b5 95b7                      	ror r27
0027b6 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0027b8 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0027b9 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0027ba 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0027bb c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0027bc c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0027bd 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
0027be 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0027bf 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0027c0 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0027c2 91e0 2848                 	lds ZL, pulse1_fx_1xx
0027c4 91f0 2849                 	lds ZH, pulse1_fx_1xx+1
0027c6 9630                      	adiw Z, 0
0027c7 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0027c8 91a0 284a                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0027ca 91b0 284b                 	lds r27, pulse1_fx_1xx_total+1
0027cc 0fae                      	add r26, ZL //increase the total offset by the rate
0027cd 1fbf                      	adc r27, ZH
0027ce 93a0 284a                 	sts pulse1_fx_1xx_total, r26
0027d0 93b0 284b                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0027d2 91e0 284c                 	lds ZL, pulse1_fx_2xx
0027d4 91f0 284d                 	lds ZH, pulse1_fx_2xx+1
0027d6 9630                      	adiw Z, 0
0027d7 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0027d8 91a0 284e                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0027da 91b0 284f                 	lds r27, pulse1_fx_2xx_total+1
0027dc 0fae                      	add r26, ZL //increase the total offset by the rate
0027dd 1fbf                      	adc r27, ZH
0027de 93a0 284e                 	sts pulse1_fx_2xx_total, r26
0027e0 93b0 284f                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0027e2 91e0 2854                 	lds ZL, pulse1_fx_3xx_speed
0027e4 91f0 2855                 	lds ZH, pulse1_fx_3xx_speed+1
0027e6 9630                      	adiw Z, 0
0027e7 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0027e8 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0027e9 91a0 2850                 	lds r26, pulse1_fx_3xx_start
0027eb 91b0 2851                 	lds r27, pulse1_fx_3xx_start+1
0027ed 9610                      	adiw r26:r27, 0
0027ee f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0027ef c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0027f0 91c0 2852                 	lds r28, pulse1_fx_3xx_target
0027f2 91d0 2853                 	lds r29, pulse1_fx_3xx_target+1
                                 
0027f4 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0027f5 07bd                      	cpc r27, r29
0027f6 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0027f7 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0027f8 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0027f9 9220 2850                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0027fb 9220 2851                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0027fd c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0027fe 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0027ff 0bdb                      	sbc r29, r27
002800 91a0 2856                 	lds r26, pulse1_fx_3xx_total_offset
002802 91b0 2857                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
002804 0fae                      	add r26, ZL //add the speed to the total offset
002805 1fbf                      	adc r27, ZH
002806 1bca                      	sub r28, r26 //invert the total difference with the total offset
002807 0bdb                      	sbc r29, r27
002808 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002809 93a0 2856                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
00280b 93b0 2857                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
00280d 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
00280f 91b0 0a8d                 	lds r27, TCB0_CCMPH
002811 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002812 0bbd                      	sbc r27, r29
002813 93a0 0a8c                 	sts TCB0_CCMPL, r26
002815 93b0 0a8d                 	sts TCB0_CCMPH, r27
002817 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002818 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002819 0bbd                      	sbc r27, r29
00281a 91c0 2856                 	lds r28, pulse1_fx_3xx_total_offset
00281c 91d0 2857                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
00281e 0fce                      	add r28, ZL //add the speed to the total offset
00281f 1fdf                      	adc r29, ZH
002820 1bac                      	sub r26, r28 //invert the total difference with the total offset
002821 0bbd                      	sbc r27, r29
002822 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002823 93c0 2856                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
002825 93d0 2857                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
002827 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
002829 91d0 0a8d                 	lds r29, TCB0_CCMPH
00282b 0fca                      	add r28, r26 //offset the current timer period with the total offset
00282c 1fdb                      	adc r29, r27
00282d 93c0 0a8c                 	sts TCB0_CCMPL, r28
00282f 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002831 91a0 2858                 	lds r26, pulse1_fx_4xy_speed
002833 15a2                      	cp r26, zero
002834 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
002835 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
002836 91b0 2859                 	lds r27, pulse1_fx_4xy_depth
002838 91c0 285a                 	lds r28, pulse1_fx_4xy_phase
00283a 0fca                      	add r28, r26 //increase the phase by the speed
00283b 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00283c f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00283d e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
00283e 93c0 285a                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002840 31c0                      	cpi r28, 16
002841 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
002842 32c0                      	cpi r28, 32
002843 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
002844 33c0                      	cpi r28, 48
002845 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
002846 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
002847 70cf                      	andi r28, 0x0F //mask for values 0-15
002848 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
002849 6fc0                      	ori r28, 0xF0
00284a 95c0                      	com r28 //invert values 0-15
00284b c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
00284c 70cf                      	andi r28, 0x0F //mask for values 0-15
00284d c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
00284e 6fc0                      	ori r28, 0xF0
00284f 95c0                      	com r28 //invert values 0-15
002850 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
002851 95b2                      	swap r27 //multiply depth by 16
002852 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002853 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002854 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002855 0fec                      	add ZL, r28 //offset the table by the depth+phase
002856 1df2                      	adc ZH, zero
002857 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002858 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002859 937f                      	push r23
00285a 2f6c                      	mov r22, r28 //store the vibrato value into r22
00285b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00285c 9f67                      	mul r22, r23
00285d 917f                      	pop r23
00285e 916f                      	pop r22
                                 
00285f 9416                      	lsr r1 //shift out the fractional bits
002860 9407                      	ror r0
002861 9416                      	lsr r1
002862 9407                      	ror r0
002863 9416                      	lsr r1
002864 9407                      	ror r0
002865 9416                      	lsr r1
002866 9407                      	ror r0
                                 	
002867 91a0 0a8c                 	lds r26, TCB0_CCMPL
002869 91b0 0a8d                 	lds r27, TCB0_CCMPH
00286b 0da0                      	add r26, r0
00286c 1db1                      	adc r27, r1
00286d 93a0 0a8c                 	sts TCB0_CCMPL, r26
00286f 93b0 0a8d                 	sts TCB0_CCMPH, r27
002871 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
002872 95b2                      	swap r27 //multiply depth by 16
002873 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002874 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002875 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002876 0fec                      	add ZL, r28 //offset the table by the depth+phase
002877 1df2                      	adc ZH, zero
002878 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002879 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00287a 937f                      	push r23
00287b 2f6c                      	mov r22, r28 //store the vibrato value into r22
00287c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00287d 9f67                      	mul r22, r23
00287e 917f                      	pop r23
00287f 916f                      	pop r22
                                 
002880 9416                      	lsr r1 //shift out the fractional bits
002881 9407                      	ror r0
002882 9416                      	lsr r1
002883 9407                      	ror r0
002884 9416                      	lsr r1
002885 9407                      	ror r0
002886 9416                      	lsr r1
002887 9407                      	ror r0
                                 
002888 91a0 0a8c                 	lds r26, TCB0_CCMPL
00288a 91b0 0a8d                 	lds r27, TCB0_CCMPH
00288c 19a0                      	sub r26, r0
00288d 09b1                      	sbc r27, r1
00288e 93a0 0a8c                 	sts TCB0_CCMPL, r26
002890 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
002892 91a0 285b                 	lds r26, pulse1_fx_7xy_speed
002894 15a2                      	cp r26, zero
002895 f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002896 91b0 285c                 	lds r27, pulse1_fx_7xy_depth
002898 91c0 285d                 	lds r28, pulse1_fx_7xy_phase
00289a 0fca                      	add r28, r26 //increase the phase by the speed
00289b 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00289c f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00289d e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
00289e 93c0 285d                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
0028a0 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0028a1 ffc4                      	sbrs r28, 4
0028a2 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
0028a3 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
0028a4 70cf                      	andi r28, 0x0F //mask for values 0-15
0028a5 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
0028a6 6fc0                      	ori r28, 0xF0
0028a7 95c0                      	com r28 //invert values 0-15
0028a8 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
0028a9 95b2                      	swap r27 //multiply depth by 16
0028aa 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0028ab e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0028ac e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0028ad 0fec                      	add ZL, r28 //offset the table by the depth+phase
0028ae 1df2                      	adc ZH, zero
0028af 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0028b0 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0028b1 93c0 285e                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
0028b3 91b0 285f                 	lds r27, pulse1_fx_Axy
0028b5 15b2                      	cp r27, zero
0028b6 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0028b7 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0028b9 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0028bb 2fda                      	mov r29, r26 //copy fractional volume into r29
0028bc 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0028bd 95e2                      	swap r30
0028be 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0028bf 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0028c0 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0028c1 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0028c2 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0028c3 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0028c4 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0028c5 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0028c6 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0028c7 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0028c8 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0028c9 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0028ca f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0028cb e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0028cc 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0028ce 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0028cf 95a2                      	swap r26
0028d0 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0028d1 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0028d2 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0028d4 91e0 2865                 	lds ZL, pulse1_fx_Qxy_target
0028d6 91f0 2866                 	lds ZH, pulse1_fx_Qxy_target+1
0028d8 9630                      	adiw Z, 0
0028d9 f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0028da 91a0 2869                 	lds r26, pulse1_fx_Qxy_total_offset
0028dc 91b0 286a                 	lds r27, pulse1_fx_Qxy_total_offset+1
0028de 91c0 0a8c                 	lds r28, TCB0_CCMPL
0028e0 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0028e2 1bec                      	sub ZL, r28 //calculate the difference to the target
0028e3 0bfd                      	sbc ZH, r29
0028e4 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0028e5 f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0028e6 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
0028e8 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
0028ea 9220 2865                 	sts pulse1_fx_Qxy_target, zero
0028ec 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
0028ee 91b0 2864                 	lds r27, pulse1_fx_Qxy_target_note
0028f0 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
0028f2 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0028f3 91c0 2867                 	lds r28, pulse1_fx_Qxy_speed
0028f5 91d0 2868                 	lds r29, pulse1_fx_Qxy_speed+1
0028f7 0fac                      	add r26, r28 //increase the total offset by the speed
0028f8 1fbd                      	adc r27, r29
0028f9 93a0 2869                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0028fb 93b0 286a                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0028fd 91e0 286c                 	lds ZL, pulse1_fx_Rxy_target
0028ff 91f0 286d                 	lds ZH, pulse1_fx_Rxy_target+1
002901 9630                      	adiw Z, 0
002902 f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
002903 91a0 2870                 	lds r26, pulse1_fx_Rxy_total_offset
002905 91b0 2871                 	lds r27, pulse1_fx_Rxy_total_offset+1
002907 91c0 0a8c                 	lds r28, TCB0_CCMPL
002909 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
00290b 1bce                      	sub r28, ZL //calculate the difference to the target
00290c 0bdf                      	sbc r29, ZH
00290d f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
00290e f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
00290f 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
002911 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
002913 9220 286c                 	sts pulse1_fx_Rxy_target, zero
002915 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
002917 91b0 286b                 	lds r27, pulse1_fx_Rxy_target_note
002919 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
00291b c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
00291c 91c0 286e                 	lds r28, pulse1_fx_Rxy_speed
00291e 91d0 286f                 	lds r29, pulse1_fx_Rxy_speed+1
002920 0fac                      	add r26, r28 //increase the total offset by the speed
002921 1fbd                      	adc r27, r29
002922 93a0 2870                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002924 93b0 2871                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
002926 91e0 287a                 	lds ZL, pulse2_volume_macro
002928 91f0 287b                 	lds ZH, pulse2_volume_macro+1
00292a 9630                      	adiw Z, 0
00292b f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
00292c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00292d 1fff                      	rol ZH
00292e 91a0 287c                 	lds r26, pulse2_volume_macro_offset
002930 0fea                      	add ZL, r26
002931 1df2                      	adc ZH, zero
                                 
002932 91b0 287e                 	lds r27, pulse2_volume_macro_release
002934 17ba                      	cp r27, r26
002935 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
002936 91a0 287d                 	lds r26, pulse2_volume_macro_loop
002938 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002939 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00293a c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
00293b 95a3                      	inc r26 //increment the macro offset
00293c 93a0 287c                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
00293e 91b4                      	lpm r27, Z //load volume data into r27
00293f 3fbf                      	cpi r27, 0xFF //check for macro end flag
002940 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002941 91b0 287e                 	lds r27, pulse2_volume_macro_release
002943 3fbf                      	cpi r27, 0xFF
002944 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
002945 91b0 287d                 	lds r27, pulse2_volume_macro_loop //load the loop index
002947 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
002949 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
00294a 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00294b 93a0 287c                 	sts pulse2_volume_macro_offset, r26
00294d cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
00294e efea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
00294f e6f3                      	ldi ZH, HIGH(volumes << 1)
002950 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002951 0feb                      	add ZL, r27 //add offset to the table
002952 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
002953 91b0 2808                 	lds r27, pulse2_param //load main volume
002955 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002956 91a0 28af                 	lds r26, pulse2_fx_7xy_value
002958 30a0                      	cpi r26, 0x00
002959 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
00295a 0feb                      	add ZL, r27 //offset the volume table by the main volume
00295b 1df2                      	adc ZH, zero
00295c 91b4                      	lpm r27, Z
00295d 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00295f c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
002960 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002962 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002963 91a0 28af                 	lds r26, pulse2_fx_7xy_value
002965 30a0                      	cpi r26, 0x00
002966 f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
002967 93b0 280e                 	sts pulse2_output_volume, r27
002969 c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
00296a 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00296b f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
00296c f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
00296d 0feb                      	add ZL, r27 //offset the volume table by the main volume
00296e 1df2                      	adc ZH, zero
00296f 91b4                      	lpm r27, Z
002970 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002972 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
002973 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002974 0feb                      	add ZL, r27 //offset the volume table by the main volume
002975 1df2                      	adc ZH, zero
002976 91b4                      	lpm r27, Z
002977 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002979 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
00297a 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00297b f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00297c f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00297d 93b0 280e                 	sts pulse2_output_volume, r27
00297f c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002980 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002981 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002983 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
002985 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
002987 9630                      	adiw Z, 0
002988 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002989 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00298a 1fff                      	rol ZH
00298b 91a0 2881                 	lds r26, pulse2_arpeggio_macro_offset
00298d 0fea                      	add ZL, r26
00298e 1df2                      	adc ZH, zero
                                 
00298f 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
002991 17ba                      	cp r27, r26
002992 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002993 91a0 2882                 	lds r26, pulse2_arpeggio_macro_loop
002995 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002996 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002997 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
002998 95a3                      	inc r26 //increment the macro offset
002999 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
00299b 91b4                      	lpm r27, Z //load arpeggio data into r27
00299c 38b0                      	cpi r27, 0x80 //check for macro end flag
00299d f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
00299e c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
00299f 50a1                      	subi r26, 1 //keep the offset at the end flag
0029a0 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
0029a2 91b0 2884                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0029a4 30b1                      	cpi r27, 0x01
0029a5 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
0029a6 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
0029a8 3fbf                      	cpi r27, 0xFF
0029a9 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
0029aa 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop
0029ac 3fbf                      	cpi r27, 0xFF
0029ad f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0029ae c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
0029af 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
0029b1 3fbf                      	cpi r27, 0xFF
0029b2 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
0029b3 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
0029b5 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0029b6 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
0029b7 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
0029b9 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
0029bb 9620                      	adiw r29:r28, 0
0029bc f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0029bd 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0029be 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
0029c0 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
0029c1 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
0029c3 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
0029c4 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
0029c6 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
0029c8 9620                      	adiw r29:r28, 0 //check for 0xy effect
0029c9 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
0029ca 95d6                      	lsr r29
0029cb 95c7                      	ror r28
0029cc 95d7                      	ror r29
0029cd 95c7                      	ror r28
0029ce 95d7                      	ror r29
0029cf 95c7                      	ror r28
0029d0 95d7                      	ror r29
0029d1 95c7                      	ror r28
0029d2 95d7                      	ror r29
0029d3 95d2                      	swap r29
                                 
0029d4 93c0 2897                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
0029d6 93d0 2898                 	sts pulse2_fx_0xy_sequence+1, r29
0029d8 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0029d9 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029db 0fac                      	add r26, r28 //add the note offset
0029dc c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0029dd 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029df c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0029e0 9220 2885                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0029e2 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
0029e4 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
0029e6 91a0 2884                 	lds r26, pulse2_arpeggio_macro_mode
0029e8 30a1                      	cpi r26, 0x01 //absolute mode
0029e9 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0029ea f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0029eb c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0029ec 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029ee 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029ef fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029f0 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0029f1 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029f2 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0029f3 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029f4 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0029f5 fda7                      	sbrc r26, 7 //check if result is negative
0029f6 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029f7 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0029f8 2fab                      	mov r26, r27 //move the arpeggio data into r26
0029f9 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0029fa 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029fc 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029fd fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029fe c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0029ff 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
002a01 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002a02 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002a03 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002a04 93a0 280f                 	sts pulse2_note, r26
002a06 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
002a07 fda7                      	sbrc r26, 7 //check if result is negative
002a08 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002a09 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
002a0b e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002a0c e0f0                      	ldi ZH, HIGH(note_table << 1)
002a0d 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002a0e 0fea                      	add ZL, r26 //add offset
002a0f 1df2                      	adc ZH, zero
002a10 91a5                      	lpm r26, Z+ //load bytes
002a11 91b4                      	lpm r27, Z
002a12 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
002a14 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
002a16 93a0 28a3                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002a18 93b0 28a4                 	sts pulse2_fx_3xx_target+1, r27
002a1a c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
002a1b 91e0 2887                 	lds ZL, pulse2_pitch_macro
002a1d 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
002a1f 9630                      	adiw Z, 0
002a20 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002a21 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002a22 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a23 1fff                      	rol ZH
002a24 91a0 2889                 	lds r26, pulse2_pitch_macro_offset
002a26 0fea                      	add ZL, r26
002a27 1df2                      	adc ZH, zero
                                 
002a28 91b0 288b                 	lds r27, pulse2_pitch_macro_release
002a2a 17ba                      	cp r27, r26
002a2b f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a2c 91a0 288a                 	lds r26, pulse2_pitch_macro_loop
002a2e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a2f f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a30 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002a31 95a3                      	inc r26 //increment the macro offset
002a32 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002a34 91b4                      	lpm r27, Z //load pitch data into r27
002a35 38b0                      	cpi r27, 0x80 //check for macro end flag
002a36 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002a37 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a38 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
002a3a 91b0 288b                 	lds r27, pulse2_pitch_macro_release
002a3c 3fbf                      	cpi r27, 0xFF
002a3d f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002a3e 91b0 288a                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002a40 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a41 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002a42 93b0 2889                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002a44 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002a45 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002a46 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a47 937f                      	push r23
002a48 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002a49 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a4a 0367                      	mulsu r22, r23
002a4b 917f                      	pop r23
002a4c 916f                      	pop r22
                                 
002a4d 9416                      	lsr r1 //shift out the fractional bits
002a4e 9407                      	ror r0
002a4f 9416                      	lsr r1
002a50 9407                      	ror r0
002a51 9416                      	lsr r1
002a52 9407                      	ror r0
002a53 9416                      	lsr r1
002a54 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
002a55 fe13                      	sbrs r1, 3 //check if result was a negative number
002a56 c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002a57 efc0                      	ldi r28, 0xF0
002a58 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
002a59 70b7                      	andi r27, 0b00000111
002a5a f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
002a5b e0b1                      	ldi r27, 0x01
002a5c 0e0b                      	add r0, r27
002a5d 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002a5e 91a0 2885                 	lds r26, pulse2_total_pitch_offset
002a60 91b0 2886                 	lds r27, pulse2_total_pitch_offset+1
002a62 0e0a                      	add r0, r26
002a63 1e1b                      	adc r1, r27
002a64 9200 2885                 	sts pulse2_total_pitch_offset, r0
002a66 9210 2886                 	sts pulse2_total_pitch_offset+1, r1
002a68 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002a6a 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002a6c 0da0                      	add r26, r0 //offset the timer values
002a6d 1db1                      	adc r27, r1
                                 	
002a6e 91c0 289b                 	lds r28, pulse2_fx_1xx_total
002a70 91d0 289c                 	lds r29, pulse2_fx_1xx_total+1
002a72 1bac                      	sub r26, r28
002a73 0bbd                      	sbc r27, r29
002a74 91c0 289f                 	lds r28, pulse2_fx_2xx_total
002a76 91d0 28a0                 	lds r29, pulse2_fx_2xx_total+1
002a78 0fac                      	add r26, r28
002a79 1fbd                      	adc r27, r29
002a7a 91c0 28b3                 	lds r28, pulse2_fx_Pxx_total
002a7c 91d0 28b4                 	lds r29, pulse2_fx_Pxx_total+1
002a7e 0fac                      	add r26, r28
002a7f 1fbd                      	adc r27, r29
002a80 91c0 28ba                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002a82 91d0 28bb                 	lds r29, pulse2_fx_Qxy_total_offset+1
002a84 1bac                      	sub r26, r28
002a85 0bbd                      	sbc r27, r29
002a86 91c0 28c1                 	lds r28, pulse2_fx_Rxy_total_offset
002a88 91d0 28c2                 	lds r29, pulse2_fx_Rxy_total_offset+1
002a8a 0fac                      	add r26, r28
002a8b 1fbd                      	adc r27, r29
                                 
002a8c e5c9                      	ldi r28, 0x59
002a8d e0d0                      	ldi r29, 0x00
002a8e 17ac                      	cp r26, r28
002a8f 07bd                      	cpc r27, r29
002a90 f030                      	brlo sound_driver_instrument_routine_channel1_pitch_min
                                 
002a91 e5ca                      	ldi r28, 0x5A
002a92 e5d9                      	ldi r29, 0x59
002a93 17ac                      	cp r26, r28
002a94 07bd                      	cpc r27, r29
002a95 f420                      	brsh sound_driver_instrument_routine_channel1_pitch_max
002a96 c006                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_min:
002a97 e5c9                      	ldi r28, 0x59
002a98 e0d0                      	ldi r29, 0x00
002a99 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_max:
002a9a e5c9                      	ldi r28, 0x59
002a9b e5d9                      	ldi r29, 0x59
002a9c c000                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_store:
002a9d 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a9f 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002aa1 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
002aa3 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
002aa5 9630                      	adiw Z, 0
002aa6 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002aa7 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002aa8 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002aa9 1fff                      	rol ZH
002aaa 91a0 288f                 	lds r26, pulse2_hi_pitch_macro_offset
002aac 0fea                      	add ZL, r26
002aad 1df2                      	adc ZH, zero
                                 
002aae 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
002ab0 17ba                      	cp r27, r26
002ab1 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002ab2 91a0 2890                 	lds r26, pulse2_hi_pitch_macro_loop
002ab4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ab5 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ab6 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002ab7 95a3                      	inc r26 //increment the macro offset
002ab8 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002aba 91b4                      	lpm r27, Z //load hi pitch data into r27
002abb 38b0                      	cpi r27, 0x80 //check for macro end flag
002abc f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002abd 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002abe 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
002ac0 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
002ac2 3fbf                      	cpi r27, 0xFF
002ac3 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002ac4 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002ac6 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002ac7 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002ac8 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002aca cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002acb 91b0 288c                 	lds r27, pulse2_total_hi_pitch_offset
002acd c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002ace 91a0 288c                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002ad0 0fba                      	add r27, r26
002ad1 93b0 288c                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002ad3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ad4 937f                      	push r23
002ad5 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002ad6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ad7 0367                      	mulsu r22, r23
002ad8 917f                      	pop r23
002ad9 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002ada 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002adc 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002ade 0da0                      	add r26, r0 //offset the timer values
002adf 1db1                      	adc r27, r1
002ae0 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002ae2 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002ae4 91e0 2892                 	lds ZL, pulse2_duty_macro
002ae6 91f0 2893                 	lds ZH, pulse2_duty_macro+1
002ae8 9630                      	adiw Z, 0
002ae9 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002aea 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002aeb 1fff                      	rol ZH
002aec 91a0 2894                 	lds r26, pulse2_duty_macro_offset
002aee 0fea                      	add ZL, r26
002aef 1df2                      	adc ZH, zero
                                 
002af0 91b0 2896                 	lds r27, pulse2_duty_macro_release
002af2 17ba                      	cp r27, r26
002af3 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002af4 91a0 2895                 	lds r26, pulse2_duty_macro_loop
002af6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002af7 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002af8 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002af9 95a3                      	inc r26 //increment the macro offset
002afa 93a0 2894                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002afc 91b4                      	lpm r27, Z //load pitch data into r27
002afd 3fbf                      	cpi r27, 0xFF //check for macro end flag
002afe f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002aff 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002b00 93a0 2894                 	sts pulse2_duty_macro_offset, r26
002b02 91b0 2896                 	lds r27, pulse2_duty_macro_release
002b04 3fbf                      	cpi r27, 0xFF
002b05 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002b06 91b0 2895                 	lds r27, pulse2_duty_macro_loop //load the loop index
002b08 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002b09 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002b0a 93b0 2894                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002b0c cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002b0d efe2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002b0e e6f2                      	ldi ZH, HIGH(sequences << 1)
002b0f 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002b10 1df2                      	adc ZH, zero
                                 
002b11 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002b12 95b7                      	ror r27
002b13 95b7                      	ror r27
002b14 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002b16 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002b17 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002b18 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002b19 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002b1a c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002b1b 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002b1c 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002b1d 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002b1e 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002b20 91e0 2899                 	lds ZL, pulse2_fx_1xx
002b22 91f0 289a                 	lds ZH, pulse2_fx_1xx+1
002b24 9630                      	adiw Z, 0
002b25 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002b26 91a0 289b                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002b28 91b0 289c                 	lds r27, pulse2_fx_1xx_total+1
002b2a 0fae                      	add r26, ZL //increase the total offset by the rate
002b2b 1fbf                      	adc r27, ZH
002b2c 93a0 289b                 	sts pulse2_fx_1xx_total, r26
002b2e 93b0 289c                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002b30 91e0 289d                 	lds ZL, pulse2_fx_2xx
002b32 91f0 289e                 	lds ZH, pulse2_fx_2xx+1
002b34 9630                      	adiw Z, 0
002b35 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002b36 91a0 289f                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002b38 91b0 28a0                 	lds r27, pulse2_fx_2xx_total+1
002b3a 0fae                      	add r26, ZL //increase the total offset by the rate
002b3b 1fbf                      	adc r27, ZH
002b3c 93a0 289f                 	sts pulse2_fx_2xx_total, r26
002b3e 93b0 28a0                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002b40 91e0 28a5                 	lds ZL, pulse2_fx_3xx_speed
002b42 91f0 28a6                 	lds ZH, pulse2_fx_3xx_speed+1
002b44 9630                      	adiw Z, 0
002b45 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002b46 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002b47 91a0 28a1                 	lds r26, pulse2_fx_3xx_start
002b49 91b0 28a2                 	lds r27, pulse2_fx_3xx_start+1
002b4b 9610                      	adiw r26:r27, 0
002b4c f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002b4d c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002b4e 91c0 28a3                 	lds r28, pulse2_fx_3xx_target
002b50 91d0 28a4                 	lds r29, pulse2_fx_3xx_target+1
                                 
002b52 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002b53 07bd                      	cpc r27, r29
002b54 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002b55 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002b56 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002b57 9220 28a1                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002b59 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002b5b c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002b5c 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002b5d 0bdb                      	sbc r29, r27
002b5e 91a0 28a7                 	lds r26, pulse2_fx_3xx_total_offset
002b60 91b0 28a8                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002b62 0fae                      	add r26, ZL //add the speed to the total offset
002b63 1fbf                      	adc r27, ZH
002b64 1bca                      	sub r28, r26 //invert the total difference with the total offset
002b65 0bdb                      	sbc r29, r27
002b66 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b67 93a0 28a7                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002b69 93b0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002b6b 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002b6d 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b6f 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002b70 0bbd                      	sbc r27, r29
002b71 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b73 93b0 0a9d                 	sts TCB1_CCMPH, r27
002b75 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002b76 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002b77 0bbd                      	sbc r27, r29
002b78 91c0 28a7                 	lds r28, pulse2_fx_3xx_total_offset
002b7a 91d0 28a8                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002b7c 0fce                      	add r28, ZL //add the speed to the total offset
002b7d 1fdf                      	adc r29, ZH
002b7e 1bac                      	sub r26, r28 //invert the total difference with the total offset
002b7f 0bbd                      	sbc r27, r29
002b80 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b81 93c0 28a7                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002b83 93d0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002b85 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002b87 91d0 0a9d                 	lds r29, TCB1_CCMPH
002b89 0fca                      	add r28, r26 //offset the current timer period with the total offset
002b8a 1fdb                      	adc r29, r27
002b8b 93c0 0a9c                 	sts TCB1_CCMPL, r28
002b8d 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002b8f 91a0 28a9                 	lds r26, pulse2_fx_4xy_speed
002b91 15a2                      	cp r26, zero
002b92 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002b93 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002b94 91b0 28aa                 	lds r27, pulse2_fx_4xy_depth
002b96 91c0 28ab                 	lds r28, pulse2_fx_4xy_phase
002b98 0fca                      	add r28, r26 //increase the phase by the speed
002b99 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002b9a f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002b9b e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002b9c 93c0 28ab                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002b9e 31c0                      	cpi r28, 16
002b9f f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002ba0 32c0                      	cpi r28, 32
002ba1 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002ba2 33c0                      	cpi r28, 48
002ba3 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002ba4 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002ba5 70cf                      	andi r28, 0x0F //mask for values 0-15
002ba6 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002ba7 6fc0                      	ori r28, 0xF0
002ba8 95c0                      	com r28 //invert values 0-15
002ba9 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002baa 70cf                      	andi r28, 0x0F //mask for values 0-15
002bab c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002bac 6fc0                      	ori r28, 0xF0
002bad 95c0                      	com r28 //invert values 0-15
002bae c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002baf 95b2                      	swap r27 //multiply depth by 16
002bb0 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002bb1 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002bb2 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002bb3 0fec                      	add ZL, r28 //offset the table by the depth+phase
002bb4 1df2                      	adc ZH, zero
002bb5 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002bb6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002bb7 937f                      	push r23
002bb8 2f6c                      	mov r22, r28 //store the vibrato value into r22
002bb9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002bba 9f67                      	mul r22, r23
002bbb 917f                      	pop r23
002bbc 916f                      	pop r22
                                 
002bbd 9416                      	lsr r1 //shift out the fractional bits
002bbe 9407                      	ror r0
002bbf 9416                      	lsr r1
002bc0 9407                      	ror r0
002bc1 9416                      	lsr r1
002bc2 9407                      	ror r0
002bc3 9416                      	lsr r1
002bc4 9407                      	ror r0
                                 	
002bc5 91a0 0a9c                 	lds r26, TCB1_CCMPL
002bc7 91b0 0a9d                 	lds r27, TCB1_CCMPH
002bc9 0da0                      	add r26, r0
002bca 1db1                      	adc r27, r1
002bcb 93a0 0a9c                 	sts TCB1_CCMPL, r26
002bcd 93b0 0a9d                 	sts TCB1_CCMPH, r27
002bcf c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002bd0 95b2                      	swap r27 //multiply depth by 16
002bd1 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002bd2 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002bd3 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002bd4 0fec                      	add ZL, r28 //offset the table by the depth+phase
002bd5 1df2                      	adc ZH, zero
002bd6 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002bd7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002bd8 937f                      	push r23
002bd9 2f6c                      	mov r22, r28 //store the vibrato value into r22
002bda eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002bdb 9f67                      	mul r22, r23
002bdc 917f                      	pop r23
002bdd 916f                      	pop r22
                                 
002bde 9416                      	lsr r1 //shift out the fractional bits
002bdf 9407                      	ror r0
002be0 9416                      	lsr r1
002be1 9407                      	ror r0
002be2 9416                      	lsr r1
002be3 9407                      	ror r0
002be4 9416                      	lsr r1
002be5 9407                      	ror r0
                                 
002be6 91a0 0a9c                 	lds r26, TCB1_CCMPL
002be8 91b0 0a9d                 	lds r27, TCB1_CCMPH
002bea 19a0                      	sub r26, r0
002beb 09b1                      	sbc r27, r1
002bec 93a0 0a9c                 	sts TCB1_CCMPL, r26
002bee 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002bf0 91a0 28ac                 	lds r26, pulse2_fx_7xy_speed
002bf2 15a2                      	cp r26, zero
002bf3 f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002bf4 91b0 28ad                 	lds r27, pulse2_fx_7xy_depth
002bf6 91c0 28ae                 	lds r28, pulse2_fx_7xy_phase
002bf8 0fca                      	add r28, r26 //increase the phase by the speed
002bf9 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002bfa f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002bfb e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002bfc 93c0 28ae                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002bfe 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002bff ffc4                      	sbrs r28, 4
002c00 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002c01 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002c02 70cf                      	andi r28, 0x0F //mask for values 0-15
002c03 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002c04 6fc0                      	ori r28, 0xF0
002c05 95c0                      	com r28 //invert values 0-15
002c06 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002c07 95b2                      	swap r27 //multiply depth by 16
002c08 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002c09 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002c0a e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002c0b 0fec                      	add ZL, r28 //offset the table by the depth+phase
002c0c 1df2                      	adc ZH, zero
002c0d 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002c0e 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002c0f 93c0 28af                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002c11 91b0 28b0                 	lds r27, pulse2_fx_Axy
002c13 15b2                      	cp r27, zero
002c14 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002c15 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002c17 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002c19 2fda                      	mov r29, r26 //copy fractional volume into r29
002c1a 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002c1b 95e2                      	swap r30
002c1c 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002c1d 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002c1e 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002c1f f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002c20 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002c21 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002c22 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002c23 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002c24 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002c25 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002c26 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002c27 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002c28 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002c29 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002c2a 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002c2c 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002c2d 95a2                      	swap r26
002c2e 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002c2f 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002c30 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002c32 91e0 28b6                 	lds ZL, pulse2_fx_Qxy_target
002c34 91f0 28b7                 	lds ZH, pulse2_fx_Qxy_target+1
002c36 9630                      	adiw Z, 0
002c37 f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002c38 91a0 28ba                 	lds r26, pulse2_fx_Qxy_total_offset
002c3a 91b0 28bb                 	lds r27, pulse2_fx_Qxy_total_offset+1
002c3c 91c0 0a9c                 	lds r28, TCB1_CCMPL
002c3e 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002c40 1bec                      	sub ZL, r28 //calculate the difference to the target
002c41 0bfd                      	sbc ZH, r29
002c42 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002c43 f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002c44 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
002c46 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
002c48 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
002c4a 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
002c4c 91b0 28b5                 	lds r27, pulse2_fx_Qxy_target_note
002c4e 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002c50 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002c51 91c0 28b8                 	lds r28, pulse2_fx_Qxy_speed
002c53 91d0 28b9                 	lds r29, pulse2_fx_Qxy_speed+1
002c55 0fac                      	add r26, r28 //increase the total offset by the speed
002c56 1fbd                      	adc r27, r29
002c57 93a0 28ba                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002c59 93b0 28bb                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002c5b 91e0 28bd                 	lds ZL, pulse2_fx_Rxy_target
002c5d 91f0 28be                 	lds ZH, pulse2_fx_Rxy_target+1
002c5f 9630                      	adiw Z, 0
002c60 f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002c61 91a0 28c1                 	lds r26, pulse2_fx_Rxy_total_offset
002c63 91b0 28c2                 	lds r27, pulse2_fx_Rxy_total_offset+1
002c65 91c0 0a9c                 	lds r28, TCB1_CCMPL
002c67 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002c69 1bce                      	sub r28, ZL //calculate the difference to the target
002c6a 0bdf                      	sbc r29, ZH
002c6b f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002c6c f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002c6d 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
002c6f 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
002c71 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
002c73 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
002c75 91b0 28bc                 	lds r27, pulse2_fx_Rxy_target_note
002c77 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002c79 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002c7a 91c0 28bf                 	lds r28, pulse2_fx_Rxy_speed
002c7c 91d0 28c0                 	lds r29, pulse2_fx_Rxy_speed+1
002c7e 0fac                      	add r26, r28 //increase the total offset by the speed
002c7f 1fbd                      	adc r27, r29
002c80 93a0 28c1                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002c82 93b0 28c2                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002c84 91e0 28cb                 	lds ZL, triangle_volume_macro
002c86 91f0 28cc                 	lds ZH, triangle_volume_macro+1
002c88 9630                      	adiw Z, 0
002c89 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002c8a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c8b 1fff                      	rol ZH
002c8c 91a0 28cd                 	lds r26, triangle_volume_macro_offset
002c8e 0fea                      	add ZL, r26
002c8f 1df2                      	adc ZH, zero
                                 
002c90 91b0 28cf                 	lds r27, triangle_volume_macro_release
002c92 17ba                      	cp r27, r26
002c93 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002c94 91a0 28ce                 	lds r26, triangle_volume_macro_loop
002c96 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c97 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c98 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002c99 95a3                      	inc r26 //increment the macro offset
002c9a 93a0 28cd                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002c9c 91b4                      	lpm r27, Z //load volume data into r27
002c9d 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c9e f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002c9f 91b0 28cf                 	lds r27, triangle_volume_macro_release
002ca1 3fbf                      	cpi r27, 0xFF
002ca2 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002ca3 91b0 28ce                 	lds r27, triangle_volume_macro_loop //load the loop index
002ca5 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002ca7 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002ca8 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002ca9 93a0 28cd                 	sts triangle_volume_macro_offset, r26
002cab cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002cac 15b2                      	cp r27, zero
002cad f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002cae 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002cb0 30b1                      	cpi r27, TCB_CAPT_bm
002cb1 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002cb2 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002cb3 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002cb5 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002cb6 9220 0aa5                 	sts TCB2_INTCTRL, zero
002cb8 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002cba 9220 0aad                 	sts TCB2_CCMPH, zero
002cbc c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002cbd 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
002cbf 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
002cc1 9630                      	adiw Z, 0
002cc2 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002cc3 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002cc4 1fff                      	rol ZH
002cc5 91a0 28d2                 	lds r26, triangle_arpeggio_macro_offset
002cc7 0fea                      	add ZL, r26
002cc8 1df2                      	adc ZH, zero
                                 
002cc9 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002ccb 17ba                      	cp r27, r26
002ccc f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002ccd 91a0 28d3                 	lds r26, triangle_arpeggio_macro_loop
002ccf 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002cd0 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002cd1 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002cd2 95a3                      	inc r26 //increment the macro offset
002cd3 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002cd5 91b4                      	lpm r27, Z //load arpeggio data into r27
002cd6 38b0                      	cpi r27, 0x80 //check for macro end flag
002cd7 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002cd8 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002cd9 50a1                      	subi r26, 1 //keep the offset at the end flag
002cda 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
002cdc 91b0 28d5                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002cde 30b1                      	cpi r27, 0x01
002cdf f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002ce0 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002ce2 3fbf                      	cpi r27, 0xFF
002ce3 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002ce4 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop
002ce6 3fbf                      	cpi r27, 0xFF
002ce7 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002ce8 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002ce9 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002ceb 3fbf                      	cpi r27, 0xFF
002cec f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002ced 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002cef 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002cf0 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002cf1 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002cf3 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
002cf5 9620                      	adiw r29:r28, 0
002cf6 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002cf7 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002cf8 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002cfa cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002cfb 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002cfd cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002cfe 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002d00 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
002d02 9620                      	adiw r29:r28, 0 //check for 0xy effect
002d03 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
002d04 95d6                      	lsr r29
002d05 95c7                      	ror r28
002d06 95d7                      	ror r29
002d07 95c7                      	ror r28
002d08 95d7                      	ror r29
002d09 95c7                      	ror r28
002d0a 95d7                      	ror r29
002d0b 95c7                      	ror r28
002d0c 95d7                      	ror r29
002d0d 95d2                      	swap r29
                                 
002d0e 93c0 28e8                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002d10 93d0 28e9                 	sts triangle_fx_0xy_sequence+1, r29
002d12 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002d13 91a0 2812                 	lds r26, triangle_note //load the current note index
002d15 0fac                      	add r26, r28 //add the note offset
002d16 c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002d17 91a0 2812                 	lds r26, triangle_note //load the current note index
002d19 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002d1a 9220 28d6                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002d1c 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
002d1e 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
002d20 91a0 28d5                 	lds r26, triangle_arpeggio_macro_mode
002d22 30a1                      	cpi r26, 0x01 //absolute mode
002d23 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002d24 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002d25 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002d26 91a0 2812                 	lds r26, triangle_note //load the current note index
002d28 0fab                      	add r26, r27 //offset the note with the arpeggio data
002d29 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002d2a c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002d2b 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002d2c f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002d2d e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002d2e c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002d2f fda7                      	sbrc r26, 7 //check if result is negative
002d30 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002d31 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002d32 2fab                      	mov r26, r27 //move the arpeggio data into r26
002d33 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002d34 91a0 2812                 	lds r26, triangle_note //load the current note index
002d36 0fab                      	add r26, r27 //offset the note with the arpeggio data
002d37 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002d38 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002d39 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002d3b 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002d3c f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002d3d e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002d3e 93a0 2812                 	sts triangle_note, r26
002d40 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002d41 fda7                      	sbrc r26, 7 //check if result is negative
002d42 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002d43 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002d45 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002d46 e0f0                      	ldi ZH, HIGH(note_table << 1)
002d47 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002d48 0fea                      	add ZL, r26 //add offset
002d49 1df2                      	adc ZH, zero
002d4a 91a5                      	lpm r26, Z+ //load bytes
002d4b 91b4                      	lpm r27, Z
002d4c 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002d4e 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002d50 93a0 28f4                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002d52 93b0 28f5                 	sts triangle_fx_3xx_target+1, r27
002d54 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002d55 91e0 28d8                 	lds ZL, triangle_pitch_macro
002d57 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
002d59 9630                      	adiw Z, 0
002d5a f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002d5b c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002d5c 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d5d 1fff                      	rol ZH
002d5e 91a0 28da                 	lds r26, triangle_pitch_macro_offset
002d60 0fea                      	add ZL, r26
002d61 1df2                      	adc ZH, zero
                                 
002d62 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002d64 17ba                      	cp r27, r26
002d65 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d66 91a0 28db                 	lds r26, triangle_pitch_macro_loop
002d68 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d69 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d6a c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002d6b 95a3                      	inc r26 //increment the macro offset
002d6c 93a0 28da                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002d6e 91b4                      	lpm r27, Z //load pitch data into r27
002d6f 38b0                      	cpi r27, 0x80 //check for macro end flag
002d70 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002d71 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d72 93a0 28da                 	sts triangle_pitch_macro_offset, r26
002d74 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002d76 3fbf                      	cpi r27, 0xFF
002d77 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002d78 91b0 28db                 	lds r27, triangle_pitch_macro_loop //load the loop index
002d7a 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d7b f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002d7c 93b0 28da                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002d7e cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002d7f e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002d80 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d81 937f                      	push r23
002d82 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002d83 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d84 0367                      	mulsu r22, r23
002d85 917f                      	pop r23
002d86 916f                      	pop r22
                                 
002d87 9416                      	lsr r1 //shift out the fractional bits
002d88 9407                      	ror r0
002d89 9416                      	lsr r1
002d8a 9407                      	ror r0
002d8b 9416                      	lsr r1
002d8c 9407                      	ror r0
002d8d 9416                      	lsr r1
002d8e 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
002d8f fe13                      	sbrs r1, 3 //check if result was a negative number
002d90 c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002d91 efc0                      	ldi r28, 0xF0
002d92 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
002d93 70b7                      	andi r27, 0b00000111
002d94 f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
002d95 e0b1                      	ldi r27, 0x01
002d96 0e0b                      	add r0, r27
002d97 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002d98 91a0 28d6                 	lds r26, triangle_total_pitch_offset
002d9a 91b0 28d7                 	lds r27, triangle_total_pitch_offset+1
002d9c 0e0a                      	add r0, r26
002d9d 1e1b                      	adc r1, r27
002d9e 9200 28d6                 	sts triangle_total_pitch_offset, r0
002da0 9210 28d7                 	sts triangle_total_pitch_offset+1, r1
002da2 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002da4 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002da6 0da0                      	add r26, r0 //offset the timer values
002da7 1db1                      	adc r27, r1
                                 	
002da8 91c0 28ec                 	lds r28, triangle_fx_1xx_total
002daa 91d0 28ed                 	lds r29, triangle_fx_1xx_total+1
002dac 1bac                      	sub r26, r28
002dad 0bbd                      	sbc r27, r29
002dae 91c0 28f0                 	lds r28, triangle_fx_2xx_total
002db0 91d0 28f1                 	lds r29, triangle_fx_2xx_total+1
002db2 0fac                      	add r26, r28
002db3 1fbd                      	adc r27, r29
002db4 91c0 28ff                 	lds r28, triangle_fx_Pxx_total
002db6 91d0 2900                 	lds r29, triangle_fx_Pxx_total+1
002db8 0fac                      	add r26, r28
002db9 1fbd                      	adc r27, r29
002dba 91c0 2906                 	lds r28, triangle_fx_Qxy_total_offset
002dbc 91d0 2907                 	lds r29, triangle_fx_Qxy_total_offset+1
002dbe 1bac                      	sub r26, r28
002dbf 0bbd                      	sbc r27, r29
002dc0 91c0 290d                 	lds r28, triangle_fx_Rxy_total_offset
002dc2 91d0 290e                 	lds r29, triangle_fx_Rxy_total_offset+1
002dc4 0fac                      	add r26, r28
002dc5 1fbd                      	adc r27, r29
                                 
002dc6 e5c9                      	ldi r28, 0x59
002dc7 e0d0                      	ldi r29, 0x00
002dc8 17ac                      	cp r26, r28
002dc9 07bd                      	cpc r27, r29
002dca f030                      	brlo sound_driver_instrument_routine_channel2_pitch_min
                                 
002dcb e5ca                      	ldi r28, 0x5A
002dcc e5d9                      	ldi r29, 0x59
002dcd 17ac                      	cp r26, r28
002dce 07bd                      	cpc r27, r29
002dcf f420                      	brsh sound_driver_instrument_routine_channel2_pitch_max
002dd0 c006                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_min:
002dd1 e5c9                      	ldi r28, 0x59
002dd2 e0d0                      	ldi r29, 0x00
002dd3 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_max:
002dd4 e5c9                      	ldi r28, 0x59
002dd5 e5d9                      	ldi r29, 0x59
002dd6 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_store:
002dd7 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002dd9 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002ddb 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
002ddd 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
002ddf 9630                      	adiw Z, 0
002de0 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002de1 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002de2 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002de3 1fff                      	rol ZH
002de4 91a0 28e0                 	lds r26, triangle_hi_pitch_macro_offset
002de6 0fea                      	add ZL, r26
002de7 1df2                      	adc ZH, zero
                                 
002de8 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002dea 17ba                      	cp r27, r26
002deb f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002dec 91a0 28e1                 	lds r26, triangle_hi_pitch_macro_loop
002dee 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002def f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002df0 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002df1 95a3                      	inc r26 //increment the macro offset
002df2 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002df4 91b4                      	lpm r27, Z //load hi pitch data into r27
002df5 38b0                      	cpi r27, 0x80 //check for macro end flag
002df6 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002df7 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002df8 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
002dfa 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002dfc 3fbf                      	cpi r27, 0xFF
002dfd f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002dfe 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002e00 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002e01 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002e02 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002e04 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002e05 91b0 28dd                 	lds r27, triangle_total_hi_pitch_offset
002e07 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002e08 91a0 28dd                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002e0a 0fba                      	add r27, r26
002e0b 93b0 28dd                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002e0d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e0e 937f                      	push r23
002e0f 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002e10 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e11 0367                      	mulsu r22, r23
002e12 917f                      	pop r23
002e13 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002e14 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002e16 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002e18 0da0                      	add r26, r0 //offset the timer values
002e19 1db1                      	adc r27, r1
002e1a 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002e1c 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002e1e 91e0 28ea                 	lds ZL, triangle_fx_1xx
002e20 91f0 28eb                 	lds ZH, triangle_fx_1xx+1
002e22 9630                      	adiw Z, 0
002e23 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002e24 91a0 28ec                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002e26 91b0 28ed                 	lds r27, triangle_fx_1xx_total+1
002e28 0fae                      	add r26, ZL //increase the total offset by the rate
002e29 1fbf                      	adc r27, ZH
002e2a 93a0 28ec                 	sts triangle_fx_1xx_total, r26
002e2c 93b0 28ed                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002e2e 91e0 28ee                 	lds ZL, triangle_fx_2xx
002e30 91f0 28ef                 	lds ZH, triangle_fx_2xx+1
002e32 9630                      	adiw Z, 0
002e33 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002e34 91a0 28f0                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002e36 91b0 28f1                 	lds r27, triangle_fx_2xx_total+1
002e38 0fae                      	add r26, ZL //increase the total offset by the rate
002e39 1fbf                      	adc r27, ZH
002e3a 93a0 28f0                 	sts triangle_fx_2xx_total, r26
002e3c 93b0 28f1                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002e3e 91e0 28f6                 	lds ZL, triangle_fx_3xx_speed
002e40 91f0 28f7                 	lds ZH, triangle_fx_3xx_speed+1
002e42 9630                      	adiw Z, 0
002e43 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002e44 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002e45 91a0 28f2                 	lds r26, triangle_fx_3xx_start
002e47 91b0 28f3                 	lds r27, triangle_fx_3xx_start+1
002e49 9610                      	adiw r26:r27, 0
002e4a f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002e4b c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002e4c 91c0 28f4                 	lds r28, triangle_fx_3xx_target
002e4e 91d0 28f5                 	lds r29, triangle_fx_3xx_target+1
                                 
002e50 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002e51 07bd                      	cpc r27, r29
002e52 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002e53 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002e54 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002e55 9220 28f2                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002e57 9220 28f3                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002e59 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002e5a 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002e5b 0bdb                      	sbc r29, r27
002e5c 91a0 28f8                 	lds r26, triangle_fx_3xx_total_offset
002e5e 91b0 28f9                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002e60 0fae                      	add r26, ZL //add the speed to the total offset
002e61 1fbf                      	adc r27, ZH
002e62 1bca                      	sub r28, r26 //invert the total difference with the total offset
002e63 0bdb                      	sbc r29, r27
002e64 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e65 93a0 28f8                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002e67 93b0 28f9                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002e69 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002e6b 91b0 0aad                 	lds r27, TCB2_CCMPH
002e6d 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002e6e 0bbd                      	sbc r27, r29
002e6f 93a0 0aac                 	sts TCB2_CCMPL, r26
002e71 93b0 0aad                 	sts TCB2_CCMPH, r27
002e73 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002e74 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002e75 0bbd                      	sbc r27, r29
002e76 91c0 28f8                 	lds r28, triangle_fx_3xx_total_offset
002e78 91d0 28f9                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002e7a 0fce                      	add r28, ZL //add the speed to the total offset
002e7b 1fdf                      	adc r29, ZH
002e7c 1bac                      	sub r26, r28 //invert the total difference with the total offset
002e7d 0bbd                      	sbc r27, r29
002e7e f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e7f 93c0 28f8                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002e81 93d0 28f9                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002e83 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002e85 91d0 0aad                 	lds r29, TCB2_CCMPH
002e87 0fca                      	add r28, r26 //offset the current timer period with the total offset
002e88 1fdb                      	adc r29, r27
002e89 93c0 0aac                 	sts TCB2_CCMPL, r28
002e8b 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002e8d 91a0 28fa                 	lds r26, triangle_fx_4xy_speed
002e8f 15a2                      	cp r26, zero
002e90 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002e91 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002e92 91b0 28fb                 	lds r27, triangle_fx_4xy_depth
002e94 91c0 28fc                 	lds r28, triangle_fx_4xy_phase
002e96 0fca                      	add r28, r26 //increase the phase by the speed
002e97 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002e98 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002e99 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002e9a 93c0 28fc                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002e9c 31c0                      	cpi r28, 16
002e9d f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002e9e 32c0                      	cpi r28, 32
002e9f f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002ea0 33c0                      	cpi r28, 48
002ea1 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002ea2 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002ea3 70cf                      	andi r28, 0x0F //mask for values 0-15
002ea4 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002ea5 6fc0                      	ori r28, 0xF0
002ea6 95c0                      	com r28 //invert values 0-15
002ea7 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002ea8 70cf                      	andi r28, 0x0F //mask for values 0-15
002ea9 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002eaa 6fc0                      	ori r28, 0xF0
002eab 95c0                      	com r28 //invert values 0-15
002eac c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002ead 95b2                      	swap r27 //multiply depth by 16
002eae 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002eaf e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002eb0 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002eb1 0fec                      	add ZL, r28 //offset the table by the depth+phase
002eb2 1df2                      	adc ZH, zero
002eb3 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002eb4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002eb5 937f                      	push r23
002eb6 2f6c                      	mov r22, r28 //store the vibrato value into r22
002eb7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002eb8 9f67                      	mul r22, r23
002eb9 917f                      	pop r23
002eba 916f                      	pop r22
                                 
002ebb 9416                      	lsr r1 //shift out the fractional bits
002ebc 9407                      	ror r0
002ebd 9416                      	lsr r1
002ebe 9407                      	ror r0
002ebf 9416                      	lsr r1
002ec0 9407                      	ror r0
002ec1 9416                      	lsr r1
002ec2 9407                      	ror r0
                                 	
002ec3 91a0 0aac                 	lds r26, TCB2_CCMPL
002ec5 91b0 0aad                 	lds r27, TCB2_CCMPH
002ec7 0da0                      	add r26, r0
002ec8 1db1                      	adc r27, r1
002ec9 93a0 0aac                 	sts TCB2_CCMPL, r26
002ecb 93b0 0aad                 	sts TCB2_CCMPH, r27
002ecd c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002ece 95b2                      	swap r27 //multiply depth by 16
002ecf 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002ed0 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002ed1 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002ed2 0fec                      	add ZL, r28 //offset the table by the depth+phase
002ed3 1df2                      	adc ZH, zero
002ed4 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002ed5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ed6 937f                      	push r23
002ed7 2f6c                      	mov r22, r28 //store the vibrato value into r22
002ed8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ed9 9f67                      	mul r22, r23
002eda 917f                      	pop r23
002edb 916f                      	pop r22
                                 
002edc 9416                      	lsr r1 //shift out the fractional bits
002edd 9407                      	ror r0
002ede 9416                      	lsr r1
002edf 9407                      	ror r0
002ee0 9416                      	lsr r1
002ee1 9407                      	ror r0
002ee2 9416                      	lsr r1
002ee3 9407                      	ror r0
                                 
002ee4 91a0 0aac                 	lds r26, TCB2_CCMPL
002ee6 91b0 0aad                 	lds r27, TCB2_CCMPH
002ee8 19a0                      	sub r26, r0
002ee9 09b1                      	sbc r27, r1
002eea 93a0 0aac                 	sts TCB2_CCMPL, r26
002eec 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002eee 91e0 2902                 	lds ZL, triangle_fx_Qxy_target
002ef0 91f0 2903                 	lds ZH, triangle_fx_Qxy_target+1
002ef2 9630                      	adiw Z, 0
002ef3 f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002ef4 91a0 2906                 	lds r26, triangle_fx_Qxy_total_offset
002ef6 91b0 2907                 	lds r27, triangle_fx_Qxy_total_offset+1
002ef8 91c0 0aac                 	lds r28, TCB2_CCMPL
002efa 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002efc 1bec                      	sub ZL, r28 //calculate the difference to the target
002efd 0bfd                      	sbc ZH, r29
002efe f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002eff f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002f00 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
002f02 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
002f04 9220 2902                 	sts triangle_fx_Qxy_target, zero
002f06 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002f08 91b0 2901                 	lds r27, triangle_fx_Qxy_target_note
002f0a 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002f0c c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002f0d 91c0 2904                 	lds r28, triangle_fx_Qxy_speed
002f0f 91d0 2905                 	lds r29, triangle_fx_Qxy_speed+1
002f11 0fac                      	add r26, r28 //increase the total offset by the speed
002f12 1fbd                      	adc r27, r29
002f13 93a0 2906                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002f15 93b0 2907                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002f17 91e0 2909                 	lds ZL, triangle_fx_Rxy_target
002f19 91f0 290a                 	lds ZH, triangle_fx_Rxy_target+1
002f1b 9630                      	adiw Z, 0
002f1c f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002f1d 91a0 290d                 	lds r26, triangle_fx_Rxy_total_offset
002f1f 91b0 290e                 	lds r27, triangle_fx_Rxy_total_offset+1
002f21 91c0 0aac                 	lds r28, TCB2_CCMPL
002f23 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002f25 1bce                      	sub r28, ZL //calculate the difference to the target
002f26 0bdf                      	sbc r29, ZH
002f27 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002f28 f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002f29 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002f2b 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
002f2d 9220 2909                 	sts triangle_fx_Rxy_target, zero
002f2f 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002f31 91b0 2908                 	lds r27, triangle_fx_Rxy_target_note
002f33 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002f35 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002f36 91c0 290b                 	lds r28, triangle_fx_Rxy_speed
002f38 91d0 290c                 	lds r29, triangle_fx_Rxy_speed+1
002f3a 0fac                      	add r26, r28 //increase the total offset by the speed
002f3b 1fbd                      	adc r27, r29
002f3c 93a0 290d                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002f3e 93b0 290e                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002f40 91e0 2917                 	lds ZL, noise_volume_macro
002f42 91f0 2918                 	lds ZH, noise_volume_macro+1
002f44 9630                      	adiw Z, 0
002f45 f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002f46 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f47 1fff                      	rol ZH
002f48 91a0 2919                 	lds r26, noise_volume_macro_offset
002f4a 0fea                      	add ZL, r26
002f4b 1df2                      	adc ZH, zero
                                 
002f4c 91b0 291b                 	lds r27, noise_volume_macro_release
002f4e 17ba                      	cp r27, r26
002f4f f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002f50 91a0 291a                 	lds r26, noise_volume_macro_loop
002f52 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f53 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f54 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002f55 95a3                      	inc r26 //increment the macro offset
002f56 93a0 2919                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002f58 91b4                      	lpm r27, Z //load volume data into r27
002f59 3fbf                      	cpi r27, 0xFF //check for macro end flag
002f5a f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002f5b 91b0 291b                 	lds r27, noise_volume_macro_release
002f5d 3fbf                      	cpi r27, 0xFF
002f5e f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002f5f 91b0 291a                 	lds r27, noise_volume_macro_loop //load the loop index
002f61 93b0 2919                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002f63 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002f64 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002f65 93a0 2919                 	sts noise_volume_macro_offset, r26
002f67 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002f68 efea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002f69 e6f3                      	ldi ZH, HIGH(volumes << 1)
002f6a 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002f6b 0feb                      	add ZL, r27 //add offset to the table
002f6c 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002f6d 91b0 2813                 	lds r27, noise_param //load main volume
002f6f 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f70 91a0 2941                 	lds r26, noise_fx_7xy_value
002f72 30a0                      	cpi r26, 0x00
002f73 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002f74 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f75 1df2                      	adc ZH, zero
002f76 91b4                      	lpm r27, Z
002f77 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f79 c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002f7a 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002f7c 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f7d 91a0 2941                 	lds r26, noise_fx_7xy_value
002f7f 30a0                      	cpi r26, 0x00
002f80 f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002f81 93b0 2816                 	sts noise_output_volume, r27
002f83 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002f84 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f85 f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002f86 f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002f87 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f88 1df2                      	adc ZH, zero
002f89 91b4                      	lpm r27, Z
002f8a 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f8c c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002f8d e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f8e 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f8f 1df2                      	adc ZH, zero
002f90 91b4                      	lpm r27, Z
002f91 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f93 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002f94 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f95 f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f96 f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f97 93b0 2816                 	sts noise_output_volume, r27
002f99 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002f9a e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f9b 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002f9d 91e0 291c                 	lds ZL, noise_arpeggio_macro
002f9f 91f0 291d                 	lds ZH, noise_arpeggio_macro+1
002fa1 9630                      	adiw Z, 0
002fa2 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002fa3 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002fa4 1fff                      	rol ZH
002fa5 91a0 291e                 	lds r26, noise_arpeggio_macro_offset
002fa7 0fea                      	add ZL, r26
002fa8 1df2                      	adc ZH, zero
                                 
002fa9 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002fab 17ba                      	cp r27, r26
002fac f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002fad 91a0 291f                 	lds r26, noise_arpeggio_macro_loop
002faf 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002fb0 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002fb1 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002fb2 95a3                      	inc r26 //increment the macro offset
002fb3 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002fb5 91b4                      	lpm r27, Z //load arpeggio data into r27
002fb6 38b0                      	cpi r27, 0x80 //check for macro end flag
002fb7 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002fb8 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002fb9 50a1                      	subi r26, 1 //keep the offset at the end flag
002fba 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
002fbc 91b0 2921                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002fbe 30b1                      	cpi r27, 0x01
002fbf f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002fc0 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002fc2 3fbf                      	cpi r27, 0xFF
002fc3 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002fc4 91b0 291f                 	lds r27, noise_arpeggio_macro_loop
002fc6 3fbf                      	cpi r27, 0xFF
002fc7 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002fc8 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002fc9 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002fcb 3fbf                      	cpi r27, 0xFF
002fcc f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002fcd 91b0 291f                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002fcf 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002fd0 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002fd1 91c0 2934                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002fd3 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
002fd5 9620                      	adiw r29:r28, 0
002fd6 f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002fd7 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002fd8 93a0 291e                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002fda cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002fdb 93b0 291e                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002fdd cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002fde 91c0 2934                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002fe0 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
002fe2 9620                      	adiw r29:r28, 0 //check for 0xy effect
002fe3 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
002fe4 95d6                      	lsr r29
002fe5 95c7                      	ror r28
002fe6 95d7                      	ror r29
002fe7 95c7                      	ror r28
002fe8 95d7                      	ror r29
002fe9 95c7                      	ror r28
002fea 95d7                      	ror r29
002feb 95c7                      	ror r28
002fec 95d7                      	ror r29
002fed 95d2                      	swap r29
                                 
002fee 93c0 2934                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002ff0 93d0 2935                 	sts noise_fx_0xy_sequence+1, r29
002ff2 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002ff3 91a0 2817                 	lds r26, noise_note //load the current note index
002ff5 0fac                      	add r26, r28 //add the note offset
002ff6 c01c                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002ff7 91a0 2817                 	lds r26, noise_note //load the current note index
002ff9 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002ffa 9220 2922                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002ffc 9220 2923                 	sts noise_total_pitch_offset+1, zero
002ffe 9220 2929                 	sts noise_total_hi_pitch_offset, zero
003000 91a0 2921                 	lds r26, noise_arpeggio_macro_mode
003002 30a1                      	cpi r26, 0x01 //absolute mode
003003 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
003004 f031                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
003005 c007                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
003006 91a0 2817                 	lds r26, noise_note //load the current note index
003008 0fab                      	add r26, r27 //offset the note with the arpeggio data
003009 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
00300a c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
00300b 2fab                      	mov r26, r27 //move the arpeggio data into r26
00300c c006                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
00300d 91a0 2817                 	lds r26, noise_note //load the current note index
00300f 0fab                      	add r26, r27 //offset the note with the arpeggio data
003010 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
003011 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
003013 93a0 2818                 	sts noise_adjusted_note, r26
003015 c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
003016 91e0 2924                 	lds ZL, noise_pitch_macro
003018 91f0 2925                 	lds ZH, noise_pitch_macro+1
00301a 9630                      	adiw Z, 0
00301b f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
00301c c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
00301d 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00301e 1fff                      	rol ZH
00301f 91a0 2926                 	lds r26, noise_pitch_macro_offset
003021 0fea                      	add ZL, r26
003022 1df2                      	adc ZH, zero
                                 
003023 91b0 2928                 	lds r27, noise_pitch_macro_release
003025 17ba                      	cp r27, r26
003026 f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
003027 91a0 2927                 	lds r26, noise_pitch_macro_loop
003029 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00302a f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00302b c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
00302c 95a3                      	inc r26 //increment the macro offset
00302d 93a0 2926                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
00302f 91b4                      	lpm r27, Z //load pitch data into r27
003030 38b0                      	cpi r27, 0x80 //check for macro end flag
003031 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
003032 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003033 93a0 2926                 	sts noise_pitch_macro_offset, r26
003035 91b0 2928                 	lds r27, noise_pitch_macro_release
003037 3fbf                      	cpi r27, 0xFF
003038 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
003039 91b0 2927                 	lds r27, noise_pitch_macro_loop //load the loop index
00303b 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00303c f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00303d 93b0 2926                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
00303f cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
003040 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
003041 91a0 2922                 	lds r26, noise_total_pitch_offset
003043 0fba                      	add r27, r26
003044 93b0 2922                 	sts noise_total_pitch_offset, r27
003046 91a0 2818                 	lds r26, noise_adjusted_note
003048 1bab                      	sub r26, r27
                                 	
003049 91b0 2937                 	lds r27, noise_fx_1xx_total
00304b 0fab                      	add r26, r27
00304c 91b0 2939                 	lds r27, noise_fx_2xx_total
00304e 1bab                      	sub r26, r27
00304f 91b0 293d                 	lds r27, noise_fx_4xy_offset
003051 1bab                      	sub r26, r27
003052 91b0 2945                 	lds r27, noise_fx_Pxx_total
003054 1bab                      	sub r26, r27
                                 
003055 70af                      	andi r26, 0x0F
                                 
003056 e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
003057 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
003058 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
003059 0fea                      	add ZL, r26 //add offset
00305a 1df2                      	adc ZH, zero
00305b 91a5                      	lpm r26, Z+ //load bytes
00305c 91b4                      	lpm r27, Z
00305d 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
00305f 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
003061 91e0 292a                 	lds ZL, noise_hi_pitch_macro
003063 91f0 292b                 	lds ZH, noise_hi_pitch_macro+1
003065 9630                      	adiw Z, 0
003066 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
003067 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
003068 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003069 1fff                      	rol ZH
00306a 91a0 292c                 	lds r26, noise_hi_pitch_macro_offset
00306c 0fea                      	add ZL, r26
00306d 1df2                      	adc ZH, zero
                                 
00306e 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
003070 17ba                      	cp r27, r26
003071 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
003072 91a0 292d                 	lds r26, noise_hi_pitch_macro_loop
003074 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003075 f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003076 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
003077 95a3                      	inc r26 //increment the macro offset
003078 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
00307a 91b4                      	lpm r27, Z //load hi pitch data into r27
00307b 38b0                      	cpi r27, 0x80 //check for macro end flag
00307c f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
00307d 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00307e 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
003080 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
003082 3fbf                      	cpi r27, 0xFF
003083 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
003084 91b0 292d                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
003086 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003087 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
003088 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
00308a cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
00308b 91b0 2929                 	lds r27, noise_total_hi_pitch_offset
00308d c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
00308e 91a0 2929                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
003090 0fba                      	add r27, r26
003091 93b0 2929                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
003093 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003094 937f                      	push r23
003095 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
003096 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003097 0367                      	mulsu r22, r23
003098 917f                      	pop r23
003099 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
00309a 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
00309c 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
00309e 0da0                      	add r26, r0 //offset the timer values
00309f 1db1                      	adc r27, r1
0030a0 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
0030a2 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
0030a4 91e0 292f                 	lds ZL, noise_duty_macro
0030a6 91f0 2930                 	lds ZH, noise_duty_macro+1
0030a8 9630                      	adiw Z, 0
0030a9 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
0030aa 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0030ab 1fff                      	rol ZH
0030ac 91a0 2931                 	lds r26, noise_duty_macro_offset
0030ae 0fea                      	add ZL, r26
0030af 1df2                      	adc ZH, zero
                                 
0030b0 91b0 2933                 	lds r27, noise_duty_macro_release
0030b2 17ba                      	cp r27, r26
0030b3 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
0030b4 91a0 2932                 	lds r26, noise_duty_macro_loop
0030b6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0030b7 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0030b8 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
0030b9 95a3                      	inc r26 //increment the macro offset
0030ba 93a0 2931                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
0030bc 91b4                      	lpm r27, Z //load pitch data into r27
0030bd 3fbf                      	cpi r27, 0xFF //check for macro end flag
0030be f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
0030bf 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0030c0 93a0 2931                 	sts noise_duty_macro_offset, r26
0030c2 91b0 2933                 	lds r27, noise_duty_macro_release
0030c4 3fbf                      	cpi r27, 0xFF
0030c5 f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
0030c6 91b0 2932                 	lds r27, noise_duty_macro_loop //load the loop index
0030c8 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0030c9 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0030ca 93b0 2931                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
0030cc cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
0030cd 95b6                      	lsr r27
0030ce 95b7                      	ror r27 //move mode bit to bit 7
0030cf 91c0 2814                 	lds r28, noise_period
0030d1 77cf                      	andi r28, 0b01111111
0030d2 2bcb                      	or r28, r27 //store the new noise mode
0030d3 93c0 2813                 	sts noise_param, r28
                                 
0030d5 776f                      	andi noise_sequence_HIGH, 0b01111111
0030d6 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
0030d7 91e0 2936                 	lds ZL, noise_fx_1xx
0030d9 30e0                      	cpi ZL, 0
0030da f029                      	breq sound_driver_channel3_fx_2xx_routine
                                 
0030db 91a0 2937                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
0030dd 0fae                      	add r26, ZL //increase the total offset by the rate
0030de 93a0 2937                 	sts noise_fx_1xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
0030e0 91e0 2938                 	lds ZL, noise_fx_2xx
0030e2 30e0                      	cpi ZL, 0
0030e3 f029                      	breq sound_driver_channel3_fx_3xx_routine
                                 
0030e4 91a0 2939                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
0030e6 0fae                      	add r26, ZL //increase the total offset by the rate
0030e7 93a0 2939                 	sts noise_fx_2xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
0030e9 91a0 293a                 	lds r26, noise_fx_4xy_speed
0030eb 15a2                      	cp r26, zero
0030ec f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
0030ed c033                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
0030ee 91b0 293b                 	lds r27, noise_fx_4xy_depth
0030f0 91c0 293c                 	lds r28, noise_fx_4xy_phase
0030f2 0fca                      	add r28, r26 //increase the phase by the speed
0030f3 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0030f4 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0030f5 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
0030f6 93c0 293c                 	sts noise_fx_4xy_phase, r28 //store the new phase
0030f8 31c0                      	cpi r28, 16
0030f9 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
0030fa 32c0                      	cpi r28, 32
0030fb f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
0030fc 33c0                      	cpi r28, 48
0030fd f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
0030fe c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
0030ff 70cf                      	andi r28, 0x0F //mask for values 0-15
003100 c014                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
003101 6fc0                      	ori r28, 0xF0
003102 95c0                      	com r28 //invert values 0-15
003103 c011                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
003104 70cf                      	andi r28, 0x0F //mask for values 0-15
003105 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
003106 6fc0                      	ori r28, 0xF0
003107 95c0                      	com r28 //invert values 0-15
003108 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
003109 95b2                      	swap r27 //multiply depth by 16
00310a 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00310b e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00310c e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00310d 0fec                      	add ZL, r28 //offset the table by the depth+phase
00310e 1df2                      	adc ZH, zero
00310f 91c4                      	lpm r28, Z //load the tremelo value into r28
003110 95c2                      	swap r28
003111 70cf                      	andi r28, 0x0F
                                 
003112 93c0 293d                 	sts noise_fx_4xy_offset, r28
003114 c00c                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
003115 95b2                      	swap r27 //multiply depth by 16
003116 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
003117 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003118 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003119 0fec                      	add ZL, r28 //offset the table by the depth+phase
00311a 1df2                      	adc ZH, zero
00311b 91c4                      	lpm r28, Z //load the vibrato value into r28
00311c 95c2                      	swap r28
00311d 70cf                      	andi r28, 0x0F
                                 
00311e 95c1                      	neg r28
00311f 93c0 293d                 	sts noise_fx_4xy_offset, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
003121 91a0 293e                 	lds r26, noise_fx_7xy_speed
003123 15a2                      	cp r26, zero
003124 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
003125 91b0 293f                 	lds r27, noise_fx_7xy_depth
003127 91c0 2940                 	lds r28, noise_fx_7xy_phase
003129 0fca                      	add r28, r26 //increase the phase by the speed
00312a 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00312b f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00312c e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
00312d 93c0 2940                 	sts noise_fx_7xy_phase, r28 //store the new phase
00312f 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
003130 ffc4                      	sbrs r28, 4
003131 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
003132 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
003133 70cf                      	andi r28, 0x0F //mask for values 0-15
003134 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
003135 6fc0                      	ori r28, 0xF0
003136 95c0                      	com r28 //invert values 0-15
003137 c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
003138 95b2                      	swap r27 //multiply depth by 16
003139 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00313a e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00313b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00313c 0fec                      	add ZL, r28 //offset the table by the depth+phase
00313d 1df2                      	adc ZH, zero
00313e 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00313f 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
003140 93c0 2941                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
003142 91b0 2942                 	lds r27, noise_fx_Axy
003144 15b2                      	cp r27, zero
003145 f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
003146 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
003148 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
00314a 2fda                      	mov r29, r26 //copy fractional volume into r29
00314b 2fec                      	mov r30, r28 //copy the noise_param into r30
00314c 95e2                      	swap r30
00314d 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
00314e 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
00314f 17ed                      	cp r30, r29 //compare the fractional and integer volumes
003150 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
003151 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
003152 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
003153 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
003154 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
003155 f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
003156 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
003157 c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
003158 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
003159 f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00315a e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
00315b 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
00315d 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
00315e 95a2                      	swap r26
00315f 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
003160 2bca                      	or r28, r26 //store the new volume back into noise_param
003161 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Qxy_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
                                 
                                 
                                 
                                 sound_driver_exit:
003163 91ff                      	pop r31
003164 91ef                      	pop r30
003165 91df                      	pop r29
003166 91cf                      	pop r28
003167 940c 173e                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
003169 7f05
00316a 010a
00316b 0214
00316c 0328
00316d 0450
00316e 051e
00316f 0607
003170 070d
003171 0806
003172 090c
003173 0a18
003174 0b30
003175 0c60
003176 0d24
003177 0e08
003178 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
003179 0301
00317a fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
00317b 1975
00317c 197a
00317d 1996
00317e 19b2
00317f 19d5                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
003180 19e0
003181 19ed
003182 19f0
003183 19f3
003184 19f6                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
003185 19f9
003186 1a01
003187 1a04
003188 1a11
003189 1a12                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
00318a 1a13
00318b 1a14
00318c 1a15
00318d 1a2d
00318e 1a6f                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
00318f 1ab0
003190 1abd
003191 1ad1
003192 1ad2
003193 1ad3                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
003194 1ad4                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
003195 1c63
003196 1c68
003197 1c84
003198 1ca0
003199 1cc3                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
00319a 1cce
00319b 1cdb
00319c 1cde
00319d 1ce1
00319e 1ce4                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
00319f 1ce7
0031a0 1cef
0031a1 1cf2
0031a2 1cff
0031a3 1d00                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
0031a4 1d01
0031a5 1d02
0031a6 1d03
0031a7 1d1b
0031a8 1d5d                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
0031a9 1d9e
0031aa 1dab
0031ab 1dbf
0031ac 1dc0
0031ad 1dc1                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
0031ae 1dc2                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
0031af 1f44
0031b0 1f49
0031b1 1f65
0031b2 1f81
0031b3 1fa4                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
0031b4 1faf
0031b5 1fb0
0031b6 1fb1
0031b7 1fb4
0031b8 1fb7                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
0031b9 1fba
0031ba 1fc7
0031bb 1fca
0031bc 1fd7
0031bd 1fd8                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
0031be 1fd9
0031bf 1fda
0031c0 1fdb
0031c1 1ff3
0031c2 2035                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
0031c3 2076
0031c4 2083
0031c5 2084
0031c6 2085
0031c7 2086                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
0031c8 2087                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
0031c9 220d
0031ca 2212
0031cb 221b
0031cc 2224
0031cd 2225                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
0031ce 2232
0031cf 223f
0031d0 2242
0031d1 2245
0031d2 2248                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
0031d3 224b
0031d4 2252
0031d5 2255
0031d6 2262
0031d7 2263                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
0031d8 2264
0031d9 2265
0031da 2266
0031db 2269
0031dc 226a                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
0031dd 226b
0031de 2278
0031df 2283
0031e0 2284
0031e1 2285                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
0031e2 2286                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 channel4_fx:
0031e3 23d0
0031e4 23d1
0031e5 23d2
0031e6 23d3
0031e7 23d4                      	.dw sound_driver_channel4_fx_0xy, sound_driver_channel4_fx_1xx, sound_driver_channel4_fx_2xx, sound_driver_channel4_fx_3xx, sound_driver_channel4_fx_4xy
0031e8 23d5
0031e9 23d6
0031ea 23d7
0031eb 23da
0031ec 23dd                      	.dw sound_driver_channel4_fx_7xy, sound_driver_channel4_fx_Axy, sound_driver_channel4_fx_Bxx, sound_driver_channel4_fx_Cxx, sound_driver_channel4_fx_Dxx
0031ed 23e0
0031ee 23e1
0031ef 23e4
0031f0 23f1
0031f1 23f2                      	.dw sound_driver_channel4_fx_Exx, sound_driver_channel4_fx_Fxx, sound_driver_channel4_fx_Gxx, sound_driver_channel4_fx_Hxy, sound_driver_channel4_fx_Ixy
0031f2 23f3
0031f3 23f4
0031f4 23f5
0031f5 23f6
0031f6 23f7                      	.dw sound_driver_channel4_fx_Hxx, sound_driver_channel4_fx_Ixx, sound_driver_channel4_fx_Pxx, sound_driver_channel4_fx_Qxy, sound_driver_channel4_fx_Rxy
0031f7 23f8
0031f8 2405
0031f9 2406
0031fa 2407
0031fb 2408                      	.dw sound_driver_channel4_fx_Sxx, sound_driver_channel4_fx_Vxx, sound_driver_channel4_fx_Wxx, sound_driver_channel4_fx_Xxx, sound_driver_channel4_fx_Yxx
0031fc 2409                      	.dw sound_driver_channel4_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0031fd 0000
0031fe 0000
0031ff 0000
003200 0000
003201 0000
003202 0000
003203 0000
003204 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
003205 0100
003206 0101
003207 0101
003208 0101
003209 0101
00320a 0101
00320b 0101
00320c 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
00320d 0100
00320e 0101
00320f 0101
003210 0101
003211 0101
003212 0101
003213 0101
003214 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
003215 0100
003216 0101
003217 0101
003218 0101
003219 0101
00321a 0202
00321b 0202
00321c 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
00321d 0100
00321e 0101
00321f 0101
003220 0101
003221 0202
003222 0202
003223 0303
003224 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
003225 0100
003226 0101
003227 0101
003228 0202
003229 0302
00322a 0303
00322b 0404
00322c 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
00322d 0100
00322e 0101
00322f 0201
003230 0202
003231 0303
003232 0404
003233 0504
003234 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
003235 0100
003236 0101
003237 0201
003238 0302
003239 0403
00323a 0504
00323b 0605
00323c 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
00323d 0100
00323e 0101
00323f 0202
003240 0303
003241 0404
003242 0505
003243 0606
003244 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
003245 0100
003246 0101
003247 0302
003248 0403
003249 0504
00324a 0606
00324b 0707
00324c 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
00324d 0100
00324e 0201
00324f 0302
003250 0404
003251 0605
003252 0706
003253 0808
003254 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
003255 0100
003256 0201
003257 0302
003258 0504
003259 0605
00325a 0807
00325b 0908
00325c 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
00325d 0100
00325e 0201
00325f 0403
003260 0504
003261 0706
003262 0808
003263 0a09
003264 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
003265 0100
003266 0201
003267 0403
003268 0605
003269 0706
00326a 0908
00326b 0b0a
00326c 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
00326d 0100
00326e 0201
00326f 0403
003270 0605
003271 0807
003272 0a09
003273 0c0b
003274 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
003275 0100
003276 0302
003277 0504
003278 0706
003279 0908
00327a 0b0a
00327b 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 249 r0 : 148 r1 : 160 r2 : 668 r3 :   3 r4 :   4 
r5 :   0 r6 :   0 r7 :   6 r8 :   4 r9 :   9 r10:   6 r11:   4 r12:   9 
r13:   1 r14:   1 r15:   2 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 138 r23: 127 r24:   3 r25:  24 r26: 942 r27:1203 r28: 666 
r29: 350 r30: 383 r31: 331 
Registers used: 31 out of 35 (88.6%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 132 add   : 183 adiw  : 100 and   :   2 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   6 brcs  :  13 break :   0 breq  : 173 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  76 brlt  :   0 brmi  :   0 
brne  : 123 brpl  :   0 brsh  :  37 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   6 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 115 cpc   :  15 
cpi   : 175 cpse  :  21 dec   :  40 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   5 in    :   5 inc   :  46 
jmp   :   8 ld    :   0 ldd   :   0 ldi   : 300 lds   : 675 lpm   : 273 
lsl   :  80 lsr   : 135 mov   : 146 movw  :   0 mul   :  21 muls  :   0 
mulsu :  10 neg   :   1 nop   :   0 or    :  24 ori   :  12 out   :   9 
pop   :  97 push  :  89 rcall :  56 ret   :  34 reti  :   7 rjmp  : 560 
rol   :  57 ror   : 156 sbc   :  30 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  25 sbrs  :  18 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1349 sub   :  53 subi  :  49 swap  :  47 tst   :   0 wdr   :   0 

Instructions used: 54 out of 114 (47.4%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0064fa  15332  10394  25726   49152  52.3%
[.dseg] 0x002800 0x002956      0    342    342    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 63 warnings
