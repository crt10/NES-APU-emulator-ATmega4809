
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Wed Jan 20 00:21:32 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           song_frames: .byte 2
002815                           song_frame_offset: .byte 2
002817                           song_size: .byte 2
002819                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281a                           song_fx_Bxx: .byte 1
00281b                           song_fx_Cxx: .byte 1
00281c                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
00281d                           pulse1_pattern: .byte 2
00281f                           pulse1_pattern_delay_rows: .byte 1
002820                           pulse1_pattern_delay_frames: .byte 1
002821                           pulse1_pattern_offset: .byte 2
                                 
002823                           pulse1_volume_macro: .byte 2
002825                           pulse1_volume_macro_offset: .byte 1
002826                           pulse1_volume_macro_loop: .byte 1
002827                           pulse1_volume_macro_release: .byte 1
                                 
002828                           pulse1_arpeggio_macro: .byte 2
00282a                           pulse1_arpeggio_macro_offset: .byte 1
00282b                           pulse1_arpeggio_macro_loop: .byte 1
00282c                           pulse1_arpeggio_macro_release: .byte 1
00282d                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00282e                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00282f                           pulse1_pitch_macro: .byte 2
002831                           pulse1_pitch_macro_offset: .byte 1
002832                           pulse1_pitch_macro_loop: .byte 1
002833                           pulse1_pitch_macro_release: .byte 1
                                 
002834                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002835                           pulse1_hi_pitch_macro: .byte 2
002837                           pulse1_hi_pitch_macro_offset: .byte 1
002838                           pulse1_hi_pitch_macro_loop: .byte 1
002839                           pulse1_hi_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_duty_macro: .byte 2
00283c                           pulse1_duty_macro_offset: .byte 1
00283d                           pulse1_duty_macro_loop: .byte 1
00283e                           pulse1_duty_macro_release: .byte 1
                                 
00283f                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002841                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002843                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002845                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002847                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002849                           pulse1_fx_3xx_start: .byte 2 //the starting note period
00284b                           pulse1_fx_3xx_target: .byte 2 //target note period
00284d                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00284f                           pulse1_fx_3xx_total_offset: .byte 2
002851                           pulse1_fx_4xy_speed: .byte 1
002852                           pulse1_fx_4xy_depth: .byte 1
002853                           pulse1_fx_4xy_phase: .byte 1
002854                           pulse1_fx_7xy_speed: .byte 1
002855                           pulse1_fx_7xy_depth: .byte 1
002856                           pulse1_fx_7xy_phase: .byte 1
002857                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002858                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002859                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00285a                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00285b                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
00285c                           pulse1_fx_Qxy_target: .byte 2 //target note period
00285e                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002860                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002862                           pulse1_fx_Rxy_target: .byte 2 //target note period
002864                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002866                           pulse1_fx_Rxy_total_offset: .byte 2
002868                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002869                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
00286a                           pulse2_pattern: .byte 2
00286c                           pulse2_pattern_delay_rows: .byte 1
00286d                           pulse2_pattern_delay_frames: .byte 1
00286e                           pulse2_pattern_offset: .byte 2
                                 
002870                           pulse2_volume_macro: .byte 2
002872                           pulse2_volume_macro_offset: .byte 1
002873                           pulse2_volume_macro_loop: .byte 1
002874                           pulse2_volume_macro_release: .byte 1
                                 
002875                           pulse2_arpeggio_macro: .byte 2
002877                           pulse2_arpeggio_macro_offset: .byte 1
002878                           pulse2_arpeggio_macro_loop: .byte 1
002879                           pulse2_arpeggio_macro_release: .byte 1
00287a                           pulse2_arpeggio_macro_mode: .byte 1
                                 
00287b                           pulse2_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00287c                           pulse2_pitch_macro: .byte 2
00287e                           pulse2_pitch_macro_offset: .byte 1
00287f                           pulse2_pitch_macro_loop: .byte 1
002880                           pulse2_pitch_macro_release: .byte 1
                                 
002881                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002882                           pulse2_hi_pitch_macro: .byte 2
002884                           pulse2_hi_pitch_macro_offset: .byte 1
002885                           pulse2_hi_pitch_macro_loop: .byte 1
002886                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002887                           pulse2_duty_macro: .byte 2
002889                           pulse2_duty_macro_offset: .byte 1
00288a                           pulse2_duty_macro_loop: .byte 1
00288b                           pulse2_duty_macro_release: .byte 1
                                 
00288c                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00288e                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002890                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002892                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002894                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002896                           pulse2_fx_3xx_start: .byte 2 //the starting note period
002898                           pulse2_fx_3xx_target: .byte 2 //target note period
00289a                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00289c                           pulse2_fx_3xx_total_offset: .byte 2
00289e                           pulse2_fx_4xy_speed: .byte 1
00289f                           pulse2_fx_4xy_depth: .byte 1
0028a0                           pulse2_fx_4xy_phase: .byte 1
0028a1                           pulse2_fx_7xy_speed: .byte 1
0028a2                           pulse2_fx_7xy_depth: .byte 1
0028a3                           pulse2_fx_7xy_phase: .byte 1
0028a4                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028a5                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028a6                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028a7                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028a8                           pulse2_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
0028a9                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028ab                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028ad                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028af                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028b1                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028b3                           pulse2_fx_Rxy_total_offset: .byte 2
0028b5                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028b6                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028b7                           triangle_pattern: .byte 2
0028b9                           triangle_pattern_delay_rows: .byte 1
0028ba                           triangle_pattern_delay_frames: .byte 1
0028bb                           triangle_pattern_offset: .byte 2
                                 
0028bd                           triangle_volume_macro: .byte 2
0028bf                           triangle_volume_macro_offset: .byte 1
0028c0                           triangle_volume_macro_loop: .byte 1
0028c1                           triangle_volume_macro_release: .byte 1
                                 
0028c2                           triangle_arpeggio_macro: .byte 2
0028c4                           triangle_arpeggio_macro_offset: .byte 1
0028c5                           triangle_arpeggio_macro_loop: .byte 1
0028c6                           triangle_arpeggio_macro_release: .byte 1
0028c7                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028c8                           triangle_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
0028c9                           triangle_pitch_macro: .byte 2
0028cb                           triangle_pitch_macro_offset: .byte 1
0028cc                           triangle_pitch_macro_loop: .byte 1
0028cd                           triangle_pitch_macro_release: .byte 1
                                 
0028ce                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028cf                           triangle_hi_pitch_macro: .byte 2
0028d1                           triangle_hi_pitch_macro_offset: .byte 1
0028d2                           triangle_hi_pitch_macro_loop: .byte 1
0028d3                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028d4                           triangle_duty_macro: .byte 2
0028d6                           triangle_duty_macro_offset: .byte 1
0028d7                           triangle_duty_macro_loop: .byte 1
0028d8                           triangle_duty_macro_release: .byte 1
                                 
0028d9                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028db                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028dd                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028df                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028e1                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028e3                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028e5                           triangle_fx_3xx_target: .byte 2 //target note period
0028e7                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028e9                           triangle_fx_3xx_total_offset: .byte 2
0028eb                           triangle_fx_4xy_speed: .byte 1
0028ec                           triangle_fx_4xy_depth: .byte 1
0028ed                           triangle_fx_4xy_phase: .byte 1
0028ee                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028ef                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028f0                           triangle_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
0028f1                           triangle_fx_Qxy_target: .byte 2 //target note period
0028f3                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028f5                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028f7                           triangle_fx_Rxy_target: .byte 2 //target note period
0028f9                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028fb                           triangle_fx_Rxy_total_offset: .byte 2
0028fd                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028fe                           triangle_fx_Sxx_post: .byte 1
                                 
                                 
0028ff                           noise_pattern_delay: .byte 1
002900                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 
                                 reset:
000000 940c 11fd                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 15a3                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 14d0                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 14db                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 14d0                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 14f2                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 153f                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 158c                 	jmp triangle_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(72): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(73): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(103): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(114): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(140): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(141): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(142): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(145): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(153): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(156): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(158): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(159): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(161): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(164): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(165): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(166): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(169): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(170): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(171): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(282): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(283): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(284): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(286): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(291): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(292): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(293): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(294): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(295): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(296): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(297): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(298): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(299): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(301): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(305): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(306): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(307): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(308): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(311): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(313): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(317): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(322): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(323): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(324): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(326): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(327): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(328): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(331): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(332): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(335): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(336): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(338): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(345): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(346): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
0011fd edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
0011fe 93c0 0034                 	sts CPU_CCP, r28
001200 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
001201 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001203 2422                      	clr zero
                                 
                                 	//MEMORY
001204 e3c0                      	ldi r28, 0b00110000
001205 93c0 2800                 	sts pulse1_param, r28
001207 e8c0                      	ldi r28, 0b10000000
001208 93c0 2801                 	sts pulse1_sweep_param, r28
00120a efcf                      	ldi r28, 0xFF
00120b 93c0 2802                 	sts pulse1_timerL, r28
00120d 93c0 2803                 	sts pulse1_timerH, r28
00120f 93c0 2804                 	sts pulse1_length, r28
                                 
001211 e3c0                      	ldi r28, 0b00110000
001212 93c0 2808                 	sts pulse2_param, r28
001214 e8c0                      	ldi r28, 0b10000000
001215 93c0 2809                 	sts pulse2_sweep_param, r28
001217 efcf                      	ldi r28, 0xFF
001218 93c0 280a                 	sts pulse2_timerL, r28
00121a 93c0 280b                 	sts pulse2_timerH, r28
00121c 93c0 280c                 	sts pulse2_length, r28
                                 
00121e efcf                      	ldi r28, 0xFF
00121f 93c0 2810                 	sts triangle_timerL, r28
001221 93c0 2811                 	sts triangle_timerH, r28
                                 
001223 e0c2                      	ldi r28, 0x02
001224 93c0 2815                 	sts song_frame_offset, r28
001226 9220 2816                 	sts song_frame_offset+1, zero
001228 efcf                      	ldi r28, 0xFF
001229 93c0 281a                 	sts song_fx_Bxx, r28
00122b 9220 281b                 	sts song_fx_Cxx, zero
00122d 9220 281c                 	sts song_fx_Dxx, zero
00122f e3e6                      	ldi ZL, LOW(song0_frames << 1)
001230 e0f2                      	ldi ZH, HIGH(song0_frames << 1)
001231 93e0 2813                 	sts song_frames, ZL
001233 93f0 2814                 	sts song_frames+1, ZH
001235 91c5                      	lpm r28, Z+ //load the song size
001236 91d5                      	lpm r29, Z+
001237 93c0 2817                 	sts song_size, r28
001239 93d0 2818                 	sts song_size+1, r29
00123b 9220 2819                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
00123d 91c5                      	lpm r28, Z+
00123e 91d5                      	lpm r29, Z+
00123f 0fcc                      	lsl r28
001240 1fdd                      	rol r29
001241 93c0 281d                 	sts pulse1_pattern, r28
001243 93d0 281e                 	sts pulse1_pattern+1, r29
001245 9220 281f                 	sts pulse1_pattern_delay_rows, zero
001247 9220 2820                 	sts pulse1_pattern_delay_frames, zero
001249 9220 2821                 	sts pulse1_pattern_offset, zero
00124b 9220 2822                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
00124d 91c5                      	lpm r28, Z+
00124e 91d5                      	lpm r29, Z+
00124f 0fcc                      	lsl r28
001250 1fdd                      	rol r29
001251 93c0 286a                 	sts pulse2_pattern, r28
001253 93d0 286b                 	sts pulse2_pattern+1, r29
001255 9220 286c                 	sts pulse2_pattern_delay_rows, zero
001257 9220 286d                 	sts pulse2_pattern_delay_frames, zero
001259 9220 286e                 	sts pulse2_pattern_offset, zero
00125b 9220 286f                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
00125d 91c5                      	lpm r28, Z+
00125e 91d5                      	lpm r29, Z+
00125f 0fcc                      	lsl r28
001260 1fdd                      	rol r29
001261 93c0 28b7                 	sts triangle_pattern, r28
001263 93d0 28b8                 	sts triangle_pattern+1, r29
001265 9220 28b9                 	sts triangle_pattern_delay_rows, zero
001267 9220 28ba                 	sts triangle_pattern_delay_frames, zero
001269 9220 28bb                 	sts triangle_pattern_offset, zero
00126b 9220 28bc                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
00126d efcf                      	ldi r28, 0xFF
00126e 9220 2825                 	sts pulse1_volume_macro_offset, zero
001270 93c0 2826                 	sts pulse1_volume_macro_loop, r28
001272 93c0 2827                 	sts pulse1_volume_macro_release, r28
001274 9220 282a                 	sts pulse1_arpeggio_macro_offset, zero
001276 93c0 282b                 	sts pulse1_arpeggio_macro_loop, r28
001278 93c0 282c                 	sts pulse1_arpeggio_macro_release, r28
00127a 93c0 282d                 	sts pulse1_arpeggio_macro_mode, r28
00127c 9220 2831                 	sts pulse1_pitch_macro_offset, zero
00127e 93c0 2832                 	sts pulse1_pitch_macro_loop, r28
001280 93c0 2833                 	sts pulse1_pitch_macro_release, r28
001282 9220 2837                 	sts pulse1_hi_pitch_macro_offset, zero
001284 93c0 2838                 	sts pulse1_hi_pitch_macro_loop, r28
001286 93c0 2839                 	sts pulse1_hi_pitch_macro_release, r28
001288 9220 283c                 	sts pulse1_duty_macro_offset, zero
00128a 93c0 283d                 	sts pulse1_duty_macro_loop, r28
00128c 93c0 283e                 	sts pulse1_duty_macro_release, r28
                                 
00128e 9220 2823                 	sts pulse1_volume_macro, zero
001290 9220 2824                 	sts pulse1_volume_macro+1, zero
001292 9220 2828                 	sts pulse1_arpeggio_macro, zero
001294 9220 2829                 	sts pulse1_arpeggio_macro+1, zero
001296 9220 282e                 	sts pulse1_total_pitch_offset, zero
001298 9220 282f                 	sts pulse1_pitch_macro, zero
00129a 9220 2830                 	sts pulse1_pitch_macro+1, zero
00129c 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero
00129e 9220 2835                 	sts pulse1_hi_pitch_macro, zero
0012a0 9220 2836                 	sts pulse1_hi_pitch_macro+1, zero
0012a2 9220 283a                 	sts pulse1_duty_macro, zero
0012a4 9220 283b                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
0012a6 e00f                      	ldi pulse1_volume_divider, 0x0F
0012a7 9110 2800                 	lds pulse1_volume_decay, pulse1_param
0012a9 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
0012aa 9190 2800                 	lds pulse_channel_flags, pulse1_param
0012ac 7390                      	andi pulse_channel_flags, 0b00110000
0012ad 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
0012ae 9220 2806                 	sts pulse1_output_volume, zero
0012b0 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
0012b2 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
0012b3 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0012b4 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
0012b5 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
0012b7 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
0012b8 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
0012b9 efcf                      	ldi r28, 0xFF
0012ba 9220 283f                 	sts pulse1_fx_0xy_sequence, zero
0012bc 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
0012be 9220 2841                 	sts pulse1_fx_1xx, zero
0012c0 9220 2842                 	sts pulse1_fx_1xx+1, zero
0012c2 9220 2843                 	sts pulse1_fx_1xx_total, zero
0012c4 9220 2844                 	sts pulse1_fx_1xx_total+1, zero
0012c6 9220 2845                 	sts pulse1_fx_2xx, zero
0012c8 9220 2846                 	sts pulse1_fx_2xx+1, zero
0012ca 9220 2847                 	sts pulse1_fx_2xx_total, zero
0012cc 9220 2848                 	sts pulse1_fx_2xx_total+1, zero
0012ce 9220 2849                 	sts pulse1_fx_3xx_start, zero
0012d0 9220 284a                 	sts pulse1_fx_3xx_start+1, zero
0012d2 9220 284b                 	sts pulse1_fx_3xx_target, zero
0012d4 9220 284c                 	sts pulse1_fx_3xx_target+1, zero
0012d6 9220 284d                 	sts pulse1_fx_3xx_speed, zero
0012d8 9220 284e                 	sts pulse1_fx_3xx_speed+1, zero
0012da 9220 284f                 	sts pulse1_fx_3xx_total_offset, zero
0012dc 9220 2850                 	sts pulse1_fx_3xx_total_offset+1, zero
0012de 9220 2851                 	sts pulse1_fx_4xy_speed, zero
0012e0 9220 2852                 	sts pulse1_fx_4xy_depth, zero
0012e2 9220 2853                 	sts pulse1_fx_4xy_phase, zero
0012e4 9220 2854                 	sts pulse1_fx_7xy_speed, zero
0012e6 9220 2855                 	sts pulse1_fx_7xy_depth, zero
0012e8 9220 2856                 	sts pulse1_fx_7xy_phase, zero
0012ea 9220 2857                 	sts pulse1_fx_7xy_value, zero
0012ec 9220 2858                 	sts pulse1_fx_Axy, zero
0012ee 93c0 2859                 	sts pulse1_fx_Gxx_pre, r28
0012f0 93c0 285a                 	sts pulse1_fx_Gxx_post, r28
0012f2 9220 285b                 	sts pulse1_fx_Pxx, zero
0012f4 9220 285c                 	sts pulse1_fx_Qxy_target, zero
0012f6 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
0012f8 9220 285e                 	sts pulse1_fx_Qxy_speed, zero
0012fa 9220 285f                 	sts pulse1_fx_Qxy_speed+1, zero
0012fc 9220 2860                 	sts pulse1_fx_Qxy_total_offset, zero
0012fe 9220 2861                 	sts pulse1_fx_Qxy_total_offset+1, zero
001300 9220 2862                 	sts pulse1_fx_Rxy_target, zero
001302 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
001304 9220 2864                 	sts pulse1_fx_Rxy_speed, zero
001306 9220 2865                 	sts pulse1_fx_Rxy_speed+1, zero
001308 9220 2866                 	sts pulse1_fx_Rxy_total_offset, zero
00130a 9220 2867                 	sts pulse1_fx_Rxy_total_offset+1, zero
00130c 93c0 2868                 	sts pulse1_fx_Sxx_pre, r28
00130e 93c0 2869                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
001310 efcf                      	ldi r28, 0xFF
001311 9220 2872                 	sts pulse2_volume_macro_offset, zero
001313 93c0 2873                 	sts pulse2_volume_macro_loop, r28
001315 93c0 2874                 	sts pulse2_volume_macro_release, r28
001317 9220 2877                 	sts pulse2_arpeggio_macro_offset, zero
001319 93c0 2878                 	sts pulse2_arpeggio_macro_loop, r28
00131b 93c0 2879                 	sts pulse2_arpeggio_macro_release, r28
00131d 93c0 287a                 	sts pulse2_arpeggio_macro_mode, r28
00131f 9220 287e                 	sts pulse2_pitch_macro_offset, zero
001321 93c0 287f                 	sts pulse2_pitch_macro_loop, r28
001323 93c0 2880                 	sts pulse2_pitch_macro_release, r28
001325 9220 2884                 	sts pulse2_hi_pitch_macro_offset, zero
001327 93c0 2885                 	sts pulse2_hi_pitch_macro_loop, r28
001329 93c0 2886                 	sts pulse2_hi_pitch_macro_release, r28
00132b 9220 2889                 	sts pulse2_duty_macro_offset, zero
00132d 93c0 288a                 	sts pulse2_duty_macro_loop, r28
00132f 93c0 288b                 	sts pulse2_duty_macro_release, r28
                                 
001331 9220 2870                 	sts pulse2_volume_macro, zero
001333 9220 2871                 	sts pulse2_volume_macro+1, zero
001335 9220 2875                 	sts pulse2_arpeggio_macro, zero
001337 9220 2876                 	sts pulse2_arpeggio_macro+1, zero
001339 9220 287b                 	sts pulse2_total_pitch_offset, zero
00133b 9220 287c                 	sts pulse2_pitch_macro, zero
00133d 9220 287d                 	sts pulse2_pitch_macro+1, zero
00133f 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero
001341 9220 2882                 	sts pulse2_hi_pitch_macro, zero
001343 9220 2883                 	sts pulse2_hi_pitch_macro+1, zero
001345 9220 2887                 	sts pulse2_duty_macro, zero
001347 9220 2888                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
001349 e02f                      	ldi pulse2_volume_divider, 0x0F
00134a 9130 2808                 	lds pulse2_volume_decay, pulse2_param
00134c 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
00134d 91d0 2808                 	lds r29, pulse2_param
00134f 73d0                      	andi r29, 0b00110000
001350 62d0                      	sbr r29, 0b0100000 //set start flag
001351 95d2                      	swap r29
001352 2b9d                      	or pulse_channel_flags, r29
001353 9220 280e                 	sts pulse2_output_volume, zero
001355 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
001357 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
001358 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001359 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
00135a 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
00135c 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
00135d 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
00135e efcf                      	ldi r28, 0xFF
00135f 9220 288c                 	sts pulse2_fx_0xy_sequence, zero
001361 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
001363 9220 288e                 	sts pulse2_fx_1xx, zero
001365 9220 288f                 	sts pulse2_fx_1xx+1, zero
001367 9220 2890                 	sts pulse2_fx_1xx_total, zero
001369 9220 2891                 	sts pulse2_fx_1xx_total+1, zero
00136b 9220 2892                 	sts pulse2_fx_2xx, zero
00136d 9220 2893                 	sts pulse2_fx_2xx+1, zero
00136f 9220 2894                 	sts pulse2_fx_2xx_total, zero
001371 9220 2895                 	sts pulse2_fx_2xx_total+1, zero
001373 9220 2896                 	sts pulse2_fx_3xx_start, zero
001375 9220 2897                 	sts pulse2_fx_3xx_start+1, zero
001377 9220 2898                 	sts pulse2_fx_3xx_target, zero
001379 9220 2899                 	sts pulse2_fx_3xx_target+1, zero
00137b 9220 289a                 	sts pulse2_fx_3xx_speed, zero
00137d 9220 289b                 	sts pulse2_fx_3xx_speed+1, zero
00137f 9220 289c                 	sts pulse2_fx_3xx_total_offset, zero
001381 9220 289d                 	sts pulse2_fx_3xx_total_offset+1, zero
001383 9220 289e                 	sts pulse2_fx_4xy_speed, zero
001385 9220 289f                 	sts pulse2_fx_4xy_depth, zero
001387 9220 28a0                 	sts pulse2_fx_4xy_phase, zero
001389 9220 28a1                 	sts pulse2_fx_7xy_speed, zero
00138b 9220 28a2                 	sts pulse2_fx_7xy_depth, zero
00138d 9220 28a3                 	sts pulse2_fx_7xy_phase, zero
00138f 9220 28a4                 	sts pulse2_fx_7xy_value, zero
001391 9220 28a5                 	sts pulse2_fx_Axy, zero
001393 93c0 28a6                 	sts pulse2_fx_Gxx_pre, r28
001395 93c0 28a7                 	sts pulse2_fx_Gxx_post, r28
001397 9220 28a8                 	sts pulse2_fx_Pxx, zero
001399 9220 28a9                 	sts pulse2_fx_Qxy_target, zero
00139b 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
00139d 9220 28ab                 	sts pulse2_fx_Qxy_speed, zero
00139f 9220 28ac                 	sts pulse2_fx_Qxy_speed+1, zero
0013a1 9220 28ad                 	sts pulse2_fx_Qxy_total_offset, zero
0013a3 9220 28ae                 	sts pulse2_fx_Qxy_total_offset+1, zero
0013a5 9220 28af                 	sts pulse2_fx_Rxy_target, zero
0013a7 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
0013a9 9220 28b1                 	sts pulse2_fx_Rxy_speed, zero
0013ab 9220 28b2                 	sts pulse2_fx_Rxy_speed+1, zero
0013ad 9220 28b3                 	sts pulse2_fx_Rxy_total_offset, zero
0013af 9220 28b4                 	sts pulse2_fx_Rxy_total_offset+1, zero
0013b1 93c0 28b5                 	sts pulse2_fx_Sxx_pre, r28
0013b3 93c0 28b6                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0013b5 efcf                      	ldi r28, 0xFF
0013b6 9220 28bf                 	sts triangle_volume_macro_offset, zero
0013b8 93c0 28c0                 	sts triangle_volume_macro_loop, r28
0013ba 93c0 28c1                 	sts triangle_volume_macro_release, r28
0013bc 9220 28c4                 	sts triangle_arpeggio_macro_offset, zero
0013be 93c0 28c5                 	sts triangle_arpeggio_macro_loop, r28
0013c0 93c0 28c6                 	sts triangle_arpeggio_macro_release, r28
0013c2 93c0 28c7                 	sts triangle_arpeggio_macro_mode, r28
0013c4 9220 28cb                 	sts triangle_pitch_macro_offset, zero
0013c6 93c0 28cc                 	sts triangle_pitch_macro_loop, r28
0013c8 93c0 28cd                 	sts triangle_pitch_macro_release, r28
0013ca 9220 28d1                 	sts triangle_hi_pitch_macro_offset, zero
0013cc 93c0 28d2                 	sts triangle_hi_pitch_macro_loop, r28
0013ce 93c0 28d3                 	sts triangle_hi_pitch_macro_release, r28
0013d0 9220 28d6                 	sts triangle_duty_macro_offset, zero
0013d2 93c0 28d7                 	sts triangle_duty_macro_loop, r28
0013d4 93c0 28d8                 	sts triangle_duty_macro_release, r28
                                 
0013d6 9220 28bd                 	sts triangle_volume_macro, zero
0013d8 9220 28be                 	sts triangle_volume_macro+1, zero
0013da 9220 28c2                 	sts triangle_arpeggio_macro, zero
0013dc 9220 28c3                 	sts triangle_arpeggio_macro+1, zero
0013de 9220 28c8                 	sts triangle_total_pitch_offset, zero
0013e0 9220 28c9                 	sts triangle_pitch_macro, zero
0013e2 9220 28ca                 	sts triangle_pitch_macro+1, zero
0013e4 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero
0013e6 9220 28cf                 	sts triangle_hi_pitch_macro, zero
0013e8 9220 28d0                 	sts triangle_hi_pitch_macro+1, zero
0013ea 9220 28d4                 	sts triangle_duty_macro, zero
0013ec 9220 28d5                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 SEQUENCE
0013ee e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
0013ef 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 3 FX
0013f0 efcf                      	ldi r28, 0xFF
0013f1 9220 28d9                 	sts triangle_fx_0xy_sequence, zero
0013f3 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
0013f5 9220 28db                 	sts triangle_fx_1xx, zero
0013f7 9220 28dc                 	sts triangle_fx_1xx+1, zero
0013f9 9220 28dd                 	sts triangle_fx_1xx_total, zero
0013fb 9220 28de                 	sts triangle_fx_1xx_total+1, zero
0013fd 9220 28df                 	sts triangle_fx_2xx, zero
0013ff 9220 28e0                 	sts triangle_fx_2xx+1, zero
001401 9220 28e1                 	sts triangle_fx_2xx_total, zero
001403 9220 28e2                 	sts triangle_fx_2xx_total+1, zero
001405 9220 28e3                 	sts triangle_fx_3xx_start, zero
001407 9220 28e4                 	sts triangle_fx_3xx_start+1, zero
001409 9220 28e5                 	sts triangle_fx_3xx_target, zero
00140b 9220 28e6                 	sts triangle_fx_3xx_target+1, zero
00140d 9220 28e7                 	sts triangle_fx_3xx_speed, zero
00140f 9220 28e8                 	sts triangle_fx_3xx_speed+1, zero
001411 9220 28e9                 	sts triangle_fx_3xx_total_offset, zero
001413 9220 28ea                 	sts triangle_fx_3xx_total_offset+1, zero
001415 9220 28eb                 	sts triangle_fx_4xy_speed, zero
001417 9220 28ec                 	sts triangle_fx_4xy_depth, zero
001419 9220 28ed                 	sts triangle_fx_4xy_phase, zero
00141b 93c0 28ee                 	sts triangle_fx_Gxx_pre, r28
00141d 93c0 28ef                 	sts triangle_fx_Gxx_post, r28
00141f 9220 28f0                 	sts triangle_fx_Pxx, zero
001421 9220 28f1                 	sts triangle_fx_Qxy_target, zero
001423 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001425 9220 28f3                 	sts triangle_fx_Qxy_speed, zero
001427 9220 28f4                 	sts triangle_fx_Qxy_speed+1, zero
001429 9220 28f5                 	sts triangle_fx_Qxy_total_offset, zero
00142b 9220 28f6                 	sts triangle_fx_Qxy_total_offset+1, zero
00142d 9220 28f7                 	sts triangle_fx_Rxy_target, zero
00142f 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001431 9220 28f9                 	sts triangle_fx_Rxy_speed, zero
001433 9220 28fa                 	sts triangle_fx_Rxy_speed+1, zero
001435 9220 28fb                 	sts triangle_fx_Rxy_total_offset, zero
001437 9220 28fc                 	sts triangle_fx_Rxy_total_offset+1, zero
001439 93c0 28fd                 	sts triangle_fx_Sxx_pre, r28
00143b 93c0 28fe                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//PINS
00143d efcf                      	ldi r28, 0xFF
00143e b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
00143f e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
001440 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
001442 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
001443 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001445 e1c5                      	ldi r28, 0x15 //set the period for CMP0
001446 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
001448 e0c5                      	ldi r28, 0x05
001449 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
00144b e2cb                      	ldi r28, 0x2B //set the period for CMP1
00144c 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
00144e e0ca                      	ldi r28, 0x0A
00144f 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
001451 e4c1                      	ldi r28, 0x41 //set the period for CMP2
001452 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
001454 e0cf                      	ldi r28, 0x0F
001455 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
001457 e5c7                      	ldi r28, 0x57 //set the period for OVF
001458 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
00145a e1c4                      	ldi r28, 0x14
00145b 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
00145d e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
00145e 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
001460 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
001461 93c0 0a81                 	sts TCB0_CTRLB, r28
001463 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
001464 93c0 0a85                 	sts TCB0_INTCTRL, r28
001466 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001468 93c0 0a8c                 	sts TCB0_CCMPL, r28
00146a 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
00146c 93c0 0a8d                 	sts TCB0_CCMPH, r28
00146e e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00146f 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001471 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001472 93b0 0a91                 	sts TCB1_CTRLB, r27
001474 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001475 93b0 0a95                 	sts TCB1_INTCTRL, r27
001477 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001479 93b0 0a9c                 	sts TCB1_CCMPL, r27
00147b 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
00147d 93b0 0a9d                 	sts TCB1_CCMPH, r27
00147f e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001480 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001482 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001483 93b0 0aa1                 	sts TCB2_CTRLB, r27
001485 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001486 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001488 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
00148a 93b0 0aac                 	sts TCB2_CCMPL, r27
00148c 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
00148e 93b0 0aad                 	sts TCB2_CCMPH, r27
001490 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001491 93b0 0aa0                 	sts TCB2_CTRLA, r27
001493 9478                      	sei //global interrupt enable
                                 
                                 volume_mixer:
001494 91c0 2806                 	lds r28, pulse1_output_volume
001496 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
001498 fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
001499 c015                      	rjmp volume_mixer_pulse1_off
                                 
00149a 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
00149b f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
00149c 91e0 0a8c                 	lds r30, TCB0_CCMPL
00149e e5f9                      	ldi r31, 0x059
00149f 17ef                      	cp r30, r31
0014a0 91e0 0a8d                 	lds r30, TCB0_CCMPH
0014a2 e0f0                      	ldi r31, 0x00
0014a3 07ef                      	cpc r30, r31
0014a4 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0014a5 91e0 0a8c                 	lds r30, TCB0_CCMPL
0014a7 e6f6                      	ldi r31, 0x66
0014a8 17ef                      	cp r30, r31
0014a9 91e0 0a8d                 	lds r30, TCB0_CCMPH
0014ab e5f9                      	ldi r31, 0x59
0014ac 07ef                      	cpc r30, r31
0014ad f408                      	brsh volume_mixer_pulse1_off
0014ae c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0014af 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0014b0 fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0014b1 c015                      	rjmp volume_mixer_pulse2_off
                                 
0014b2 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
0014b3 f099                      	breq volume_mixer_pulse2_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0014b4 91e0 0a9c                 	lds r30, TCB1_CCMPL
0014b6 e5f9                      	ldi r31, 0x059
0014b7 17ef                      	cp r30, r31
0014b8 91e0 0a9d                 	lds r30, TCB1_CCMPH
0014ba e0f0                      	ldi r31, 0x00
0014bb 07ef                      	cpc r30, r31
0014bc f050                      	brlo volume_mixer_pulse2_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0014bd 91e0 0a9c                 	lds r30, TCB1_CCMPL
0014bf e6f6                      	ldi r31, 0x66
0014c0 17ef                      	cp r30, r31
0014c1 91e0 0a9d                 	lds r30, TCB1_CCMPH
0014c3 e5f9                      	ldi r31, 0x59
0014c4 07ef                      	cpc r30, r31
0014c5 f408                      	brsh volume_mixer_pulse2_off
0014c6 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
0014c7 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
0014c8 0fcd                      	add r28, r29
0014c9 e1e6                      	ldi ZL, LOW(pulse_volume_table << 1)
0014ca e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
0014cb 0fec                      	add ZL, r28
0014cc 1df2                      	adc ZH, zero
0014cd 91c4                      	lpm r28, Z
0014ce b9c1                      	out VPORTA_OUT, r28
0014cf cfc4                      	rjmp volume_mixer
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
0014d0 b7bf                      	in r27, CPU_SREG
0014d1 93bf                      	push r27
0014d2 94f8                      	cli
                                 
                                 	//ENVELOPE
0014d3 d053                      	rcall pulse1_envelope_routine
0014d4 d09f                      	rcall pulse2_envelope_routine
                                 
0014d5 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
0014d6 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0014d8 91bf                      	pop r27
0014d9 bfbf                      	out CPU_SREG, r27
0014da 9518                      	reti
                                 
                                 sequence_1_3:
0014db b7bf                      	in r27, CPU_SREG
0014dc 93bf                      	push r27
0014dd 94f8                      	cli
                                 
                                 	//ENVELOPE
0014de d048                      	rcall pulse1_envelope_routine
0014df d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
0014e0 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
0014e1 d01b                      	rcall pulse1_sweep_routine
0014e2 fcf3                      	sbrc pulse2_sweep, 3
0014e3 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
0014e4 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
0014e5 c002                      	rjmp sequence_1_3_pulse2_length
0014e6 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
0014e7 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
0014e8 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
0014e9 c002                      	rjmp sequence_1_3_exit
0014ea 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
0014eb 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
0014ec e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
0014ed 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0014ef 91bf                      	pop r27
0014f0 bfbf                      	out CPU_SREG, r27
0014f1 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
0014f2 b7bf                      	in r27, CPU_SREG
0014f3 93bf                      	push r27
0014f4 94f8                      	cli
                                 
0014f5 0caa                      	lsl pulse1_sequence //shifts sequence to the left
0014f6 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0014f7 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0014f8 93b0 0a86                 	sts TCB0_INTFLAGS, r27
0014fa 91bf                      	pop r27
0014fb bfbf                      	out CPU_SREG, r27
0014fc 9518                      	reti
                                 
                                 pulse1_sweep_routine:
0014fd 2dbc                      	mov r27, pulse1_sweep
0014fe 70b7                      	andi r27, 0x07 //mask for period divider bits
0014ff f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001500 93df                      	push r29
001501 2ddc                      	mov r29, pulse1_sweep
001502 95d2                      	swap r29
001503 70d7                      	andi r29, 0x07 //mask for shift bits
001504 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001505 91df                      	pop r29
001506 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001507 91a0 0a8c                 	lds r26, TCB0_CCMPL
001509 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
00150b 95b6                      	lsr r27
00150c 95a7                      	ror r26
00150d 95da                      	dec r29
00150e f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00150f fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
001510 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001511 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001512 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001513 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001515 0fad                      	add r26, r29
001516 91d0 0a8d                 	lds r29, TCB0_CCMPH
001518 1fbd                      	adc r27, r29
                                 
001519 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00151b 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00151d 91df                      	pop r29
00151e c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
00151f 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001520 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
001521 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001522 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001524 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
001525 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
001526 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001527 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
001528 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001529 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
00152a f011                      	breq PC+3 //if the divider == 0, check loop flag
00152b 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
00152c 9508                      	ret
                                 
00152d 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
00152f 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001530 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001531 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001532 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001533 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001534 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001535 f409                      	brne PC+2 //if decay != 0, go decrement
001536 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001537 951a                      	dec pulse1_volume_decay
001538 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001539 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
00153a 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
00153c 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00153d e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
00153e 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
00153f b7bf                      	in r27, CPU_SREG
001540 93bf                      	push r27
001541 94f8                      	cli
                                 
001542 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
001543 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001544 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001545 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001547 91bf                      	pop r27
001548 bfbf                      	out CPU_SREG, r27
001549 9518                      	reti
                                 
                                 pulse2_sweep_routine:
00154a 2dbf                      	mov r27, pulse2_sweep
00154b 70b7                      	andi r27, 0x07 //mask for period divider bits
00154c f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00154d 93df                      	push r29
00154e 2ddf                      	mov r29, pulse2_sweep
00154f 95d2                      	swap r29
001550 70d7                      	andi r29, 0x07 //mask for shift bits
001551 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001552 91df                      	pop r29
001553 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001554 91a0 0a9c                 	lds r26, TCB1_CCMPL
001556 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
001558 95b6                      	lsr r27
001559 95a7                      	ror r26
00155a 95da                      	dec r29
00155b f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00155c fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
00155d c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
00155e 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
00155f 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001560 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001562 0fad                      	add r26, r29
001563 91d0 0a9d                 	lds r29, TCB1_CCMPH
001565 1fbd                      	adc r27, r29
                                 
001566 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
001568 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00156a 91df                      	pop r29
00156b c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
00156c 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
00156d ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
00156e 9508                      	ret
                                 
                                 pulse2_sweep_reload:
00156f 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001571 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
001572 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
001573 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
001574 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
001575 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
001576 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
001577 f011                      	breq PC+3 //if the divider == 0, check loop flag
001578 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
001579 9508                      	ret
                                 
00157a 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
00157c 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
00157d ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
00157e c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
00157f e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001580 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001581 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
001582 f409                      	brne PC+2 //if decay != 0, go decrement
001583 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001584 953a                      	dec pulse2_volume_decay
001585 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
001586 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
001587 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
001589 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
00158a e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
00158b 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
00158c b7bf                      	in r27, CPU_SREG
00158d 93bf                      	push r27
00158e 94f8                      	cli
                                 
00158f 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
001590 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
001591 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001592 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
001594 91bf                      	pop r27
001595 bfbf                      	out CPU_SREG, r27
001596 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001597 e0e0                      	ldi ZL, LOW(length << 1)
001598 e5f2                      	ldi ZH, HIGH(length << 1)
001599 0fed                      	add ZL, r29
00159a 1df2                      	adc ZH, zero
00159b 91d4                      	lpm r29, Z
00159c 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
00159d e2e0                      	ldi ZL, LOW(sequences << 1)
00159e e5f2                      	ldi ZH, HIGH(sequences << 1)
00159f 0fed                      	add ZL, r29
0015a0 1df2                      	adc ZH, zero
0015a1 91d4                      	lpm r29, Z
0015a2 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
0015a3 b7bf                      	in r27, CPU_SREG
0015a4 93bf                      	push r27
0015a5 94f8                      	cli
0015a6 93cf                      	push r28
0015a7 93df                      	push r29
0015a8 93ef                      	push r30
0015a9 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
0015aa 91a0 281a                 	lds r26, song_fx_Bxx
0015ac 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
0015ad f4a9                      	brne sound_driver_fx_Bxx_routine
0015ae 91a0 281b                 	lds r26, song_fx_Cxx
0015b0 11a2                      	cpse r26, zero
0015b1 c05b                      	rjmp sound_driver_fx_Cxx_routine
0015b2 91a0 281c                 	lds r26, song_fx_Dxx
0015b4 11a2                      	cpse r26, zero
0015b5 c068                      	rjmp sound_driver_fx_Dxx_routine
                                 
0015b6 91a0 2815                 	lds r26, song_frame_offset
0015b8 91b0 2816                 	lds r27, song_frame_offset+1
0015ba 91c0 2817                 	lds r28, song_size
0015bc 91d0 2818                 	lds r29, song_size+1
0015be 17ac                      	cp r26, r28
0015bf 07bd                      	cpc r27, r29
0015c0 f408                      	brsh sound_driver_fx_song_loop
0015c1 c0a3                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
0015c2 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
0015c3 91e0 2813                 	lds ZL, song_frames
0015c5 91f0 2814                 	lds ZH, song_frames+1
0015c7 27cc                      	clr r28 //initialize r29:r28 to 0
0015c8 27dd                      	clr r29
0015c9 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
0015ca 95aa                      	dec r26
0015cb f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
0015cc 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
0015cd cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
0015ce 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
0015cf 93c0 2815                 	sts song_frame_offset, r28
0015d1 93d0 2816                 	sts song_frame_offset+1, r29
0015d3 0fec                      	add ZL, r28
0015d4 1ffd                      	adc ZH, r29
                                 
0015d5 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
0015d6 91b5                      	lpm r27, Z+
0015d7 0faa                      	lsl r26
0015d8 1fbb                      	rol r27
0015d9 93a0 281d                 	sts pulse1_pattern, r26
0015db 93b0 281e                 	sts pulse1_pattern+1, r27
0015dd 91a5                      	lpm r26, Z+
0015de 91b5                      	lpm r27, Z+
0015df 0faa                      	lsl r26
0015e0 1fbb                      	rol r27
0015e1 93a0 286a                 	sts pulse2_pattern, r26
0015e3 93b0 286b                 	sts pulse2_pattern+1, r27
0015e5 91a5                      	lpm r26, Z+
0015e6 91b5                      	lpm r27, Z+
0015e7 0faa                      	lsl r26
0015e8 1fbb                      	rol r27
0015e9 93a0 28b7                 	sts triangle_pattern, r26
0015eb 93b0 28b8                 	sts triangle_pattern+1, r27
                                 
0015ed 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0015ef 9220 2822                 	sts pulse1_pattern_offset+1, zero
0015f1 9220 281f                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0015f3 9220 2820                 	sts pulse1_pattern_delay_frames, zero
0015f5 9220 286e                 	sts pulse2_pattern_offset, zero
0015f7 9220 286f                 	sts pulse2_pattern_offset+1, zero
0015f9 9220 286c                 	sts pulse2_pattern_delay_rows, zero
0015fb 9220 286d                 	sts pulse2_pattern_delay_frames, zero
0015fd 9220 28bb                 	sts triangle_pattern_offset, zero
0015ff 9220 28bc                 	sts triangle_pattern_offset+1, zero
001601 9220 28b9                 	sts triangle_pattern_delay_rows, zero
001603 9220 28ba                 	sts triangle_pattern_delay_frames, zero
                                 
001605 efaf                      	ldi r26, 0xFF
001606 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
001608 9220 281b                 	sts song_fx_Cxx, zero
00160a 9220 281c                 	sts song_fx_Dxx, zero
00160c c058                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
00160d 91ff                      	pop r31
00160e 91ef                      	pop r30
00160f 91df                      	pop r29
001610 91cf                      	pop r28
001611 91bf                      	pop r27
001612 bfbf                      	out CPU_SREG, r27
001613 94f8                      	cli //disable global interrupts
                                 		
001614 efaf                      	ldi r26, 0xFF
001615 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
001617 9220 281b                 	sts song_fx_Cxx, zero
001619 9220 281c                 	sts song_fx_Dxx, zero
                                 
00161b 9220 2806                 	sts pulse1_output_volume, zero //mute all channels
00161d 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
00161e 91e0 2813                 	lds ZL, song_frames
001620 91f0 2814                 	lds ZH, song_frames+1
001622 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001624 91b0 2816                 	lds r27, song_frame_offset+1
001626 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001627 93a0 2815                 	sts song_frame_offset, r26
001629 93b0 2816                 	sts song_frame_offset+1, r27
00162b 0fea                      	add ZL, r26
00162c 1ffb                      	adc ZH, r27
                                 
00162d 91a5                      	lpm r26, Z+ //load the address of the next pattern
00162e 91b5                      	lpm r27, Z+
00162f 0faa                      	lsl r26
001630 1fbb                      	rol r27
001631 93a0 281d                 	sts pulse1_pattern, r26
001633 93b0 281e                 	sts pulse1_pattern+1, r27
001635 91a5                      	lpm r26, Z+
001636 91b5                      	lpm r27, Z+
001637 0faa                      	lsl r26
001638 1fbb                      	rol r27
001639 93a0 286a                 	sts pulse2_pattern, r26
00163b 93b0 286b                 	sts pulse2_pattern+1, r27
00163d 91a5                      	lpm r26, Z+
00163e 91b5                      	lpm r27, Z+
00163f 0faa                      	lsl r26
001640 1fbb                      	rol r27
001641 93a0 28b7                 	sts triangle_pattern, r26
001643 93b0 28b8                 	sts triangle_pattern+1, r27
                                 
001645 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001647 9220 2822                 	sts pulse1_pattern_offset+1, zero
001649 9220 281f                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00164b 9220 2820                 	sts pulse1_pattern_delay_frames, zero
00164d 9220 286e                 	sts pulse2_pattern_offset, zero
00164f 9220 286f                 	sts pulse2_pattern_offset+1, zero
001651 9220 286c                 	sts pulse2_pattern_delay_rows, zero
001653 9220 286d                 	sts pulse2_pattern_delay_frames, zero
001655 9220 28bb                 	sts triangle_pattern_offset, zero
001657 9220 28bc                 	sts triangle_pattern_offset+1, zero
001659 9220 28b9                 	sts triangle_pattern_delay_rows, zero
00165b 9220 28ba                 	sts triangle_pattern_delay_frames, zero
                                 
00165d efaf                      	ldi r26, 0xFF
00165e 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
001660 9220 281b                 	sts song_fx_Cxx, zero
001662 9220 281c                 	sts song_fx_Dxx, zero
001664 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001665 91a0 281f                 	lds r26, pulse1_pattern_delay_rows
001667 91b0 2820                 	lds r27, pulse1_pattern_delay_frames
001669 9610                      	adiw r27:r26, 0
00166a f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
00166b c2c2                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
00166c 91e0 281d                 	lds ZL, pulse1_pattern //current pattern for pulse 1
00166e 91f0 281e                 	lds ZH, pulse1_pattern+1
001670 91a0 2821                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001672 91b0 2822                 	lds r27, pulse1_pattern_offset+1
001674 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001675 1ffb                      	adc ZH, r27
001676 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
001677 35b7                      	cpi r27, 0x57
001678 f408                      	brsh sound_driver_channel0_check_if_volume
001679 c16b                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
00167a 36b7                      	cpi r27, 0x67
00167b f408                      	brsh sound_driver_channel0_check_if_delay
00167c c1a3                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
00167d 3eb3                      	cpi r27, 0xE3
00167e f408                      	brsh sound_driver_channel0_check_if_instrument
00167f c1aa                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001680 f409                      	brne sound_driver_channel0_check_if_release
001681 c1ad                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001682 3eb4                      	cpi r27, 0xE4
001683 f409                      	brne sound_driver_channel0_check_if_end
001684 c254                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001685 3fbf                      	cpi r27, 0xFF
001686 f409                      	brne sound_driver_channel0_check_if_fx
001687 c276                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001688 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001689 91a4                      	lpm r26, Z //load the fx data into r26
00168a d299                      	rcall sound_driver_channel0_increment_offset_twice
                                 
00168b 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
00168c e2e4                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
00168d e5f2                      	ldi ZH, HIGH(channel0_fx << 1)
00168e 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00168f 0feb                      	add ZL, r27 //add offset
001690 1df2                      	adc ZH, zero
001691 91c5                      	lpm r28, Z+ //load address bytes
001692 91d4                      	lpm r29, Z
001693 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001694 2ffd                      	mov ZH, r29
001695 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001696 93a0 283f                 	sts pulse1_fx_0xy_sequence, r26
001698 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
00169a cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00169b 9220 2845                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
00169d 9220 2846                 	sts pulse1_fx_2xx+1, zero
00169f 9220 283f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0016a1 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
0016a3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0016a4 937f                      	push r23
0016a5 2f6a                      	mov r22, r26 //store the rate into r22
0016a6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0016a7 9f67                      	mul r22, r23
0016a8 917f                      	pop r23
0016a9 916f                      	pop r22
                                 
0016aa 9416                      	lsr r1 //shift out the fractional bits
0016ab 9407                      	ror r0
0016ac 9416                      	lsr r1
0016ad 9407                      	ror r0
0016ae 9416                      	lsr r1
0016af 9407                      	ror r0
0016b0 9416                      	lsr r1
0016b1 9407                      	ror r0
0016b2 9200 2841                 	sts pulse1_fx_1xx, r0
0016b4 9210 2842                 	sts pulse1_fx_1xx+1, r1
0016b6 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0016b7 9220 2841                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0016b9 9220 2842                 	sts pulse1_fx_1xx+1, zero
0016bb 9220 283f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0016bd 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
0016bf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0016c0 937f                      	push r23
0016c1 2f6a                      	mov r22, r26 //store the rate into r22
0016c2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0016c3 9f67                      	mul r22, r23
0016c4 917f                      	pop r23
0016c5 916f                      	pop r22
                                 
0016c6 9416                      	lsr r1 //shift out the fractional bits
0016c7 9407                      	ror r0
0016c8 9416                      	lsr r1
0016c9 9407                      	ror r0
0016ca 9416                      	lsr r1
0016cb 9407                      	ror r0
0016cc 9416                      	lsr r1
0016cd 9407                      	ror r0
0016ce 9200 2845                 	sts pulse1_fx_2xx, r0
0016d0 9210 2846                 	sts pulse1_fx_2xx+1, r1
0016d2 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0016d3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0016d4 937f                      	push r23
0016d5 2f6a                      	mov r22, r26 //store the rate into r22
0016d6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0016d7 9f67                      	mul r22, r23
0016d8 917f                      	pop r23
0016d9 916f                      	pop r22
                                 
0016da 9416                      	lsr r1 //shift out the fractional bits
0016db 9407                      	ror r0
0016dc 9416                      	lsr r1
0016dd 9407                      	ror r0
0016de 9416                      	lsr r1
0016df 9407                      	ror r0
0016e0 9416                      	lsr r1
0016e1 9407                      	ror r0
0016e2 9200 284d                 	sts pulse1_fx_3xx_speed, r0
0016e4 9210 284e                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0016e6 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0016e7 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0016e8 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0016e9 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0016eb 91b0 0a8d                 	lds r27, TCB0_CCMPH
0016ed 93a0 2849                 	sts pulse1_fx_3xx_start, r26
0016ef 93b0 284a                 	sts pulse1_fx_3xx_start+1, r27
                                 
0016f1 9220 284f                 	sts pulse1_fx_3xx_total_offset, zero
0016f3 9220 2850                 	sts pulse1_fx_3xx_total_offset+1, zero
0016f5 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0016f6 2fba                      	mov r27, r26
0016f7 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0016f8 95a2                      	swap r26
0016f9 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0016fa 93a0 2851                 	sts pulse1_fx_4xy_speed, r26
0016fc 93b0 2852                 	sts pulse1_fx_4xy_depth, r27
0016fe 9220 2853                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
001700 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
001701 2fba                      	mov r27, r26
001702 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001703 95a2                      	swap r26
001704 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001705 93a0 2854                 	sts pulse1_fx_7xy_speed, r26
001707 93b0 2855                 	sts pulse1_fx_7xy_depth, r27
001709 9220 2856                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
00170b 9220 2857                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
00170d cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
00170e 93a0 2858                 	sts pulse1_fx_Axy, r26
001710 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
001711 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001713 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
001714 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001716 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
001717 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001719 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
00171a 91b0 2800                 	lds r27, pulse1_param
00171c 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
00171d 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
00171e 93b0 2800                 	sts pulse1_param, r27
001720 6096                      	sbr pulse_channel_flags, 6
001721 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
001722 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001724 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
001725 15a2                      	cp r26, zero
001726 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
001727 91b0 2819                 	lds r27, song_speed
001729 17ab                      	cp r26, r27
00172a f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
00172b 93a0 2859                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00172d e0b1                      	ldi r27, 0x01
00172e 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
001730 c200                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
001731 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001732 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
001733 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
001734 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
001735 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
001736 93a0 285b                 	sts pulse1_fx_Pxx, r26
001738 cf33                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001739 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
00173b 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
00173d 9630                      	adiw Z, 0
00173e f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
00173f cf2c                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001740 91e0 282f                 	lds ZL, pulse1_pitch_macro
001742 91f0 2830                 	lds ZH, pulse1_pitch_macro+1
001744 9630                      	adiw Z, 0
001745 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001746 cf25                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001747 91e0 2835                 	lds ZL, pulse1_hi_pitch_macro
001749 91f0 2836                 	lds ZH, pulse1_hi_pitch_macro+1
00174b 9630                      	adiw Z, 0
00174c f009                      	breq sound_driver_channel0_fx_Qxy_process
00174d cf1e                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
00174e 2fba                      	mov r27, r26 //copy fx parameters into r27
00174f 70bf                      	andi r27, 0x0F //mask note index offset
001750 91c0 2807                 	lds r28, pulse1_note //load current note index
001752 0fbc                      	add r27, r28
001753 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001754 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001755 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001756 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001757 e0f0                      	ldi ZH, HIGH(note_table << 1)
001758 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001759 0feb                      	add ZL, r27 //add offset
00175a 1df2                      	adc ZH, zero
00175b 91c5                      	lpm r28, Z+ //load bytes
00175c 91d4                      	lpm r29, Z
00175d 93c0 285c                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
00175f 93d0 285d                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001761 95a2                      	swap r26
001762 70af                      	andi r26, 0x0F //mask effect speed
001763 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001764 95a3                      	inc r26 //increment the speed by 1
                                 
001765 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001766 937f                      	push r23
001767 2f6a                      	mov r22, r26 //store the speed data into r27
001768 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001769 9f67                      	mul r22, r23
00176a 917f                      	pop r23
00176b 916f                      	pop r22
                                 
00176c 9416                      	lsr r1 //shift out the fractional bits
00176d 9407                      	ror r0
00176e 9416                      	lsr r1
00176f 9407                      	ror r0
001770 9416                      	lsr r1
001771 9407                      	ror r0
001772 9416                      	lsr r1
001773 9407                      	ror r0
                                 
001774 9200 285e                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001776 9210 285f                 	sts pulse1_fx_Qxy_speed+1, r1
001778 9220 2860                 	sts pulse1_fx_Qxy_total_offset, zero
00177a 9220 2861                 	sts pulse1_fx_Qxy_total_offset+1, zero
00177c ceef                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
00177d 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
00177f 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
001781 9630                      	adiw Z, 0
001782 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001783 cee8                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001784 91e0 282f                 	lds ZL, pulse1_pitch_macro
001786 91f0 2830                 	lds ZH, pulse1_pitch_macro+1
001788 9630                      	adiw Z, 0
001789 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
00178a cee1                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
00178b 91e0 2835                 	lds ZL, pulse1_hi_pitch_macro
00178d 91f0 2836                 	lds ZH, pulse1_hi_pitch_macro+1
00178f 9630                      	adiw Z, 0
001790 f009                      	breq sound_driver_channel0_fx_Rxy_process
001791 ceda                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001792 2fba                      	mov r27, r26 //copy fx parameters into r27
001793 70bf                      	andi r27, 0x0F //mask note index offset
001794 91c0 2807                 	lds r28, pulse1_note //load current note index
001796 1bcb                      	sub r28, r27
001797 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001798 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001799 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
00179a e0f0                      	ldi ZH, HIGH(note_table << 1)
00179b 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00179c 0fec                      	add ZL, r28 //add offset
00179d 1df2                      	adc ZH, zero
00179e 91c5                      	lpm r28, Z+ //load bytes
00179f 91d4                      	lpm r29, Z
0017a0 93c0 2862                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0017a2 93d0 2863                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0017a4 95a2                      	swap r26
0017a5 70af                      	andi r26, 0x0F //mask effect speed
0017a6 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0017a7 95a3                      	inc r26 //increment the speed by 1
                                 
0017a8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017a9 937f                      	push r23
0017aa 2f6a                      	mov r22, r26 //store the speed data into r27
0017ab eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017ac 9f67                      	mul r22, r23
0017ad 917f                      	pop r23
0017ae 916f                      	pop r22
                                 
0017af 9416                      	lsr r1 //shift out the fractional bits
0017b0 9407                      	ror r0
0017b1 9416                      	lsr r1
0017b2 9407                      	ror r0
0017b3 9416                      	lsr r1
0017b4 9407                      	ror r0
0017b5 9416                      	lsr r1
0017b6 9407                      	ror r0
                                 
0017b7 9200 2864                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
0017b9 9210 2865                 	sts pulse1_fx_Rxy_speed+1, r1
0017bb 9220 2866                 	sts pulse1_fx_Rxy_total_offset, zero
0017bd 9220 2867                 	sts pulse1_fx_Rxy_total_offset+1, zero
0017bf ceac                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
0017c0 15a2                      	cp r26, zero
0017c1 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
0017c2 91b0 2819                 	lds r27, song_speed
0017c4 17ab                      	cp r26, r27
0017c5 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
0017c6 93a0 2868                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0017c8 e0b1                      	ldi r27, 0x01
0017c9 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
0017cb c165                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
0017cc ce9f                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
0017cd e2e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0017ce e5f2                      	ldi ZH, HIGH(sequences << 1)
0017cf 0fea                      	add ZL, r26 //offset the pointer
0017d0 1df2                      	adc ZH, zero
                                 
0017d1 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0017d2 95a7                      	ror r26
0017d3 95a7                      	ror r26
0017d4 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0017d6 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0017d7 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0017d8 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0017d9 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0017da ce91                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0017db 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0017dc 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0017dd 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0017de 93c0 2800                 	sts pulse1_param, r28
0017e0 ce8b                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0017e1 ce8a                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
0017e2 ce89                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
0017e3 ce88                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
0017e4 ce87                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
0017e5 93b0 2807                 	sts pulse1_note, r27 //store the note index
0017e7 e0a3                      	ldi r26, 0x03
0017e8 e0b2                      	ldi r27, 0x02
0017e9 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0017eb 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
0017ed 93b0 2831                 	sts pulse1_pitch_macro_offset, r27
0017ef 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27
0017f1 93b0 283c                 	sts pulse1_duty_macro_offset, r27
0017f3 9220 282e                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0017f5 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero
0017f7 9220 2843                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0017f9 9220 2844                 	sts pulse1_fx_1xx_total+1, zero
0017fb 9220 2847                 	sts pulse1_fx_2xx_total, zero
0017fd 9220 2848                 	sts pulse1_fx_2xx_total+1, zero
0017ff 9220 284f                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001801 9220 2850                 	sts pulse1_fx_3xx_total_offset+1, zero
001803 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001805 91b0 0a8d                 	lds r27, TCB0_CCMPH
001807 93a0 2849                 	sts pulse1_fx_3xx_start, r26
001809 93b0 284a                 	sts pulse1_fx_3xx_start+1, r27
00180b 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
00180d 6097                      	sbr pulse_channel_flags, 7 //set reload flag
00180e 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001810 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
001812 9220 2860                 	sts pulse1_fx_Qxy_total_offset, zero
001814 9220 2861                 	sts pulse1_fx_Qxy_total_offset+1, zero
001816 9220 2862                 	sts pulse1_fx_Rxy_target, zero
001818 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
00181a 9220 2866                 	sts pulse1_fx_Rxy_total_offset, zero
00181c 9220 2867                 	sts pulse1_fx_Rxy_total_offset+1, zero
00181e d0fb                      	rcall sound_driver_channel0_increment_offset
00181f ce4c                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001820 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001821 91a0 2800                 	lds r26, pulse1_param
001823 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001824 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001825 93a0 2800                 	sts pulse1_param, r26
001827 6096                      	sbr pulse_channel_flags, 6
001828 d0f1                      	rcall sound_driver_channel0_increment_offset
001829 ce42                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
00182a 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00182b 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
00182d d0ec                      	rcall sound_driver_channel0_increment_offset
00182e c102                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
00182f 9220 2823                 	sts pulse1_volume_macro, zero //reset all macro addresses
001831 9220 2824                 	sts pulse1_volume_macro+1, zero
001833 9220 2828                 	sts pulse1_arpeggio_macro, zero
001835 9220 2829                 	sts pulse1_arpeggio_macro+1, zero
001837 9220 282f                 	sts pulse1_pitch_macro, zero
001839 9220 2830                 	sts pulse1_pitch_macro+1, zero
00183b 9220 2835                 	sts pulse1_hi_pitch_macro, zero
00183d 9220 2836                 	sts pulse1_hi_pitch_macro+1, zero
00183f 9220 283a                 	sts pulse1_duty_macro, zero
001841 9220 283b                 	sts pulse1_duty_macro+1, zero
001843 9220 282e                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001845 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001847 9631                      	adiw Z, 1 //point to the byte next to the flag
001848 91b4                      	lpm r27, Z //store the instrument offset into r27
001849 eded                      	ldi ZL, LOW(instruments) //point Z to instruments table
00184a e0ff                      	ldi ZH, HIGH(instruments)
00184b 0feb                      	add ZL, r27 //point Z to offsetted instrument
00184c 1df2                      	adc ZH, zero
00184d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00184e 1fff                      	rol ZH
00184f 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001850 91b4                      	lpm r27, Z
                                 
001851 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001852 1fbb                      	rol r27
001853 2fea                      	mov ZL, r26
001854 2ffb                      	mov ZH, r27
001855 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001856 9632                      	adiw Z, 2 //point Z to the address of the macro
001857 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001858 95aa                      	dec r26
001859 f019                      	breq sound_driver_channel0_instrument_change_exit
00185a 95b6                      	lsr r27
00185b f078                      	brcs sound_driver_channel0_instrument_change_load_macro
00185c cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
00185d e0a3                      	ldi r26, 0x03
00185e e0b2                      	ldi r27, 0x02
00185f 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001861 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
001863 93b0 2831                 	sts pulse1_pitch_macro_offset, r27
001865 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27
001867 93b0 283c                 	sts pulse1_duty_macro_offset, r27
001869 d0ba                      	rcall sound_driver_channel0_increment_offset_twice
00186a ce01                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
00186b 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
00186c 91d5                      	lpm r29, Z+
                                 
00186d 30a5                      	cpi r26, 5
00186e f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
00186f 30a4                      	cpi r26, 4
001870 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001871 30a3                      	cpi r26, 3
001872 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001873 30a2                      	cpi r26, 2
001874 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001875 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001876 93c0 2823                 	sts pulse1_volume_macro, r28
001878 93d0 2824                 	sts pulse1_volume_macro+1, r29
00187a d041                      	rcall sound_driver_channel0_instrument_change_read_header
00187b 93c0 2827                 	sts pulse1_volume_macro_release, r28
00187d 93d0 2826                 	sts pulse1_volume_macro_loop, r29
00187f cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001880 93c0 2828                 	sts pulse1_arpeggio_macro, r28
001882 93d0 2829                 	sts pulse1_arpeggio_macro+1, r29
001884 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001886 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
001888 9220 2862                 	sts pulse1_fx_Rxy_target, zero
00188a 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
00188c d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
00188d cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
00188e 93c0 282f                 	sts pulse1_pitch_macro, r28
001890 93d0 2830                 	sts pulse1_pitch_macro+1, r29
001892 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001894 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
001896 9220 2862                 	sts pulse1_fx_Rxy_target, zero
001898 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
00189a d021                      	rcall sound_driver_channel0_instrument_change_read_header
00189b 93c0 2833                 	sts pulse1_pitch_macro_release, r28
00189d 93d0 2832                 	sts pulse1_pitch_macro_loop, r29
00189f cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0018a0 93c0 2835                 	sts pulse1_hi_pitch_macro, r28
0018a2 93d0 2836                 	sts pulse1_hi_pitch_macro+1, r29
0018a4 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0018a6 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
0018a8 9220 2862                 	sts pulse1_fx_Rxy_target, zero
0018aa 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
0018ac d00f                      	rcall sound_driver_channel0_instrument_change_read_header
0018ad 93c0 2839                 	sts pulse1_hi_pitch_macro_release, r28
0018af 93d0 2838                 	sts pulse1_hi_pitch_macro_loop, r29
0018b1 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
0018b2 93c0 283a                 	sts pulse1_duty_macro, r28
0018b4 93d0 283b                 	sts pulse1_duty_macro+1, r29
0018b6 d005                      	rcall sound_driver_channel0_instrument_change_read_header
0018b7 93c0 283e                 	sts pulse1_duty_macro_release, r28
0018b9 93d0 283d                 	sts pulse1_duty_macro_loop, r29
0018bb cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
0018bc 93ef                      	push ZL
0018bd 93ff                      	push ZH
0018be 2fec                      	mov ZL, r28
0018bf 2ffd                      	mov ZH, r29
0018c0 0fee                      	lsl ZL
0018c1 1fff                      	rol ZH
0018c2 91c5                      	lpm r28, Z+
0018c3 91d4                      	lpm r29, Z
0018c4 91ff                      	pop ZH
0018c5 91ef                      	pop ZL
0018c6 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
0018c7 93ef                      	push ZL
0018c8 93ff                      	push ZH
0018c9 2fec                      	mov ZL, r28
0018ca 2ffd                      	mov ZH, r29
0018cb 0fee                      	lsl ZL
0018cc 1fff                      	rol ZH
0018cd 91c5                      	lpm r28, Z+
0018ce 91d5                      	lpm r29, Z+
0018cf 93c0 282c                 	sts pulse1_arpeggio_macro_release, r28
0018d1 93d0 282b                 	sts pulse1_arpeggio_macro_loop, r29
0018d3 91c4                      	lpm r28, Z
0018d4 93c0 282d                 	sts pulse1_arpeggio_macro_mode, r28
0018d6 91ff                      	pop ZH
0018d7 91ef                      	pop ZL
0018d8 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
0018d9 91b0 2827                 	lds r27, pulse1_volume_macro_release
0018db 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0018dc f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
0018dd 95b3                      	inc r27
0018de 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
0018e0 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
0018e2 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
0018e3 f019                      	breq sound_driver_channel0_release_pitch
0018e4 95b3                      	inc r27
0018e5 93b0 282a                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
0018e7 91b0 2833                 	lds r27, pulse1_pitch_macro_release
0018e9 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
0018ea f019                      	breq sound_driver_channel0_release_hi_pitch
0018eb 95b3                      	inc r27
0018ec 93b0 2831                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
0018ee 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_release
0018f0 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
0018f1 f019                      	breq sound_driver_channel0_release_duty
0018f2 95b3                      	inc r27
0018f3 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
0018f5 91b0 283e                 	lds r27, pulse1_duty_macro_release
0018f7 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0018f8 f019                      	breq sound_driver_channel0_release_exit
0018f9 95b3                      	inc r27
0018fa 93b0 283c                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
0018fc d01d                      	rcall sound_driver_channel0_increment_offset
0018fd cd6e                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
0018fe 91e0 2813                 	lds ZL, song_frames
001900 91f0 2814                 	lds ZH, song_frames+1
001902 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001904 91b0 2816                 	lds r27, song_frame_offset+1
001906 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001907 93a0 2815                 	sts song_frame_offset, r26
001909 93b0 2816                 	sts song_frame_offset+1, r27
00190b 0fea                      	add ZL, r26
00190c 1ffb                      	adc ZH, r27
                                 
00190d 91a5                      	lpm r26, Z+ //load the address of the next pattern
00190e 91b4                      	lpm r27, Z
00190f 0faa                      	lsl r26
001910 1fbb                      	rol r27
001911 93a0 281d                 	sts pulse1_pattern, r26
001913 93b0 281e                 	sts pulse1_pattern+1, r27
                                 
001915 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001917 9220 2822                 	sts pulse1_pattern_offset+1, zero
001919 cd52                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
00191a 91e0 2821                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
00191c 91f0 2822                 	lds ZH, pulse1_pattern_offset+1
00191e 9631                      	adiw Z, 1
00191f 93e0 2821                 	sts pulse1_pattern_offset, ZL
001921 93f0 2822                 	sts pulse1_pattern_offset+1, ZH
001923 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001924 91e0 2821                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001926 91f0 2822                 	lds ZH, pulse1_pattern_offset+1
001928 9632                      	adiw Z, 2 //increment the pointer twice
001929 93e0 2821                 	sts pulse1_pattern_offset, ZL
00192b 93f0 2822                 	sts pulse1_pattern_offset+1, ZH
00192d 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
00192e 95ba                      	dec r27
00192f 93b0 2820                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001931 91a0 286c                 	lds r26, pulse2_pattern_delay_rows
001933 91b0 286d                 	lds r27, pulse2_pattern_delay_frames
001935 9610                      	adiw r27:r26, 0
001936 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001937 c2be                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001938 91e0 286a                 	lds ZL, pulse2_pattern //current pattern for pulse 2
00193a 91f0 286b                 	lds ZH, pulse2_pattern+1
00193c 91a0 286e                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
00193e 91b0 286f                 	lds r27, pulse2_pattern_offset+1
001940 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001941 1ffb                      	adc ZH, r27
001942 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001943 35b7                      	cpi r27, 0x57
001944 f408                      	brsh sound_driver_channel1_check_if_volume
001945 c16b                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001946 36b7                      	cpi r27, 0x67
001947 f408                      	brsh sound_driver_channel1_check_if_delay
001948 c1a3                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001949 3eb3                      	cpi r27, 0xE3
00194a f408                      	brsh sound_driver_channel1_check_if_instrument
00194b c1aa                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
00194c f409                      	brne sound_driver_channel1_check_if_release
00194d c1ad                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
00194e 3eb4                      	cpi r27, 0xE4
00194f f409                      	brne sound_driver_channel1_check_if_end
001950 c254                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001951 3fbf                      	cpi r27, 0xFF
001952 f409                      	brne sound_driver_channel1_check_if_fx
001953 c276                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001954 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001955 91a4                      	lpm r26, Z //load the fx data into r26
001956 d295                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001957 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001958 e5e8                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001959 e5f2                      	ldi ZH, HIGH(channel1_fx << 1)
00195a 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00195b 0feb                      	add ZL, r27 //add offset
00195c 1df2                      	adc ZH, zero
00195d 91c5                      	lpm r28, Z+ //load address bytes
00195e 91d4                      	lpm r29, Z
00195f 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001960 2ffd                      	mov ZH, r29
001961 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001962 93a0 288c                 	sts pulse2_fx_0xy_sequence, r26
001964 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
001966 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001967 9220 2892                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001969 9220 2893                 	sts pulse2_fx_2xx+1, zero
00196b 9220 288c                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
00196d 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
00196f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001970 937f                      	push r23
001971 2f6a                      	mov r22, r26 //store the rate into r22
001972 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001973 9f67                      	mul r22, r23
001974 917f                      	pop r23
001975 916f                      	pop r22
                                 
001976 9416                      	lsr r1 //shift out the fractional bits
001977 9407                      	ror r0
001978 9416                      	lsr r1
001979 9407                      	ror r0
00197a 9416                      	lsr r1
00197b 9407                      	ror r0
00197c 9416                      	lsr r1
00197d 9407                      	ror r0
00197e 9200 288e                 	sts pulse2_fx_1xx, r0
001980 9210 288f                 	sts pulse2_fx_1xx+1, r1
001982 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001983 9220 288e                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001985 9220 288f                 	sts pulse2_fx_1xx+1, zero
001987 9220 288c                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001989 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
00198b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00198c 937f                      	push r23
00198d 2f6a                      	mov r22, r26 //store the rate into r22
00198e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00198f 9f67                      	mul r22, r23
001990 917f                      	pop r23
001991 916f                      	pop r22
                                 
001992 9416                      	lsr r1 //shift out the fractional bits
001993 9407                      	ror r0
001994 9416                      	lsr r1
001995 9407                      	ror r0
001996 9416                      	lsr r1
001997 9407                      	ror r0
001998 9416                      	lsr r1
001999 9407                      	ror r0
00199a 9200 2892                 	sts pulse2_fx_2xx, r0
00199c 9210 2893                 	sts pulse2_fx_2xx+1, r1
00199e cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
00199f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019a0 937f                      	push r23
0019a1 2f6a                      	mov r22, r26 //store the rate into r22
0019a2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019a3 9f67                      	mul r22, r23
0019a4 917f                      	pop r23
0019a5 916f                      	pop r22
                                 
0019a6 9416                      	lsr r1 //shift out the fractional bits
0019a7 9407                      	ror r0
0019a8 9416                      	lsr r1
0019a9 9407                      	ror r0
0019aa 9416                      	lsr r1
0019ab 9407                      	ror r0
0019ac 9416                      	lsr r1
0019ad 9407                      	ror r0
0019ae 9200 289a                 	sts pulse2_fx_3xx_speed, r0
0019b0 9210 289b                 	sts pulse2_fx_3xx_speed+1, r1
                                 
0019b2 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0019b3 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
0019b4 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
0019b5 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0019b7 91b0 0a9d                 	lds r27, TCB1_CCMPH
0019b9 93a0 2896                 	sts pulse2_fx_3xx_start, r26
0019bb 93b0 2897                 	sts pulse2_fx_3xx_start+1, r27
                                 
0019bd 9220 289c                 	sts pulse2_fx_3xx_total_offset, zero
0019bf 9220 289d                 	sts pulse2_fx_3xx_total_offset+1, zero
0019c1 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
0019c2 2fba                      	mov r27, r26
0019c3 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019c4 95a2                      	swap r26
0019c5 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019c6 93a0 289e                 	sts pulse2_fx_4xy_speed, r26
0019c8 93b0 289f                 	sts pulse2_fx_4xy_depth, r27
0019ca 9220 28a0                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
0019cc cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
0019cd 2fba                      	mov r27, r26
0019ce 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0019cf 95a2                      	swap r26
0019d0 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0019d1 93a0 28a1                 	sts pulse2_fx_7xy_speed, r26
0019d3 93b0 28a2                 	sts pulse2_fx_7xy_depth, r27
0019d5 9220 28a3                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
0019d7 9220 28a4                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
0019d9 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
0019da 93a0 28a5                 	sts pulse2_fx_Axy, r26
0019dc cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
0019dd 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0019df cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
0019e0 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019e2 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
0019e3 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0019e5 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
0019e6 91b0 2808                 	lds r27, pulse2_param
0019e8 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0019e9 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
0019ea 93b0 2808                 	sts pulse2_param, r27
0019ec 6092                      	sbr pulse_channel_flags, 2
0019ed cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
0019ee 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0019f0 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
0019f1 15a2                      	cp r26, zero
0019f2 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
0019f3 91b0 2819                 	lds r27, song_speed
0019f5 17ab                      	cp r26, r27
0019f6 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
0019f7 93a0 28a6                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0019f9 e0b1                      	ldi r27, 0x01
0019fa 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
0019fc c1fc                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
0019fd cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
0019fe cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
0019ff cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001a00 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001a01 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001a02 93a0 28a8                 	sts pulse2_fx_Pxx, r26
001a04 cf33                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001a05 91e0 2875                 	lds ZL, pulse2_arpeggio_macro
001a07 91f0 2876                 	lds ZH, pulse2_arpeggio_macro+1
001a09 9630                      	adiw Z, 0
001a0a f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001a0b cf2c                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001a0c 91e0 287c                 	lds ZL, pulse2_pitch_macro
001a0e 91f0 287d                 	lds ZH, pulse2_pitch_macro+1
001a10 9630                      	adiw Z, 0
001a11 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001a12 cf25                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001a13 91e0 2882                 	lds ZL, pulse2_hi_pitch_macro
001a15 91f0 2883                 	lds ZH, pulse2_hi_pitch_macro+1
001a17 9630                      	adiw Z, 0
001a18 f009                      	breq sound_driver_channel1_fx_Qxy_process
001a19 cf1e                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001a1a 2fba                      	mov r27, r26 //copy fx parameters into r27
001a1b 70bf                      	andi r27, 0x0F //mask note index offset
001a1c 91c0 280f                 	lds r28, pulse2_note //load current note index
001a1e 0fbc                      	add r27, r28
001a1f 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001a20 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001a21 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001a22 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001a23 e0f0                      	ldi ZH, HIGH(note_table << 1)
001a24 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001a25 0feb                      	add ZL, r27 //add offset
001a26 1df2                      	adc ZH, zero
001a27 91c5                      	lpm r28, Z+ //load bytes
001a28 91d4                      	lpm r29, Z
001a29 93c0 28a9                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001a2b 93d0 28aa                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001a2d 95a2                      	swap r26
001a2e 70af                      	andi r26, 0x0F //mask effect speed
001a2f 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a30 95a3                      	inc r26 //increment the speed by 1
                                 
001a31 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a32 937f                      	push r23
001a33 2f6a                      	mov r22, r26 //store the speed data into r27
001a34 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a35 9f67                      	mul r22, r23
001a36 917f                      	pop r23
001a37 916f                      	pop r22
                                 
001a38 9416                      	lsr r1 //shift out the fractional bits
001a39 9407                      	ror r0
001a3a 9416                      	lsr r1
001a3b 9407                      	ror r0
001a3c 9416                      	lsr r1
001a3d 9407                      	ror r0
001a3e 9416                      	lsr r1
001a3f 9407                      	ror r0
                                 
001a40 9200 28ab                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001a42 9210 28ac                 	sts pulse2_fx_Qxy_speed+1, r1
001a44 9220 28ad                 	sts pulse2_fx_Qxy_total_offset, zero
001a46 9220 28ae                 	sts pulse2_fx_Qxy_total_offset+1, zero
001a48 ceef                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001a49 91e0 2875                 	lds ZL, pulse2_arpeggio_macro
001a4b 91f0 2876                 	lds ZH, pulse2_arpeggio_macro+1
001a4d 9630                      	adiw Z, 0
001a4e f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001a4f cee8                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001a50 91e0 287c                 	lds ZL, pulse2_pitch_macro
001a52 91f0 287d                 	lds ZH, pulse2_pitch_macro+1
001a54 9630                      	adiw Z, 0
001a55 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001a56 cee1                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001a57 91e0 2882                 	lds ZL, pulse2_hi_pitch_macro
001a59 91f0 2883                 	lds ZH, pulse2_hi_pitch_macro+1
001a5b 9630                      	adiw Z, 0
001a5c f009                      	breq sound_driver_channel1_fx_Rxy_process
001a5d ceda                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001a5e 2fba                      	mov r27, r26 //copy fx parameters into r27
001a5f 70bf                      	andi r27, 0x0F //mask note index offset
001a60 91c0 280f                 	lds r28, pulse2_note //load current note index
001a62 1bcb                      	sub r28, r27
001a63 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001a64 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001a65 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001a66 e0f0                      	ldi ZH, HIGH(note_table << 1)
001a67 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001a68 0fec                      	add ZL, r28 //add offset
001a69 1df2                      	adc ZH, zero
001a6a 91c5                      	lpm r28, Z+ //load bytes
001a6b 91d4                      	lpm r29, Z
001a6c 93c0 28af                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001a6e 93d0 28b0                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001a70 95a2                      	swap r26
001a71 70af                      	andi r26, 0x0F //mask effect speed
001a72 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a73 95a3                      	inc r26 //increment the speed by 1
                                 
001a74 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a75 937f                      	push r23
001a76 2f6a                      	mov r22, r26 //store the speed data into r27
001a77 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a78 9f67                      	mul r22, r23
001a79 917f                      	pop r23
001a7a 916f                      	pop r22
                                 
001a7b 9416                      	lsr r1 //shift out the fractional bits
001a7c 9407                      	ror r0
001a7d 9416                      	lsr r1
001a7e 9407                      	ror r0
001a7f 9416                      	lsr r1
001a80 9407                      	ror r0
001a81 9416                      	lsr r1
001a82 9407                      	ror r0
                                 
001a83 9200 28b1                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001a85 9210 28b2                 	sts pulse2_fx_Rxy_speed+1, r1
001a87 9220 28b3                 	sts pulse2_fx_Rxy_total_offset, zero
001a89 9220 28b4                 	sts pulse2_fx_Rxy_total_offset+1, zero
001a8b ceac                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001a8c 15a2                      	cp r26, zero
001a8d f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001a8e 91b0 2819                 	lds r27, song_speed
001a90 17ab                      	cp r26, r27
001a91 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001a92 93a0 28b5                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001a94 e0b1                      	ldi r27, 0x01
001a95 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
001a97 c161                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001a98 ce9f                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001a99 e2e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001a9a e5f2                      	ldi ZH, HIGH(sequences << 1)
001a9b 0fea                      	add ZL, r26 //offset the pointer
001a9c 1df2                      	adc ZH, zero
                                 
001a9d 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001a9e 95a7                      	ror r26
001a9f 95a7                      	ror r26
001aa0 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001aa2 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001aa3 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001aa4 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001aa5 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001aa6 ce91                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001aa7 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001aa8 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001aa9 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001aaa 93c0 2808                 	sts pulse2_param, r28
001aac ce8b                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001aad ce8a                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001aae ce89                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001aaf ce88                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001ab0 ce87                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001ab1 93b0 280f                 	sts pulse2_note, r27 //store the note index
001ab3 e0a3                      	ldi r26, 0x03
001ab4 e0b2                      	ldi r27, 0x02
001ab5 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001ab7 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
001ab9 93b0 287e                 	sts pulse2_pitch_macro_offset, r27
001abb 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27
001abd 93b0 2889                 	sts pulse2_duty_macro_offset, r27
001abf 9220 287b                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001ac1 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero
001ac3 9220 2890                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001ac5 9220 2891                 	sts pulse2_fx_1xx_total+1, zero
001ac7 9220 2894                 	sts pulse2_fx_2xx_total, zero
001ac9 9220 2895                 	sts pulse2_fx_2xx_total+1, zero
001acb 9220 289c                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001acd 9220 289d                 	sts pulse2_fx_3xx_total_offset+1, zero
001acf 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ad1 91b0 0a9d                 	lds r27, TCB1_CCMPH
001ad3 93a0 2896                 	sts pulse2_fx_3xx_start, r26
001ad5 93b0 2897                 	sts pulse2_fx_3xx_start+1, r27
001ad7 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001ad9 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001ada 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001adc 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001ade 9220 28ad                 	sts pulse2_fx_Qxy_total_offset, zero
001ae0 9220 28ae                 	sts pulse2_fx_Qxy_total_offset+1, zero
001ae2 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001ae4 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001ae6 9220 28b3                 	sts pulse2_fx_Rxy_total_offset, zero
001ae8 9220 28b4                 	sts pulse2_fx_Rxy_total_offset+1, zero
001aea d0f7                      	rcall sound_driver_channel1_increment_offset
001aeb ce4c                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001aec 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001aed 91a0 2808                 	lds r26, pulse2_param
001aef 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001af0 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001af1 93a0 2808                 	sts pulse2_param, r26
001af3 6092                      	sbr pulse_channel_flags, 2
001af4 d0ed                      	rcall sound_driver_channel1_increment_offset
001af5 ce42                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001af6 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001af7 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
001af9 d0e8                      	rcall sound_driver_channel1_increment_offset
001afa c0fe                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001afb 9220 2870                 	sts pulse2_volume_macro, zero //reset all macro addresses
001afd 9220 2871                 	sts pulse2_volume_macro+1, zero
001aff 9220 2875                 	sts pulse2_arpeggio_macro, zero
001b01 9220 2876                 	sts pulse2_arpeggio_macro+1, zero
001b03 9220 287c                 	sts pulse2_pitch_macro, zero
001b05 9220 287d                 	sts pulse2_pitch_macro+1, zero
001b07 9220 2882                 	sts pulse2_hi_pitch_macro, zero
001b09 9220 2883                 	sts pulse2_hi_pitch_macro+1, zero
001b0b 9220 2887                 	sts pulse2_duty_macro, zero
001b0d 9220 2888                 	sts pulse2_duty_macro+1, zero
001b0f 9220 287b                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001b11 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001b13 9631                      	adiw Z, 1 //point to the byte next to the flag
001b14 91b4                      	lpm r27, Z //store the instrument offset into r27
001b15 eded                      	ldi ZL, LOW(instruments) //point Z to instruments table
001b16 e0ff                      	ldi ZH, HIGH(instruments)
001b17 0feb                      	add ZL, r27 //point Z to offsetted instrument
001b18 1df2                      	adc ZH, zero
001b19 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001b1a 1fff                      	rol ZH
001b1b 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001b1c 91b4                      	lpm r27, Z
                                 
001b1d 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001b1e 1fbb                      	rol r27
001b1f 2fea                      	mov ZL, r26
001b20 2ffb                      	mov ZH, r27
001b21 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001b22 9632                      	adiw Z, 2 //point Z to the address of the macro
001b23 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001b24 95aa                      	dec r26
001b25 f019                      	breq sound_driver_channel1_instrument_change_exit
001b26 95b6                      	lsr r27
001b27 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001b28 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001b29 e0a3                      	ldi r26, 0x03
001b2a e0b2                      	ldi r27, 0x02
001b2b 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001b2d 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
001b2f 93b0 287e                 	sts pulse2_pitch_macro_offset, r27
001b31 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27
001b33 93b0 2889                 	sts pulse2_duty_macro_offset, r27
001b35 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001b36 ce01                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001b37 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001b38 91d5                      	lpm r29, Z+
                                 
001b39 30a5                      	cpi r26, 5
001b3a f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001b3b 30a4                      	cpi r26, 4
001b3c f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001b3d 30a3                      	cpi r26, 3
001b3e f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001b3f 30a2                      	cpi r26, 2
001b40 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001b41 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001b42 93c0 2870                 	sts pulse2_volume_macro, r28
001b44 93d0 2871                 	sts pulse2_volume_macro+1, r29
001b46 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001b47 93c0 2874                 	sts pulse2_volume_macro_release, r28
001b49 93d0 2873                 	sts pulse2_volume_macro_loop, r29
001b4b cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001b4c 93c0 2875                 	sts pulse2_arpeggio_macro, r28
001b4e 93d0 2876                 	sts pulse2_arpeggio_macro+1, r29
001b50 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b52 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001b54 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001b56 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001b58 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001b59 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001b5a 93c0 287c                 	sts pulse2_pitch_macro, r28
001b5c 93d0 287d                 	sts pulse2_pitch_macro+1, r29
001b5e 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b60 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001b62 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001b64 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001b66 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001b67 93c0 2880                 	sts pulse2_pitch_macro_release, r28
001b69 93d0 287f                 	sts pulse2_pitch_macro_loop, r29
001b6b cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001b6c 93c0 2882                 	sts pulse2_hi_pitch_macro, r28
001b6e 93d0 2883                 	sts pulse2_hi_pitch_macro+1, r29
001b70 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b72 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001b74 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001b76 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001b78 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001b79 93c0 2886                 	sts pulse2_hi_pitch_macro_release, r28
001b7b 93d0 2885                 	sts pulse2_hi_pitch_macro_loop, r29
001b7d cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001b7e 93c0 2887                 	sts pulse2_duty_macro, r28
001b80 93d0 2888                 	sts pulse2_duty_macro+1, r29
001b82 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001b83 93c0 288b                 	sts pulse2_duty_macro_release, r28
001b85 93d0 288a                 	sts pulse2_duty_macro_loop, r29
001b87 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001b88 93ef                      	push ZL
001b89 93ff                      	push ZH
001b8a 2fec                      	mov ZL, r28
001b8b 2ffd                      	mov ZH, r29
001b8c 0fee                      	lsl ZL
001b8d 1fff                      	rol ZH
001b8e 91c5                      	lpm r28, Z+
001b8f 91d4                      	lpm r29, Z
001b90 91ff                      	pop ZH
001b91 91ef                      	pop ZL
001b92 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001b93 93ef                      	push ZL
001b94 93ff                      	push ZH
001b95 2fec                      	mov ZL, r28
001b96 2ffd                      	mov ZH, r29
001b97 0fee                      	lsl ZL
001b98 1fff                      	rol ZH
001b99 91c5                      	lpm r28, Z+
001b9a 91d5                      	lpm r29, Z+
001b9b 93c0 2879                 	sts pulse2_arpeggio_macro_release, r28
001b9d 93d0 2878                 	sts pulse2_arpeggio_macro_loop, r29
001b9f 91c4                      	lpm r28, Z
001ba0 93c0 287a                 	sts pulse2_arpeggio_macro_mode, r28
001ba2 91ff                      	pop ZH
001ba3 91ef                      	pop ZL
001ba4 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001ba5 91b0 2874                 	lds r27, pulse2_volume_macro_release
001ba7 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001ba8 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001ba9 95b3                      	inc r27
001baa 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001bac 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
001bae 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001baf f019                      	breq sound_driver_channel1_release_pitch
001bb0 95b3                      	inc r27
001bb1 93b0 2877                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001bb3 91b0 2880                 	lds r27, pulse2_pitch_macro_release
001bb5 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001bb6 f019                      	breq sound_driver_channel1_release_hi_pitch
001bb7 95b3                      	inc r27
001bb8 93b0 287e                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001bba 91b0 2886                 	lds r27, pulse2_hi_pitch_macro_release
001bbc 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001bbd f019                      	breq sound_driver_channel1_release_duty
001bbe 95b3                      	inc r27
001bbf 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001bc1 91b0 288b                 	lds r27, pulse2_duty_macro_release
001bc3 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001bc4 f019                      	breq sound_driver_channel1_release_exit
001bc5 95b3                      	inc r27
001bc6 93b0 2889                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001bc8 d019                      	rcall sound_driver_channel1_increment_offset
001bc9 cd6e                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001bca 91e0 2813                 	lds ZL, song_frames
001bcc 91f0 2814                 	lds ZH, song_frames+1
001bce 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001bd0 91b0 2816                 	lds r27, song_frame_offset+1
001bd2 9612                      	adiw r27:r26, 2 //offset for channel 1
001bd3 0fea                      	add ZL, r26
001bd4 1ffb                      	adc ZH, r27
                                 
001bd5 91a5                      	lpm r26, Z+ //load the address of the next pattern
001bd6 91b4                      	lpm r27, Z
001bd7 0faa                      	lsl r26
001bd8 1fbb                      	rol r27
001bd9 93a0 286a                 	sts pulse2_pattern, r26
001bdb 93b0 286b                 	sts pulse2_pattern+1, r27
                                 
001bdd 9220 286e                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001bdf 9220 286f                 	sts pulse2_pattern_offset+1, zero
001be1 cd56                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001be2 91e0 286e                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001be4 91f0 286f                 	lds ZH, pulse2_pattern_offset+1
001be6 9631                      	adiw Z, 1
001be7 93e0 286e                 	sts pulse2_pattern_offset, ZL
001be9 93f0 286f                 	sts pulse2_pattern_offset+1, ZH
001beb 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001bec 91e0 286e                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001bee 91f0 286f                 	lds ZH, pulse2_pattern_offset+1
001bf0 9632                      	adiw Z, 2 //increment the pointer twice
001bf1 93e0 286e                 	sts pulse2_pattern_offset, ZL
001bf3 93f0 286f                 	sts pulse2_pattern_offset+1, ZH
001bf5 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001bf6 95ba                      	dec r27
001bf7 93b0 286d                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001bf9 91a0 28b9                 	lds r26, triangle_pattern_delay_rows
001bfb 91b0 28ba                 	lds r27, triangle_pattern_delay_frames
001bfd 9610                      	adiw r27:r26, 0
001bfe f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001bff c2a3                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001c00 91e0 28b7                 	lds ZL, triangle_pattern //current pattern for triangle
001c02 91f0 28b8                 	lds ZH, triangle_pattern+1
001c04 91a0 28bb                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001c06 91b0 28bc                 	lds r27, triangle_pattern_offset+1
001c08 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001c09 1ffb                      	adc ZH, r27
001c0a 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001c0b 35b7                      	cpi r27, 0x57
001c0c f408                      	brsh sound_driver_channel2_check_if_volume
001c0d c14f                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001c0e 36b7                      	cpi r27, 0x67
001c0f f408                      	brsh sound_driver_channel2_check_if_delay
001c10 c184                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001c11 3eb3                      	cpi r27, 0xE3
001c12 f408                      	brsh sound_driver_channel2_check_if_instrument
001c13 c18f                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001c14 f409                      	brne sound_driver_channel2_check_if_release
001c15 c192                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001c16 3eb4                      	cpi r27, 0xE4
001c17 f409                      	brne sound_driver_channel2_check_if_end
001c18 c239                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001c19 3fbf                      	cpi r27, 0xFF
001c1a f409                      	brne sound_driver_channel2_check_if_fx
001c1b c25b                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001c1c 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001c1d 91a4                      	lpm r26, Z //load the fx data into r26
001c1e d27a                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001c1f 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001c20 e8ec                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001c21 e5f2                      	ldi ZH, HIGH(channel2_fx << 1)
001c22 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001c23 0feb                      	add ZL, r27 //add offset
001c24 1df2                      	adc ZH, zero
001c25 91c5                      	lpm r28, Z+ //load address bytes
001c26 91d4                      	lpm r29, Z
001c27 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001c28 2ffd                      	mov ZH, r29
001c29 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001c2a 93a0 28d9                 	sts triangle_fx_0xy_sequence, r26
001c2c 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
001c2e cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001c2f 9220 28df                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001c31 9220 28e0                 	sts triangle_fx_2xx+1, zero
001c33 9220 28d9                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001c35 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
001c37 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c38 937f                      	push r23
001c39 2f6a                      	mov r22, r26 //store the rate into r22
001c3a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c3b 9f67                      	mul r22, r23
001c3c 917f                      	pop r23
001c3d 916f                      	pop r22
                                 
001c3e 9416                      	lsr r1 //shift out the fractional bits
001c3f 9407                      	ror r0
001c40 9416                      	lsr r1
001c41 9407                      	ror r0
001c42 9416                      	lsr r1
001c43 9407                      	ror r0
001c44 9416                      	lsr r1
001c45 9407                      	ror r0
001c46 9200 28db                 	sts triangle_fx_1xx, r0
001c48 9210 28dc                 	sts triangle_fx_1xx+1, r1
001c4a cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001c4b 9220 28db                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001c4d 9220 28dc                 	sts triangle_fx_1xx+1, zero
001c4f 9220 28d9                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001c51 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
001c53 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c54 937f                      	push r23
001c55 2f6a                      	mov r22, r26 //store the rate into r22
001c56 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c57 9f67                      	mul r22, r23
001c58 917f                      	pop r23
001c59 916f                      	pop r22
                                 
001c5a 9416                      	lsr r1 //shift out the fractional bits
001c5b 9407                      	ror r0
001c5c 9416                      	lsr r1
001c5d 9407                      	ror r0
001c5e 9416                      	lsr r1
001c5f 9407                      	ror r0
001c60 9416                      	lsr r1
001c61 9407                      	ror r0
001c62 9200 28df                 	sts triangle_fx_2xx, r0
001c64 9210 28e0                 	sts triangle_fx_2xx+1, r1
001c66 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001c67 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c68 937f                      	push r23
001c69 2f6a                      	mov r22, r26 //store the rate into r22
001c6a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c6b 9f67                      	mul r22, r23
001c6c 917f                      	pop r23
001c6d 916f                      	pop r22
                                 
001c6e 9416                      	lsr r1 //shift out the fractional bits
001c6f 9407                      	ror r0
001c70 9416                      	lsr r1
001c71 9407                      	ror r0
001c72 9416                      	lsr r1
001c73 9407                      	ror r0
001c74 9416                      	lsr r1
001c75 9407                      	ror r0
001c76 9200 28e7                 	sts triangle_fx_3xx_speed, r0
001c78 9210 28e8                 	sts triangle_fx_3xx_speed+1, r1
                                 
001c7a 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001c7b c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001c7c cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001c7d 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001c7f 91b0 0a9d                 	lds r27, TCB1_CCMPH
001c81 93a0 28e3                 	sts triangle_fx_3xx_start, r26
001c83 93b0 28e4                 	sts triangle_fx_3xx_start+1, r27
                                 
001c85 9220 28e9                 	sts triangle_fx_3xx_total_offset, zero
001c87 9220 28ea                 	sts triangle_fx_3xx_total_offset+1, zero
001c89 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001c8a 2fba                      	mov r27, r26
001c8b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001c8c 95a2                      	swap r26
001c8d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001c8e 93a0 28eb                 	sts triangle_fx_4xy_speed, r26
001c90 93b0 28ec                 	sts triangle_fx_4xy_depth, r27
001c92 9220 28ed                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001c94 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001c95 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001c96 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001c97 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001c99 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001c9a 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001c9c cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001c9d 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001c9f cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001ca0 15a2                      	cp r26, zero
001ca1 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001ca2 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ca3 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001ca5 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001ca6 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001ca8 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001caa 9220 0aad                 	sts TCB2_CCMPH, zero
001cac cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001cad 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001caf cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001cb0 15a2                      	cp r26, zero
001cb1 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001cb2 91b0 2819                 	lds r27, song_speed
001cb4 17ab                      	cp r26, r27
001cb5 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001cb6 93a0 28ee                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001cb8 e0b1                      	ldi r27, 0x01
001cb9 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
001cbb c1ea                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel2_fx_Gxx_invalid:
001cbc cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001cbd cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001cbe cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001cbf cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001cc0 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001cc1 93a0 28f0                 	sts triangle_fx_Pxx, r26
001cc3 cf3c                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001cc4 91e0 28c2                 	lds ZL, triangle_arpeggio_macro
001cc6 91f0 28c3                 	lds ZH, triangle_arpeggio_macro+1
001cc8 9630                      	adiw Z, 0
001cc9 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001cca cf35                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001ccb 91e0 28c9                 	lds ZL, triangle_pitch_macro
001ccd 91f0 28ca                 	lds ZH, triangle_pitch_macro+1
001ccf 9630                      	adiw Z, 0
001cd0 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001cd1 cf2e                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001cd2 91e0 28cf                 	lds ZL, triangle_hi_pitch_macro
001cd4 91f0 28d0                 	lds ZH, triangle_hi_pitch_macro+1
001cd6 9630                      	adiw Z, 0
001cd7 f009                      	breq sound_driver_channel2_fx_Qxy_process
001cd8 cf27                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001cd9 2fba                      	mov r27, r26 //copy fx parameters into r27
001cda 70bf                      	andi r27, 0x0F //mask note index offset
001cdb 91c0 2812                 	lds r28, triangle_note //load current note index
001cdd 0fbc                      	add r27, r28
001cde 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001cdf f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001ce0 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001ce1 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001ce2 e0f0                      	ldi ZH, HIGH(note_table << 1)
001ce3 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001ce4 0feb                      	add ZL, r27 //add offset
001ce5 1df2                      	adc ZH, zero
001ce6 91c5                      	lpm r28, Z+ //load bytes
001ce7 91d4                      	lpm r29, Z
001ce8 93c0 28f1                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001cea 93d0 28f2                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001cec 95a2                      	swap r26
001ced 70af                      	andi r26, 0x0F //mask effect speed
001cee 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001cef 95a3                      	inc r26 //increment the speed by 1
                                 
001cf0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001cf1 937f                      	push r23
001cf2 2f6a                      	mov r22, r26 //store the speed data into r27
001cf3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001cf4 9f67                      	mul r22, r23
001cf5 917f                      	pop r23
001cf6 916f                      	pop r22
                                 
001cf7 9416                      	lsr r1 //shift out the fractional bits
001cf8 9407                      	ror r0
001cf9 9416                      	lsr r1
001cfa 9407                      	ror r0
001cfb 9416                      	lsr r1
001cfc 9407                      	ror r0
001cfd 9416                      	lsr r1
001cfe 9407                      	ror r0
                                 
001cff 9200 28f3                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001d01 9210 28f4                 	sts triangle_fx_Qxy_speed+1, r1
001d03 9220 28f5                 	sts triangle_fx_Qxy_total_offset, zero
001d05 9220 28f6                 	sts triangle_fx_Qxy_total_offset+1, zero
001d07 cef8                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001d08 91e0 28c2                 	lds ZL, triangle_arpeggio_macro
001d0a 91f0 28c3                 	lds ZH, triangle_arpeggio_macro+1
001d0c 9630                      	adiw Z, 0
001d0d f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001d0e cef1                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001d0f 91e0 28c9                 	lds ZL, triangle_pitch_macro
001d11 91f0 28ca                 	lds ZH, triangle_pitch_macro+1
001d13 9630                      	adiw Z, 0
001d14 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001d15 ceea                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001d16 91e0 28cf                 	lds ZL, triangle_hi_pitch_macro
001d18 91f0 28d0                 	lds ZH, triangle_hi_pitch_macro+1
001d1a 9630                      	adiw Z, 0
001d1b f009                      	breq sound_driver_channel2_fx_Rxy_process
001d1c cee3                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001d1d 2fba                      	mov r27, r26 //copy fx parameters into r27
001d1e 70bf                      	andi r27, 0x0F //mask note index offset
001d1f 91c0 2812                 	lds r28, triangle_note //load current note index
001d21 1bcb                      	sub r28, r27
001d22 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001d23 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001d24 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001d25 e0f0                      	ldi ZH, HIGH(note_table << 1)
001d26 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001d27 0fec                      	add ZL, r28 //add offset
001d28 1df2                      	adc ZH, zero
001d29 91c5                      	lpm r28, Z+ //load bytes
001d2a 91d4                      	lpm r29, Z
001d2b 93c0 28f7                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001d2d 93d0 28f8                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001d2f 95a2                      	swap r26
001d30 70af                      	andi r26, 0x0F //mask effect speed
001d31 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d32 95a3                      	inc r26 //increment the speed by 1
                                 
001d33 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d34 937f                      	push r23
001d35 2f6a                      	mov r22, r26 //store the speed data into r27
001d36 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d37 9f67                      	mul r22, r23
001d38 917f                      	pop r23
001d39 916f                      	pop r22
                                 
001d3a 9416                      	lsr r1 //shift out the fractional bits
001d3b 9407                      	ror r0
001d3c 9416                      	lsr r1
001d3d 9407                      	ror r0
001d3e 9416                      	lsr r1
001d3f 9407                      	ror r0
001d40 9416                      	lsr r1
001d41 9407                      	ror r0
                                 
001d42 9200 28f9                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001d44 9210 28fa                 	sts triangle_fx_Rxy_speed+1, r1
001d46 9220 28fb                 	sts triangle_fx_Rxy_total_offset, zero
001d48 9220 28fc                 	sts triangle_fx_Rxy_total_offset+1, zero
001d4a ceb5                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001d4b 15a2                      	cp r26, zero
001d4c f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001d4d 91b0 2819                 	lds r27, song_speed
001d4f 17ab                      	cp r26, r27
001d50 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001d51 93a0 28fd                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001d53 e0b1                      	ldi r27, 0x01
001d54 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
001d56 c14f                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel2_fx_Sxx_invalid:
001d57 cea8                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001d58 cea7                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001d59 cea6                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001d5a cea5                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001d5b cea4                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001d5c cea3                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001d5d 93b0 2812                 	sts triangle_note, r27 //store the note index
001d5f e0a3                      	ldi r26, 0x03
001d60 e0b2                      	ldi r27, 0x02
001d61 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001d63 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
001d65 93b0 28cb                 	sts triangle_pitch_macro_offset, r27
001d67 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27
001d69 93b0 28d6                 	sts triangle_duty_macro_offset, r27
001d6b 9220 28c8                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001d6d 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero
001d6f 9220 28dd                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001d71 9220 28de                 	sts triangle_fx_1xx_total+1, zero
001d73 9220 28e1                 	sts triangle_fx_2xx_total, zero
001d75 9220 28e2                 	sts triangle_fx_2xx_total+1, zero
001d77 9220 28e9                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001d79 9220 28ea                 	sts triangle_fx_3xx_total_offset+1, zero
001d7b 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001d7d 91b0 0a9d                 	lds r27, TCB1_CCMPH
001d7f 93a0 28e3                 	sts triangle_fx_3xx_start, r26
001d81 93b0 28e4                 	sts triangle_fx_3xx_start+1, r27
001d83 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d85 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001d87 9220 28f5                 	sts triangle_fx_Qxy_total_offset, zero
001d89 9220 28f6                 	sts triangle_fx_Qxy_total_offset+1, zero
001d8b 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001d8d 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001d8f 9220 28fb                 	sts triangle_fx_Rxy_total_offset, zero
001d91 9220 28fc                 	sts triangle_fx_Rxy_total_offset+1, zero
001d93 d0fb                      	rcall sound_driver_channel2_increment_offset
001d94 ce6b                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001d95 d0f9                      	rcall sound_driver_channel2_increment_offset
001d96 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001d97 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001d98 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001d99 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001d9b ce64                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001d9c 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001d9e 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001da0 9220 0aad                 	sts TCB2_CCMPH, zero
001da2 ce5d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001da3 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001da4 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
001da6 d0e8                      	rcall sound_driver_channel2_increment_offset
001da7 c0fe                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001da8 9220 28bd                 	sts triangle_volume_macro, zero //reset all macro addresses
001daa 9220 28be                 	sts triangle_volume_macro+1, zero
001dac 9220 28c2                 	sts triangle_arpeggio_macro, zero
001dae 9220 28c3                 	sts triangle_arpeggio_macro+1, zero
001db0 9220 28c9                 	sts triangle_pitch_macro, zero
001db2 9220 28ca                 	sts triangle_pitch_macro+1, zero
001db4 9220 28cf                 	sts triangle_hi_pitch_macro, zero
001db6 9220 28d0                 	sts triangle_hi_pitch_macro+1, zero
001db8 9220 28d4                 	sts triangle_duty_macro, zero
001dba 9220 28d5                 	sts triangle_duty_macro+1, zero
001dbc 9220 28c8                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001dbe 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001dc0 9631                      	adiw Z, 1 //point to the byte next to the flag
001dc1 91b4                      	lpm r27, Z //store the instrument offset into r27
001dc2 eded                      	ldi ZL, LOW(instruments) //point Z to instruments table
001dc3 e0ff                      	ldi ZH, HIGH(instruments)
001dc4 0feb                      	add ZL, r27 //point Z to offsetted instrument
001dc5 1df2                      	adc ZH, zero
001dc6 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001dc7 1fff                      	rol ZH
001dc8 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001dc9 91b4                      	lpm r27, Z
                                 
001dca 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001dcb 1fbb                      	rol r27
001dcc 2fea                      	mov ZL, r26
001dcd 2ffb                      	mov ZH, r27
001dce 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001dcf 9632                      	adiw Z, 2 //point Z to the address of the macro
001dd0 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001dd1 95aa                      	dec r26
001dd2 f019                      	breq sound_driver_channel2_instrument_change_exit
001dd3 95b6                      	lsr r27
001dd4 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001dd5 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001dd6 e0a3                      	ldi r26, 0x03
001dd7 e0b2                      	ldi r27, 0x02
001dd8 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001dda 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
001ddc 93b0 28cb                 	sts triangle_pitch_macro_offset, r27
001dde 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27
001de0 93b0 28d6                 	sts triangle_duty_macro_offset, r27
001de2 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001de3 ce1c                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001de4 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001de5 91d5                      	lpm r29, Z+
                                 
001de6 30a5                      	cpi r26, 5
001de7 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
001de8 30a4                      	cpi r26, 4
001de9 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
001dea 30a3                      	cpi r26, 3
001deb f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
001dec 30a2                      	cpi r26, 2
001ded f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
001dee c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
001def 93c0 28bd                 	sts triangle_volume_macro, r28
001df1 93d0 28be                 	sts triangle_volume_macro+1, r29
001df3 d041                      	rcall sound_driver_channel2_instrument_change_read_header
001df4 93c0 28c1                 	sts triangle_volume_macro_release, r28
001df6 93d0 28c0                 	sts triangle_volume_macro_loop, r29
001df8 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
001df9 93c0 28c2                 	sts triangle_arpeggio_macro, r28
001dfb 93d0 28c3                 	sts triangle_arpeggio_macro+1, r29
001dfd 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001dff 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001e01 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001e03 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001e05 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
001e06 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
001e07 93c0 28c9                 	sts triangle_pitch_macro, r28
001e09 93d0 28ca                 	sts triangle_pitch_macro+1, r29
001e0b 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e0d 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001e0f 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001e11 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001e13 d021                      	rcall sound_driver_channel2_instrument_change_read_header
001e14 93c0 28cd                 	sts triangle_pitch_macro_release, r28
001e16 93d0 28cc                 	sts triangle_pitch_macro_loop, r29
001e18 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001e19 93c0 28cf                 	sts triangle_hi_pitch_macro, r28
001e1b 93d0 28d0                 	sts triangle_hi_pitch_macro+1, r29
001e1d 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e1f 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001e21 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001e23 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001e25 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001e26 93c0 28d3                 	sts triangle_hi_pitch_macro_release, r28
001e28 93d0 28d2                 	sts triangle_hi_pitch_macro_loop, r29
001e2a cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
001e2b 93c0 28d4                 	sts triangle_duty_macro, r28
001e2d 93d0 28d5                 	sts triangle_duty_macro+1, r29
001e2f d005                      	rcall sound_driver_channel2_instrument_change_read_header
001e30 93c0 28d8                 	sts triangle_duty_macro_release, r28
001e32 93d0 28d7                 	sts triangle_duty_macro_loop, r29
001e34 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001e35 93ef                      	push ZL
001e36 93ff                      	push ZH
001e37 2fec                      	mov ZL, r28
001e38 2ffd                      	mov ZH, r29
001e39 0fee                      	lsl ZL
001e3a 1fff                      	rol ZH
001e3b 91c5                      	lpm r28, Z+
001e3c 91d4                      	lpm r29, Z
001e3d 91ff                      	pop ZH
001e3e 91ef                      	pop ZL
001e3f 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
001e40 93ef                      	push ZL
001e41 93ff                      	push ZH
001e42 2fec                      	mov ZL, r28
001e43 2ffd                      	mov ZH, r29
001e44 0fee                      	lsl ZL
001e45 1fff                      	rol ZH
001e46 91c5                      	lpm r28, Z+
001e47 91d5                      	lpm r29, Z+
001e48 93c0 28c6                 	sts triangle_arpeggio_macro_release, r28
001e4a 93d0 28c5                 	sts triangle_arpeggio_macro_loop, r29
001e4c 91c4                      	lpm r28, Z
001e4d 93c0 28c7                 	sts triangle_arpeggio_macro_mode, r28
001e4f 91ff                      	pop ZH
001e50 91ef                      	pop ZL
001e51 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001e52 91b0 28c1                 	lds r27, triangle_volume_macro_release
001e54 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001e55 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001e56 95b3                      	inc r27
001e57 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001e59 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
001e5b 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001e5c f019                      	breq sound_driver_channel2_release_pitch
001e5d 95b3                      	inc r27
001e5e 93b0 28c4                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
001e60 91b0 28cd                 	lds r27, triangle_pitch_macro_release
001e62 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001e63 f019                      	breq sound_driver_channel2_release_hi_pitch
001e64 95b3                      	inc r27
001e65 93b0 28cb                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001e67 91b0 28d3                 	lds r27, triangle_hi_pitch_macro_release
001e69 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001e6a f019                      	breq sound_driver_channel2_release_duty
001e6b 95b3                      	inc r27
001e6c 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
001e6e 91b0 28d8                 	lds r27, triangle_duty_macro_release
001e70 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001e71 f019                      	breq sound_driver_channel2_release_exit
001e72 95b3                      	inc r27
001e73 93b0 28d6                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001e75 d019                      	rcall sound_driver_channel2_increment_offset
001e76 cd89                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001e77 91e0 2813                 	lds ZL, song_frames
001e79 91f0 2814                 	lds ZH, song_frames+1
001e7b 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001e7d 91b0 2816                 	lds r27, song_frame_offset+1
001e7f 9614                      	adiw r27:r26, 4 //offset for channel 2
001e80 0fea                      	add ZL, r26
001e81 1ffb                      	adc ZH, r27
                                 
001e82 91a5                      	lpm r26, Z+ //load the address of the next pattern
001e83 91b4                      	lpm r27, Z
001e84 0faa                      	lsl r26
001e85 1fbb                      	rol r27
001e86 93a0 28b7                 	sts triangle_pattern, r26
001e88 93b0 28b8                 	sts triangle_pattern+1, r27
                                 
001e8a 9220 28bb                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001e8c 9220 28bc                 	sts triangle_pattern_offset+1, zero
001e8e cd71                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
001e8f 91e0 28bb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001e91 91f0 28bc                 	lds ZH, triangle_pattern_offset+1
001e93 9631                      	adiw Z, 1
001e94 93e0 28bb                 	sts triangle_pattern_offset, ZL
001e96 93f0 28bc                 	sts triangle_pattern_offset+1, ZH
001e98 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001e99 91e0 28bb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001e9b 91f0 28bc                 	lds ZH, triangle_pattern_offset+1
001e9d 9632                      	adiw Z, 2 //increment the pointer twice
001e9e 93e0 28bb                 	sts triangle_pattern_offset, ZL
001ea0 93f0 28bc                 	sts triangle_pattern_offset+1, ZH
001ea2 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001ea3 95ba                      	dec r27
001ea4 93b0 28ba                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
001ea6 91f0 2819                 	lds r31, song_speed
001ea8 2fef                      	mov r30, r31
001ea9 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
001eaa 91a0 2820                 	lds r26, pulse1_pattern_delay_frames
001eac 11a2                      	cpse r26, zero
001ead c042                      	rjmp sound_driver_calculate_delays_pulse2
001eae c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
001eaf 2faf                      	mov r26, r31 //move the speed to r26
001eb0 91b0 281f                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
001eb2 15b2                      	cp r27, zero
001eb3 f409                      	brne PC+2
001eb4 c03b                      	rjmp sound_driver_calculate_delays_pulse2
001eb5 95ba                      	dec r27
001eb6 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
001eb8 11b2                      	cpse r27, zero
001eb9 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
001eba 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
001ebb efbf                      	ldi r27, 0xFF
001ebc 91c0 2868                 	lds r28, pulse1_fx_Sxx_pre
001ebe 91d0 2869                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
001ec0 17cb                      	cp r28, r27
001ec1 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
001ec2 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
001ec3 17db                      	cp r29, r27
001ec4 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
001ec5 c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
001ec6 91c0 2859                 	lds r28, pulse1_fx_Gxx_pre
001ec8 91d0 285a                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
001eca 17cb                      	cp r28, r27
001ecb f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
001ecc c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
001ecd 17db                      	cp r29, r27
001ece f0f9                      	breq sound_driver_calculate_delays_pulse1_store
001ecf c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
001ed0 93b0 2868                 	sts pulse1_fx_Sxx_pre, r27
001ed2 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001ed3 93e0 2869                 	sts pulse1_fx_Sxx_post, r30
001ed5 95ca                      	dec r28
001ed6 93c0 2820                 	sts pulse1_pattern_delay_frames, r28
001ed8 2fef                      	mov r30, r31
001ed9 50e1                      	subi r30, 1
001eda c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
001edb 93b0 2869                 	sts pulse1_fx_Sxx_post, r27
001edd 2fad                      	mov r26, r29
001ede c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
001edf 93b0 2859                 	sts pulse1_fx_Gxx_pre, r27
001ee1 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001ee2 93e0 285a                 	sts pulse1_fx_Gxx_post, r30
001ee4 95ca                      	dec r28
001ee5 93c0 2820                 	sts pulse1_pattern_delay_frames, r28
001ee7 2fef                      	mov r30, r31
001ee8 50e1                      	subi r30, 1
001ee9 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
001eea 93b0 285a                 	sts pulse1_fx_Gxx_post, r27
001eec 2fad                      	mov r26, r29
001eed c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
001eee 93a0 2820                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
001ef0 91a0 286d                 	lds r26, pulse2_pattern_delay_frames
001ef2 11a2                      	cpse r26, zero
001ef3 c042                      	rjmp sound_driver_calculate_delays_triangle
001ef4 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
001ef5 2faf                      	mov r26, r31 //move the speed to r26
001ef6 91b0 286c                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
001ef8 15b2                      	cp r27, zero
001ef9 f409                      	brne PC+2
001efa c03b                      	rjmp sound_driver_calculate_delays_triangle
001efb 95ba                      	dec r27
001efc 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
001efe 11b2                      	cpse r27, zero
001eff c034                      	rjmp sound_driver_calculate_delays_pulse2_store
001f00 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
001f01 efbf                      	ldi r27, 0xFF
001f02 91c0 28b5                 	lds r28, pulse2_fx_Sxx_pre
001f04 91d0 28b6                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
001f06 17cb                      	cp r28, r27
001f07 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
001f08 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
001f09 17db                      	cp r29, r27
001f0a f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
001f0b c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
001f0c 91c0 28a6                 	lds r28, pulse2_fx_Gxx_pre
001f0e 91d0 28a7                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
001f10 17cb                      	cp r28, r27
001f11 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
001f12 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
001f13 17db                      	cp r29, r27
001f14 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
001f15 c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
001f16 93b0 28b5                 	sts pulse2_fx_Sxx_pre, r27
001f18 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001f19 93e0 28b6                 	sts pulse2_fx_Sxx_post, r30
001f1b 95ca                      	dec r28
001f1c 93c0 286d                 	sts pulse2_pattern_delay_frames, r28
001f1e 2fef                      	mov r30, r31
001f1f 50e1                      	subi r30, 1
001f20 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
001f21 93b0 28b6                 	sts pulse2_fx_Sxx_post, r27
001f23 2fad                      	mov r26, r29
001f24 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
001f25 93b0 28a6                 	sts pulse2_fx_Gxx_pre, r27
001f27 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001f28 93e0 28a7                 	sts pulse2_fx_Gxx_post, r30
001f2a 95ca                      	dec r28
001f2b 93c0 286d                 	sts pulse2_pattern_delay_frames, r28
001f2d 2fef                      	mov r30, r31
001f2e 50e1                      	subi r30, 1
001f2f cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
001f30 93b0 28a7                 	sts pulse2_fx_Gxx_post, r27
001f32 2fad                      	mov r26, r29
001f33 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
001f34 93a0 286d                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
001f36 91a0 28ba                 	lds r26, triangle_pattern_delay_frames
001f38 11a2                      	cpse r26, zero
001f39 c042                      	rjmp sound_driver_calculate_delays_noise
001f3a c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
001f3b 2faf                      	mov r26, r31 //move the speed to r26
001f3c 91b0 28b9                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
001f3e 15b2                      	cp r27, zero
001f3f f409                      	brne PC+2
001f40 c03b                      	rjmp sound_driver_calculate_delays_noise
001f41 95ba                      	dec r27
001f42 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
001f44 11b2                      	cpse r27, zero
001f45 c034                      	rjmp sound_driver_calculate_delays_triangle_store
001f46 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
001f47 efbf                      	ldi r27, 0xFF
001f48 91c0 28fd                 	lds r28, triangle_fx_Sxx_pre
001f4a 91d0 28fe                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
001f4c 17cb                      	cp r28, r27
001f4d f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
001f4e c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
001f4f 17db                      	cp r29, r27
001f50 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
001f51 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
001f52 91c0 28ee                 	lds r28, triangle_fx_Gxx_pre
001f54 91d0 28ef                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
001f56 17cb                      	cp r28, r27
001f57 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
001f58 c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
001f59 17db                      	cp r29, r27
001f5a f0f9                      	breq sound_driver_calculate_delays_triangle_store
001f5b c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
001f5c 93b0 28fd                 	sts triangle_fx_Sxx_pre, r27
001f5e 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001f5f 93e0 28fe                 	sts triangle_fx_Sxx_post, r30
001f61 95ca                      	dec r28
001f62 93c0 28ba                 	sts triangle_pattern_delay_frames, r28
001f64 2fef                      	mov r30, r31
001f65 50e1                      	subi r30, 1
001f66 c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
001f67 93b0 28fe                 	sts triangle_fx_Sxx_post, r27
001f69 2fad                      	mov r26, r29
001f6a c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
001f6b 93b0 28ee                 	sts triangle_fx_Gxx_pre, r27
001f6d 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001f6e 93e0 28ef                 	sts triangle_fx_Gxx_post, r30
001f70 95ca                      	dec r28
001f71 93c0 28ba                 	sts triangle_pattern_delay_frames, r28
001f73 2fef                      	mov r30, r31
001f74 50e1                      	subi r30, 1
001f75 c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
001f76 93b0 28ef                 	sts triangle_fx_Gxx_post, r27
001f78 2fad                      	mov r26, r29
001f79 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
001f7a 93a0 28ba                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
001f7c 91e0 2823                 	lds ZL, pulse1_volume_macro
001f7e 91f0 2824                 	lds ZH, pulse1_volume_macro+1
001f80 9630                      	adiw Z, 0
001f81 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
001f82 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001f83 1fff                      	rol ZH
001f84 91a0 2825                 	lds r26, pulse1_volume_macro_offset
001f86 0fea                      	add ZL, r26
001f87 1df2                      	adc ZH, zero
                                 
001f88 91b0 2827                 	lds r27, pulse1_volume_macro_release
001f8a 17ba                      	cp r27, r26
001f8b f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
001f8c 91a0 2826                 	lds r26, pulse1_volume_macro_loop
001f8e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001f8f f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001f90 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
001f91 95a3                      	inc r26 //increment the macro offset
001f92 93a0 2825                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
001f94 91b4                      	lpm r27, Z //load volume data into r27
001f95 3fbf                      	cpi r27, 0xFF //check for macro end flag
001f96 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
001f97 91b0 2827                 	lds r27, pulse1_volume_macro_release
001f99 3fbf                      	cpi r27, 0xFF
001f9a f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
001f9b 91b0 2826                 	lds r27, pulse1_volume_macro_loop //load the loop index
001f9d 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
001f9f cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
001fa0 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
001fa1 93a0 2825                 	sts pulse1_volume_macro_offset, r26
001fa3 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
001fa4 ece0                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
001fa5 e5f2                      	ldi ZH, HIGH(volumes << 1)
001fa6 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
001fa7 0feb                      	add ZL, r27 //add offset to the table
001fa8 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
001fa9 91b0 2800                 	lds r27, pulse1_param //load main volume
001fab 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001fac 91a0 2857                 	lds r26, pulse1_fx_7xy_value
001fae 30a0                      	cpi r26, 0x00
001faf f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
001fb0 0feb                      	add ZL, r27 //offset the volume table by the main volume
001fb1 1df2                      	adc ZH, zero
001fb2 91b4                      	lpm r27, Z
001fb3 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001fb5 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
001fb6 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
001fb8 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001fb9 91a0 2857                 	lds r26, pulse1_fx_7xy_value
001fbb 30a0                      	cpi r26, 0x00
001fbc f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
001fbd 93b0 2806                 	sts pulse1_output_volume, r27
001fbf c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
001fc0 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001fc1 f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
001fc2 f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
001fc3 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
001fc4 0feb                      	add ZL, r27 //offset the volume table by the main volume
001fc5 1df2                      	adc ZH, zero
001fc6 91b4                      	lpm r27, Z
001fc7 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001fc9 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
001fca e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001fcb 0feb                      	add ZL, r27 //offset the volume table by the main volume
001fcc 1df2                      	adc ZH, zero
001fcd 91b4                      	lpm r27, Z
001fce 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001fd0 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
001fd1 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001fd2 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001fd3 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001fd4 93b0 2806                 	sts pulse1_output_volume, r27
001fd6 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
001fd7 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001fd8 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001fda 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
001fdc 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
001fde 9630                      	adiw Z, 0
001fdf f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
001fe0 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001fe1 1fff                      	rol ZH
001fe2 91a0 282a                 	lds r26, pulse1_arpeggio_macro_offset
001fe4 0fea                      	add ZL, r26
001fe5 1df2                      	adc ZH, zero
                                 
001fe6 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
001fe8 17ba                      	cp r27, r26
001fe9 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
001fea 91a0 282b                 	lds r26, pulse1_arpeggio_macro_loop
001fec 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001fed f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
001fee c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
001fef 95a3                      	inc r26 //increment the macro offset
001ff0 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
001ff2 91b4                      	lpm r27, Z //load arpeggio data into r27
001ff3 38b0                      	cpi r27, 0x80 //check for macro end flag
001ff4 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
001ff5 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
001ff6 50a1                      	subi r26, 1 //keep the offset at the end flag
001ff7 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
001ff9 91b0 282d                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001ffb 30b1                      	cpi r27, 0x01
001ffc f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
001ffd 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
001fff 3fbf                      	cpi r27, 0xFF
002000 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
002001 91b0 282b                 	lds r27, pulse1_arpeggio_macro_loop
002003 3fbf                      	cpi r27, 0xFF
002004 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002005 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002006 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
002008 3fbf                      	cpi r27, 0xFF
002009 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
00200a 91b0 282b                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
00200c 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00200d f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
00200e 91c0 283f                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
002010 91d0 2840                 	lds r29, pulse1_fx_0xy_sequence+1
002012 9620                      	adiw r29:r28, 0
002013 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002014 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002015 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
002017 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002018 93b0 282a                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
00201a cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
00201b 91c0 283f                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
00201d 91d0 2840                 	lds r29, pulse1_fx_0xy_sequence+1
00201f 9620                      	adiw r29:r28, 0 //check for 0xy effect
002020 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
002021 95d6                      	lsr r29
002022 95c7                      	ror r28
002023 95d7                      	ror r29
002024 95c7                      	ror r28
002025 95d7                      	ror r29
002026 95c7                      	ror r28
002027 95d7                      	ror r29
002028 95c7                      	ror r28
002029 95d7                      	ror r29
00202a 95d2                      	swap r29
                                 
00202b 93c0 283f                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
00202d 93d0 2840                 	sts pulse1_fx_0xy_sequence+1, r29
00202f 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002030 91a0 2807                 	lds r26, pulse1_note //load the current note index
002032 0fac                      	add r26, r28 //add the note offset
002033 c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002034 91a0 2807                 	lds r26, pulse1_note //load the current note index
002036 c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002037 9220 282e                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002039 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero
00203b 91a0 282d                 	lds r26, pulse1_arpeggio_macro_mode
00203d 30a1                      	cpi r26, 0x01 //absolute mode
00203e f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
00203f f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
002040 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
002041 91a0 2807                 	lds r26, pulse1_note //load the current note index
002043 0fab                      	add r26, r27 //offset the note with the arpeggio data
002044 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002045 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002046 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002047 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002048 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002049 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
00204a fda7                      	sbrc r26, 7 //check if result is negative
00204b e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00204c c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
00204d 2fab                      	mov r26, r27 //move the arpeggio data into r26
00204e c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
00204f 91a0 2807                 	lds r26, pulse1_note //load the current note index
002051 0fab                      	add r26, r27 //offset the note with the arpeggio data
002052 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002053 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002054 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002056 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002057 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002058 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002059 93a0 2807                 	sts pulse1_note, r26
00205b c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
00205c fda7                      	sbrc r26, 7 //check if result is negative
00205d e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00205e 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
002060 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
002061 e0f0                      	ldi ZH, HIGH(note_table << 1)
002062 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002063 0fea                      	add ZL, r26 //add offset
002064 1df2                      	adc ZH, zero
002065 91a5                      	lpm r26, Z+ //load bytes
002066 91b4                      	lpm r27, Z
002067 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002069 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
00206b 93a0 284b                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00206d 93b0 284c                 	sts pulse1_fx_3xx_target+1, r27
00206f c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
002070 91e0 282f                 	lds ZL, pulse1_pitch_macro
002072 91f0 2830                 	lds ZH, pulse1_pitch_macro+1
002074 9630                      	adiw Z, 0
002075 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002076 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002077 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002078 1fff                      	rol ZH
002079 91a0 2831                 	lds r26, pulse1_pitch_macro_offset
00207b 0fea                      	add ZL, r26
00207c 1df2                      	adc ZH, zero
                                 
00207d 91b0 2833                 	lds r27, pulse1_pitch_macro_release
00207f 17ba                      	cp r27, r26
002080 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
002081 91a0 2832                 	lds r26, pulse1_pitch_macro_loop
002083 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002084 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002085 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
002086 95a3                      	inc r26 //increment the macro offset
002087 93a0 2831                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
002089 91b4                      	lpm r27, Z //load pitch data into r27
00208a 38b0                      	cpi r27, 0x80 //check for macro end flag
00208b f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
00208c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00208d 93a0 2831                 	sts pulse1_pitch_macro_offset, r26
00208f 91b0 2833                 	lds r27, pulse1_pitch_macro_release
002091 3fbf                      	cpi r27, 0xFF
002092 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
002093 91b0 2832                 	lds r27, pulse1_pitch_macro_loop //load the loop index
002095 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002096 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002097 93b0 2831                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
002099 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
00209a 91b0 282e                 	lds r27, pulse1_total_pitch_offset
00209c c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
00209d 91a0 282e                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
00209f 0fba                      	add r27, r26
0020a0 93b0 282e                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
0020a2 91a0 285b                 	lds r26, pulse1_fx_Pxx
0020a4 0fba                      	add r27, r26
                                 
0020a5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0020a6 937f                      	push r23
0020a7 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0020a8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0020a9 0367                      	mulsu r22, r23
0020aa 917f                      	pop r23
0020ab 916f                      	pop r22
                                 
0020ac 9416                      	lsr r1 //shift out the fractional bits
0020ad 9407                      	ror r0
0020ae 9416                      	lsr r1
0020af 9407                      	ror r0
0020b0 9416                      	lsr r1
0020b1 9407                      	ror r0
0020b2 9416                      	lsr r1
0020b3 9407                      	ror r0
0020b4 fe13                      	sbrs r1, 3 //check if result was a negative number
0020b5 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0020b6 efb0                      	ldi r27, 0xF0
0020b7 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0020b8 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0020ba 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0020bc 0da0                      	add r26, r0 //offset the timer values
0020bd 1db1                      	adc r27, r1
                                 	
0020be 91c0 2843                 	lds r28, pulse1_fx_1xx_total
0020c0 91d0 2844                 	lds r29, pulse1_fx_1xx_total+1
0020c2 1bac                      	sub r26, r28
0020c3 0bbd                      	sbc r27, r29
0020c4 91c0 2847                 	lds r28, pulse1_fx_2xx_total
0020c6 91d0 2848                 	lds r29, pulse1_fx_2xx_total+1
0020c8 0fac                      	add r26, r28
0020c9 1fbd                      	adc r27, r29
0020ca 91c0 2860                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0020cc 91d0 2861                 	lds r29, pulse1_fx_Qxy_total_offset+1
0020ce 1bac                      	sub r26, r28
0020cf 0bbd                      	sbc r27, r29
0020d0 91c0 2866                 	lds r28, pulse1_fx_Rxy_total_offset
0020d2 91d0 2867                 	lds r29, pulse1_fx_Rxy_total_offset+1
0020d4 0fac                      	add r26, r28
0020d5 1fbd                      	adc r27, r29
                                 
0020d6 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0020d8 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
0020da 91e0 2835                 	lds ZL, pulse1_hi_pitch_macro
0020dc 91f0 2836                 	lds ZH, pulse1_hi_pitch_macro+1
0020de 9630                      	adiw Z, 0
0020df f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
0020e0 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
0020e1 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0020e2 1fff                      	rol ZH
0020e3 91a0 2837                 	lds r26, pulse1_hi_pitch_macro_offset
0020e5 0fea                      	add ZL, r26
0020e6 1df2                      	adc ZH, zero
                                 
0020e7 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_release
0020e9 17ba                      	cp r27, r26
0020ea f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0020eb 91a0 2838                 	lds r26, pulse1_hi_pitch_macro_loop
0020ed 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0020ee f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0020ef c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
0020f0 95a3                      	inc r26 //increment the macro offset
0020f1 93a0 2837                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
0020f3 91b4                      	lpm r27, Z //load hi pitch data into r27
0020f4 38b0                      	cpi r27, 0x80 //check for macro end flag
0020f5 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
0020f6 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0020f7 93a0 2837                 	sts pulse1_hi_pitch_macro_offset, r26
0020f9 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_release
0020fb 3fbf                      	cpi r27, 0xFF
0020fc f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0020fd 91b0 2838                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0020ff 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002100 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002101 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
002103 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
002104 91b0 2834                 	lds r27, pulse1_total_hi_pitch_offset
002106 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
002107 91a0 2834                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
002109 0fba                      	add r27, r26
00210a 93b0 2834                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
00210c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00210d 937f                      	push r23
00210e 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00210f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002110 0367                      	mulsu r22, r23
002111 917f                      	pop r23
002112 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
002113 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002115 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002117 0da0                      	add r26, r0 //offset the timer values
002118 1db1                      	adc r27, r1
002119 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00211b 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
00211d 91e0 283a                 	lds ZL, pulse1_duty_macro
00211f 91f0 283b                 	lds ZH, pulse1_duty_macro+1
002121 9630                      	adiw Z, 0
002122 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
002123 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002124 1fff                      	rol ZH
002125 91a0 283c                 	lds r26, pulse1_duty_macro_offset
002127 0fea                      	add ZL, r26
002128 1df2                      	adc ZH, zero
                                 
002129 91b0 283e                 	lds r27, pulse1_duty_macro_release
00212b 17ba                      	cp r27, r26
00212c f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
00212d 91a0 283d                 	lds r26, pulse1_duty_macro_loop
00212f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002130 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002131 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
002132 95a3                      	inc r26 //increment the macro offset
002133 93a0 283c                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
002135 91b4                      	lpm r27, Z //load pitch data into r27
002136 3fbf                      	cpi r27, 0xFF //check for macro end flag
002137 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
002138 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002139 93a0 283c                 	sts pulse1_duty_macro_offset, r26
00213b 91b0 283e                 	lds r27, pulse1_duty_macro_release
00213d 3fbf                      	cpi r27, 0xFF
00213e f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
00213f 91b0 283d                 	lds r27, pulse1_duty_macro_loop //load the loop index
002141 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002142 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002143 93b0 283c                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
002145 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
002146 e2e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002147 e5f2                      	ldi ZH, HIGH(sequences << 1)
002148 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002149 1df2                      	adc ZH, zero
                                 
00214a 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00214b 95b7                      	ror r27
00214c 95b7                      	ror r27
00214d 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
00214f 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
002150 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002151 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002152 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
002153 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
002154 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
002155 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002156 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002157 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
002159 91e0 2841                 	lds ZL, pulse1_fx_1xx
00215b 91f0 2842                 	lds ZH, pulse1_fx_1xx+1
00215d 9630                      	adiw Z, 0
00215e f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
00215f 91a0 2843                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
002161 91b0 2844                 	lds r27, pulse1_fx_1xx_total+1
002163 0fae                      	add r26, ZL //increase the total offset by the rate
002164 1fbf                      	adc r27, ZH
002165 93a0 2843                 	sts pulse1_fx_1xx_total, r26
002167 93b0 2844                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
002169 91e0 2845                 	lds ZL, pulse1_fx_2xx
00216b 91f0 2846                 	lds ZH, pulse1_fx_2xx+1
00216d 9630                      	adiw Z, 0
00216e f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
00216f 91a0 2847                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
002171 91b0 2848                 	lds r27, pulse1_fx_2xx_total+1
002173 0fae                      	add r26, ZL //increase the total offset by the rate
002174 1fbf                      	adc r27, ZH
002175 93a0 2847                 	sts pulse1_fx_2xx_total, r26
002177 93b0 2848                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
002179 91e0 284d                 	lds ZL, pulse1_fx_3xx_speed
00217b 91f0 284e                 	lds ZH, pulse1_fx_3xx_speed+1
00217d 9630                      	adiw Z, 0
00217e f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
00217f c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
002180 91a0 2849                 	lds r26, pulse1_fx_3xx_start
002182 91b0 284a                 	lds r27, pulse1_fx_3xx_start+1
002184 9610                      	adiw r26:r27, 0
002185 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
002186 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
002187 91c0 284b                 	lds r28, pulse1_fx_3xx_target
002189 91d0 284c                 	lds r29, pulse1_fx_3xx_target+1
                                 
00218b 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00218c 07bd                      	cpc r27, r29
00218d f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
00218e f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00218f c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
002190 9220 2849                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002192 9220 284a                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002194 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
002195 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002196 0bdb                      	sbc r29, r27
002197 91a0 284f                 	lds r26, pulse1_fx_3xx_total_offset
002199 91b0 2850                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
00219b 0fae                      	add r26, ZL //add the speed to the total offset
00219c 1fbf                      	adc r27, ZH
00219d 1bca                      	sub r28, r26 //invert the total difference with the total offset
00219e 0bdb                      	sbc r29, r27
00219f f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0021a0 93a0 284f                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0021a2 93b0 2850                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0021a4 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0021a6 91b0 0a8d                 	lds r27, TCB0_CCMPH
0021a8 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0021a9 0bbd                      	sbc r27, r29
0021aa 93a0 0a8c                 	sts TCB0_CCMPL, r26
0021ac 93b0 0a8d                 	sts TCB0_CCMPH, r27
0021ae c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
0021af 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0021b0 0bbd                      	sbc r27, r29
0021b1 91c0 284f                 	lds r28, pulse1_fx_3xx_total_offset
0021b3 91d0 2850                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
0021b5 0fce                      	add r28, ZL //add the speed to the total offset
0021b6 1fdf                      	adc r29, ZH
0021b7 1bac                      	sub r26, r28 //invert the total difference with the total offset
0021b8 0bbd                      	sbc r27, r29
0021b9 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0021ba 93c0 284f                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
0021bc 93d0 2850                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
0021be 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
0021c0 91d0 0a8d                 	lds r29, TCB0_CCMPH
0021c2 0fca                      	add r28, r26 //offset the current timer period with the total offset
0021c3 1fdb                      	adc r29, r27
0021c4 93c0 0a8c                 	sts TCB0_CCMPL, r28
0021c6 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
0021c8 91a0 2851                 	lds r26, pulse1_fx_4xy_speed
0021ca 15a2                      	cp r26, zero
0021cb f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
0021cc c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
0021cd 91b0 2852                 	lds r27, pulse1_fx_4xy_depth
0021cf 91c0 2853                 	lds r28, pulse1_fx_4xy_phase
0021d1 0fca                      	add r28, r26 //increase the phase by the speed
0021d2 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0021d3 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0021d4 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
0021d5 93c0 2853                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
0021d7 31c0                      	cpi r28, 16
0021d8 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
0021d9 32c0                      	cpi r28, 32
0021da f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
0021db 33c0                      	cpi r28, 48
0021dc f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
0021dd c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
0021de 70cf                      	andi r28, 0x0F //mask for values 0-15
0021df c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
0021e0 6fc0                      	ori r28, 0xF0
0021e1 95c0                      	com r28 //invert values 0-15
0021e2 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
0021e3 70cf                      	andi r28, 0x0F //mask for values 0-15
0021e4 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
0021e5 6fc0                      	ori r28, 0xF0
0021e6 95c0                      	com r28 //invert values 0-15
0021e7 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
0021e8 95b2                      	swap r27 //multiply depth by 16
0021e9 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0021ea e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0021eb e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0021ec 0fec                      	add ZL, r28 //offset the table by the depth+phase
0021ed 1df2                      	adc ZH, zero
0021ee 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0021ef 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0021f0 937f                      	push r23
0021f1 2f6c                      	mov r22, r28 //store the vibrato value into r22
0021f2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0021f3 9f67                      	mul r22, r23
0021f4 917f                      	pop r23
0021f5 916f                      	pop r22
                                 
0021f6 9416                      	lsr r1 //shift out the fractional bits
0021f7 9407                      	ror r0
0021f8 9416                      	lsr r1
0021f9 9407                      	ror r0
0021fa 9416                      	lsr r1
0021fb 9407                      	ror r0
0021fc 9416                      	lsr r1
0021fd 9407                      	ror r0
                                 	
0021fe 91a0 0a8c                 	lds r26, TCB0_CCMPL
002200 91b0 0a8d                 	lds r27, TCB0_CCMPH
002202 0da0                      	add r26, r0
002203 1db1                      	adc r27, r1
002204 93a0 0a8c                 	sts TCB0_CCMPL, r26
002206 93b0 0a8d                 	sts TCB0_CCMPH, r27
002208 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
002209 95b2                      	swap r27 //multiply depth by 16
00220a 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00220b e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00220c e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00220d 0fec                      	add ZL, r28 //offset the table by the depth+phase
00220e 1df2                      	adc ZH, zero
00220f 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002210 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002211 937f                      	push r23
002212 2f6c                      	mov r22, r28 //store the vibrato value into r22
002213 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002214 9f67                      	mul r22, r23
002215 917f                      	pop r23
002216 916f                      	pop r22
                                 
002217 9416                      	lsr r1 //shift out the fractional bits
002218 9407                      	ror r0
002219 9416                      	lsr r1
00221a 9407                      	ror r0
00221b 9416                      	lsr r1
00221c 9407                      	ror r0
00221d 9416                      	lsr r1
00221e 9407                      	ror r0
                                 
00221f 91a0 0a8c                 	lds r26, TCB0_CCMPL
002221 91b0 0a8d                 	lds r27, TCB0_CCMPH
002223 19a0                      	sub r26, r0
002224 09b1                      	sbc r27, r1
002225 93a0 0a8c                 	sts TCB0_CCMPL, r26
002227 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
002229 91a0 2854                 	lds r26, pulse1_fx_7xy_speed
00222b 15a2                      	cp r26, zero
00222c f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00222d 91b0 2855                 	lds r27, pulse1_fx_7xy_depth
00222f 91c0 2856                 	lds r28, pulse1_fx_7xy_phase
002231 0fca                      	add r28, r26 //increase the phase by the speed
002232 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002233 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002234 e0c0                      	ldi r28, 0x00
002235 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
002236 93c0 2856                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
002238 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002239 ffc4                      	sbrs r28, 4
00223a c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
00223b c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
00223c 70cf                      	andi r28, 0x0F //mask for values 0-15
00223d c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
00223e 6fc0                      	ori r28, 0xF0
00223f 95c0                      	com r28 //invert values 0-15
002240 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002241 95b2                      	swap r27 //multiply depth by 16
002242 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002243 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002244 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002245 0fec                      	add ZL, r28 //offset the table by the depth+phase
002246 1df2                      	adc ZH, zero
002247 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002248 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002249 93c0 2857                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
00224b 91b0 2858                 	lds r27, pulse1_fx_Axy
00224d 15b2                      	cp r27, zero
00224e f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00224f 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
002251 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
002253 2fda                      	mov r29, r26 //copy fractional volume into r29
002254 2fec                      	mov r30, r28 //copy the pulse1_param into r30
002255 95e2                      	swap r30
002256 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002257 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002258 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002259 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
00225a 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
00225b fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
00225c c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
00225d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00225e f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00225f efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002260 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
002261 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002262 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002263 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
002264 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
002266 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002267 95a2                      	swap r26
002268 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002269 2bca                      	or r28, r26 //store the new volume back into pulse1_param
00226a 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
00226c 91e0 285c                 	lds ZL, pulse1_fx_Qxy_target
00226e 91f0 285d                 	lds ZH, pulse1_fx_Qxy_target+1
002270 9630                      	adiw Z, 0
002271 f199                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002272 91a0 2860                 	lds r26, pulse1_fx_Qxy_total_offset
002274 91b0 2861                 	lds r27, pulse1_fx_Qxy_total_offset+1
002276 91c0 0a8c                 	lds r28, TCB0_CCMPL
002278 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
00227a 1bec                      	sub ZL, r28 //calculate the difference to the target
00227b 0bfd                      	sbc ZH, r29
00227c f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
00227d f0e8                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
00227e 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
00227f 0bbf                      	sbc r27, ZH
                                 
002280 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002281 937f                      	push r23
002282 9160 285b                 	lds r22, pulse1_fx_Pxx
002284 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002285 9f67                      	mul r22, r23
002286 917f                      	pop r23
002287 916f                      	pop r22
002288 9416                      	lsr r1 //shift out the fractional bits
002289 9407                      	ror r0
00228a 9416                      	lsr r1
00228b 9407                      	ror r0
00228c 9416                      	lsr r1
00228d 9407                      	ror r0
00228e 9416                      	lsr r1
00228f 9407                      	ror r0
                                 
002290 0da0                      	add r26, r0
002291 1db2                      	adc r27, zero
                                 
002292 93a0 2860                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
002294 93b0 2861                 	sts pulse1_fx_Qxy_total_offset+1, r27
002296 9220 285c                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002298 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
00229a c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
00229b 91c0 285e                 	lds r28, pulse1_fx_Qxy_speed
00229d 91d0 285f                 	lds r29, pulse1_fx_Qxy_speed+1
00229f 0fac                      	add r26, r28 //increase the total offset by the speed
0022a0 1fbd                      	adc r27, r29
0022a1 93a0 2860                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0022a3 93b0 2861                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0022a5 91e0 2862                 	lds ZL, pulse1_fx_Rxy_target
0022a7 91f0 2863                 	lds ZH, pulse1_fx_Rxy_target+1
0022a9 9630                      	adiw Z, 0
0022aa f199                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0022ab 91a0 2866                 	lds r26, pulse1_fx_Rxy_total_offset
0022ad 91b0 2867                 	lds r27, pulse1_fx_Rxy_total_offset+1
0022af 91c0 0a8c                 	lds r28, TCB0_CCMPL
0022b1 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0022b3 1bce                      	sub r28, ZL //calculate the difference to the target
0022b4 0bdf                      	sbc r29, ZH
0022b5 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0022b6 f0e8                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0022b7 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0022b8 0bbd                      	sbc r27, r29
                                 
0022b9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022ba 937f                      	push r23
0022bb 9160 285b                 	lds r22, pulse1_fx_Pxx
0022bd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022be 9f67                      	mul r22, r23
0022bf 917f                      	pop r23
0022c0 916f                      	pop r22
0022c1 9416                      	lsr r1 //shift out the fractional bits
0022c2 9407                      	ror r0
0022c3 9416                      	lsr r1
0022c4 9407                      	ror r0
0022c5 9416                      	lsr r1
0022c6 9407                      	ror r0
0022c7 9416                      	lsr r1
0022c8 9407                      	ror r0
                                 
0022c9 0da0                      	add r26, r0
0022ca 1db2                      	adc r27, zero
                                 
0022cb 93a0 2866                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0022cd 93b0 2867                 	sts pulse1_fx_Rxy_total_offset+1, r27
0022cf 9220 2862                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0022d1 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
0022d3 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0022d4 91c0 2864                 	lds r28, pulse1_fx_Rxy_speed
0022d6 91d0 2865                 	lds r29, pulse1_fx_Rxy_speed+1
0022d8 0fac                      	add r26, r28 //increase the total offset by the speed
0022d9 1fbd                      	adc r27, r29
0022da 93a0 2866                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0022dc 93b0 2867                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
0022de 91e0 2870                 	lds ZL, pulse2_volume_macro
0022e0 91f0 2871                 	lds ZH, pulse2_volume_macro+1
0022e2 9630                      	adiw Z, 0
0022e3 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
0022e4 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0022e5 1fff                      	rol ZH
0022e6 91a0 2872                 	lds r26, pulse2_volume_macro_offset
0022e8 0fea                      	add ZL, r26
0022e9 1df2                      	adc ZH, zero
                                 
0022ea 91b0 2874                 	lds r27, pulse2_volume_macro_release
0022ec 17ba                      	cp r27, r26
0022ed f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
0022ee 91a0 2873                 	lds r26, pulse2_volume_macro_loop
0022f0 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0022f1 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0022f2 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
0022f3 95a3                      	inc r26 //increment the macro offset
0022f4 93a0 2872                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
0022f6 91b4                      	lpm r27, Z //load volume data into r27
0022f7 3fbf                      	cpi r27, 0xFF //check for macro end flag
0022f8 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
0022f9 91b0 2874                 	lds r27, pulse2_volume_macro_release
0022fb 3fbf                      	cpi r27, 0xFF
0022fc f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
0022fd 91b0 2873                 	lds r27, pulse2_volume_macro_loop //load the loop index
0022ff 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
002301 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
002302 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002303 93a0 2872                 	sts pulse2_volume_macro_offset, r26
002305 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
002306 ece0                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002307 e5f2                      	ldi ZH, HIGH(volumes << 1)
002308 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002309 0feb                      	add ZL, r27 //add offset to the table
00230a 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
00230b 91b0 2808                 	lds r27, pulse2_param //load main volume
00230d 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00230e 91a0 28a4                 	lds r26, pulse2_fx_7xy_value
002310 30a0                      	cpi r26, 0x00
002311 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
002312 0feb                      	add ZL, r27 //offset the volume table by the main volume
002313 1df2                      	adc ZH, zero
002314 91b4                      	lpm r27, Z
002315 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002317 c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
002318 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
00231a 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00231b 91a0 28a4                 	lds r26, pulse2_fx_7xy_value
00231d 30a0                      	cpi r26, 0x00
00231e f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
00231f 93b0 280e                 	sts pulse2_output_volume, r27
002321 c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
002322 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002323 f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002324 f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002325 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002326 0feb                      	add ZL, r27 //offset the volume table by the main volume
002327 1df2                      	adc ZH, zero
002328 91b4                      	lpm r27, Z
002329 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00232b c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
00232c e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00232d 0feb                      	add ZL, r27 //offset the volume table by the main volume
00232e 1df2                      	adc ZH, zero
00232f 91b4                      	lpm r27, Z
002330 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002332 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
002333 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002334 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002335 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002336 93b0 280e                 	sts pulse2_output_volume, r27
002338 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002339 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00233a 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00233c 91e0 2875                 	lds ZL, pulse2_arpeggio_macro
00233e 91f0 2876                 	lds ZH, pulse2_arpeggio_macro+1
002340 9630                      	adiw Z, 0
002341 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002342 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002343 1fff                      	rol ZH
002344 91a0 2877                 	lds r26, pulse2_arpeggio_macro_offset
002346 0fea                      	add ZL, r26
002347 1df2                      	adc ZH, zero
                                 
002348 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
00234a 17ba                      	cp r27, r26
00234b f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00234c 91a0 2878                 	lds r26, pulse2_arpeggio_macro_loop
00234e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00234f f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002350 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
002351 95a3                      	inc r26 //increment the macro offset
002352 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
002354 91b4                      	lpm r27, Z //load arpeggio data into r27
002355 38b0                      	cpi r27, 0x80 //check for macro end flag
002356 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
002357 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
002358 50a1                      	subi r26, 1 //keep the offset at the end flag
002359 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
00235b 91b0 287a                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00235d 30b1                      	cpi r27, 0x01
00235e f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
00235f 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
002361 3fbf                      	cpi r27, 0xFF
002362 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
002363 91b0 2878                 	lds r27, pulse2_arpeggio_macro_loop
002365 3fbf                      	cpi r27, 0xFF
002366 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002367 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002368 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
00236a 3fbf                      	cpi r27, 0xFF
00236b f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
00236c 91b0 2878                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
00236e 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00236f f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
002370 91c0 288c                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002372 91d0 288d                 	lds r29, pulse2_fx_0xy_sequence+1
002374 9620                      	adiw r29:r28, 0
002375 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002376 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002377 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002379 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
00237a 93b0 2877                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
00237c cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
00237d 91c0 288c                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
00237f 91d0 288d                 	lds r29, pulse2_fx_0xy_sequence+1
002381 9620                      	adiw r29:r28, 0 //check for 0xy effect
002382 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
002383 95d6                      	lsr r29
002384 95c7                      	ror r28
002385 95d7                      	ror r29
002386 95c7                      	ror r28
002387 95d7                      	ror r29
002388 95c7                      	ror r28
002389 95d7                      	ror r29
00238a 95c7                      	ror r28
00238b 95d7                      	ror r29
00238c 95d2                      	swap r29
                                 
00238d 93c0 288c                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
00238f 93d0 288d                 	sts pulse2_fx_0xy_sequence+1, r29
002391 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002392 91a0 280f                 	lds r26, pulse2_note //load the current note index
002394 0fac                      	add r26, r28 //add the note offset
002395 c02c                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002396 91a0 280f                 	lds r26, pulse2_note //load the current note index
002398 c029                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
002399 9220 287b                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00239b 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero
00239d 91a0 287a                 	lds r26, pulse2_arpeggio_macro_mode
00239f 30a1                      	cpi r26, 0x01 //absolute mode
0023a0 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0023a1 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0023a2 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0023a3 91a0 280f                 	lds r26, pulse2_note //load the current note index
0023a5 0fab                      	add r26, r27 //offset the note with the arpeggio data
0023a6 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0023a7 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0023a8 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0023a9 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0023aa e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0023ab c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0023ac fda7                      	sbrc r26, 7 //check if result is negative
0023ad e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0023ae c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0023af 2fab                      	mov r26, r27 //move the arpeggio data into r26
0023b0 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0023b1 91a0 280f                 	lds r26, pulse2_note //load the current note index
0023b3 0fab                      	add r26, r27 //offset the note with the arpeggio data
0023b4 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0023b5 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0023b6 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0023b8 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0023b9 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0023ba e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0023bb 93a0 280f                 	sts pulse2_note, r26
0023bd c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0023be fda7                      	sbrc r26, 7 //check if result is negative
0023bf e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0023c0 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
0023c2 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
0023c3 e0f0                      	ldi ZH, HIGH(note_table << 1)
0023c4 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0023c5 0fea                      	add ZL, r26 //add offset
0023c6 1df2                      	adc ZH, zero
0023c7 91a5                      	lpm r26, Z+ //load bytes
0023c8 91b4                      	lpm r27, Z
0023c9 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
0023cb 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
0023cd 93a0 2898                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0023cf 93b0 2899                 	sts pulse2_fx_3xx_target+1, r27
0023d1 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel1_pitch:
0023d2 91e0 287c                 	lds ZL, pulse2_pitch_macro
0023d4 91f0 287d                 	lds ZH, pulse2_pitch_macro+1
0023d6 9630                      	adiw Z, 0
0023d7 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
0023d8 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
0023d9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0023da 1fff                      	rol ZH
0023db 91a0 287e                 	lds r26, pulse2_pitch_macro_offset
0023dd 0fea                      	add ZL, r26
0023de 1df2                      	adc ZH, zero
                                 
0023df 91b0 2880                 	lds r27, pulse2_pitch_macro_release
0023e1 17ba                      	cp r27, r26
0023e2 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
0023e3 91a0 287f                 	lds r26, pulse2_pitch_macro_loop
0023e5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0023e6 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0023e7 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
0023e8 95a3                      	inc r26 //increment the macro offset
0023e9 93a0 287e                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
0023eb 91b4                      	lpm r27, Z //load pitch data into r27
0023ec 38b0                      	cpi r27, 0x80 //check for macro end flag
0023ed f489                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
0023ee 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0023ef 93a0 287e                 	sts pulse2_pitch_macro_offset, r26
0023f1 91b0 2880                 	lds r27, pulse2_pitch_macro_release
0023f3 3fbf                      	cpi r27, 0xFF
0023f4 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
0023f5 91b0 287f                 	lds r27, pulse2_pitch_macro_loop //load the loop index
0023f7 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0023f8 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0023f9 93b0 287e                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
0023fb cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
0023fc 91b0 287b                 	lds r27, pulse2_total_pitch_offset
0023fe c005                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
0023ff 91a0 287b                 	lds r26, pulse2_total_pitch_offset //load the total pitch offset to change
002401 0fba                      	add r27, r26
002402 93b0 287b                 	sts pulse2_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
002404 91a0 28a8                 	lds r26, pulse2_fx_Pxx
002406 0fba                      	add r27, r26
                                 
002407 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002408 937f                      	push r23
002409 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00240a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00240b 0367                      	mulsu r22, r23
00240c 917f                      	pop r23
00240d 916f                      	pop r22
                                 
00240e 9416                      	lsr r1 //shift out the fractional bits
00240f 9407                      	ror r0
002410 9416                      	lsr r1
002411 9407                      	ror r0
002412 9416                      	lsr r1
002413 9407                      	ror r0
002414 9416                      	lsr r1
002415 9407                      	ror r0
002416 fe13                      	sbrs r1, 3 //check if result was a negative number
002417 c002                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002418 efb0                      	ldi r27, 0xF0
002419 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
00241a 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
00241c 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
00241e 0da0                      	add r26, r0 //offset the timer values
00241f 1db1                      	adc r27, r1
                                 	
002420 91c0 2890                 	lds r28, pulse2_fx_1xx_total
002422 91d0 2891                 	lds r29, pulse2_fx_1xx_total+1
002424 1bac                      	sub r26, r28
002425 0bbd                      	sbc r27, r29
002426 91c0 2894                 	lds r28, pulse2_fx_2xx_total
002428 91d0 2895                 	lds r29, pulse2_fx_2xx_total+1
00242a 0fac                      	add r26, r28
00242b 1fbd                      	adc r27, r29
00242c 91c0 28ad                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00242e 91d0 28ae                 	lds r29, pulse2_fx_Qxy_total_offset+1
002430 1bac                      	sub r26, r28
002431 0bbd                      	sbc r27, r29
002432 91c0 28b3                 	lds r28, pulse2_fx_Rxy_total_offset
002434 91d0 28b4                 	lds r29, pulse2_fx_Rxy_total_offset+1
002436 0fac                      	add r26, r28
002437 1fbd                      	adc r27, r29
                                 
002438 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
00243a 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
00243c 91e0 2882                 	lds ZL, pulse2_hi_pitch_macro
00243e 91f0 2883                 	lds ZH, pulse2_hi_pitch_macro+1
002440 9630                      	adiw Z, 0
002441 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002442 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002443 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002444 1fff                      	rol ZH
002445 91a0 2884                 	lds r26, pulse2_hi_pitch_macro_offset
002447 0fea                      	add ZL, r26
002448 1df2                      	adc ZH, zero
                                 
002449 91b0 2886                 	lds r27, pulse2_hi_pitch_macro_release
00244b 17ba                      	cp r27, r26
00244c f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00244d 91a0 2885                 	lds r26, pulse2_hi_pitch_macro_loop
00244f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002450 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002451 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002452 95a3                      	inc r26 //increment the macro offset
002453 93a0 2884                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002455 91b4                      	lpm r27, Z //load hi pitch data into r27
002456 38b0                      	cpi r27, 0x80 //check for macro end flag
002457 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002458 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002459 93a0 2884                 	sts pulse2_hi_pitch_macro_offset, r26
00245b 91b0 2886                 	lds r27, pulse2_hi_pitch_macro_release
00245d 3fbf                      	cpi r27, 0xFF
00245e f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
00245f 91b0 2885                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002461 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002462 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002463 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002465 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002466 91b0 2881                 	lds r27, pulse2_total_hi_pitch_offset
002468 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002469 91a0 2881                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
00246b 0fba                      	add r27, r26
00246c 93b0 2881                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
00246e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00246f 937f                      	push r23
002470 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002471 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002472 0367                      	mulsu r22, r23
002473 917f                      	pop r23
002474 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002475 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002477 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002479 0da0                      	add r26, r0 //offset the timer values
00247a 1db1                      	adc r27, r1
00247b 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
00247d 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
00247f 91e0 2887                 	lds ZL, pulse2_duty_macro
002481 91f0 2888                 	lds ZH, pulse2_duty_macro+1
002483 9630                      	adiw Z, 0
002484 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002485 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002486 1fff                      	rol ZH
002487 91a0 2889                 	lds r26, pulse2_duty_macro_offset
002489 0fea                      	add ZL, r26
00248a 1df2                      	adc ZH, zero
                                 
00248b 91b0 288b                 	lds r27, pulse2_duty_macro_release
00248d 17ba                      	cp r27, r26
00248e f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
00248f 91a0 288a                 	lds r26, pulse2_duty_macro_loop
002491 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002492 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002493 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002494 95a3                      	inc r26 //increment the macro offset
002495 93a0 2889                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002497 91b4                      	lpm r27, Z //load pitch data into r27
002498 3fbf                      	cpi r27, 0xFF //check for macro end flag
002499 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
00249a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00249b 93a0 2889                 	sts pulse2_duty_macro_offset, r26
00249d 91b0 288b                 	lds r27, pulse2_duty_macro_release
00249f 3fbf                      	cpi r27, 0xFF
0024a0 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
0024a1 91b0 288a                 	lds r27, pulse2_duty_macro_loop //load the loop index
0024a3 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0024a4 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0024a5 93b0 2889                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
0024a7 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
0024a8 e2e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0024a9 e5f2                      	ldi ZH, HIGH(sequences << 1)
0024aa 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0024ab 1df2                      	adc ZH, zero
                                 
0024ac 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
0024ad 95b7                      	ror r27
0024ae 95b7                      	ror r27
0024af 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
0024b1 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
0024b2 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0024b3 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0024b4 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
0024b5 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
0024b6 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
0024b7 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0024b8 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0024b9 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
0024bb 91e0 288e                 	lds ZL, pulse2_fx_1xx
0024bd 91f0 288f                 	lds ZH, pulse2_fx_1xx+1
0024bf 9630                      	adiw Z, 0
0024c0 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
0024c1 91a0 2890                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
0024c3 91b0 2891                 	lds r27, pulse2_fx_1xx_total+1
0024c5 0fae                      	add r26, ZL //increase the total offset by the rate
0024c6 1fbf                      	adc r27, ZH
0024c7 93a0 2890                 	sts pulse2_fx_1xx_total, r26
0024c9 93b0 2891                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
0024cb 91e0 2892                 	lds ZL, pulse2_fx_2xx
0024cd 91f0 2893                 	lds ZH, pulse2_fx_2xx+1
0024cf 9630                      	adiw Z, 0
0024d0 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
0024d1 91a0 2894                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
0024d3 91b0 2895                 	lds r27, pulse2_fx_2xx_total+1
0024d5 0fae                      	add r26, ZL //increase the total offset by the rate
0024d6 1fbf                      	adc r27, ZH
0024d7 93a0 2894                 	sts pulse2_fx_2xx_total, r26
0024d9 93b0 2895                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
0024db 91e0 289a                 	lds ZL, pulse2_fx_3xx_speed
0024dd 91f0 289b                 	lds ZH, pulse2_fx_3xx_speed+1
0024df 9630                      	adiw Z, 0
0024e0 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
0024e1 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
0024e2 91a0 2896                 	lds r26, pulse2_fx_3xx_start
0024e4 91b0 2897                 	lds r27, pulse2_fx_3xx_start+1
0024e6 9610                      	adiw r26:r27, 0
0024e7 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
0024e8 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
0024e9 91c0 2898                 	lds r28, pulse2_fx_3xx_target
0024eb 91d0 2899                 	lds r29, pulse2_fx_3xx_target+1
                                 
0024ed 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0024ee 07bd                      	cpc r27, r29
0024ef f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
0024f0 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0024f1 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
0024f2 9220 2896                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0024f4 9220 2897                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0024f6 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
0024f7 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0024f8 0bdb                      	sbc r29, r27
0024f9 91a0 289c                 	lds r26, pulse2_fx_3xx_total_offset
0024fb 91b0 289d                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
0024fd 0fae                      	add r26, ZL //add the speed to the total offset
0024fe 1fbf                      	adc r27, ZH
0024ff 1bca                      	sub r28, r26 //invert the total difference with the total offset
002500 0bdb                      	sbc r29, r27
002501 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002502 93a0 289c                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002504 93b0 289d                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002506 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002508 91b0 0a9d                 	lds r27, TCB1_CCMPH
00250a 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00250b 0bbd                      	sbc r27, r29
00250c 93a0 0a9c                 	sts TCB1_CCMPL, r26
00250e 93b0 0a9d                 	sts TCB1_CCMPH, r27
002510 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002511 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002512 0bbd                      	sbc r27, r29
002513 91c0 289c                 	lds r28, pulse2_fx_3xx_total_offset
002515 91d0 289d                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002517 0fce                      	add r28, ZL //add the speed to the total offset
002518 1fdf                      	adc r29, ZH
002519 1bac                      	sub r26, r28 //invert the total difference with the total offset
00251a 0bbd                      	sbc r27, r29
00251b f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00251c 93c0 289c                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
00251e 93d0 289d                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002520 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002522 91d0 0a9d                 	lds r29, TCB1_CCMPH
002524 0fca                      	add r28, r26 //offset the current timer period with the total offset
002525 1fdb                      	adc r29, r27
002526 93c0 0a9c                 	sts TCB1_CCMPL, r28
002528 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
00252a 91a0 289e                 	lds r26, pulse2_fx_4xy_speed
00252c 15a2                      	cp r26, zero
00252d f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
00252e c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
00252f 91b0 289f                 	lds r27, pulse2_fx_4xy_depth
002531 91c0 28a0                 	lds r28, pulse2_fx_4xy_phase
002533 0fca                      	add r28, r26 //increase the phase by the speed
002534 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002535 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002536 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002537 93c0 28a0                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002539 31c0                      	cpi r28, 16
00253a f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
00253b 32c0                      	cpi r28, 32
00253c f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
00253d 33c0                      	cpi r28, 48
00253e f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
00253f c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002540 70cf                      	andi r28, 0x0F //mask for values 0-15
002541 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002542 6fc0                      	ori r28, 0xF0
002543 95c0                      	com r28 //invert values 0-15
002544 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002545 70cf                      	andi r28, 0x0F //mask for values 0-15
002546 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002547 6fc0                      	ori r28, 0xF0
002548 95c0                      	com r28 //invert values 0-15
002549 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
00254a 95b2                      	swap r27 //multiply depth by 16
00254b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00254c e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00254d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00254e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00254f 1df2                      	adc ZH, zero
002550 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002551 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002552 937f                      	push r23
002553 2f6c                      	mov r22, r28 //store the vibrato value into r22
002554 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002555 9f67                      	mul r22, r23
002556 917f                      	pop r23
002557 916f                      	pop r22
                                 
002558 9416                      	lsr r1 //shift out the fractional bits
002559 9407                      	ror r0
00255a 9416                      	lsr r1
00255b 9407                      	ror r0
00255c 9416                      	lsr r1
00255d 9407                      	ror r0
00255e 9416                      	lsr r1
00255f 9407                      	ror r0
                                 	
002560 91a0 0a9c                 	lds r26, TCB1_CCMPL
002562 91b0 0a9d                 	lds r27, TCB1_CCMPH
002564 0da0                      	add r26, r0
002565 1db1                      	adc r27, r1
002566 93a0 0a9c                 	sts TCB1_CCMPL, r26
002568 93b0 0a9d                 	sts TCB1_CCMPH, r27
00256a c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
00256b 95b2                      	swap r27 //multiply depth by 16
00256c 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00256d e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00256e e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00256f 0fec                      	add ZL, r28 //offset the table by the depth+phase
002570 1df2                      	adc ZH, zero
002571 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002572 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002573 937f                      	push r23
002574 2f6c                      	mov r22, r28 //store the vibrato value into r22
002575 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002576 9f67                      	mul r22, r23
002577 917f                      	pop r23
002578 916f                      	pop r22
                                 
002579 9416                      	lsr r1 //shift out the fractional bits
00257a 9407                      	ror r0
00257b 9416                      	lsr r1
00257c 9407                      	ror r0
00257d 9416                      	lsr r1
00257e 9407                      	ror r0
00257f 9416                      	lsr r1
002580 9407                      	ror r0
                                 
002581 91a0 0a9c                 	lds r26, TCB1_CCMPL
002583 91b0 0a9d                 	lds r27, TCB1_CCMPH
002585 19a0                      	sub r26, r0
002586 09b1                      	sbc r27, r1
002587 93a0 0a9c                 	sts TCB1_CCMPL, r26
002589 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
00258b 91a0 28a1                 	lds r26, pulse2_fx_7xy_speed
00258d 15a2                      	cp r26, zero
00258e f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00258f 91b0 28a2                 	lds r27, pulse2_fx_7xy_depth
002591 91c0 28a3                 	lds r28, pulse2_fx_7xy_phase
002593 0fca                      	add r28, r26 //increase the phase by the speed
002594 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002595 f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002596 e0c0                      	ldi r28, 0x00
002597 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002598 93c0 28a3                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
00259a 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
00259b ffc4                      	sbrs r28, 4
00259c c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
00259d c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
00259e 70cf                      	andi r28, 0x0F //mask for values 0-15
00259f c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
0025a0 6fc0                      	ori r28, 0xF0
0025a1 95c0                      	com r28 //invert values 0-15
0025a2 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
0025a3 95b2                      	swap r27 //multiply depth by 16
0025a4 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0025a5 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0025a6 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0025a7 0fec                      	add ZL, r28 //offset the table by the depth+phase
0025a8 1df2                      	adc ZH, zero
0025a9 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0025aa 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0025ab 93c0 28a4                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
0025ad 91b0 28a5                 	lds r27, pulse2_fx_Axy
0025af 15b2                      	cp r27, zero
0025b0 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0025b1 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
0025b3 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
0025b5 2fda                      	mov r29, r26 //copy fractional volume into r29
0025b6 2fec                      	mov r30, r28 //copy the pulse2_param into r30
0025b7 95e2                      	swap r30
0025b8 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0025b9 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0025ba 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0025bb f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
0025bc 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
0025bd fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0025be c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
0025bf 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0025c0 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0025c1 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0025c2 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
0025c3 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0025c4 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0025c5 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
0025c6 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
0025c8 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0025c9 95a2                      	swap r26
0025ca 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0025cb 2bca                      	or r28, r26 //store the new volume back into pulse2_param
0025cc 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
0025ce 91e0 28a9                 	lds ZL, pulse2_fx_Qxy_target
0025d0 91f0 28aa                 	lds ZH, pulse2_fx_Qxy_target+1
0025d2 9630                      	adiw Z, 0
0025d3 f199                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0025d4 91a0 28ad                 	lds r26, pulse2_fx_Qxy_total_offset
0025d6 91b0 28ae                 	lds r27, pulse2_fx_Qxy_total_offset+1
0025d8 91c0 0a9c                 	lds r28, TCB1_CCMPL
0025da 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
0025dc 1bec                      	sub ZL, r28 //calculate the difference to the target
0025dd 0bfd                      	sbc ZH, r29
0025de f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
0025df f0e8                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
0025e0 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0025e1 0bbf                      	sbc r27, ZH
                                 
0025e2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025e3 937f                      	push r23
0025e4 9160 28a8                 	lds r22, pulse2_fx_Pxx
0025e6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025e7 9f67                      	mul r22, r23
0025e8 917f                      	pop r23
0025e9 916f                      	pop r22
0025ea 9416                      	lsr r1 //shift out the fractional bits
0025eb 9407                      	ror r0
0025ec 9416                      	lsr r1
0025ed 9407                      	ror r0
0025ee 9416                      	lsr r1
0025ef 9407                      	ror r0
0025f0 9416                      	lsr r1
0025f1 9407                      	ror r0
                                 
0025f2 0da0                      	add r26, r0
0025f3 1db2                      	adc r27, zero
                                 
0025f4 93a0 28ad                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
0025f6 93b0 28ae                 	sts pulse2_fx_Qxy_total_offset+1, r27
0025f8 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0025fa 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
0025fc c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
0025fd 91c0 28ab                 	lds r28, pulse2_fx_Qxy_speed
0025ff 91d0 28ac                 	lds r29, pulse2_fx_Qxy_speed+1
002601 0fac                      	add r26, r28 //increase the total offset by the speed
002602 1fbd                      	adc r27, r29
002603 93a0 28ad                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002605 93b0 28ae                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002607 91e0 28af                 	lds ZL, pulse2_fx_Rxy_target
002609 91f0 28b0                 	lds ZH, pulse2_fx_Rxy_target+1
00260b 9630                      	adiw Z, 0
00260c f199                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
00260d 91a0 28b3                 	lds r26, pulse2_fx_Rxy_total_offset
00260f 91b0 28b4                 	lds r27, pulse2_fx_Rxy_total_offset+1
002611 91c0 0a9c                 	lds r28, TCB1_CCMPL
002613 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002615 1bce                      	sub r28, ZL //calculate the difference to the target
002616 0bdf                      	sbc r29, ZH
002617 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002618 f0e8                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002619 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
00261a 0bbd                      	sbc r27, r29
                                 
00261b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00261c 937f                      	push r23
00261d 9160 28a8                 	lds r22, pulse2_fx_Pxx
00261f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002620 9f67                      	mul r22, r23
002621 917f                      	pop r23
002622 916f                      	pop r22
002623 9416                      	lsr r1 //shift out the fractional bits
002624 9407                      	ror r0
002625 9416                      	lsr r1
002626 9407                      	ror r0
002627 9416                      	lsr r1
002628 9407                      	ror r0
002629 9416                      	lsr r1
00262a 9407                      	ror r0
                                 
00262b 0da0                      	add r26, r0
00262c 1db2                      	adc r27, zero
                                 
00262d 93a0 28b3                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
00262f 93b0 28b4                 	sts pulse2_fx_Rxy_total_offset+1, r27
002631 9220 28af                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002633 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
002635 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002636 91c0 28b1                 	lds r28, pulse2_fx_Rxy_speed
002638 91d0 28b2                 	lds r29, pulse2_fx_Rxy_speed+1
00263a 0fac                      	add r26, r28 //increase the total offset by the speed
00263b 1fbd                      	adc r27, r29
00263c 93a0 28b3                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
00263e 93b0 28b4                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002640 91e0 28bd                 	lds ZL, triangle_volume_macro
002642 91f0 28be                 	lds ZH, triangle_volume_macro+1
002644 9630                      	adiw Z, 0
002645 f179                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002646 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002647 1fff                      	rol ZH
002648 91a0 28bf                 	lds r26, triangle_volume_macro_offset
00264a 0fea                      	add ZL, r26
00264b 1df2                      	adc ZH, zero
                                 
00264c 91b0 28c1                 	lds r27, triangle_volume_macro_release
00264e 17ba                      	cp r27, r26
00264f f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002650 91a0 28c0                 	lds r26, triangle_volume_macro_loop
002652 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002653 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002654 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002655 95a3                      	inc r26 //increment the macro offset
002656 93a0 28bf                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002658 91b4                      	lpm r27, Z //load volume data into r27
002659 3fbf                      	cpi r27, 0xFF //check for macro end flag
00265a f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
00265b 91b0 28c1                 	lds r27, triangle_volume_macro_release
00265d 3fbf                      	cpi r27, 0xFF
00265e f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
00265f 91b0 28c0                 	lds r27, triangle_volume_macro_loop //load the loop index
002661 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002663 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002664 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002665 93a0 28bf                 	sts triangle_volume_macro_offset, r26
002667 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002668 15b2                      	cp r27, zero
002669 f021                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
00266a e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00266b 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00266d c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
00266e 9220 0aa5                 	sts TCB2_INTCTRL, zero
002670 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002672 9220 0aad                 	sts TCB2_CCMPH, zero
002674 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002675 91e0 28c2                 	lds ZL, triangle_arpeggio_macro
002677 91f0 28c3                 	lds ZH, triangle_arpeggio_macro+1
002679 9630                      	adiw Z, 0
00267a f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00267b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00267c 1fff                      	rol ZH
00267d 91a0 28c4                 	lds r26, triangle_arpeggio_macro_offset
00267f 0fea                      	add ZL, r26
002680 1df2                      	adc ZH, zero
                                 
002681 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
002683 17ba                      	cp r27, r26
002684 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002685 91a0 28c5                 	lds r26, triangle_arpeggio_macro_loop
002687 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002688 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002689 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
00268a 95a3                      	inc r26 //increment the macro offset
00268b 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
00268d 91b4                      	lpm r27, Z //load arpeggio data into r27
00268e 38b0                      	cpi r27, 0x80 //check for macro end flag
00268f f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002690 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002691 50a1                      	subi r26, 1 //keep the offset at the end flag
002692 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
002694 91b0 28c7                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002696 30b1                      	cpi r27, 0x01
002697 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002698 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
00269a 3fbf                      	cpi r27, 0xFF
00269b f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
00269c 91b0 28c5                 	lds r27, triangle_arpeggio_macro_loop
00269e 3fbf                      	cpi r27, 0xFF
00269f f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0026a0 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
0026a1 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
0026a3 3fbf                      	cpi r27, 0xFF
0026a4 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
0026a5 91b0 28c5                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
0026a7 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0026a8 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
0026a9 91c0 28d9                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
0026ab 91d0 28da                 	lds r29, triangle_fx_0xy_sequence+1
0026ad 9620                      	adiw r29:r28, 0
0026ae f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0026af 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0026b0 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
0026b2 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
0026b3 93b0 28c4                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
0026b5 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
0026b6 91c0 28d9                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
0026b8 91d0 28da                 	lds r29, triangle_fx_0xy_sequence+1
0026ba 9620                      	adiw r29:r28, 0 //check for 0xy effect
0026bb f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
0026bc 95d6                      	lsr r29
0026bd 95c7                      	ror r28
0026be 95d7                      	ror r29
0026bf 95c7                      	ror r28
0026c0 95d7                      	ror r29
0026c1 95c7                      	ror r28
0026c2 95d7                      	ror r29
0026c3 95c7                      	ror r28
0026c4 95d7                      	ror r29
0026c5 95d2                      	swap r29
                                 
0026c6 93c0 28d9                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
0026c8 93d0 28da                 	sts triangle_fx_0xy_sequence+1, r29
0026ca 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0026cb 91a0 2812                 	lds r26, triangle_note //load the current note index
0026cd 0fac                      	add r26, r28 //add the note offset
0026ce c02c                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0026cf 91a0 2812                 	lds r26, triangle_note //load the current note index
0026d1 c029                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
0026d2 9220 28c8                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0026d4 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero
0026d6 91a0 28c7                 	lds r26, triangle_arpeggio_macro_mode
0026d8 30a1                      	cpi r26, 0x01 //absolute mode
0026d9 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
0026da f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
0026db c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
0026dc 91a0 2812                 	lds r26, triangle_note //load the current note index
0026de 0fab                      	add r26, r27 //offset the note with the arpeggio data
0026df fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0026e0 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
0026e1 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0026e2 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
0026e3 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0026e4 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
0026e5 fda7                      	sbrc r26, 7 //check if result is negative
0026e6 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0026e7 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
0026e8 2fab                      	mov r26, r27 //move the arpeggio data into r26
0026e9 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
0026ea 91a0 2812                 	lds r26, triangle_note //load the current note index
0026ec 0fab                      	add r26, r27 //offset the note with the arpeggio data
0026ed fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0026ee c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
0026ef 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
0026f1 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0026f2 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
0026f3 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0026f4 93a0 2812                 	sts triangle_note, r26
0026f6 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
0026f7 fda7                      	sbrc r26, 7 //check if result is negative
0026f8 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0026f9 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
0026fb e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
0026fc e0f0                      	ldi ZH, HIGH(note_table << 1)
0026fd 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0026fe 0fea                      	add ZL, r26 //add offset
0026ff 1df2                      	adc ZH, zero
002700 91a5                      	lpm r26, Z+ //load bytes
002701 91b4                      	lpm r27, Z
002702 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002704 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002706 93a0 28e5                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002708 93b0 28e6                 	sts triangle_fx_3xx_target+1, r27
00270a c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel2_pitch:
00270b 91e0 28c9                 	lds ZL, triangle_pitch_macro
00270d 91f0 28ca                 	lds ZH, triangle_pitch_macro+1
00270f 9630                      	adiw Z, 0
002710 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002711 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002712 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002713 1fff                      	rol ZH
002714 91a0 28cb                 	lds r26, triangle_pitch_macro_offset
002716 0fea                      	add ZL, r26
002717 1df2                      	adc ZH, zero
                                 
002718 91b0 28cd                 	lds r27, triangle_pitch_macro_release
00271a 17ba                      	cp r27, r26
00271b f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
00271c 91a0 28cc                 	lds r26, triangle_pitch_macro_loop
00271e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00271f f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002720 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002721 95a3                      	inc r26 //increment the macro offset
002722 93a0 28cb                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002724 91b4                      	lpm r27, Z //load pitch data into r27
002725 38b0                      	cpi r27, 0x80 //check for macro end flag
002726 f489                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002727 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002728 93a0 28cb                 	sts triangle_pitch_macro_offset, r26
00272a 91b0 28cd                 	lds r27, triangle_pitch_macro_release
00272c 3fbf                      	cpi r27, 0xFF
00272d f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
00272e 91b0 28cc                 	lds r27, triangle_pitch_macro_loop //load the loop index
002730 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002731 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002732 93b0 28cb                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002734 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002735 91b0 28c8                 	lds r27, triangle_total_pitch_offset
002737 c005                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002738 91a0 28c8                 	lds r26, triangle_total_pitch_offset //load the total pitch offset to change
00273a 0fba                      	add r27, r26
00273b 93b0 28c8                 	sts triangle_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
00273d 91a0 28f0                 	lds r26, triangle_fx_Pxx
00273f 0fba                      	add r27, r26
                                 
002740 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002741 937f                      	push r23
002742 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002743 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002744 0367                      	mulsu r22, r23
002745 917f                      	pop r23
002746 916f                      	pop r22
                                 
002747 9416                      	lsr r1 //shift out the fractional bits
002748 9407                      	ror r0
002749 9416                      	lsr r1
00274a 9407                      	ror r0
00274b 9416                      	lsr r1
00274c 9407                      	ror r0
00274d 9416                      	lsr r1
00274e 9407                      	ror r0
00274f fe13                      	sbrs r1, 3 //check if result was a negative number
002750 c002                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002751 efb0                      	ldi r27, 0xF0
002752 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002753 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002755 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002757 0da0                      	add r26, r0 //offset the timer values
002758 1db1                      	adc r27, r1
                                 	
002759 91c0 28dd                 	lds r28, triangle_fx_1xx_total
00275b 91d0 28de                 	lds r29, triangle_fx_1xx_total+1
00275d 1bac                      	sub r26, r28
00275e 0bbd                      	sbc r27, r29
00275f 91c0 28e1                 	lds r28, triangle_fx_2xx_total
002761 91d0 28e2                 	lds r29, triangle_fx_2xx_total+1
002763 0fac                      	add r26, r28
002764 1fbd                      	adc r27, r29
002765 91c0 28f5                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002767 91d0 28f6                 	lds r29, triangle_fx_Qxy_total_offset+1
002769 1bac                      	sub r26, r28
00276a 0bbd                      	sbc r27, r29
00276b 91c0 28fb                 	lds r28, triangle_fx_Rxy_total_offset
00276d 91d0 28fc                 	lds r29, triangle_fx_Rxy_total_offset+1
00276f 0fac                      	add r26, r28
002770 1fbd                      	adc r27, r29
                                 
002771 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002773 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002775 91e0 28cf                 	lds ZL, triangle_hi_pitch_macro
002777 91f0 28d0                 	lds ZH, triangle_hi_pitch_macro+1
002779 9630                      	adiw Z, 0
00277a f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
00277b c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
00277c 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00277d 1fff                      	rol ZH
00277e 91a0 28d1                 	lds r26, triangle_hi_pitch_macro_offset
002780 0fea                      	add ZL, r26
002781 1df2                      	adc ZH, zero
                                 
002782 91b0 28d3                 	lds r27, triangle_hi_pitch_macro_release
002784 17ba                      	cp r27, r26
002785 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002786 91a0 28d2                 	lds r26, triangle_hi_pitch_macro_loop
002788 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002789 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00278a c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
00278b 95a3                      	inc r26 //increment the macro offset
00278c 93a0 28d1                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
00278e 91b4                      	lpm r27, Z //load hi pitch data into r27
00278f 38b0                      	cpi r27, 0x80 //check for macro end flag
002790 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002791 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002792 93a0 28d1                 	sts triangle_hi_pitch_macro_offset, r26
002794 91b0 28d3                 	lds r27, triangle_hi_pitch_macro_release
002796 3fbf                      	cpi r27, 0xFF
002797 f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002798 91b0 28d2                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
00279a 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00279b f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00279c 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
00279e cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
00279f 91b0 28ce                 	lds r27, triangle_total_hi_pitch_offset
0027a1 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
0027a2 91a0 28ce                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
0027a4 0fba                      	add r27, r26
0027a5 93b0 28ce                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
0027a7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0027a8 937f                      	push r23
0027a9 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0027aa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0027ab 0367                      	mulsu r22, r23
0027ac 917f                      	pop r23
0027ad 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
0027ae 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
0027b0 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
0027b2 0da0                      	add r26, r0 //offset the timer values
0027b3 1db1                      	adc r27, r1
0027b4 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
0027b6 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
0027b8 91e0 28db                 	lds ZL, triangle_fx_1xx
0027ba 91f0 28dc                 	lds ZH, triangle_fx_1xx+1
0027bc 9630                      	adiw Z, 0
0027bd f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
0027be 91a0 28dd                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
0027c0 91b0 28de                 	lds r27, triangle_fx_1xx_total+1
0027c2 0fae                      	add r26, ZL //increase the total offset by the rate
0027c3 1fbf                      	adc r27, ZH
0027c4 93a0 28dd                 	sts triangle_fx_1xx_total, r26
0027c6 93b0 28de                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
0027c8 91e0 28df                 	lds ZL, triangle_fx_2xx
0027ca 91f0 28e0                 	lds ZH, triangle_fx_2xx+1
0027cc 9630                      	adiw Z, 0
0027cd f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
0027ce 91a0 28e1                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
0027d0 91b0 28e2                 	lds r27, triangle_fx_2xx_total+1
0027d2 0fae                      	add r26, ZL //increase the total offset by the rate
0027d3 1fbf                      	adc r27, ZH
0027d4 93a0 28e1                 	sts triangle_fx_2xx_total, r26
0027d6 93b0 28e2                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
0027d8 91e0 28e7                 	lds ZL, triangle_fx_3xx_speed
0027da 91f0 28e8                 	lds ZH, triangle_fx_3xx_speed+1
0027dc 9630                      	adiw Z, 0
0027dd f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
0027de c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
0027df 91a0 28e3                 	lds r26, triangle_fx_3xx_start
0027e1 91b0 28e4                 	lds r27, triangle_fx_3xx_start+1
0027e3 9610                      	adiw r26:r27, 0
0027e4 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
0027e5 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
0027e6 91c0 28e5                 	lds r28, triangle_fx_3xx_target
0027e8 91d0 28e6                 	lds r29, triangle_fx_3xx_target+1
                                 
0027ea 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0027eb 07bd                      	cpc r27, r29
0027ec f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
0027ed f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0027ee c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
0027ef 9220 28e3                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0027f1 9220 28e4                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0027f3 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
0027f4 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0027f5 0bdb                      	sbc r29, r27
0027f6 91a0 28e9                 	lds r26, triangle_fx_3xx_total_offset
0027f8 91b0 28ea                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
0027fa 0fae                      	add r26, ZL //add the speed to the total offset
0027fb 1fbf                      	adc r27, ZH
0027fc 1bca                      	sub r28, r26 //invert the total difference with the total offset
0027fd 0bdb                      	sbc r29, r27
0027fe f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0027ff 93a0 28e9                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002801 93b0 28ea                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002803 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002805 91b0 0aad                 	lds r27, TCB2_CCMPH
002807 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002808 0bbd                      	sbc r27, r29
002809 93a0 0aac                 	sts TCB2_CCMPL, r26
00280b 93b0 0aad                 	sts TCB2_CCMPH, r27
00280d c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
00280e 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00280f 0bbd                      	sbc r27, r29
002810 91c0 28e9                 	lds r28, triangle_fx_3xx_total_offset
002812 91d0 28ea                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002814 0fce                      	add r28, ZL //add the speed to the total offset
002815 1fdf                      	adc r29, ZH
002816 1bac                      	sub r26, r28 //invert the total difference with the total offset
002817 0bbd                      	sbc r27, r29
002818 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002819 93c0 28e9                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
00281b 93d0 28ea                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
00281d 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
00281f 91d0 0aad                 	lds r29, TCB2_CCMPH
002821 0fca                      	add r28, r26 //offset the current timer period with the total offset
002822 1fdb                      	adc r29, r27
002823 93c0 0aac                 	sts TCB2_CCMPL, r28
002825 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002827 91a0 28eb                 	lds r26, triangle_fx_4xy_speed
002829 15a2                      	cp r26, zero
00282a f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
00282b c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
00282c 91b0 28ec                 	lds r27, triangle_fx_4xy_depth
00282e 91c0 28ed                 	lds r28, triangle_fx_4xy_phase
002830 0fca                      	add r28, r26 //increase the phase by the speed
002831 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002832 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002833 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002834 93c0 28ed                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002836 31c0                      	cpi r28, 16
002837 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002838 32c0                      	cpi r28, 32
002839 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
00283a 33c0                      	cpi r28, 48
00283b f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
00283c c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
00283d 70cf                      	andi r28, 0x0F //mask for values 0-15
00283e c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
00283f 6fc0                      	ori r28, 0xF0
002840 95c0                      	com r28 //invert values 0-15
002841 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002842 70cf                      	andi r28, 0x0F //mask for values 0-15
002843 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002844 6fc0                      	ori r28, 0xF0
002845 95c0                      	com r28 //invert values 0-15
002846 c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002847 95b2                      	swap r27 //multiply depth by 16
002848 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002849 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00284a e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00284b 0fec                      	add ZL, r28 //offset the table by the depth+phase
00284c 1df2                      	adc ZH, zero
00284d 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00284e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00284f 937f                      	push r23
002850 2f6c                      	mov r22, r28 //store the vibrato value into r22
002851 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002852 9f67                      	mul r22, r23
002853 917f                      	pop r23
002854 916f                      	pop r22
                                 
002855 9416                      	lsr r1 //shift out the fractional bits
002856 9407                      	ror r0
002857 9416                      	lsr r1
002858 9407                      	ror r0
002859 9416                      	lsr r1
00285a 9407                      	ror r0
00285b 9416                      	lsr r1
00285c 9407                      	ror r0
                                 	
00285d 91a0 0aac                 	lds r26, TCB2_CCMPL
00285f 91b0 0aad                 	lds r27, TCB2_CCMPH
002861 0da0                      	add r26, r0
002862 1db1                      	adc r27, r1
002863 93a0 0aac                 	sts TCB2_CCMPL, r26
002865 93b0 0aad                 	sts TCB2_CCMPH, r27
002867 c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002868 95b2                      	swap r27 //multiply depth by 16
002869 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00286a e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00286b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00286c 0fec                      	add ZL, r28 //offset the table by the depth+phase
00286d 1df2                      	adc ZH, zero
00286e 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00286f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002870 937f                      	push r23
002871 2f6c                      	mov r22, r28 //store the vibrato value into r22
002872 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002873 9f67                      	mul r22, r23
002874 917f                      	pop r23
002875 916f                      	pop r22
                                 
002876 9416                      	lsr r1 //shift out the fractional bits
002877 9407                      	ror r0
002878 9416                      	lsr r1
002879 9407                      	ror r0
00287a 9416                      	lsr r1
00287b 9407                      	ror r0
00287c 9416                      	lsr r1
00287d 9407                      	ror r0
                                 
00287e 91a0 0aac                 	lds r26, TCB2_CCMPL
002880 91b0 0aad                 	lds r27, TCB2_CCMPH
002882 19a0                      	sub r26, r0
002883 09b1                      	sbc r27, r1
002884 93a0 0aac                 	sts TCB2_CCMPL, r26
002886 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002888 91e0 28f1                 	lds ZL, triangle_fx_Qxy_target
00288a 91f0 28f2                 	lds ZH, triangle_fx_Qxy_target+1
00288c 9630                      	adiw Z, 0
00288d f199                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00288e 91a0 28f5                 	lds r26, triangle_fx_Qxy_total_offset
002890 91b0 28f6                 	lds r27, triangle_fx_Qxy_total_offset+1
002892 91c0 0aac                 	lds r28, TCB2_CCMPL
002894 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002896 1bec                      	sub ZL, r28 //calculate the difference to the target
002897 0bfd                      	sbc ZH, r29
002898 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002899 f0e8                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
00289a 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
00289b 0bbf                      	sbc r27, ZH
                                 
00289c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00289d 937f                      	push r23
00289e 9160 28f0                 	lds r22, triangle_fx_Pxx
0028a0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028a1 9f67                      	mul r22, r23
0028a2 917f                      	pop r23
0028a3 916f                      	pop r22
0028a4 9416                      	lsr r1 //shift out the fractional bits
0028a5 9407                      	ror r0
0028a6 9416                      	lsr r1
0028a7 9407                      	ror r0
0028a8 9416                      	lsr r1
0028a9 9407                      	ror r0
0028aa 9416                      	lsr r1
0028ab 9407                      	ror r0
                                 
0028ac 0da0                      	add r26, r0
0028ad 1db2                      	adc r27, zero
                                 
0028ae 93a0 28f5                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
0028b0 93b0 28f6                 	sts triangle_fx_Qxy_total_offset+1, r27
0028b2 9220 28f1                 	sts triangle_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0028b4 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
0028b6 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
0028b7 91c0 28f3                 	lds r28, triangle_fx_Qxy_speed
0028b9 91d0 28f4                 	lds r29, triangle_fx_Qxy_speed+1
0028bb 0fac                      	add r26, r28 //increase the total offset by the speed
0028bc 1fbd                      	adc r27, r29
0028bd 93a0 28f5                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
0028bf 93b0 28f6                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
0028c1 91e0 28f7                 	lds ZL, triangle_fx_Rxy_target
0028c3 91f0 28f8                 	lds ZH, triangle_fx_Rxy_target+1
0028c5 9630                      	adiw Z, 0
0028c6 f199                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
0028c7 91a0 28fb                 	lds r26, triangle_fx_Rxy_total_offset
0028c9 91b0 28fc                 	lds r27, triangle_fx_Rxy_total_offset+1
0028cb 91c0 0aac                 	lds r28, TCB2_CCMPL
0028cd 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
0028cf 1bce                      	sub r28, ZL //calculate the difference to the target
0028d0 0bdf                      	sbc r29, ZH
0028d1 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
0028d2 f0e8                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
0028d3 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0028d4 0bbd                      	sbc r27, r29
                                 
0028d5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028d6 937f                      	push r23
0028d7 9160 28f0                 	lds r22, triangle_fx_Pxx
0028d9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028da 9f67                      	mul r22, r23
0028db 917f                      	pop r23
0028dc 916f                      	pop r22
0028dd 9416                      	lsr r1 //shift out the fractional bits
0028de 9407                      	ror r0
0028df 9416                      	lsr r1
0028e0 9407                      	ror r0
0028e1 9416                      	lsr r1
0028e2 9407                      	ror r0
0028e3 9416                      	lsr r1
0028e4 9407                      	ror r0
                                 
0028e5 0da0                      	add r26, r0
0028e6 1db2                      	adc r27, zero
                                 
0028e7 93a0 28fb                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
0028e9 93b0 28fc                 	sts triangle_fx_Rxy_total_offset+1, r27
0028eb 9220 28f7                 	sts triangle_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0028ed 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
0028ef c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
0028f0 91c0 28f9                 	lds r28, triangle_fx_Rxy_speed
0028f2 91d0 28fa                 	lds r29, triangle_fx_Rxy_speed+1
0028f4 0fac                      	add r26, r28 //increase the total offset by the speed
0028f5 1fbd                      	adc r27, r29
0028f6 93a0 28fb                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
0028f8 93b0 28fc                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
                                 
                                 sound_driver_exit:
0028fa 91ff                      	pop r31
0028fb 91ef                      	pop r30
0028fc 91df                      	pop r29
0028fd 91cf                      	pop r28
0028fe 940c 14de                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
002900 7f05
002901 010a
002902 0214
002903 0328
002904 0450
002905 051e
002906 0607
002907 070d
002908 0806
002909 090c
00290a 0a18
00290b 0b30
00290c 0c60
00290d 0d24
00290e 0e08
00290f 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
002910 0301
002911 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
002912 1696
002913 169b
002914 16b7
002915 16d3
002916 16f6                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
002917 1701
002918 170e
002919 1711
00291a 1714
00291b 1717                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
00291c 171a
00291d 1722
00291e 1725
00291f 1732
002920 1733                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
002921 1734
002922 1735
002923 1736
002924 1739
002925 177d                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
002926 17c0
002927 17cd
002928 17e1
002929 17e2
00292a 17e3                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
00292b 17e4                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
00292c 1962
00292d 1967
00292e 1983
00292f 199f
002930 19c2                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
002931 19cd
002932 19da
002933 19dd
002934 19e0
002935 19e3                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
002936 19e6
002937 19ee
002938 19f1
002939 19fe
00293a 19ff                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
00293b 1a00
00293c 1a01
00293d 1a02
00293e 1a05
00293f 1a49                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
002940 1a8c
002941 1a99
002942 1aad
002943 1aae
002944 1aaf                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
002945 1ab0                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
002946 1c2a
002947 1c2f
002948 1c4b
002949 1c67
00294a 1c8a                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
00294b 1c95
00294c 1c96
00294d 1c97
00294e 1c9a
00294f 1c9d                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
002950 1ca0
002951 1cad
002952 1cb0
002953 1cbd
002954 1cbe                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
002955 1cbf
002956 1cc0
002957 1cc1
002958 1cc4
002959 1d08                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
00295a 1d4b
00295b 1d58
00295c 1d59
00295d 1d5a
00295e 1d5b                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
00295f 1d5c                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
002960 0000
002961 0000
002962 0000
002963 0000
002964 0000
002965 0000
002966 0000
002967 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
002968 0100
002969 0101
00296a 0101
00296b 0101
00296c 0101
00296d 0101
00296e 0101
00296f 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
002970 0100
002971 0101
002972 0101
002973 0101
002974 0101
002975 0101
002976 0101
002977 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
002978 0100
002979 0101
00297a 0101
00297b 0101
00297c 0101
00297d 0202
00297e 0202
00297f 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
002980 0100
002981 0101
002982 0101
002983 0101
002984 0202
002985 0202
002986 0303
002987 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
002988 0100
002989 0101
00298a 0101
00298b 0202
00298c 0302
00298d 0303
00298e 0404
00298f 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
002990 0100
002991 0101
002992 0201
002993 0202
002994 0303
002995 0404
002996 0504
002997 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
002998 0100
002999 0101
00299a 0201
00299b 0302
00299c 0403
00299d 0504
00299e 0605
00299f 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
0029a0 0100
0029a1 0101
0029a2 0202
0029a3 0303
0029a4 0404
0029a5 0505
0029a6 0606
0029a7 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
0029a8 0100
0029a9 0101
0029aa 0302
0029ab 0403
0029ac 0504
0029ad 0606
0029ae 0707
0029af 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
0029b0 0100
0029b1 0201
0029b2 0302
0029b3 0404
0029b4 0605
0029b5 0706
0029b6 0808
0029b7 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
0029b8 0100
0029b9 0201
0029ba 0302
0029bb 0504
0029bc 0605
0029bd 0807
0029be 0908
0029bf 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
0029c0 0100
0029c1 0201
0029c2 0403
0029c3 0504
0029c4 0706
0029c5 0808
0029c6 0a09
0029c7 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
0029c8 0100
0029c9 0201
0029ca 0403
0029cb 0605
0029cc 0706
0029cd 0908
0029ce 0b0a
0029cf 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
0029d0 0100
0029d1 0201
0029d2 0403
0029d3 0605
0029d4 0807
0029d5 0a09
0029d6 0c0b
0029d7 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
0029d8 0100
0029d9 0302
0029da 0504
0029db 0706
0029dc 0908
0029dd 0b0a
0029de 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 186 r0 : 153 r1 : 153 r2 : 519 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   3 
r21:   0 r22: 132 r23: 132 r24:   0 r25:  24 r26: 705 r27: 880 r28: 516 
r29: 265 r30: 284 r31: 259 
Registers used: 24 out of 35 (68.6%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 106 add   : 143 adiw  :  80 and   :   0 
andi  :  70 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   5 brcs  :   9 break :   0 breq  : 127 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  60 brlt  :   0 brmi  :   0 
brne  :  91 brpl  :   0 brsh  :  24 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   4 
clc   :   0 clh   :   0 cli   :   7 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  12 cp    :  76 cpc   :   8 
cpi   : 125 cpse  :  17 dec   :  29 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   3 in    :   6 inc   :  36 
jmp   :   9 ld    :   0 ldd   :   0 ldi   : 223 lds   : 539 lpm   : 195 
lsl   :  58 lsr   : 136 mov   : 100 movw  :   0 mul   :  27 muls  :   0 
mulsu :   6 neg   :   0 nop   :   0 or    :  14 ori   :   8 out   :   8 
pop   :  96 push  :  90 rcall :  39 ret   :  28 reti  :   6 rjmp  : 388 
rol   :  38 ror   : 154 sbc   :  36 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  10 sbrc  :  20 sbrs  :  13 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1011 sub   :  49 subi  :  39 swap  :  35 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0053c0  11814   9554  21368   49152  43.5%
[.dseg] 0x002800 0x002901      0    257    257    6144   4.2%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 106 warnings
