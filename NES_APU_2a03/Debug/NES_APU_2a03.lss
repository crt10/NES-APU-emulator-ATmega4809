
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Mon Jan 11 20:53:00 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4002 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           song_frames: .byte 2
00280a                           song_frame_offset: .byte 2
                                 
                                 
                                 
00280c                           pulse1_pattern: .byte 2
00280e                           pulse1_pattern_delay: .byte 1
00280f                           pulse1_pattern_offset: .byte 2
                                 
002811                           pulse1_volume_macro: .byte 2
002813                           pulse1_volume_macro_offset: .byte 1
002814                           pulse1_volume_macro_loop: .byte 1
002815                           pulse1_volume_macro_release: .byte 1
                                 
002816                           pulse1_arpeggio_macro: .byte 2
002818                           pulse1_arpeggio_macro_offset: .byte 1
002819                           pulse1_arpeggio_macro_loop: .byte 1
00281a                           pulse1_arpeggio_macro_release: .byte 1
00281b                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00281c                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00281d                           pulse1_pitch_macro: .byte 2
00281f                           pulse1_pitch_macro_offset: .byte 1
002820                           pulse1_pitch_macro_loop: .byte 1
002821                           pulse1_pitch_macro_release: .byte 1
                                 
002822                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002823                           pulse1_hi_pitch_macro: .byte 2
002825                           pulse1_hi_pitch_macro_offset: .byte 1
002826                           pulse1_hi_pitch_macro_loop: .byte 1
002827                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002828                           pulse1_duty_macro: .byte 2
00282a                           pulse1_duty_macro_offset: .byte 1
00282b                           pulse1_duty_macro_loop: .byte 1
00282c                           pulse1_duty_macro_release: .byte 1
                                 
00282d                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00282f                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002831                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002833                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002835                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002837                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002839                           pulse1_fx_3xx_target: .byte 2 //target note period
00283b                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00283d                           pulse1_fx_3xx_total_offset: .byte 2
00283f                           pulse1_fx_4xy_speed: .byte 1
002840                           pulse1_fx_4xy_depth: .byte 1
002841                           pulse1_fx_4xy_phase: .byte 1
002842                           pulse1_fx_7xy_speed: .byte 1
002843                           pulse1_fx_7xy_depth: .byte 1
002844                           pulse1_fx_7xy_phase: .byte 1
002845                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002846                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002847                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002848                           pulse1_fx_Qxy_target: .byte 2 //target note period
00284a                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00284c                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00284e                           pulse1_fx_Rxy_target: .byte 2 //target note period
002850                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002852                           pulse1_fx_Rxy_total_offset: .byte 2
                                 
002854                           pulse2_pattern_delay: .byte 1
002855                           triangle_pattern_delay: .byte 1
002856                           noise_pattern_delay: .byte 1
002857                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.0000 = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r13
                                 .def pulse1_length_counter = r14
                                 .def pulse1_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 
                                 reset:
000000 940c 0163                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 02a8                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 028e                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 0298                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 028e                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 0897                 	jmp pulse1_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(40): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(41): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
000163 edb8                      	ldi r27, CPU_CCP_IOREG_gc //protected write
000164 93b0 0034                 	sts CPU_CCP, r27
000166 e0b0                      	ldi r27, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
000167 93b0 0061                 	sts CLKCTRL_MCLKCTRLB, r27
                                 
                                 /*	//TEST FOR C4, 1 SECOND, 50% DD
                                 	ldi r26, 0x97
                                 	ldi r27, 0x12
                                 	ldi r26, 0x15
                                 	ldi r27, 0x09
                                 	sts pulse1_timerL, r26
                                 	sts pulse1_timerH, r27
                                 	ldi r27, 0b10111111
                                 	sts pulse1_param, r27
                                 	ldi r27, 0x01
                                 	sts pulse1_length, r27
                                 	//TEST FOR SWEEP UP
                                 	ldi r27, 0b11111111
                                 	sts pulse1_sweep_param, r27*/
                                 
                                 	//ZERO
000169 2422                      	clr zero
                                 
                                 	//MEMORY
00016a e3b0                      	ldi r27, 0b00110000
00016b 93b0 2800                 	sts pulse1_param, r27
00016d e8b0                      	ldi r27, 0b10000000
00016e 93b0 2801                 	sts pulse1_sweep_param, r27
000170 efbf                      	ldi r27, 0xFF
000171 93b0 2802                 	sts pulse1_timerL, r27
000173 93b0 2803                 	sts pulse1_timerH, r27
000175 93b0 2804                 	sts pulse1_length, r27
                                 
000177 e0b0                      	ldi r27, 0x00
000178 93b0 280a                 	sts song_frame_offset, r27
00017a 93b0 280b                 	sts song_frame_offset+1, r27
00017c eee2                      	ldi ZL, LOW(song0_frames << 1)
00017d e0f1                      	ldi ZH, HIGH(song0_frames << 1)
00017e 93e0 2808                 	sts song_frames, ZL
000180 93f0 2809                 	sts song_frames+1, ZH
                                 
                                 	//CHANNEL 0 TEST
000182 e0b0                      	ldi r27, 0x00
000183 0feb                      	add ZL, r27
000184 1df2                      	adc ZH, zero
000185 91a5                      	lpm r26, Z+
000186 91b4                      	lpm r27, Z
000187 0faa                      	lsl r26
000188 1fbb                      	rol r27
000189 93a0 280c                 	sts pulse1_pattern, r26
00018b 93b0 280d                 	sts pulse1_pattern+1, r27
00018d e0b0                      	ldi r27, 0x00
00018e 9220 280e                 	sts pulse1_pattern_delay, zero
000190 9220 280f                 	sts pulse1_pattern_offset, zero
000192 9220 2810                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//channel 0 instrument macros
000194 efbf                      	ldi r27, 0xFF
000195 9220 2813                 	sts pulse1_volume_macro_offset, zero
000197 93b0 2814                 	sts pulse1_volume_macro_loop, r27
000199 93b0 2815                 	sts pulse1_volume_macro_release, r27
00019b 9220 2818                 	sts pulse1_arpeggio_macro_offset, zero
00019d 93b0 2819                 	sts pulse1_arpeggio_macro_loop, r27
00019f 93b0 281a                 	sts pulse1_arpeggio_macro_release, r27
0001a1 93b0 281b                 	sts pulse1_arpeggio_macro_mode, r27
0001a3 9220 281f                 	sts pulse1_pitch_macro_offset, zero
0001a5 93b0 2820                 	sts pulse1_pitch_macro_loop, r27
0001a7 93b0 2821                 	sts pulse1_pitch_macro_release, r27
0001a9 9220 2825                 	sts pulse1_hi_pitch_macro_offset, zero
0001ab 93b0 2826                 	sts pulse1_hi_pitch_macro_loop, r27
0001ad 93b0 2827                 	sts pulse1_hi_pitch_macro_release, r27
0001af 9220 282a                 	sts pulse1_duty_macro_offset, zero
0001b1 93b0 282b                 	sts pulse1_duty_macro_loop, r27
0001b3 93b0 282c                 	sts pulse1_duty_macro_release, r27
                                 
0001b5 9220 2811                 	sts pulse1_volume_macro, zero
0001b7 9220 2812                 	sts pulse1_volume_macro+1, zero
0001b9 9220 2816                 	sts pulse1_arpeggio_macro, zero
0001bb 9220 2817                 	sts pulse1_arpeggio_macro+1, zero
0001bd 9220 281c                 	sts pulse1_total_pitch_offset, zero
0001bf 9220 281d                 	sts pulse1_pitch_macro, zero
0001c1 9220 281e                 	sts pulse1_pitch_macro+1, zero
0001c3 9220 2822                 	sts pulse1_total_hi_pitch_offset, zero
0001c5 9220 2823                 	sts pulse1_hi_pitch_macro, zero
0001c7 9220 2824                 	sts pulse1_hi_pitch_macro+1, zero
0001c9 9220 2828                 	sts pulse1_duty_macro, zero
0001cb 9220 2829                 	sts pulse1_duty_macro+1, zero
                                 
0001cd 9220 2854                 	sts pulse2_pattern_delay, zero
0001cf 9220 2855                 	sts triangle_pattern_delay, zero
0001d1 9220 2856                 	sts noise_pattern_delay, zero
0001d3 9220 2857                 	sts dcpm_pattern_delay, zero
                                 
                                 	//PINS
0001d5 efbf                      	ldi r27, 0xFF //set all pins in VPORTD to output
0001d6 b9b0                      	out VPORTA_DIR, r27
                                 
                                 	//ENVELOPE
0001d7 e00f                      	ldi pulse1_volume_divider, 0x0F
0001d8 9110 2800                 	lds pulse1_volume_decay, pulse1_param
0001da 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
0001db 9190 2800                 	lds channel_flags, pulse1_param
0001dd 7390                      	andi channel_flags, 0b00110000
0001de 6490                      	sbr channel_flags, 0b01000000 //set start flag
0001df 9220 2806                 	sts pulse1_output_volume, zero
0001e1 93b0 2805                 	sts pulse1_fractional_volume, r27 //initialize fractional volume to max value
                                 	
                                 	//LENGTH
0001e3 91d0 2804                 	lds r29, pulse1_length
0001e5 d6fe                      	rcall length_converter
0001e6 2eed                      	mov pulse1_length_counter, r29
                                 
                                 	//SEQUENCE
0001e7 91d0 2800                 	lds r29, pulse1_param //load param for sequence table
0001e9 0fdd                      	lsl r29 //shift duty cycle bits to LSB
0001ea 1fdd                      	rol r29
0001eb 1fdd                      	rol r29
0001ec 70d3                      	andi r29, 0b00000011 //mask duty cycle bits
0001ed d70c                      	rcall duty_cycle_sequences
0001ee 2edd                      	mov pulse1_sequence, r29
                                 
                                 	//SWEEP
0001ef 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param
0001f1 94f2                      	swap pulse1_sweep //swap data from high byte and low byte
0001f2 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//FX
0001f3 9220 282d                 	sts pulse1_fx_0xy_sequence, zero
0001f5 9220 282e                 	sts pulse1_fx_0xy_sequence+1, zero
0001f7 9220 282f                 	sts pulse1_fx_1xx, zero
0001f9 9220 2830                 	sts pulse1_fx_1xx+1, zero
0001fb 9220 2831                 	sts pulse1_fx_1xx_total, zero
0001fd 9220 2832                 	sts pulse1_fx_1xx_total+1, zero
0001ff 9220 2833                 	sts pulse1_fx_2xx, zero
000201 9220 2834                 	sts pulse1_fx_2xx+1, zero
000203 9220 2835                 	sts pulse1_fx_2xx_total, zero
000205 9220 2836                 	sts pulse1_fx_2xx_total+1, zero
000207 9220 2837                 	sts pulse1_fx_3xx_start, zero
000209 9220 2838                 	sts pulse1_fx_3xx_start+1, zero
00020b 9220 2839                 	sts pulse1_fx_3xx_target, zero
00020d 9220 283a                 	sts pulse1_fx_3xx_target+1, zero
00020f 9220 283b                 	sts pulse1_fx_3xx_speed, zero
000211 9220 283c                 	sts pulse1_fx_3xx_speed+1, zero
000213 9220 283d                 	sts pulse1_fx_3xx_total_offset, zero
000215 9220 283e                 	sts pulse1_fx_3xx_total_offset+1, zero
000217 9220 283f                 	sts pulse1_fx_4xy_speed, zero
000219 9220 2840                 	sts pulse1_fx_4xy_depth, zero
00021b 9220 2841                 	sts pulse1_fx_4xy_phase, zero
00021d 9220 2842                 	sts pulse1_fx_7xy_speed, zero
00021f 9220 2843                 	sts pulse1_fx_7xy_depth, zero
000221 9220 2844                 	sts pulse1_fx_7xy_phase, zero
000223 9220 2845                 	sts pulse1_fx_7xy_value, zero
000225 9220 2846                 	sts pulse1_fx_Pxx, zero
000227 9220 2847                 	sts pulse1_fx_Axy, zero
000229 9220 2848                 	sts pulse1_fx_Qxy_target, zero
00022b 9220 2849                 	sts pulse1_fx_Qxy_target+1, zero
00022d 9220 284a                 	sts pulse1_fx_Qxy_speed, zero
00022f 9220 284b                 	sts pulse1_fx_Qxy_speed+1, zero
000231 9220 284c                 	sts pulse1_fx_Qxy_total_offset, zero
000233 9220 284d                 	sts pulse1_fx_Qxy_total_offset+1, zero
000235 9220 284e                 	sts pulse1_fx_Rxy_target, zero
000237 9220 284f                 	sts pulse1_fx_Rxy_target+1, zero
000239 9220 2850                 	sts pulse1_fx_Rxy_speed, zero
00023b 9220 2851                 	sts pulse1_fx_Rxy_speed+1, zero
00023d 9220 2852                 	sts pulse1_fx_Rxy_total_offset, zero
00023f 9220 2853                 	sts pulse1_fx_Rxy_total_offset+1, zero
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
000241 e7b0                      	ldi r27, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
000242 93b0 0a01                 	sts TCA0_SINGLE_CTRLB, r27
000244 e7b1                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
000245 93b0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r27
000247 e1b5                      	ldi r27, 0x15 //set the period for CMP0
000248 93b0 0a28                 	sts TCA0_SINGLE_CMP0, r27
00024a e0b5                      	ldi r27, 0x05
00024b 93b0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r27
00024d e2bb                      	ldi r27, 0x2B //set the period for CMP1
00024e 93b0 0a2a                 	sts TCA0_SINGLE_CMP1, r27
000250 e0ba                      	ldi r27, 0x0A
000251 93b0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r27
000253 e4b1                      	ldi r27, 0x41 //set the period for CMP2
000254 93b0 0a2c                 	sts TCA0_SINGLE_CMP2, r27
000256 e0bf                      	ldi r27, 0x0F
000257 93b0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r27
000259 e5b7                      	ldi r27, 0x57 //set the period for OVF
00025a 93b0 0a26                 	sts TCA0_SINGLE_PER, r27
00025c e1b4                      	ldi r27, 0x14
00025d 93b0 0a27                 	sts TCA0_SINGLE_PER + 1, r27
00025f e0bb                      	ldi r27, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
000260 93b0 0a00                 	sts TCA0_SINGLE_CTRLA, r27
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
000262 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
000263 93b0 0a81                 	sts TCB0_CTRLB, r27
000265 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
000266 93b0 0a85                 	sts TCB0_INTCTRL, r27
000268 91b0 2802                 	lds r27, pulse1_timerL //load the LOW bits for timer
00026a 93b0 0a8c                 	sts TCB0_CCMPL, r27
00026c 91b0 2803                 	lds r27, pulse1_timerH //load the HIGH bits for timer
00026e 93b0 0a8d                 	sts TCB0_CCMPH, r27
000270 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
000271 93b0 0a80                 	sts TCB0_CTRLA, r27
000273 9478                      	sei //global interrupt enable
                                 
                                 pulse1:
000274 fed0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
000275 c012                      	rjmp pulse1_off
                                 
000276 14e2                      	cp pulse1_length_counter, zero //if length is zero, return
000277 f081                      	breq pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
                                 pulse1_check_timer_08:
000278 91c0 0a8c                 	lds r28, TCB0_CCMPL
00027a 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 pulse1_check_timer_08_HIGH:
00027c 30d1                      	cpi r29, 0x01 //check timer HIGH period
00027d f008                      	brlo pulse1_check_timer_08_LOW //if the timer HIGH period is $00, check the LOW period
00027e c002                      	rjmp pulse1_check_timer_7FF_HIGH //if the timer HIGH period is > $01, check > $07FF condition
                                 pulse1_check_timer_08_LOW:
00027f 35c9                      	cpi r28, 0x59 //check timer LOW period
000280 f038                      	brlo pulse1_off //if the HIGH period == $00 && LOW period <= $59, pulse off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
                                 pulse1_check_timer_7FF_HIGH:
000281 35d9                      	cpi r29, 0x59 //check timer HIGH period
000282 f038                      	brlo pulse1_on //if the HIGH period is < $59, then all conditions have passed and pulse is not muted
000283 f009                      	breq pulse1_check_timer_7FF_LOW //if the HIGH period is == $59, we go check if the LOW period is < $65
000284 c003                      	rjmp pulse1_off //pulse off if HIGH period is > $59
                                 pulse1_check_timer_7FF_LOW:
000285 36c5                      	cpi r28, 0x65 //check timer LOW period
000286 f408                      	brsh pulse1_off //if the HIGH period == $59 && LOW period >= $65, pulse off
000287 c002                      	rjmp pulse1_on //if the HIGH period == $59 && LOW period < $65, pulse on
                                 
                                 pulse1_off:
000288 b821                      	out VPORTA_OUT, zero
000289 cfea                      	rjmp pulse1
                                 
                                 pulse1_on:
00028a 91d0 2806                 	lds r29, pulse1_output_volume
                                 /*	cpse r29, zero
                                 	rjmp pulse1_off //if VVVV bits are 0, then there is no volume (channel off)*/
                                 
00028c b9d1                      	out VPORTA_OUT, r29
00028d cfe6                      	rjmp pulse1
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
00028e b7bf                      	in r27, CPU_SREG
00028f 93bf                      	push r27
000290 94f8                      	cli
                                 
                                 	//ENVELOPE
000291 d63a                      	rcall pulse1_envelope_routine
                                 
000292 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
000293 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
000295 91bf                      	pop r27
000296 bfbf                      	out CPU_SREG, r27
000297 9518                      	reti
                                 
                                 sequence_1_3:
000298 b7bf                      	in r27, CPU_SREG
000299 93bf                      	push r27
00029a 94f8                      	cli
                                 
                                 	//ENVELOPE
00029b d630                      	rcall pulse1_envelope_routine
                                 
                                 	//SWEEP
00029c fcf3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
00029d d604                      	rcall pulse1_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
00029e fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
00029f c002                      	rjmp sequence_1_3_exit
0002a0 10e2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
0002a1 94ea                      	dec pulse1_length_counter
                                 
                                 sequence_1_3_exit:
0002a2 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
0002a3 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0002a5 91bf                      	pop r27
0002a6 bfbf                      	out CPU_SREG, r27
0002a7 9518                      	reti
                                 
                                 sound_driver:
0002a8 b7bf                      	in r27, CPU_SREG
0002a9 93bf                      	push r27
0002aa 94f8                      	cli
0002ab 93cf                      	push r28
0002ac 93df                      	push r29
                                 
                                 	//SOUND DRIVER
0002ad 91b0 280e                 	lds r27, pulse1_pattern_delay
0002af 11b2                      	cpse r27, zero //if the pattern delay is 0, proceed with sound driver procedures
0002b0 c298                      	rjmp sound_driver_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 
                                 
                                 sound_driver_channel0:
0002b1 91e0 280c                 	lds ZL, pulse1_pattern //current pattern for pulse 1
0002b3 91f0 280d                 	lds ZH, pulse1_pattern+1
0002b5 91a0 280f                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
0002b7 91b0 2810                 	lds r27, pulse1_pattern_offset+1
0002b9 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0002ba 1ffb                      	adc ZH, r27
0002bb 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0002bc 35b7                      	cpi r27, 0x57
0002bd f408                      	brsh sound_driver_channel0_check_if_volume
0002be c144                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
0002bf 36b7                      	cpi r27, 0x67
0002c0 f408                      	brsh sound_driver_channel0_check_if_delay
0002c1 c179                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0002c2 3eb3                      	cpi r27, 0xE3
0002c3 f408                      	brsh sound_driver_channel0_check_if_instrument
0002c4 c180                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
0002c5 f409                      	brne sound_driver_channel0_check_if_release
0002c6 c183                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
0002c7 3eb4                      	cpi r27, 0xE4
0002c8 f409                      	brne sound_driver_channel0_check_if_end
0002c9 c22a                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
0002ca 3fbf                      	cpi r27, 0xFF
0002cb f409                      	brne sound_driver_channel0_check_if_fx
0002cc c24c                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
0002cd 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0002ce 91a4                      	lpm r26, Z //load the fx data into r26
0002cf d26f                      	rcall sound_driver_channel0_increment_offset_twice
                                 
0002d0 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0002d1 e0e4                      	ldi ZL, LOW(fx << 1) //load in note table
0002d2 e1f2                      	ldi ZH, HIGH(fx << 1)
0002d3 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0002d4 0feb                      	add ZL, r27 //add offset
0002d5 1df2                      	adc ZH, zero
0002d6 91c5                      	lpm r28, Z+ //load address bytes
0002d7 91d4                      	lpm r29, Z
0002d8 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0002d9 2ffd                      	mov ZH, r29
0002da 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
0002db 93a0 282d                 	sts pulse1_fx_0xy_sequence, r26
0002dd 9220 282e                 	sts pulse1_fx_0xy_sequence+1, zero
0002df cfd1                      	rjmp sound_driver_channel0
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
0002e0 9220 2833                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
0002e2 9220 2834                 	sts pulse1_fx_2xx+1, zero
0002e4 9220 282d                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0002e6 9220 282e                 	sts pulse1_fx_0xy_sequence+1, zero
0002e8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0002e9 937f                      	push r23
0002ea 2f6a                      	mov r22, r26 //store the rate into r22
0002eb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0002ec 9f67                      	mul r22, r23
0002ed 917f                      	pop r23
0002ee 916f                      	pop r22
                                 
0002ef 9416                      	lsr r1 //shift out the fractional bits
0002f0 9407                      	ror r0
0002f1 9416                      	lsr r1
0002f2 9407                      	ror r0
0002f3 9416                      	lsr r1
0002f4 9407                      	ror r0
0002f5 9416                      	lsr r1
0002f6 9407                      	ror r0
0002f7 9200 282f                 	sts pulse1_fx_1xx, r0
0002f9 9210 2830                 	sts pulse1_fx_1xx+1, r1
0002fb cfb5                      	rjmp sound_driver_channel0
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0002fc 9220 282f                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0002fe 9220 2830                 	sts pulse1_fx_1xx+1, zero
000300 9220 282d                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
000302 9220 282e                 	sts pulse1_fx_0xy_sequence+1, zero
000304 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000305 937f                      	push r23
000306 2f6a                      	mov r22, r26 //store the rate into r22
000307 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000308 9f67                      	mul r22, r23
000309 917f                      	pop r23
00030a 916f                      	pop r22
                                 
00030b 9416                      	lsr r1 //shift out the fractional bits
00030c 9407                      	ror r0
00030d 9416                      	lsr r1
00030e 9407                      	ror r0
00030f 9416                      	lsr r1
000310 9407                      	ror r0
000311 9416                      	lsr r1
000312 9407                      	ror r0
000313 9200 2833                 	sts pulse1_fx_2xx, r0
000315 9210 2834                 	sts pulse1_fx_2xx+1, r1
000317 cf99                      	rjmp sound_driver_channel0
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
000318 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000319 937f                      	push r23
00031a 2f6a                      	mov r22, r26 //store the rate into r22
00031b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00031c 9f67                      	mul r22, r23
00031d 917f                      	pop r23
00031e 916f                      	pop r22
                                 
00031f 9416                      	lsr r1 //shift out the fractional bits
000320 9407                      	ror r0
000321 9416                      	lsr r1
000322 9407                      	ror r0
000323 9416                      	lsr r1
000324 9407                      	ror r0
000325 9416                      	lsr r1
000326 9407                      	ror r0
000327 9200 283b                 	sts pulse1_fx_3xx_speed, r0
000329 9210 283c                 	sts pulse1_fx_3xx_speed+1, r1
                                 
00032b 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
00032c c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
00032d cf83                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
00032e 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
000330 91b0 0a8d                 	lds r27, TCB0_CCMPH
000332 93a0 2837                 	sts pulse1_fx_3xx_start, r26
000334 93b0 2838                 	sts pulse1_fx_3xx_start+1, r27
                                 
000336 9220 283d                 	sts pulse1_fx_3xx_total_offset, zero
000338 9220 283e                 	sts pulse1_fx_3xx_total_offset+1, zero
00033a cf76                      	rjmp sound_driver_channel0
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
00033b 2fba                      	mov r27, r26
00033c 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00033d 95a2                      	swap r26
00033e 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00033f 93a0 283f                 	sts pulse1_fx_4xy_speed, r26
000341 93b0 2840                 	sts pulse1_fx_4xy_depth, r27
000343 9220 2841                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
000345 cf6b                      	rjmp sound_driver_channel0
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
000346 2fba                      	mov r27, r26
000347 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
000348 95a2                      	swap r26
000349 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00034a 93a0 2842                 	sts pulse1_fx_7xy_speed, r26
00034c 93b0 2843                 	sts pulse1_fx_7xy_depth, r27
00034e 9220 2844                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
000350 9220 2845                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
000352 cf5e                      	rjmp sound_driver_channel0
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
000353 93a0 2847                 	sts pulse1_fx_Axy, r26
000355 cf5b                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Bxx: //pattern jump
000356 cf5a                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Cxx: //halt
000357 cf59                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Dxx: //frame skip
000358 cf58                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Exx: //volume
000359 cf57                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Fxx: //speed and tempo
00035a cf56                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Gxx: //note delay
00035b cf55                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
00035c cf54                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_lxy: //hardware sweep down
00035d cf53                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
00035e cf52                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
00035f cf51                      	rjmp sound_driver_channel0
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
000360 93a0 2846                 	sts pulse1_fx_Pxx, r26
000362 cf4e                      	rjmp sound_driver_channel0
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
000363 91e0 2816                 	lds ZL, pulse1_arpeggio_macro
000365 91f0 2817                 	lds ZH, pulse1_arpeggio_macro+1
000367 9630                      	adiw Z, 0
000368 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
000369 cf47                      	rjmp sound_driver_channel0 //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00036a 91e0 281d                 	lds ZL, pulse1_pitch_macro
00036c 91f0 281e                 	lds ZH, pulse1_pitch_macro+1
00036e 9630                      	adiw Z, 0
00036f f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
000370 cf40                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
000371 91e0 2823                 	lds ZL, pulse1_hi_pitch_macro
000373 91f0 2824                 	lds ZH, pulse1_hi_pitch_macro+1
000375 9630                      	adiw Z, 0
000376 f009                      	breq sound_driver_channel0_fx_Qxy_process
000377 cf39                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
000378 2fba                      	mov r27, r26 //copy fx parameters into r27
000379 70bf                      	andi r27, 0x0F //mask note index offset
00037a 91c0 2807                 	lds r28, pulse1_note //load current note index
00037c 0fbc                      	add r27, r28
00037d 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00037e f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
00037f e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
000380 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
000381 e0f0                      	ldi ZH, HIGH(note_table << 1)
000382 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
000383 0feb                      	add ZL, r27 //add offset
000384 1df2                      	adc ZH, zero
000385 91c5                      	lpm r28, Z+ //load bytes
000386 91d4                      	lpm r29, Z
000387 93c0 2848                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
000389 93d0 2849                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
00038b 95a2                      	swap r26
00038c 70af                      	andi r26, 0x0F //mask effect speed
00038d 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00038e 95a3                      	inc r26 //increment the speed by 1
                                 
00038f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000390 937f                      	push r23
000391 2f6a                      	mov r22, r26 //store the speed data into r27
000392 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000393 9f67                      	mul r22, r23
000394 917f                      	pop r23
000395 916f                      	pop r22
                                 
000396 9416                      	lsr r1 //shift out the fractional bits
000397 9407                      	ror r0
000398 9416                      	lsr r1
000399 9407                      	ror r0
00039a 9416                      	lsr r1
00039b 9407                      	ror r0
00039c 9416                      	lsr r1
00039d 9407                      	ror r0
                                 
00039e 9200 284a                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0003a0 9210 284b                 	sts pulse1_fx_Qxy_speed+1, r1
0003a2 9220 284c                 	sts pulse1_fx_Qxy_total_offset, zero
0003a4 9220 284d                 	sts pulse1_fx_Qxy_total_offset+1, zero
0003a6 cf0a                      	rjmp sound_driver_channel0
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0003a7 91e0 2816                 	lds ZL, pulse1_arpeggio_macro
0003a9 91f0 2817                 	lds ZH, pulse1_arpeggio_macro+1
0003ab 9630                      	adiw Z, 0
0003ac f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
0003ad cf03                      	rjmp sound_driver_channel0 //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
0003ae 91e0 281d                 	lds ZL, pulse1_pitch_macro
0003b0 91f0 281e                 	lds ZH, pulse1_pitch_macro+1
0003b2 9630                      	adiw Z, 0
0003b3 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0003b4 cefc                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0003b5 91e0 2823                 	lds ZL, pulse1_hi_pitch_macro
0003b7 91f0 2824                 	lds ZH, pulse1_hi_pitch_macro+1
0003b9 9630                      	adiw Z, 0
0003ba f009                      	breq sound_driver_channel0_fx_Rxy_process
0003bb cef5                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0003bc 2fba                      	mov r27, r26 //copy fx parameters into r27
0003bd 70bf                      	andi r27, 0x0F //mask note index offset
0003be 91c0 2807                 	lds r28, pulse1_note //load current note index
0003c0 1bcb                      	sub r28, r27
0003c1 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0003c2 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0003c3 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0003c4 e0f0                      	ldi ZH, HIGH(note_table << 1)
0003c5 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0003c6 0fec                      	add ZL, r28 //add offset
0003c7 1df2                      	adc ZH, zero
0003c8 91c5                      	lpm r28, Z+ //load bytes
0003c9 91d4                      	lpm r29, Z
0003ca 93c0 284e                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0003cc 93d0 284f                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0003ce 95a2                      	swap r26
0003cf 70af                      	andi r26, 0x0F //mask effect speed
0003d0 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0003d1 95a3                      	inc r26 //increment the speed by 1
                                 
0003d2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0003d3 937f                      	push r23
0003d4 2f6a                      	mov r22, r26 //store the speed data into r27
0003d5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0003d6 9f67                      	mul r22, r23
0003d7 917f                      	pop r23
0003d8 916f                      	pop r22
                                 
0003d9 9416                      	lsr r1 //shift out the fractional bits
0003da 9407                      	ror r0
0003db 9416                      	lsr r1
0003dc 9407                      	ror r0
0003dd 9416                      	lsr r1
0003de 9407                      	ror r0
0003df 9416                      	lsr r1
0003e0 9407                      	ror r0
                                 
0003e1 9200 2850                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
0003e3 9210 2851                 	sts pulse1_fx_Rxy_speed+1, r1
0003e5 9220 2852                 	sts pulse1_fx_Rxy_total_offset, zero
0003e7 9220 2853                 	sts pulse1_fx_Rxy_total_offset+1, zero
0003e9 cec7                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Sxx: //mute delay
0003ea cec6                      	rjmp sound_driver_channel0
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
0003eb e0e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0003ec e1f2                      	ldi ZH, HIGH(sequences << 1)
0003ed 0fea                      	add ZL, r26 //offset the pointer
0003ee 1df2                      	adc ZH, zero
                                 
0003ef 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0003f0 95a7                      	ror r26
0003f1 95a7                      	ror r26
0003f2 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0003f4 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0003f5 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0003f6 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0003f7 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0003f8 ceb8                      	rjmp sound_driver_channel0 //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0003f9 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0003fa 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0003fb 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0003fc 93c0 2800                 	sts pulse1_param, r28
0003fe ceb2                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0003ff ceb1                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
000400 ceb0                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
000401 ceaf                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
000402 ceae                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_channel0_note:
000403 93b0 2807                 	sts pulse1_note, r27 //store the note index
000405 e0a3                      	ldi r26, 0x03
000406 e0b2                      	ldi r27, 0x02
000407 93b0 2813                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
000409 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26
00040b 93b0 281f                 	sts pulse1_pitch_macro_offset, r27
00040d 93b0 2825                 	sts pulse1_hi_pitch_macro_offset, r27
00040f 93b0 282a                 	sts pulse1_duty_macro_offset, r27
000411 9220 281c                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
000413 9220 2822                 	sts pulse1_total_hi_pitch_offset, zero
000415 9220 2831                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
000417 9220 2832                 	sts pulse1_fx_1xx_total+1, zero
000419 9220 2835                 	sts pulse1_fx_2xx_total, zero
00041b 9220 2836                 	sts pulse1_fx_2xx_total+1, zero
00041d 9220 283d                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
00041f 9220 283e                 	sts pulse1_fx_3xx_total_offset+1, zero
000421 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
000423 91b0 0a8d                 	lds r27, TCB0_CCMPH
000425 93a0 2837                 	sts pulse1_fx_3xx_start, r26
000427 93b0 2838                 	sts pulse1_fx_3xx_start+1, r27
000429 9220 2848                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00042b 9220 2849                 	sts pulse1_fx_Qxy_target+1, zero
00042d 9220 284c                 	sts pulse1_fx_Qxy_total_offset, zero
00042f 9220 284d                 	sts pulse1_fx_Qxy_total_offset+1, zero
000431 9220 284e                 	sts pulse1_fx_Rxy_target, zero
000433 9220 284f                 	sts pulse1_fx_Rxy_target+1, zero
000435 9220 2852                 	sts pulse1_fx_Rxy_total_offset, zero
000437 9220 2853                 	sts pulse1_fx_Rxy_total_offset+1, zero
000439 d0fb                      	rcall sound_driver_channel0_increment_offset
00043a ce76                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
00043b 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00043c 91a0 2800                 	lds r26, pulse1_param
00043e 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
00043f 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
000440 93a0 2800                 	sts pulse1_param, r26
000442 6096                      	sbr channel_flags, 6
000443 d0f1                      	rcall sound_driver_channel0_increment_offset
000444 ce6c                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
000445 56b7                      	subi r27, 0x67 //NOTE: the delay values are offset by the highest volume value, which is 0x66
000446 93b0 280e                 	sts pulse1_pattern_delay, r27
000448 d0ec                      	rcall sound_driver_channel0_increment_offset
000449 c102                      	rjmp sound_driver_instrument_routine
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
00044a 9220 2811                 	sts pulse1_volume_macro, zero //reset all macro addresses
00044c 9220 2812                 	sts pulse1_volume_macro+1, zero
00044e 9220 2816                 	sts pulse1_arpeggio_macro, zero
000450 9220 2817                 	sts pulse1_arpeggio_macro+1, zero
000452 9220 281d                 	sts pulse1_pitch_macro, zero
000454 9220 281e                 	sts pulse1_pitch_macro+1, zero
000456 9220 2823                 	sts pulse1_hi_pitch_macro, zero
000458 9220 2824                 	sts pulse1_hi_pitch_macro+1, zero
00045a 9220 2828                 	sts pulse1_duty_macro, zero
00045c 9220 2829                 	sts pulse1_duty_macro+1, zero
00045e 9220 281c                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
000460 9220 2822                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
000462 9631                      	adiw Z, 1 //point to the byte next to the flag
000463 91b4                      	lpm r27, Z //store the instrument offset into r27
000464 e6e1                      	ldi ZL, LOW(instruments) //point Z to instruments table
000465 e0f1                      	ldi ZH, HIGH(instruments)
000466 0feb                      	add ZL, r27 //point Z to offsetted instrument
000467 1df2                      	adc ZH, zero
000468 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
000469 1fff                      	rol ZH
00046a 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00046b 91b4                      	lpm r27, Z
                                 
00046c 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
00046d 1fbb                      	rol r27
00046e 2fea                      	mov ZL, r26
00046f 2ffb                      	mov ZH, r27
000470 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
000471 9632                      	adiw Z, 2 //point Z to the address of the macro
000472 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
000473 95aa                      	dec r26
000474 f019                      	breq sound_driver_channel0_instrument_change_exit
000475 95b6                      	lsr r27
000476 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
000477 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
000478 e0a3                      	ldi r26, 0x03
000479 e0b2                      	ldi r27, 0x02
00047a 93b0 2813                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00047c 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26
00047e 93b0 281f                 	sts pulse1_pitch_macro_offset, r27
000480 93b0 2825                 	sts pulse1_hi_pitch_macro_offset, r27
000482 93b0 282a                 	sts pulse1_duty_macro_offset, r27
000484 d0ba                      	rcall sound_driver_channel0_increment_offset_twice
000485 ce2b                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
000486 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
000487 91d5                      	lpm r29, Z+
                                 
000488 30a5                      	cpi r26, 5
000489 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
00048a 30a4                      	cpi r26, 4
00048b f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
00048c 30a3                      	cpi r26, 3
00048d f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
00048e 30a2                      	cpi r26, 2
00048f f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
000490 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
000491 93c0 2811                 	sts pulse1_volume_macro, r28
000493 93d0 2812                 	sts pulse1_volume_macro+1, r29
000495 d041                      	rcall sound_driver_channel0_instrument_change_read_header
000496 93c0 2815                 	sts pulse1_volume_macro_release, r28
000498 93d0 2814                 	sts pulse1_volume_macro_loop, r29
00049a cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
00049b 93c0 2816                 	sts pulse1_arpeggio_macro, r28
00049d 93d0 2817                 	sts pulse1_arpeggio_macro+1, r29
00049f 9220 2848                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0004a1 9220 2849                 	sts pulse1_fx_Qxy_target+1, zero
0004a3 9220 284e                 	sts pulse1_fx_Rxy_target, zero
0004a5 9220 284f                 	sts pulse1_fx_Rxy_target+1, zero
0004a7 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0004a8 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0004a9 93c0 281d                 	sts pulse1_pitch_macro, r28
0004ab 93d0 281e                 	sts pulse1_pitch_macro+1, r29
0004ad 9220 2848                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0004af 9220 2849                 	sts pulse1_fx_Qxy_target+1, zero
0004b1 9220 284e                 	sts pulse1_fx_Rxy_target, zero
0004b3 9220 284f                 	sts pulse1_fx_Rxy_target+1, zero
0004b5 d021                      	rcall sound_driver_channel0_instrument_change_read_header
0004b6 93c0 2821                 	sts pulse1_pitch_macro_release, r28
0004b8 93d0 2820                 	sts pulse1_pitch_macro_loop, r29
0004ba cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0004bb 93c0 2823                 	sts pulse1_hi_pitch_macro, r28
0004bd 93d0 2824                 	sts pulse1_hi_pitch_macro+1, r29
0004bf 9220 2848                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0004c1 9220 2849                 	sts pulse1_fx_Qxy_target+1, zero
0004c3 9220 284e                 	sts pulse1_fx_Rxy_target, zero
0004c5 9220 284f                 	sts pulse1_fx_Rxy_target+1, zero
0004c7 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
0004c8 93c0 2827                 	sts pulse1_hi_pitch_macro_release, r28
0004ca 93d0 2826                 	sts pulse1_hi_pitch_macro_loop, r29
0004cc cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
0004cd 93c0 2828                 	sts pulse1_duty_macro, r28
0004cf 93d0 2829                 	sts pulse1_duty_macro+1, r29
0004d1 d005                      	rcall sound_driver_channel0_instrument_change_read_header
0004d2 93c0 282c                 	sts pulse1_duty_macro_release, r28
0004d4 93d0 282b                 	sts pulse1_duty_macro_loop, r29
0004d6 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
0004d7 93ef                      	push ZL
0004d8 93ff                      	push ZH
0004d9 2fec                      	mov ZL, r28
0004da 2ffd                      	mov ZH, r29
0004db 0fee                      	lsl ZL
0004dc 1fff                      	rol ZH
0004dd 91c5                      	lpm r28, Z+
0004de 91d4                      	lpm r29, Z
0004df 91ff                      	pop ZH
0004e0 91ef                      	pop ZL
0004e1 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
0004e2 93ef                      	push ZL
0004e3 93ff                      	push ZH
0004e4 2fec                      	mov ZL, r28
0004e5 2ffd                      	mov ZH, r29
0004e6 0fee                      	lsl ZL
0004e7 1fff                      	rol ZH
0004e8 91c5                      	lpm r28, Z+
0004e9 91d5                      	lpm r29, Z+
0004ea 93c0 281a                 	sts pulse1_arpeggio_macro_release, r28
0004ec 93d0 2819                 	sts pulse1_arpeggio_macro_loop, r29
0004ee 91c4                      	lpm r28, Z
0004ef 93c0 281b                 	sts pulse1_arpeggio_macro_mode, r28
0004f1 91ff                      	pop ZH
0004f2 91ef                      	pop ZL
0004f3 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
0004f4 91b0 2815                 	lds r27, pulse1_volume_macro_release
0004f6 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0004f7 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
0004f8 95b3                      	inc r27
0004f9 93b0 2813                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
0004fb 91b0 281a                 	lds r27, pulse1_arpeggio_macro_release
0004fd 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
0004fe f019                      	breq sound_driver_channel0_release_pitch
0004ff 95b3                      	inc r27
000500 93b0 2818                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
000502 91b0 2821                 	lds r27, pulse1_pitch_macro_release
000504 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
000505 f019                      	breq sound_driver_channel0_release_hi_pitch
000506 95b3                      	inc r27
000507 93b0 281f                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
000509 91b0 2827                 	lds r27, pulse1_hi_pitch_macro_release
00050b 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00050c f019                      	breq sound_driver_channel0_release_duty
00050d 95b3                      	inc r27
00050e 93b0 2825                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
000510 91b0 282c                 	lds r27, pulse1_duty_macro_release
000512 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
000513 f019                      	breq sound_driver_channel0_release_exit
000514 95b3                      	inc r27
000515 93b0 282a                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
000517 d01d                      	rcall sound_driver_channel0_increment_offset
000518 cd98                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
000519 91e0 2808                 	lds ZL, song_frames
00051b 91f0 2809                 	lds ZH, song_frames+1
00051d 91a0 280a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00051f 91b0 280b                 	lds r27, song_frame_offset+1
000521 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
000522 93a0 280a                 	sts song_frame_offset, r26
000524 93b0 280b                 	sts song_frame_offset+1, r27
                                 	//adiw r27:r26, 2 //offset for channel 1 (test)
000526 0fea                      	add ZL, r26
000527 1ffb                      	adc ZH, r27
                                 
000528 91a5                      	lpm r26, Z+ //load the address of the next pattern
000529 91b4                      	lpm r27, Z
00052a 0faa                      	lsl r26
00052b 1fbb                      	rol r27
00052c 93a0 280c                 	sts pulse1_pattern, r26
00052e 93b0 280d                 	sts pulse1_pattern+1, r27
                                 
000530 9220 280f                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
000532 9220 2810                 	sts pulse1_pattern_offset+1, zero
000534 cd7c                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
000535 91e0 280f                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
000537 91f0 2810                 	lds ZH, pulse1_pattern_offset+1
000539 9631                      	adiw Z, 1
00053a 93e0 280f                 	sts pulse1_pattern_offset, ZL
00053c 93f0 2810                 	sts pulse1_pattern_offset+1, ZH
00053e 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00053f 91e0 280f                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
000541 91f0 2810                 	lds ZH, pulse1_pattern_offset+1
000543 9632                      	adiw Z, 2 //increment the pointer twice
000544 93e0 280f                 	sts pulse1_pattern_offset, ZL
000546 93f0 2810                 	sts pulse1_pattern_offset+1, ZH
000548 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_decrement_frame_delay:
000549 95ba                      	dec r27
00054a 93b0 280e                 	sts pulse1_pattern_delay, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine:
                                 sound_driver_instrument_routine_channel0_volume:
00054c 91e0 2811                 	lds ZL, pulse1_volume_macro
00054e 91f0 2812                 	lds ZH, pulse1_volume_macro+1
000550 9630                      	adiw Z, 0
000551 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
000552 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
000553 1fff                      	rol ZH
000554 91a0 2813                 	lds r26, pulse1_volume_macro_offset
000556 0fea                      	add ZL, r26
000557 1df2                      	adc ZH, zero
                                 
000558 91b0 2815                 	lds r27, pulse1_volume_macro_release
00055a 17ba                      	cp r27, r26
00055b f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
00055c 91a0 2814                 	lds r26, pulse1_volume_macro_loop
00055e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00055f f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
000560 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
000561 95a3                      	inc r26 //increment the macro offset
000562 93a0 2813                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
000564 91b4                      	lpm r27, Z //load volume data into r27
000565 3fbf                      	cpi r27, 0xFF //check for macro end flag
000566 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
000567 91b0 2815                 	lds r27, pulse1_volume_macro_release
000569 3fbf                      	cpi r27, 0xFF
00056a f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
00056b 91b0 2814                 	lds r27, pulse1_volume_macro_loop //load the loop index
00056d 93b0 2813                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00056f cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
000570 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
000571 93a0 2813                 	sts pulse1_volume_macro_offset, r26
000573 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
000574 e3e8                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
000575 e1f2                      	ldi ZH, HIGH(volumes << 1)
000576 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
000577 0feb                      	add ZL, r27 //add offset to the table
000578 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
000579 91b0 2800                 	lds r27, pulse1_param //load main volume
00057b 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00057c 91a0 2845                 	lds r26, pulse1_fx_7xy_value
00057e 30a0                      	cpi r26, 0x00
00057f f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
000580 0feb                      	add ZL, r27 //offset the volume table by the main volume
000581 1df2                      	adc ZH, zero
000582 91b4                      	lpm r27, Z
000583 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
000585 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
000586 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
000588 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
000589 91a0 2845                 	lds r26, pulse1_fx_7xy_value
00058b 30a0                      	cpi r26, 0x00
00058c f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
00058d 93b0 2806                 	sts pulse1_output_volume, r27
00058f c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
000590 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
000591 f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
000592 f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
000593 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
000594 0feb                      	add ZL, r27 //offset the volume table by the main volume
000595 1df2                      	adc ZH, zero
000596 91b4                      	lpm r27, Z
000597 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
000599 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
00059a e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00059b 0feb                      	add ZL, r27 //offset the volume table by the main volume
00059c 1df2                      	adc ZH, zero
00059d 91b4                      	lpm r27, Z
00059e 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0005a0 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
0005a1 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0005a2 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0005a3 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0005a4 93b0 2806                 	sts pulse1_output_volume, r27
0005a6 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
0005a7 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0005a8 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0005aa 91e0 2816                 	lds ZL, pulse1_arpeggio_macro
0005ac 91f0 2817                 	lds ZH, pulse1_arpeggio_macro+1
0005ae 9630                      	adiw Z, 0
0005af f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0005b0 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0005b1 1fff                      	rol ZH
0005b2 91a0 2818                 	lds r26, pulse1_arpeggio_macro_offset
0005b4 0fea                      	add ZL, r26
0005b5 1df2                      	adc ZH, zero
                                 
0005b6 91b0 281a                 	lds r27, pulse1_arpeggio_macro_release
0005b8 17ba                      	cp r27, r26
0005b9 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0005ba 91a0 2819                 	lds r26, pulse1_arpeggio_macro_loop
0005bc 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0005bd f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0005be c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
0005bf 95a3                      	inc r26 //increment the macro offset
0005c0 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
0005c2 91b4                      	lpm r27, Z //load arpeggio data into r27
0005c3 38b0                      	cpi r27, 0x80 //check for macro end flag
0005c4 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
0005c5 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0005c6 50a1                      	subi r26, 1 //keep the offset at the end flag
0005c7 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26
0005c9 91b0 281b                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0005cb 30b1                      	cpi r27, 0x01
0005cc f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0005cd 91b0 281a                 	lds r27, pulse1_arpeggio_macro_release
0005cf 3fbf                      	cpi r27, 0xFF
0005d0 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0005d1 91b0 2819                 	lds r27, pulse1_arpeggio_macro_loop
0005d3 3fbf                      	cpi r27, 0xFF
0005d4 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0005d5 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0005d6 91b0 281a                 	lds r27, pulse1_arpeggio_macro_release
0005d8 3fbf                      	cpi r27, 0xFF
0005d9 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0005da 91b0 2819                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0005dc 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0005dd f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0005de 91c0 282d                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0005e0 91d0 282e                 	lds r29, pulse1_fx_0xy_sequence+1
0005e2 9620                      	adiw r29:r28, 0
0005e3 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0005e4 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0005e5 93a0 2818                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0005e7 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0005e8 93b0 2818                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0005ea cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0005eb 91c0 282d                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0005ed 91d0 282e                 	lds r29, pulse1_fx_0xy_sequence+1
0005ef 9620                      	adiw r29:r28, 0 //check for 0xy effect
0005f0 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
0005f1 95d6                      	lsr r29
0005f2 95c7                      	ror r28
0005f3 95d7                      	ror r29
0005f4 95c7                      	ror r28
0005f5 95d7                      	ror r29
0005f6 95c7                      	ror r28
0005f7 95d7                      	ror r29
0005f8 95c7                      	ror r28
0005f9 95d7                      	ror r29
0005fa 95d2                      	swap r29
                                 
0005fb 93c0 282d                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0005fd 93d0 282e                 	sts pulse1_fx_0xy_sequence+1, r29
0005ff 70cf                      	andi r28, 0x0F //mask out the 4 LSB
000600 91a0 2807                 	lds r26, pulse1_note //load the current note index
000602 0fac                      	add r26, r28 //add the note offset
000603 c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
000604 91a0 2807                 	lds r26, pulse1_note //load the current note index
000606 c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
000607 9220 281c                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
000609 9220 2822                 	sts pulse1_total_hi_pitch_offset, zero
00060b 91a0 281b                 	lds r26, pulse1_arpeggio_macro_mode
00060d 30a1                      	cpi r26, 0x01 //absolute mode
00060e f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
00060f f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
000610 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
000611 91a0 2807                 	lds r26, pulse1_note //load the current note index
000613 0fab                      	add r26, r27 //offset the note with the arpeggio data
000614 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
000615 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
000616 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
000617 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
000618 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
000619 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
00061a fda7                      	sbrc r26, 7 //check if result is negative
00061b e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00061c c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
00061d 2fab                      	mov r26, r27 //move the arpeggio data into r26
00061e c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
00061f 91a0 2807                 	lds r26, pulse1_note //load the current note index
000621 0fab                      	add r26, r27 //offset the note with the arpeggio data
000622 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
000623 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
000624 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
000626 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
000627 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
000628 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
000629 93a0 2807                 	sts pulse1_note, r26
00062b c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
00062c fda7                      	sbrc r26, 7 //check if result is negative
00062d e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00062e 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
000630 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
000631 e0f0                      	ldi ZH, HIGH(note_table << 1)
000632 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
000633 0fea                      	add ZL, r26 //add offset
000634 1df2                      	adc ZH, zero
000635 91a5                      	lpm r26, Z+ //load bytes
000636 91b4                      	lpm r27, Z
000637 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
000639 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
00063b 93a0 2839                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00063d 93b0 283a                 	sts pulse1_fx_3xx_target+1, r27
00063f c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
000640 91e0 281d                 	lds ZL, pulse1_pitch_macro
000642 91f0 281e                 	lds ZH, pulse1_pitch_macro+1
000644 9630                      	adiw Z, 0
000645 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
000646 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
000647 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
000648 1fff                      	rol ZH
000649 91a0 281f                 	lds r26, pulse1_pitch_macro_offset
00064b 0fea                      	add ZL, r26
00064c 1df2                      	adc ZH, zero
                                 
00064d 91b0 2821                 	lds r27, pulse1_pitch_macro_release
00064f 17ba                      	cp r27, r26
000650 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
000651 91a0 2820                 	lds r26, pulse1_pitch_macro_loop
000653 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
000654 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
000655 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
000656 95a3                      	inc r26 //increment the macro offset
000657 93a0 281f                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
000659 91b4                      	lpm r27, Z //load pitch data into r27
00065a 38b0                      	cpi r27, 0x80 //check for macro end flag
00065b f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
00065c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00065d 93a0 281f                 	sts pulse1_pitch_macro_offset, r26
00065f 91b0 2821                 	lds r27, pulse1_pitch_macro_release
000661 3fbf                      	cpi r27, 0xFF
000662 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
000663 91b0 2820                 	lds r27, pulse1_pitch_macro_loop //load the loop index
000665 3fbf                      	cpi r27, 0xFF //check if there is a loop index
000666 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
000667 93b0 281f                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
000669 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
00066a 91b0 281c                 	lds r27, pulse1_total_pitch_offset
00066c c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
00066d 91a0 281c                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
00066f 0fba                      	add r27, r26
000670 93b0 281c                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
000672 91a0 2846                 	lds r26, pulse1_fx_Pxx
000674 0fba                      	add r27, r26
                                 
000675 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
000676 937f                      	push r23
000677 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
000678 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
000679 0367                      	mulsu r22, r23
00067a 917f                      	pop r23
00067b 916f                      	pop r22
                                 
00067c 9416                      	lsr r1 //shift out the fractional bits
00067d 9407                      	ror r0
00067e 9416                      	lsr r1
00067f 9407                      	ror r0
000680 9416                      	lsr r1
000681 9407                      	ror r0
000682 9416                      	lsr r1
000683 9407                      	ror r0
000684 fe13                      	sbrs r1, 3 //check if result was a negative number
000685 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
000686 efb0                      	ldi r27, 0xF0
000687 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
000688 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00068a 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00068c 0da0                      	add r26, r0 //offset the timer values
00068d 1db1                      	adc r27, r1
                                 	
00068e 91c0 2831                 	lds r28, pulse1_fx_1xx_total
000690 91d0 2832                 	lds r29, pulse1_fx_1xx_total+1
000692 1bac                      	sub r26, r28
000693 0bbd                      	sbc r27, r29
000694 91c0 2835                 	lds r28, pulse1_fx_2xx_total
000696 91d0 2836                 	lds r29, pulse1_fx_2xx_total+1
000698 0fac                      	add r26, r28
000699 1fbd                      	adc r27, r29
00069a 91c0 284c                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00069c 91d0 284d                 	lds r29, pulse1_fx_Qxy_total_offset+1
00069e 1bac                      	sub r26, r28
00069f 0bbd                      	sbc r27, r29
0006a0 91c0 2852                 	lds r28, pulse1_fx_Rxy_total_offset
0006a2 91d0 2853                 	lds r29, pulse1_fx_Rxy_total_offset+1
0006a4 0fac                      	add r26, r28
0006a5 1fbd                      	adc r27, r29
                                 
0006a6 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0006a8 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
0006aa 91e0 2823                 	lds ZL, pulse1_hi_pitch_macro
0006ac 91f0 2824                 	lds ZH, pulse1_hi_pitch_macro+1
0006ae 9630                      	adiw Z, 0
0006af f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
0006b0 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
0006b1 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0006b2 1fff                      	rol ZH
0006b3 91a0 2825                 	lds r26, pulse1_hi_pitch_macro_offset
0006b5 0fea                      	add ZL, r26
0006b6 1df2                      	adc ZH, zero
                                 
0006b7 91b0 2827                 	lds r27, pulse1_hi_pitch_macro_release
0006b9 17ba                      	cp r27, r26
0006ba f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0006bb 91a0 2826                 	lds r26, pulse1_hi_pitch_macro_loop
0006bd 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0006be f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0006bf c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
0006c0 95a3                      	inc r26 //increment the macro offset
0006c1 93a0 2825                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
0006c3 91b4                      	lpm r27, Z //load hi pitch data into r27
0006c4 38b0                      	cpi r27, 0x80 //check for macro end flag
0006c5 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
0006c6 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0006c7 93a0 2825                 	sts pulse1_hi_pitch_macro_offset, r26
0006c9 91b0 2827                 	lds r27, pulse1_hi_pitch_macro_release
0006cb 3fbf                      	cpi r27, 0xFF
0006cc f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0006cd 91b0 2826                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0006cf 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0006d0 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0006d1 93b0 2825                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0006d3 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0006d4 91b0 2822                 	lds r27, pulse1_total_hi_pitch_offset
0006d6 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0006d7 91a0 2822                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0006d9 0fba                      	add r27, r26
0006da 93b0 2822                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0006dc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0006dd 937f                      	push r23
0006de 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0006df eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0006e0 0367                      	mulsu r22, r23
0006e1 917f                      	pop r23
0006e2 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0006e3 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0006e5 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0006e7 0da0                      	add r26, r0 //offset the timer values
0006e8 1db1                      	adc r27, r1
0006e9 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0006eb 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0006ed 91e0 2828                 	lds ZL, pulse1_duty_macro
0006ef 91f0 2829                 	lds ZH, pulse1_duty_macro+1
0006f1 9630                      	adiw Z, 0
0006f2 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0006f3 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0006f4 1fff                      	rol ZH
0006f5 91a0 282a                 	lds r26, pulse1_duty_macro_offset
0006f7 0fea                      	add ZL, r26
0006f8 1df2                      	adc ZH, zero
                                 
0006f9 91b0 282c                 	lds r27, pulse1_duty_macro_release
0006fb 17ba                      	cp r27, r26
0006fc f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0006fd 91a0 282b                 	lds r26, pulse1_duty_macro_loop
0006ff 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
000700 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
000701 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
000702 95a3                      	inc r26 //increment the macro offset
000703 93a0 282a                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
000705 91b4                      	lpm r27, Z //load pitch data into r27
000706 3fbf                      	cpi r27, 0xFF //check for macro end flag
000707 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
000708 50a1                      	subi r26, 1 //keep the macro offset at the end flag
000709 93a0 282a                 	sts pulse1_duty_macro_offset, r26
00070b 91b0 282c                 	lds r27, pulse1_duty_macro_release
00070d 3fbf                      	cpi r27, 0xFF
00070e f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
00070f 91b0 282b                 	lds r27, pulse1_duty_macro_loop //load the loop index
000711 3fbf                      	cpi r27, 0xFF //check if there is a loop index
000712 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
000713 93b0 282a                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
000715 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
000716 e0e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
000717 e1f2                      	ldi ZH, HIGH(sequences << 1)
000718 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
000719 1df2                      	adc ZH, zero
                                 
00071a 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00071b 95b7                      	ror r27
00071c 95b7                      	ror r27
00071d 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
00071f 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
000720 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
000721 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
000722 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
000723 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
000724 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
000725 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
000726 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
000727 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
000729 91e0 282f                 	lds ZL, pulse1_fx_1xx
00072b 91f0 2830                 	lds ZH, pulse1_fx_1xx+1
00072d 9630                      	adiw Z, 0
00072e f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
00072f 91a0 2831                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
000731 91b0 2832                 	lds r27, pulse1_fx_1xx_total+1
000733 0fae                      	add r26, ZL //increase the total offset by the rate
000734 1fbf                      	adc r27, ZH
000735 93a0 2831                 	sts pulse1_fx_1xx_total, r26
000737 93b0 2832                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
000739 91e0 2833                 	lds ZL, pulse1_fx_2xx
00073b 91f0 2834                 	lds ZH, pulse1_fx_2xx+1
00073d 9630                      	adiw Z, 0
00073e f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
00073f 91a0 2835                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
000741 91b0 2836                 	lds r27, pulse1_fx_2xx_total+1
000743 0fae                      	add r26, ZL //increase the total offset by the rate
000744 1fbf                      	adc r27, ZH
000745 93a0 2835                 	sts pulse1_fx_2xx_total, r26
000747 93b0 2836                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
000749 91e0 283b                 	lds ZL, pulse1_fx_3xx_speed
00074b 91f0 283c                 	lds ZH, pulse1_fx_3xx_speed+1
00074d 9630                      	adiw Z, 0
00074e f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
00074f c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
000750 91a0 2837                 	lds r26, pulse1_fx_3xx_start
000752 91b0 2838                 	lds r27, pulse1_fx_3xx_start+1
000754 9610                      	adiw r26:r27, 0
000755 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
000756 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
000757 91c0 2839                 	lds r28, pulse1_fx_3xx_target
000759 91d0 283a                 	lds r29, pulse1_fx_3xx_target+1
                                 
00075b 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00075c 07bd                      	cpc r27, r29
00075d f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
00075e f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00075f c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
000760 9220 2837                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
000762 9220 2838                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
000764 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
000765 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
000766 0bdb                      	sbc r29, r27
000767 91a0 283d                 	lds r26, pulse1_fx_3xx_total_offset
000769 91b0 283e                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
00076b 0fae                      	add r26, ZL //add the speed to the total offset
00076c 1fbf                      	adc r27, ZH
00076d 1bca                      	sub r28, r26 //invert the total difference with the total offset
00076e 0bdb                      	sbc r29, r27
00076f f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
000770 93a0 283d                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
000772 93b0 283e                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
000774 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
000776 91b0 0a8d                 	lds r27, TCB0_CCMPH
000778 1bac                      	sub r26, r28 //offset the current timer period with the total offset
000779 0bbd                      	sbc r27, r29
00077a 93a0 0a8c                 	sts TCB0_CCMPL, r26
00077c 93b0 0a8d                 	sts TCB0_CCMPH, r27
00077e c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
00077f 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
000780 0bbd                      	sbc r27, r29
000781 91c0 283d                 	lds r28, pulse1_fx_3xx_total_offset
000783 91d0 283e                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
000785 0fce                      	add r28, ZL //add the speed to the total offset
000786 1fdf                      	adc r29, ZH
000787 1bac                      	sub r26, r28 //invert the total difference with the total offset
000788 0bbd                      	sbc r27, r29
000789 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00078a 93c0 283d                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
00078c 93d0 283e                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
00078e 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
000790 91d0 0a8d                 	lds r29, TCB0_CCMPH
000792 0fca                      	add r28, r26 //offset the current timer period with the total offset
000793 1fdb                      	adc r29, r27
000794 93c0 0a8c                 	sts TCB0_CCMPL, r28
000796 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
000798 91a0 283f                 	lds r26, pulse1_fx_4xy_speed
00079a 15a2                      	cp r26, zero
00079b f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
00079c c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00079d 91b0 2840                 	lds r27, pulse1_fx_4xy_depth
00079f 91c0 2841                 	lds r28, pulse1_fx_4xy_phase
0007a1 0fca                      	add r28, r26 //increase the phase by the speed
0007a2 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0007a3 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0007a4 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
0007a5 93c0 2841                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
0007a7 31c0                      	cpi r28, 16
0007a8 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
0007a9 32c0                      	cpi r28, 32
0007aa f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
0007ab 33c0                      	cpi r28, 48
0007ac f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
0007ad c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
0007ae 70cf                      	andi r28, 0x0F //mask for values 0-15
0007af c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
0007b0 6fc0                      	ori r28, 0xF0
0007b1 95c0                      	com r28 //invert values 0-15
0007b2 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
0007b3 70cf                      	andi r28, 0x0F //mask for values 0-15
0007b4 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
0007b5 6fc0                      	ori r28, 0xF0
0007b6 95c0                      	com r28 //invert values 0-15
0007b7 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
0007b8 95b2                      	swap r27 //multiply depth by 16
0007b9 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0007ba eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0007bb e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
0007bc 0fec                      	add ZL, r28 //offset the table by the depth+phase
0007bd 1df2                      	adc ZH, zero
0007be 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0007bf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0007c0 937f                      	push r23
0007c1 2f6c                      	mov r22, r28 //store the vibrato value into r22
0007c2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0007c3 9f67                      	mul r22, r23
0007c4 917f                      	pop r23
0007c5 916f                      	pop r22
                                 
0007c6 9416                      	lsr r1 //shift out the fractional bits
0007c7 9407                      	ror r0
0007c8 9416                      	lsr r1
0007c9 9407                      	ror r0
0007ca 9416                      	lsr r1
0007cb 9407                      	ror r0
0007cc 9416                      	lsr r1
0007cd 9407                      	ror r0
                                 	
0007ce 91a0 0a8c                 	lds r26, TCB0_CCMPL
0007d0 91b0 0a8d                 	lds r27, TCB0_CCMPH
0007d2 0da0                      	add r26, r0
0007d3 1db1                      	adc r27, r1
0007d4 93a0 0a8c                 	sts TCB0_CCMPL, r26
0007d6 93b0 0a8d                 	sts TCB0_CCMPH, r27
0007d8 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
0007d9 95b2                      	swap r27 //multiply depth by 16
0007da 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0007db eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0007dc e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
0007dd 0fec                      	add ZL, r28 //offset the table by the depth+phase
0007de 1df2                      	adc ZH, zero
0007df 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0007e0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0007e1 937f                      	push r23
0007e2 2f6c                      	mov r22, r28 //store the vibrato value into r22
0007e3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0007e4 9f67                      	mul r22, r23
0007e5 917f                      	pop r23
0007e6 916f                      	pop r22
                                 
0007e7 9416                      	lsr r1 //shift out the fractional bits
0007e8 9407                      	ror r0
0007e9 9416                      	lsr r1
0007ea 9407                      	ror r0
0007eb 9416                      	lsr r1
0007ec 9407                      	ror r0
0007ed 9416                      	lsr r1
0007ee 9407                      	ror r0
                                 
0007ef 91a0 0a8c                 	lds r26, TCB0_CCMPL
0007f1 91b0 0a8d                 	lds r27, TCB0_CCMPH
0007f3 19a0                      	sub r26, r0
0007f4 09b1                      	sbc r27, r1
0007f5 93a0 0a8c                 	sts TCB0_CCMPL, r26
0007f7 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0007f9 91a0 2842                 	lds r26, pulse1_fx_7xy_speed
0007fb 15a2                      	cp r26, zero
0007fc f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0007fd 91b0 2843                 	lds r27, pulse1_fx_7xy_depth
0007ff 91c0 2844                 	lds r28, pulse1_fx_7xy_phase
000801 0fca                      	add r28, r26 //increase the phase by the speed
000802 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
000803 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
000804 e0c0                      	ldi r28, 0x00
000805 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
000806 93c0 2844                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
000808 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
000809 ffc4                      	sbrs r28, 4
00080a c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
00080b c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
00080c 70cf                      	andi r28, 0x0F //mask for values 0-15
00080d c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
00080e 6fc0                      	ori r28, 0xF0
00080f 95c0                      	com r28 //invert values 0-15
000810 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
000811 95b2                      	swap r27 //multiply depth by 16
000812 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
000813 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
000814 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
000815 0fec                      	add ZL, r28 //offset the table by the depth+phase
000816 1df2                      	adc ZH, zero
000817 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
000818 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
000819 93c0 2845                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
00081b 91b0 2847                 	lds r27, pulse1_fx_Axy
00081d 15b2                      	cp r27, zero
00081e f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00081f 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
000821 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
000823 2fda                      	mov r29, r26 //copy fractional volume into r29
000824 2fec                      	mov r30, r28 //copy the pulse1_param into r30
000825 95e2                      	swap r30
000826 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
000827 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
000828 17ed                      	cp r30, r29 //compare the fractional and integer volumes
000829 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
00082a 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
00082b fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
00082c c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
00082d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00082e f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00082f efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
000830 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
000831 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
000832 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
000833 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
000834 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
000836 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
000837 95a2                      	swap r26
000838 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
000839 2bca                      	or r28, r26 //store the new volume back into pulse1_param
00083a 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
00083c 91e0 2848                 	lds ZL, pulse1_fx_Qxy_target
00083e 91f0 2849                 	lds ZH, pulse1_fx_Qxy_target+1
000840 9630                      	adiw Z, 0
000841 f131                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
000842 91a0 284c                 	lds r26, pulse1_fx_Qxy_total_offset
000844 91b0 284d                 	lds r27, pulse1_fx_Qxy_total_offset+1
000846 91c0 0a8c                 	lds r28, TCB0_CCMPL
000848 91d0 0a8d                 	lds r29, TCB0_CCMPH
00084a 1bca                      	sub r28, r26 //subtract the timer period by the total offset
00084b 0bdb                      	sbc r29, r27
                                 
00084c 17ce                      	cp r28, ZL //compare the new timer period with the target
00084d 07df                      	cpc r29, ZH
00084e f010                      	brlo sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
00084f f009                      	breq sound_driver_channel0_fx_Qxy_routine_end
000850 f468                      	brsh sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
000851 1bec                      	sub ZL, r28 //calculate the difference to the target
000852 0bfd                      	sbc ZH, r29
000853 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
000854 1fbf                      	adc r27, ZH
000855 93a0 284c                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
000857 93b0 284d                 	sts pulse1_fx_Qxy_total_offset+1, r27
000859 9220 2848                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
00085b 9220 2849                 	sts pulse1_fx_Qxy_target+1, zero
00085d c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
00085e 91c0 284a                 	lds r28, pulse1_fx_Qxy_speed
000860 91d0 284b                 	lds r29, pulse1_fx_Qxy_speed+1
000862 0fac                      	add r26, r28 //increase the total offset by the speed
000863 1fbd                      	adc r27, r29
000864 93a0 284c                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
000866 93b0 284d                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
000868 91e0 284e                 	lds ZL, pulse1_fx_Rxy_target
00086a 91f0 284f                 	lds ZH, pulse1_fx_Rxy_target+1
00086c 9630                      	adiw Z, 0
00086d f131                      	breq sound_driver_channel0_fx_xy_routine //if the effect is not enabled, skip the routine
                                 
00086e 91a0 2852                 	lds r26, pulse1_fx_Rxy_total_offset
000870 91b0 2853                 	lds r27, pulse1_fx_Rxy_total_offset+1
000872 91c0 0a8c                 	lds r28, TCB0_CCMPL
000874 91d0 0a8d                 	lds r29, TCB0_CCMPH
000876 0fca                      	add r28, r26 //add the total offset to the timer period
000877 0fdb                      	add r29, r27
                                 
000878 17ce                      	cp r28, ZL //compare the new timer period with the target
000879 07df                      	cpc r29, ZH
00087a f010                      	brlo sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
00087b f009                      	breq sound_driver_channel0_fx_Rxy_routine_end
00087c f468                      	brsh sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
00087d 1bec                      	sub ZL, r28 //calculate the difference to the target
00087e 0bfd                      	sbc ZH, r29
00087f 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
000880 1fbf                      	adc r27, ZH
000881 93a0 2852                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
000883 93b0 2853                 	sts pulse1_fx_Rxy_total_offset+1, r27
000885 9220 284e                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
000887 9220 284f                 	sts pulse1_fx_Rxy_target+1, zero
000889 c00a                      	rjmp sound_driver_channel0_fx_xy_routine
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
00088a 91c0 2850                 	lds r28, pulse1_fx_Rxy_speed
00088c 91d0 2851                 	lds r29, pulse1_fx_Rxy_speed+1
00088e 0fac                      	add r26, r28 //increase the total offset by the speed
00088f 1fbd                      	adc r27, r29
000890 93a0 2852                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
000892 93b0 2853                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 sound_driver_channel0_fx_xy_routine:
                                 
                                 sound_driver_exit:
000894 91df                      	pop r29
000895 91cf                      	pop r28
000896 ca04                      	rjmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
000897 b7bf                      	in r27, CPU_SREG
000898 93bf                      	push r27
000899 94f8                      	cli
                                 
00089a 0cdd                      	lsl pulse1_sequence //shifts sequence to the left
00089b 1cd2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00089c e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00089d 93b0 0a86                 	sts TCB0_INTFLAGS, r27
00089f 91bf                      	pop r27
0008a0 bfbf                      	out CPU_SREG, r27
0008a1 9518                      	reti
                                 
                                 pulse1_sweep_routine:
0008a2 2dbf                      	mov r27, pulse1_sweep
0008a3 70b7                      	andi r27, 0x07 //mask for period divider bits
0008a4 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0008a5 93df                      	push r29
0008a6 2ddf                      	mov r29, pulse1_sweep
0008a7 95d2                      	swap r29
0008a8 70d7                      	andi r29, 0x07 //mask for shift bits
0008a9 f409                      	brne PC+2 //check of shift == 0
0008aa 91df                      	pop r29
0008ab c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
0008ac 91a0 0a8c                 	lds r26, TCB0_CCMPL
0008ae 91b0 0a8d                 	lds r27, TCB0_CCMPH
0008b0 95b6                      	lsr r27
0008b1 95a7                      	ror r26
0008b2 95da                      	dec r29
0008b3 f7e1                      	brne PC-3 //keep looping/shifting until shift count is 0
                                 
0008b4 fef7                      	sbrs pulse1_sweep, 7 //check the negate flag
0008b5 c002                      	rjmp PC+3 //if negate flag was clear, go straight to addition
                                 
0008b6 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
0008b7 95b0                      	com r27
                                 
0008b8 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
0008ba 0fad                      	add r26, r29
0008bb 91d0 0a8d                 	lds r29, TCB0_CCMPH
0008bd 1fbd                      	adc r27, r29
                                 
0008be 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
0008c0 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 
                                 	//sts pulse1_timerL, r26
                                 	//sts pulse1_timerH, r27
                                 
                                 /*	//Sweep Test
                                 	mov r29, pulse1_sweep //invert the negate bit
                                 	ldi r27, 0b10000000
                                 	eor r29, r27
                                 	ori r29, 0b01111111
                                 
                                 	lds r27, pulse1_sweep_param //reload the pulse sweep divider params
                                 	swap r27
                                 	ori r27, 0b10000000
                                 	and r27, r29
                                 	mov pulse1_sweep, r27
                                 	sbr channel_flags, 0b10000000*/
                                 	
0008c2 91df                      	pop r29
0008c3 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
0008c4 94fa                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
0008c5 ff97                      	sbrs channel_flags, 7 //if the reload flag is set, reload the sweep divider
0008c6 9508                      	ret
                                 
                                 pulse1_sweep_reload:
0008c7 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0008c9 94f2                      	swap pulse1_sweep //bring data from high byte to low byte
0008ca 779f                      	cbr channel_flags, 0b10000000 //clear ready flag
0008cb 9508                      	ret
                                 
                                 pulse1_envelope_routine:
0008cc fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
0008cd c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
0008ce 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0008cf f011                      	breq PC+3 //if the divider == 0, check loop flag
0008d0 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0008d1 9508                      	ret
                                 
0008d2 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0008d4 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0008d5 ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
0008d6 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0008d7 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0008d8 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
0008d9 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0008da f409                      	brne PC+2 //if decay != 0, go decrement
0008db 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0008dc 951a                      	dec pulse1_volume_decay
0008dd 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0008de 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
0008df 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0008e1 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0008e2 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0008e3 9508                      	ret
                                 
                                 //CONVERTERS (TABLES)
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0008e4 ede4                      	ldi ZL, LOW(length << 1)
0008e5 e1f1                      	ldi ZH, HIGH(length << 1)
0008e6 0fed                      	add ZL, r29
0008e7 1df2                      	adc ZH, zero
0008e8 91d4                      	lpm r29, Z
0008e9 9508                      	ret
                                 
0008ea 7f05
0008eb 010a
0008ec 0214
0008ed 0328
0008ee 0450
0008ef 051e
0008f0 0607
0008f1 070d
0008f2 0806
0008f3 090c
0008f4 0a18
0008f5 0b30
0008f6 0c60
0008f7 0d24
0008f8 0e08
0008f9 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0008fa e0e0                      	ldi ZL, LOW(sequences << 1)
0008fb e1f2                      	ldi ZH, HIGH(sequences << 1)
0008fc 0fed                      	add ZL, r29
0008fd 1df2                      	adc ZH, zero
0008fe 91d4                      	lpm r29, Z
0008ff 9508                      	ret
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
000900 0301
000901 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 fx:
000902 02db
000903 02e0
000904 02fc
000905 0318
000906 033b                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
000907 0346
000908 0353
000909 0356
00090a 0357
00090b 0358                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
00090c 0359
00090d 035a
00090e 035b
00090f 035c
000910 035d                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_lxy
000911 035e
000912 035f
000913 0360
000914 0363
000915 03a7                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
000916 03ea
000917 03eb
000918 03ff
000919 0400
00091a 0401                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
00091b 0402                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
00091c 0000
00091d 0000
00091e 0000
00091f 0000
000920 0000
000921 0000
000922 0000
000923 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
000924 0100
000925 0101
000926 0101
000927 0101
000928 0101
000929 0101
00092a 0101
00092b 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
00092c 0100
00092d 0101
00092e 0101
00092f 0101
000930 0101
000931 0101
000932 0101
000933 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
000934 0100
000935 0101
000936 0101
000937 0101
000938 0101
000939 0202
00093a 0202
00093b 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
00093c 0100
00093d 0101
00093e 0101
00093f 0101
000940 0202
000941 0202
000942 0303
000943 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
000944 0100
000945 0101
000946 0101
000947 0202
000948 0302
000949 0303
00094a 0404
00094b 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
00094c 0100
00094d 0101
00094e 0201
00094f 0202
000950 0303
000951 0404
000952 0504
000953 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
000954 0100
000955 0101
000956 0201
000957 0302
000958 0403
000959 0504
00095a 0605
00095b 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
00095c 0100
00095d 0101
00095e 0202
00095f 0303
000960 0404
000961 0505
000962 0606
000963 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
000964 0100
000965 0101
000966 0302
000967 0403
000968 0504
000969 0606
00096a 0707
00096b 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
00096c 0100
00096d 0201
00096e 0302
00096f 0404
000970 0605
000971 0706
000972 0808
000973 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
000974 0100
000975 0201
000976 0302
000977 0504
000978 0605
000979 0807
00097a 0908
00097b 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
00097c 0100
00097d 0201
00097e 0403
00097f 0504
000980 0706
000981 0808
000982 0a09
000983 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
000984 0100
000985 0201
000986 0403
000987 0605
000988 0706
000989 0908
00098a 0b0a
00098b 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
00098c 0100
00098d 0201
00098e 0403
00098f 0605
000990 0807
000991 0a09
000992 0c0b
000993 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
000994 0100
000995 0302
000996 0504
000997 0706
000998 0908
000999 0b0a
00099a 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  :  61 r0 :  41 r1 :  43 r2 : 164 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   0 r19:   0 r20:   0 
r21:   0 r22:  36 r23:  36 r24:   0 r25:  11 r26: 225 r27: 348 r28: 130 
r29:  98 r30:  92 r31:  87 
Registers used: 18 out of 35 (51.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  40 add   :  55 adiw  :  25 and   :   0 
andi  :  30 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   4 break :   0 breq  :  40 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  23 brlt  :   0 brmi  :   0 
brne  :  32 brpl  :   0 brsh  :   6 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   2 
clc   :   0 clh   :   0 cli   :   4 cln   :   0 clr   :   1 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   5 cp    :  18 cpc   :   3 
cpi   :  48 cpse  :   5 dec   :   7 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :   4 inc   :  12 
jmp   :   6 ld    :   0 ldd   :   0 ldi   :  85 lds   : 175 lpm   :  68 
lsl   :  19 lsr   :  39 mov   :  31 movw  :   0 mul   :   7 muls  :   0 
mulsu :   2 neg   :   0 nop   :   0 or    :   5 ori   :   3 out   :   6 
pop   :  29 push  :  29 rcall :  16 ret   :  13 reti  :   3 rjmp  : 125 
rol   :  13 ror   :  45 sbc   :  11 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   3 sbrc  :   8 sbrs  :   6 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   : 319 sub   :  14 subi  :  11 swap  :  14 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x001338   3890   1002   4892   49152  10.0%
[.dseg] 0x002800 0x002858      0     88     88    6144   1.4%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 2 warnings
