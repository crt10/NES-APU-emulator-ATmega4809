
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Wed Jan 13 23:36:17 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4002 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           song_frames: .byte 2
00280a                           song_frame_offset: .byte 2
00280c                           song_size: .byte 2
00280e                           song_speed: .byte 1
00280f                           song_fx_Bxx: .byte 1
002810                           song_fx_Cxx: .byte 1
002811                           song_fx_Dxx: .byte 1
                                 
                                 
002812                           pulse1_pattern: .byte 2
002814                           pulse1_pattern_delay: .byte 2
002816                           pulse1_pattern_offset: .byte 2
                                 
002818                           pulse1_volume_macro: .byte 2
00281a                           pulse1_volume_macro_offset: .byte 1
00281b                           pulse1_volume_macro_loop: .byte 1
00281c                           pulse1_volume_macro_release: .byte 1
                                 
00281d                           pulse1_arpeggio_macro: .byte 2
00281f                           pulse1_arpeggio_macro_offset: .byte 1
002820                           pulse1_arpeggio_macro_loop: .byte 1
002821                           pulse1_arpeggio_macro_release: .byte 1
002822                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002823                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
002824                           pulse1_pitch_macro: .byte 2
002826                           pulse1_pitch_macro_offset: .byte 1
002827                           pulse1_pitch_macro_loop: .byte 1
002828                           pulse1_pitch_macro_release: .byte 1
                                 
002829                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00282a                           pulse1_hi_pitch_macro: .byte 2
00282c                           pulse1_hi_pitch_macro_offset: .byte 1
00282d                           pulse1_hi_pitch_macro_loop: .byte 1
00282e                           pulse1_hi_pitch_macro_release: .byte 1
                                 
00282f                           pulse1_duty_macro: .byte 2
002831                           pulse1_duty_macro_offset: .byte 1
002832                           pulse1_duty_macro_loop: .byte 1
002833                           pulse1_duty_macro_release: .byte 1
                                 
002834                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002836                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002838                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00283a                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00283c                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00283e                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002840                           pulse1_fx_3xx_target: .byte 2 //target note period
002842                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002844                           pulse1_fx_3xx_total_offset: .byte 2
002846                           pulse1_fx_4xy_speed: .byte 1
002847                           pulse1_fx_4xy_depth: .byte 1
002848                           pulse1_fx_4xy_phase: .byte 1
002849                           pulse1_fx_7xy_speed: .byte 1
00284a                           pulse1_fx_7xy_depth: .byte 1
00284b                           pulse1_fx_7xy_phase: .byte 1
00284c                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00284d                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00284e                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00284f                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002850                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002851                           pulse1_fx_Qxy_target: .byte 2 //target note period
002853                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002857                           pulse1_fx_Rxy_target: .byte 2 //target note period
002859                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00285b                           pulse1_fx_Rxy_total_offset: .byte 2
00285d                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
00285e                           pulse1_fx_Sxx_post: .byte 1
                                 
00285f                           pulse2_pattern_delay: .byte 1
002860                           triangle_pattern_delay: .byte 1
002861                           noise_pattern_delay: .byte 1
002862                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.0000 = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r13
                                 .def pulse1_length_counter = r14
                                 .def pulse1_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 
                                 reset:
000000 940c 0f08                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 1062                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1048                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1052                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1048                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 174f                 	jmp pulse1_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(59): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(61): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(62): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(65): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(66): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(67): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(68): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(69): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(72): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(120): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(133): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(140): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(141): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(184): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(186): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(187): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(188): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(191): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(192): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(193): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(196): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(198): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(204): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(205): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(209): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(210): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(217): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(128): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
000f08 edb8                      	ldi r27, CPU_CCP_IOREG_gc //protected write
000f09 93b0 0034                 	sts CPU_CCP, r27
000f0b e0b0                      	ldi r27, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
000f0c 93b0 0061                 	sts CLKCTRL_MCLKCTRLB, r27
                                 
                                 /*	//TEST FOR C4, 1 SECOND, 50% DD
                                 	ldi r26, 0x97
                                 	ldi r27, 0x12
                                 	ldi r26, 0x15
                                 	ldi r27, 0x09
                                 	sts pulse1_timerL, r26
                                 	sts pulse1_timerH, r27
                                 	ldi r27, 0b10111111
                                 	sts pulse1_param, r27
                                 	ldi r27, 0x01
                                 	sts pulse1_length, r27
                                 	//TEST FOR SWEEP UP
                                 	ldi r27, 0b11111111
                                 	sts pulse1_sweep_param, r27*/
                                 
                                 	//ZERO
000f0e 2422                      	clr zero
                                 
                                 	//MEMORY
000f0f e3b0                      	ldi r27, 0b00110000
000f10 93b0 2800                 	sts pulse1_param, r27
000f12 e8b0                      	ldi r27, 0b10000000
000f13 93b0 2801                 	sts pulse1_sweep_param, r27
000f15 efbf                      	ldi r27, 0xFF
000f16 93b0 2802                 	sts pulse1_timerL, r27
000f18 93b0 2803                 	sts pulse1_timerH, r27
000f1a 93b0 2804                 	sts pulse1_length, r27
                                 
000f1c e0b2                      	ldi r27, 0x02
000f1d 93b0 280a                 	sts song_frame_offset, r27
000f1f 9220 280b                 	sts song_frame_offset+1, zero
000f21 eee2                      	ldi ZL, LOW(song0_frames << 1)
000f22 e0f1                      	ldi ZH, HIGH(song0_frames << 1)
000f23 93e0 2808                 	sts song_frames, ZL
000f25 93f0 2809                 	sts song_frames+1, ZH
000f27 91c5                      	lpm r28, Z+ //load the song size
000f28 91d5                      	lpm r29, Z+
000f29 93c0 280c                 	sts song_size, r28
000f2b 93d0 280d                 	sts song_size+1, r29
000f2d 9220 280e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0 TEST
000f2f 91a5                      	lpm r26, Z+
000f30 91b4                      	lpm r27, Z
000f31 0faa                      	lsl r26
000f32 1fbb                      	rol r27
000f33 93a0 2812                 	sts pulse1_pattern, r26
000f35 93b0 2813                 	sts pulse1_pattern+1, r27
000f37 e0b0                      	ldi r27, 0x00
000f38 9220 2814                 	sts pulse1_pattern_delay, zero
000f3a 9220 2815                 	sts pulse1_pattern_delay+1, zero
000f3c 9220 2816                 	sts pulse1_pattern_offset, zero
000f3e 9220 2817                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//channel 0 instrument macros
000f40 efbf                      	ldi r27, 0xFF
000f41 9220 281a                 	sts pulse1_volume_macro_offset, zero
000f43 93b0 281b                 	sts pulse1_volume_macro_loop, r27
000f45 93b0 281c                 	sts pulse1_volume_macro_release, r27
000f47 9220 281f                 	sts pulse1_arpeggio_macro_offset, zero
000f49 93b0 2820                 	sts pulse1_arpeggio_macro_loop, r27
000f4b 93b0 2821                 	sts pulse1_arpeggio_macro_release, r27
000f4d 93b0 2822                 	sts pulse1_arpeggio_macro_mode, r27
000f4f 9220 2826                 	sts pulse1_pitch_macro_offset, zero
000f51 93b0 2827                 	sts pulse1_pitch_macro_loop, r27
000f53 93b0 2828                 	sts pulse1_pitch_macro_release, r27
000f55 9220 282c                 	sts pulse1_hi_pitch_macro_offset, zero
000f57 93b0 282d                 	sts pulse1_hi_pitch_macro_loop, r27
000f59 93b0 282e                 	sts pulse1_hi_pitch_macro_release, r27
000f5b 9220 2831                 	sts pulse1_duty_macro_offset, zero
000f5d 93b0 2832                 	sts pulse1_duty_macro_loop, r27
000f5f 93b0 2833                 	sts pulse1_duty_macro_release, r27
                                 
000f61 9220 2818                 	sts pulse1_volume_macro, zero
000f63 9220 2819                 	sts pulse1_volume_macro+1, zero
000f65 9220 281d                 	sts pulse1_arpeggio_macro, zero
000f67 9220 281e                 	sts pulse1_arpeggio_macro+1, zero
000f69 9220 2823                 	sts pulse1_total_pitch_offset, zero
000f6b 9220 2824                 	sts pulse1_pitch_macro, zero
000f6d 9220 2825                 	sts pulse1_pitch_macro+1, zero
000f6f 9220 2829                 	sts pulse1_total_hi_pitch_offset, zero
000f71 9220 282a                 	sts pulse1_hi_pitch_macro, zero
000f73 9220 282b                 	sts pulse1_hi_pitch_macro+1, zero
000f75 9220 282f                 	sts pulse1_duty_macro, zero
000f77 9220 2830                 	sts pulse1_duty_macro+1, zero
                                 
000f79 9220 285f                 	sts pulse2_pattern_delay, zero
000f7b 9220 2860                 	sts triangle_pattern_delay, zero
000f7d 9220 2861                 	sts noise_pattern_delay, zero
000f7f 9220 2862                 	sts dcpm_pattern_delay, zero
                                 
                                 	//PINS
000f81 efbf                      	ldi r27, 0xFF //set all pins in VPORTD to output
000f82 b9b0                      	out VPORTA_DIR, r27
                                 
                                 	//ENVELOPE
000f83 e00f                      	ldi pulse1_volume_divider, 0x0F
000f84 9110 2800                 	lds pulse1_volume_decay, pulse1_param
000f86 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
000f87 9190 2800                 	lds channel_flags, pulse1_param
000f89 7390                      	andi channel_flags, 0b00110000
000f8a 6490                      	sbr channel_flags, 0b01000000 //set start flag
000f8b 9220 2806                 	sts pulse1_output_volume, zero
000f8d 93b0 2805                 	sts pulse1_fractional_volume, r27 //initialize fractional volume to max value
                                 	
                                 	//LENGTH
000f8f 91d0 2804                 	lds r29, pulse1_length
000f91 efdf                      	ldi r29 ,0xFF
000f92 2eed                      	mov pulse1_length_counter, r29
                                 
                                 	//SEQUENCE
000f93 91d0 2800                 	lds r29, pulse1_param //load param for sequence table
000f95 e0d1                      	ldi r29, 0b00000001 //12.5% is the default duty cycle sequence
000f96 2edd                      	mov pulse1_sequence, r29
                                 
                                 	//SWEEP
000f97 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param
000f99 94f2                      	swap pulse1_sweep //swap data from high byte and low byte
000f9a 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//FX
000f9b efdf                      	ldi r29, 0xFF
000f9c 93d0 280f                 	sts song_fx_Bxx, r29
000f9e 9220 2810                 	sts song_fx_Cxx, zero
000fa0 9220 2811                 	sts song_fx_Dxx, zero
000fa2 9220 2834                 	sts pulse1_fx_0xy_sequence, zero
000fa4 9220 2835                 	sts pulse1_fx_0xy_sequence+1, zero
000fa6 9220 2836                 	sts pulse1_fx_1xx, zero
000fa8 9220 2837                 	sts pulse1_fx_1xx+1, zero
000faa 9220 2838                 	sts pulse1_fx_1xx_total, zero
000fac 9220 2839                 	sts pulse1_fx_1xx_total+1, zero
000fae 9220 283a                 	sts pulse1_fx_2xx, zero
000fb0 9220 283b                 	sts pulse1_fx_2xx+1, zero
000fb2 9220 283c                 	sts pulse1_fx_2xx_total, zero
000fb4 9220 283d                 	sts pulse1_fx_2xx_total+1, zero
000fb6 9220 283e                 	sts pulse1_fx_3xx_start, zero
000fb8 9220 283f                 	sts pulse1_fx_3xx_start+1, zero
000fba 9220 2840                 	sts pulse1_fx_3xx_target, zero
000fbc 9220 2841                 	sts pulse1_fx_3xx_target+1, zero
000fbe 9220 2842                 	sts pulse1_fx_3xx_speed, zero
000fc0 9220 2843                 	sts pulse1_fx_3xx_speed+1, zero
000fc2 9220 2844                 	sts pulse1_fx_3xx_total_offset, zero
000fc4 9220 2845                 	sts pulse1_fx_3xx_total_offset+1, zero
000fc6 9220 2846                 	sts pulse1_fx_4xy_speed, zero
000fc8 9220 2847                 	sts pulse1_fx_4xy_depth, zero
000fca 9220 2848                 	sts pulse1_fx_4xy_phase, zero
000fcc 9220 2849                 	sts pulse1_fx_7xy_speed, zero
000fce 9220 284a                 	sts pulse1_fx_7xy_depth, zero
000fd0 9220 284b                 	sts pulse1_fx_7xy_phase, zero
000fd2 9220 284c                 	sts pulse1_fx_7xy_value, zero
000fd4 9220 284d                 	sts pulse1_fx_Axy, zero
000fd6 9220 284e                 	sts pulse1_fx_Gxx_pre, zero
000fd8 9220 284f                 	sts pulse1_fx_Gxx_post, zero
000fda 9220 2850                 	sts pulse1_fx_Pxx, zero
000fdc 9220 2851                 	sts pulse1_fx_Qxy_target, zero
000fde 9220 2852                 	sts pulse1_fx_Qxy_target+1, zero
000fe0 9220 2853                 	sts pulse1_fx_Qxy_speed, zero
000fe2 9220 2854                 	sts pulse1_fx_Qxy_speed+1, zero
000fe4 9220 2855                 	sts pulse1_fx_Qxy_total_offset, zero
000fe6 9220 2856                 	sts pulse1_fx_Qxy_total_offset+1, zero
000fe8 9220 2857                 	sts pulse1_fx_Rxy_target, zero
000fea 9220 2858                 	sts pulse1_fx_Rxy_target+1, zero
000fec 9220 2859                 	sts pulse1_fx_Rxy_speed, zero
000fee 9220 285a                 	sts pulse1_fx_Rxy_speed+1, zero
000ff0 9220 285b                 	sts pulse1_fx_Rxy_total_offset, zero
000ff2 9220 285c                 	sts pulse1_fx_Rxy_total_offset+1, zero
000ff4 9220 285d                 	sts pulse1_fx_Sxx_pre, zero
000ff6 9220 285e                 	sts pulse1_fx_Sxx_post, zero
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
000ff8 e7b0                      	ldi r27, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
000ff9 93b0 0a01                 	sts TCA0_SINGLE_CTRLB, r27
000ffb e7b1                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
000ffc 93b0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r27
000ffe e1b5                      	ldi r27, 0x15 //set the period for CMP0
000fff 93b0 0a28                 	sts TCA0_SINGLE_CMP0, r27
001001 e0b5                      	ldi r27, 0x05
001002 93b0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r27
001004 e2bb                      	ldi r27, 0x2B //set the period for CMP1
001005 93b0 0a2a                 	sts TCA0_SINGLE_CMP1, r27
001007 e0ba                      	ldi r27, 0x0A
001008 93b0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r27
00100a e4b1                      	ldi r27, 0x41 //set the period for CMP2
00100b 93b0 0a2c                 	sts TCA0_SINGLE_CMP2, r27
00100d e0bf                      	ldi r27, 0x0F
00100e 93b0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r27
001010 e5b7                      	ldi r27, 0x57 //set the period for OVF
001011 93b0 0a26                 	sts TCA0_SINGLE_PER, r27
001013 e1b4                      	ldi r27, 0x14
001014 93b0 0a27                 	sts TCA0_SINGLE_PER + 1, r27
001016 e0bb                      	ldi r27, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
001017 93b0 0a00                 	sts TCA0_SINGLE_CTRLA, r27
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
001019 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00101a 93b0 0a81                 	sts TCB0_CTRLB, r27
00101c e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00101d 93b0 0a85                 	sts TCB0_INTCTRL, r27
00101f 91b0 2802                 	lds r27, pulse1_timerL //load the LOW bits for timer
001021 93b0 0a8c                 	sts TCB0_CCMPL, r27
001023 91b0 2803                 	lds r27, pulse1_timerH //load the HIGH bits for timer
001025 93b0 0a8d                 	sts TCB0_CCMPH, r27
001027 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001028 93b0 0a80                 	sts TCB0_CTRLA, r27
00102a 9478                      	sei //global interrupt enable
                                 
                                 pulse1:
00102b fed0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
00102c c015                      	rjmp pulse1_off
                                 
00102d 14e2                      	cp pulse1_length_counter, zero //if length is zero, return
00102e f099                      	breq pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
00102f 91c0 0a8c                 	lds r28, TCB0_CCMPL
001031 e5d9                      	ldi r29, 0x059
001032 17cd                      	cp r28, r29
001033 91c0 0a8d                 	lds r28, TCB0_CCMPH
001035 e0d0                      	ldi r29, 0x00
001036 07cd                      	cpc r28, r29
001037 f050                      	brlo pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
001038 91c0 0a8c                 	lds r28, TCB0_CCMPL
00103a e6d6                      	ldi r29, 0x66
00103b 17cd                      	cp r28, r29
00103c 91c0 0a8d                 	lds r28, TCB0_CCMPH
00103e e5d9                      	ldi r29, 0x59
00103f 07cd                      	cpc r28, r29
001040 f408                      	brsh pulse1_off
001041 c002                      	rjmp pulse1_on //if the HIGH period == $59 && LOW period < $65, pulse on
                                 
                                 pulse1_off:
001042 b821                      	out VPORTA_OUT, zero
001043 cfe7                      	rjmp pulse1
                                 
                                 pulse1_on:
001044 91d0 2806                 	lds r29, pulse1_output_volume
                                 /*	cpse r29, zero
                                 	rjmp pulse1_off //if VVVV bits are 0, then there is no volume (channel off)*/
                                 
001046 b9d1                      	out VPORTA_OUT, r29
001047 cfe3                      	rjmp pulse1
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001048 b7bf                      	in r27, CPU_SREG
001049 93bf                      	push r27
00104a 94f8                      	cli
                                 
                                 	//ENVELOPE
00104b d738                      	rcall pulse1_envelope_routine
                                 
00104c e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
00104d 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00104f 91bf                      	pop r27
001050 bfbf                      	out CPU_SREG, r27
001051 9518                      	reti
                                 
                                 sequence_1_3:
001052 b7bf                      	in r27, CPU_SREG
001053 93bf                      	push r27
001054 94f8                      	cli
                                 
                                 	//ENVELOPE
001055 d72e                      	rcall pulse1_envelope_routine
                                 
                                 	//SWEEP
001056 fcf3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001057 d702                      	rcall pulse1_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
001058 fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
001059 c002                      	rjmp sequence_1_3_exit
00105a 10e2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
00105b 94ea                      	dec pulse1_length_counter
                                 
                                 sequence_1_3_exit:
00105c e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
00105d 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00105f 91bf                      	pop r27
001060 bfbf                      	out CPU_SREG, r27
001061 9518                      	reti
                                 
                                 sound_driver:
001062 b7bf                      	in r27, CPU_SREG
001063 93bf                      	push r27
001064 94f8                      	cli
001065 93cf                      	push r28
001066 93df                      	push r29
                                 
                                 	//SOUND DRIVER
001067 91a0 280f                 	lds r26, song_fx_Bxx
001069 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
00106a f4a9                      	brne sound_driver_fx_Bxx_routine
00106b 91a0 2810                 	lds r26, song_fx_Cxx
00106d 11a2                      	cpse r26, zero
00106e c03b                      	rjmp sound_driver_fx_Cxx_routine
00106f 91a0 2811                 	lds r26, song_fx_Dxx
001071 11a2                      	cpse r26, zero
001072 c046                      	rjmp sound_driver_fx_Dxx_routine
                                 
001073 91a0 280a                 	lds r26, song_frame_offset
001075 91b0 280b                 	lds r27, song_frame_offset+1
001077 91c0 280c                 	lds r28, song_size
001079 91d0 280d                 	lds r29, song_size+1
00107b 17ac                      	cp r26, r28
00107c 07bd                      	cpc r27, r29
00107d f408                      	brsh sound_driver_fx_song_loop
00107e c061                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
00107f e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001080 91e0 2808                 	lds ZL, song_frames
001082 91f0 2809                 	lds ZH, song_frames+1
001084 27cc                      	clr r28 //initialize r29:r28 to 0
001085 27dd                      	clr r29
001086 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001087 95aa                      	dec r26
001088 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001089 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
00108a cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
00108b 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
00108c 93c0 280a                 	sts song_frame_offset, r28
00108e 93d0 280b                 	sts song_frame_offset+1, r29
001090 0fec                      	add ZL, r28
001091 1ffd                      	adc ZH, r29
                                 
001092 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
001093 91b4                      	lpm r27, Z
001094 0faa                      	lsl r26
001095 1fbb                      	rol r27
001096 93a0 2812                 	sts pulse1_pattern, r26
001098 93b0 2813                 	sts pulse1_pattern+1, r27
                                 
00109a 9220 2816                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00109c 9220 2817                 	sts pulse1_pattern_offset+1, zero
00109e 9220 2814                 	sts pulse1_pattern_delay, zero //reset the delay to 0 as well
0010a0 9220 2815                 	sts pulse1_pattern_delay+1, zero
                                 
0010a2 efaf                      	ldi r26, 0xFF
0010a3 93a0 280f                 	sts song_fx_Bxx, r26 //reset all song effects
0010a5 9220 2810                 	sts song_fx_Cxx, zero
0010a7 9220 2811                 	sts song_fx_Dxx, zero
0010a9 c036                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0010aa 91df                      	pop r29
0010ab 91cf                      	pop r28
0010ac 91bf                      	pop r27
0010ad bfbf                      	out CPU_SREG, r27
0010ae 94f8                      	cli //disable global interrupts
                                 		
0010af efaf                      	ldi r26, 0xFF
0010b0 93a0 280f                 	sts song_fx_Bxx, r26 //reset all song effects
0010b2 9220 2810                 	sts song_fx_Cxx, zero
0010b4 9220 2811                 	sts song_fx_Dxx, zero
                                 
0010b6 9220 2806                 	sts pulse1_output_volume, zero //mute all channels
0010b8 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0010b9 91e0 2808                 	lds ZL, song_frames
0010bb 91f0 2809                 	lds ZH, song_frames+1
0010bd 91a0 280a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0010bf 91b0 280b                 	lds r27, song_frame_offset+1
0010c1 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0010c2 93a0 280a                 	sts song_frame_offset, r26
0010c4 93b0 280b                 	sts song_frame_offset+1, r27
0010c6 0fea                      	add ZL, r26
0010c7 1ffb                      	adc ZH, r27
                                 
0010c8 91a5                      	lpm r26, Z+ //load the address of the next pattern
0010c9 91b4                      	lpm r27, Z
0010ca 0faa                      	lsl r26
0010cb 1fbb                      	rol r27
0010cc 93a0 2812                 	sts pulse1_pattern, r26
0010ce 93b0 2813                 	sts pulse1_pattern+1, r27
                                 
0010d0 9220 2816                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0010d2 9220 2817                 	sts pulse1_pattern_offset+1, zero
0010d4 9220 2814                 	sts pulse1_pattern_delay, zero //reset the delay to 0 as well
0010d6 9220 2815                 	sts pulse1_pattern_delay+1, zero
                                 
0010d8 efaf                      	ldi r26, 0xFF
0010d9 93a0 280f                 	sts song_fx_Bxx, r26 //reset all song effects
0010db 9220 2810                 	sts song_fx_Cxx, zero
0010dd 9220 2811                 	sts song_fx_Dxx, zero
0010df c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
0010e0 91a0 2814                 	lds r26, pulse1_pattern_delay
0010e2 91b0 2815                 	lds r27, pulse1_pattern_delay+1
0010e4 9610                      	adiw r27:r26, 0
0010e5 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
0010e6 c2fd                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
0010e7 91e0 2812                 	lds ZL, pulse1_pattern //current pattern for pulse 1
0010e9 91f0 2813                 	lds ZH, pulse1_pattern+1
0010eb 91a0 2816                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
0010ed 91b0 2817                 	lds r27, pulse1_pattern_offset+1
0010ef 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0010f0 1ffb                      	adc ZH, r27
0010f1 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0010f2 35b7                      	cpi r27, 0x57
0010f3 f408                      	brsh sound_driver_channel0_check_if_volume
0010f4 c164                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
0010f5 36b7                      	cpi r27, 0x67
0010f6 f408                      	brsh sound_driver_channel0_check_if_delay
0010f7 c19c                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0010f8 3eb3                      	cpi r27, 0xE3
0010f9 f408                      	brsh sound_driver_channel0_check_if_instrument
0010fa c1a3                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
0010fb f409                      	brne sound_driver_channel0_check_if_release
0010fc c1a6                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
0010fd 3eb4                      	cpi r27, 0xE4
0010fe f409                      	brne sound_driver_channel0_check_if_end
0010ff c24d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001100 3fbf                      	cpi r27, 0xFF
001101 f409                      	brne sound_driver_channel0_check_if_fx
001102 c26f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001103 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001104 91a4                      	lpm r26, Z //load the fx data into r26
001105 d292                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001106 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001107 e7e4                      	ldi ZL, LOW(fx << 1) //load in note table
001108 e2ff                      	ldi ZH, HIGH(fx << 1)
001109 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00110a 0feb                      	add ZL, r27 //add offset
00110b 1df2                      	adc ZH, zero
00110c 91c5                      	lpm r28, Z+ //load address bytes
00110d 91d4                      	lpm r29, Z
00110e 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00110f 2ffd                      	mov ZH, r29
001110 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001111 93a0 2834                 	sts pulse1_fx_0xy_sequence, r26
001113 9220 2835                 	sts pulse1_fx_0xy_sequence+1, zero
001115 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
001116 9220 283a                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001118 9220 283b                 	sts pulse1_fx_2xx+1, zero
00111a 9220 2834                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00111c 9220 2835                 	sts pulse1_fx_0xy_sequence+1, zero
00111e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00111f 937f                      	push r23
001120 2f6a                      	mov r22, r26 //store the rate into r22
001121 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001122 9f67                      	mul r22, r23
001123 917f                      	pop r23
001124 916f                      	pop r22
                                 
001125 9416                      	lsr r1 //shift out the fractional bits
001126 9407                      	ror r0
001127 9416                      	lsr r1
001128 9407                      	ror r0
001129 9416                      	lsr r1
00112a 9407                      	ror r0
00112b 9416                      	lsr r1
00112c 9407                      	ror r0
00112d 9200 2836                 	sts pulse1_fx_1xx, r0
00112f 9210 2837                 	sts pulse1_fx_1xx+1, r1
001131 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001132 9220 2836                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001134 9220 2837                 	sts pulse1_fx_1xx+1, zero
001136 9220 2834                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001138 9220 2835                 	sts pulse1_fx_0xy_sequence+1, zero
00113a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00113b 937f                      	push r23
00113c 2f6a                      	mov r22, r26 //store the rate into r22
00113d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00113e 9f67                      	mul r22, r23
00113f 917f                      	pop r23
001140 916f                      	pop r22
                                 
001141 9416                      	lsr r1 //shift out the fractional bits
001142 9407                      	ror r0
001143 9416                      	lsr r1
001144 9407                      	ror r0
001145 9416                      	lsr r1
001146 9407                      	ror r0
001147 9416                      	lsr r1
001148 9407                      	ror r0
001149 9200 283a                 	sts pulse1_fx_2xx, r0
00114b 9210 283b                 	sts pulse1_fx_2xx+1, r1
00114d cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00114e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00114f 937f                      	push r23
001150 2f6a                      	mov r22, r26 //store the rate into r22
001151 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001152 9f67                      	mul r22, r23
001153 917f                      	pop r23
001154 916f                      	pop r22
                                 
001155 9416                      	lsr r1 //shift out the fractional bits
001156 9407                      	ror r0
001157 9416                      	lsr r1
001158 9407                      	ror r0
001159 9416                      	lsr r1
00115a 9407                      	ror r0
00115b 9416                      	lsr r1
00115c 9407                      	ror r0
00115d 9200 2842                 	sts pulse1_fx_3xx_speed, r0
00115f 9210 2843                 	sts pulse1_fx_3xx_speed+1, r1
                                 
001161 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001162 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
001163 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
001164 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001166 91b0 0a8d                 	lds r27, TCB0_CCMPH
001168 93a0 283e                 	sts pulse1_fx_3xx_start, r26
00116a 93b0 283f                 	sts pulse1_fx_3xx_start+1, r27
                                 
00116c 9220 2844                 	sts pulse1_fx_3xx_total_offset, zero
00116e 9220 2845                 	sts pulse1_fx_3xx_total_offset+1, zero
001170 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
001171 2fba                      	mov r27, r26
001172 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001173 95a2                      	swap r26
001174 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001175 93a0 2846                 	sts pulse1_fx_4xy_speed, r26
001177 93b0 2847                 	sts pulse1_fx_4xy_depth, r27
001179 9220 2848                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
00117b cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
00117c 2fba                      	mov r27, r26
00117d 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00117e 95a2                      	swap r26
00117f 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001180 93a0 2849                 	sts pulse1_fx_7xy_speed, r26
001182 93b0 284a                 	sts pulse1_fx_7xy_depth, r27
001184 9220 284b                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
001186 9220 284c                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001188 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001189 93a0 284d                 	sts pulse1_fx_Axy, r26
00118b cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
00118c 93a0 280f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00118e cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
00118f 93b0 2810                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001191 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
001192 93b0 2811                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001194 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
001195 91b0 2800                 	lds r27, pulse1_param
001197 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001198 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001199 93b0 2800                 	sts pulse1_param, r27
00119b 6096                      	sbr channel_flags, 6
00119c cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
00119d 93a0 280e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00119f cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0011a0 93a0 284e                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0011a2 cf44                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0011a3 95a2                      	swap r26
0011a4 68a8                      	ori r26, 0b10001000 //enable negate and enable sweep flag
0011a5 2efa                      	mov pulse1_sweep, r26
0011a6 92f0 2801                 	sts pulse1_sweep_param, pulse1_sweep
0011a8 6097                      	sbr channel_flags, 7 //set reload flag
0011a9 cf3d                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0011aa 95a2                      	swap r26
0011ab 77af                      	andi r26, 0b01111111 //disable negate flag
0011ac 60a8                      	ori r26, 0b00001000 //enable sweep flag
0011ad 2efa                      	mov pulse1_sweep, r26
0011ae 92f0 2801                 	sts pulse1_sweep_param, pulse1_sweep
0011b0 6097                      	sbr channel_flags, 7 //set reload flag
0011b1 cf35                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0011b2 cf34                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0011b3 cf33                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0011b4 93a0 2850                 	sts pulse1_fx_Pxx, r26
0011b6 cf30                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
0011b7 91e0 281d                 	lds ZL, pulse1_arpeggio_macro
0011b9 91f0 281e                 	lds ZH, pulse1_arpeggio_macro+1
0011bb 9630                      	adiw Z, 0
0011bc f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
0011bd cf29                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
0011be 91e0 2824                 	lds ZL, pulse1_pitch_macro
0011c0 91f0 2825                 	lds ZH, pulse1_pitch_macro+1
0011c2 9630                      	adiw Z, 0
0011c3 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
0011c4 cf22                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
0011c5 91e0 282a                 	lds ZL, pulse1_hi_pitch_macro
0011c7 91f0 282b                 	lds ZH, pulse1_hi_pitch_macro+1
0011c9 9630                      	adiw Z, 0
0011ca f009                      	breq sound_driver_channel0_fx_Qxy_process
0011cb cf1b                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
0011cc 2fba                      	mov r27, r26 //copy fx parameters into r27
0011cd 70bf                      	andi r27, 0x0F //mask note index offset
0011ce 91c0 2807                 	lds r28, pulse1_note //load current note index
0011d0 0fbc                      	add r27, r28
0011d1 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0011d2 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
0011d3 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
0011d4 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0011d5 e0f0                      	ldi ZH, HIGH(note_table << 1)
0011d6 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0011d7 0feb                      	add ZL, r27 //add offset
0011d8 1df2                      	adc ZH, zero
0011d9 91c5                      	lpm r28, Z+ //load bytes
0011da 91d4                      	lpm r29, Z
0011db 93c0 2851                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
0011dd 93d0 2852                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0011df 95a2                      	swap r26
0011e0 70af                      	andi r26, 0x0F //mask effect speed
0011e1 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0011e2 95a3                      	inc r26 //increment the speed by 1
                                 
0011e3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0011e4 937f                      	push r23
0011e5 2f6a                      	mov r22, r26 //store the speed data into r27
0011e6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0011e7 9f67                      	mul r22, r23
0011e8 917f                      	pop r23
0011e9 916f                      	pop r22
                                 
0011ea 9416                      	lsr r1 //shift out the fractional bits
0011eb 9407                      	ror r0
0011ec 9416                      	lsr r1
0011ed 9407                      	ror r0
0011ee 9416                      	lsr r1
0011ef 9407                      	ror r0
0011f0 9416                      	lsr r1
0011f1 9407                      	ror r0
                                 
0011f2 9200 2853                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0011f4 9210 2854                 	sts pulse1_fx_Qxy_speed+1, r1
0011f6 9220 2855                 	sts pulse1_fx_Qxy_total_offset, zero
0011f8 9220 2856                 	sts pulse1_fx_Qxy_total_offset+1, zero
0011fa ceec                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0011fb 91e0 281d                 	lds ZL, pulse1_arpeggio_macro
0011fd 91f0 281e                 	lds ZH, pulse1_arpeggio_macro+1
0011ff 9630                      	adiw Z, 0
001200 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001201 cee5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001202 91e0 2824                 	lds ZL, pulse1_pitch_macro
001204 91f0 2825                 	lds ZH, pulse1_pitch_macro+1
001206 9630                      	adiw Z, 0
001207 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001208 cede                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001209 91e0 282a                 	lds ZL, pulse1_hi_pitch_macro
00120b 91f0 282b                 	lds ZH, pulse1_hi_pitch_macro+1
00120d 9630                      	adiw Z, 0
00120e f009                      	breq sound_driver_channel0_fx_Rxy_process
00120f ced7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001210 2fba                      	mov r27, r26 //copy fx parameters into r27
001211 70bf                      	andi r27, 0x0F //mask note index offset
001212 91c0 2807                 	lds r28, pulse1_note //load current note index
001214 1bcb                      	sub r28, r27
001215 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001216 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001217 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001218 e0f0                      	ldi ZH, HIGH(note_table << 1)
001219 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00121a 0fec                      	add ZL, r28 //add offset
00121b 1df2                      	adc ZH, zero
00121c 91c5                      	lpm r28, Z+ //load bytes
00121d 91d4                      	lpm r29, Z
00121e 93c0 2857                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001220 93d0 2858                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001222 95a2                      	swap r26
001223 70af                      	andi r26, 0x0F //mask effect speed
001224 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001225 95a3                      	inc r26 //increment the speed by 1
                                 
001226 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001227 937f                      	push r23
001228 2f6a                      	mov r22, r26 //store the speed data into r27
001229 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00122a 9f67                      	mul r22, r23
00122b 917f                      	pop r23
00122c 916f                      	pop r22
                                 
00122d 9416                      	lsr r1 //shift out the fractional bits
00122e 9407                      	ror r0
00122f 9416                      	lsr r1
001230 9407                      	ror r0
001231 9416                      	lsr r1
001232 9407                      	ror r0
001233 9416                      	lsr r1
001234 9407                      	ror r0
                                 
001235 9200 2859                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001237 9210 285a                 	sts pulse1_fx_Rxy_speed+1, r1
001239 9220 285b                 	sts pulse1_fx_Rxy_total_offset, zero
00123b 9220 285c                 	sts pulse1_fx_Rxy_total_offset+1, zero
00123d cea9                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
00123e 93a0 285d                 	sts pulse1_fx_Sxx_pre, r26
001240 cea6                      	rjmp sound_driver_channel0_main
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001241 e7e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001242 e2ff                      	ldi ZH, HIGH(sequences << 1)
001243 0fea                      	add ZL, r26 //offset the pointer
001244 1df2                      	adc ZH, zero
                                 
001245 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001246 95a7                      	ror r26
001247 95a7                      	ror r26
001248 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
00124a 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
00124b 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
00124c 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
00124d c001                      	rjmp sound_driver_channel0_fx_Vxx_store
00124e ce98                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
00124f 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001250 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001251 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001252 93c0 2800                 	sts pulse1_param, r28
001254 ce92                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001255 ce91                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001256 ce90                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001257 ce8f                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001258 ce8e                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001259 93b0 2807                 	sts pulse1_note, r27 //store the note index
00125b e0a3                      	ldi r26, 0x03
00125c e0b2                      	ldi r27, 0x02
00125d 93b0 281a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00125f 93a0 281f                 	sts pulse1_arpeggio_macro_offset, r26
001261 93b0 2826                 	sts pulse1_pitch_macro_offset, r27
001263 93b0 282c                 	sts pulse1_hi_pitch_macro_offset, r27
001265 93b0 2831                 	sts pulse1_duty_macro_offset, r27
001267 9220 2823                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001269 9220 2829                 	sts pulse1_total_hi_pitch_offset, zero
00126b 9220 2838                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00126d 9220 2839                 	sts pulse1_fx_1xx_total+1, zero
00126f 9220 283c                 	sts pulse1_fx_2xx_total, zero
001271 9220 283d                 	sts pulse1_fx_2xx_total+1, zero
001273 9220 2844                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001275 9220 2845                 	sts pulse1_fx_3xx_total_offset+1, zero
001277 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001279 91b0 0a8d                 	lds r27, TCB0_CCMPH
00127b 93a0 283e                 	sts pulse1_fx_3xx_start, r26
00127d 93b0 283f                 	sts pulse1_fx_3xx_start+1, r27
00127f 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001281 6097                      	sbr channel_flags, 7 //set reload flag
001282 9220 2851                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001284 9220 2852                 	sts pulse1_fx_Qxy_target+1, zero
001286 9220 2855                 	sts pulse1_fx_Qxy_total_offset, zero
001288 9220 2856                 	sts pulse1_fx_Qxy_total_offset+1, zero
00128a 9220 2857                 	sts pulse1_fx_Rxy_target, zero
00128c 9220 2858                 	sts pulse1_fx_Rxy_target+1, zero
00128e 9220 285b                 	sts pulse1_fx_Rxy_total_offset, zero
001290 9220 285c                 	sts pulse1_fx_Rxy_total_offset+1, zero
001292 d0fb                      	rcall sound_driver_channel0_increment_offset
001293 ce53                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001294 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001295 91a0 2800                 	lds r26, pulse1_param
001297 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001298 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001299 93a0 2800                 	sts pulse1_param, r26
00129b 6096                      	sbr channel_flags, 6
00129c d0f1                      	rcall sound_driver_channel0_increment_offset
00129d ce49                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
00129e 56b7                      	subi r27, 0x67 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00129f 93b0 2814                 	sts pulse1_pattern_delay, r27
0012a1 d0ec                      	rcall sound_driver_channel0_increment_offset
0012a2 c0ff                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
0012a3 9220 2818                 	sts pulse1_volume_macro, zero //reset all macro addresses
0012a5 9220 2819                 	sts pulse1_volume_macro+1, zero
0012a7 9220 281d                 	sts pulse1_arpeggio_macro, zero
0012a9 9220 281e                 	sts pulse1_arpeggio_macro+1, zero
0012ab 9220 2824                 	sts pulse1_pitch_macro, zero
0012ad 9220 2825                 	sts pulse1_pitch_macro+1, zero
0012af 9220 282a                 	sts pulse1_hi_pitch_macro, zero
0012b1 9220 282b                 	sts pulse1_hi_pitch_macro+1, zero
0012b3 9220 282f                 	sts pulse1_duty_macro, zero
0012b5 9220 2830                 	sts pulse1_duty_macro+1, zero
0012b7 9220 2823                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
0012b9 9220 2829                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0012bb 9631                      	adiw Z, 1 //point to the byte next to the flag
0012bc 91b4                      	lpm r27, Z //store the instrument offset into r27
0012bd e2e4                      	ldi ZL, LOW(instruments) //point Z to instruments table
0012be e0fe                      	ldi ZH, HIGH(instruments)
0012bf 0feb                      	add ZL, r27 //point Z to offsetted instrument
0012c0 1df2                      	adc ZH, zero
0012c1 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0012c2 1fff                      	rol ZH
0012c3 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0012c4 91b4                      	lpm r27, Z
                                 
0012c5 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0012c6 1fbb                      	rol r27
0012c7 2fea                      	mov ZL, r26
0012c8 2ffb                      	mov ZH, r27
0012c9 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0012ca 9632                      	adiw Z, 2 //point Z to the address of the macro
0012cb e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
0012cc 95aa                      	dec r26
0012cd f019                      	breq sound_driver_channel0_instrument_change_exit
0012ce 95b6                      	lsr r27
0012cf f078                      	brcs sound_driver_channel0_instrument_change_load_macro
0012d0 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
0012d1 e0a3                      	ldi r26, 0x03
0012d2 e0b2                      	ldi r27, 0x02
0012d3 93b0 281a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0012d5 93a0 281f                 	sts pulse1_arpeggio_macro_offset, r26
0012d7 93b0 2826                 	sts pulse1_pitch_macro_offset, r27
0012d9 93b0 282c                 	sts pulse1_hi_pitch_macro_offset, r27
0012db 93b0 2831                 	sts pulse1_duty_macro_offset, r27
0012dd d0ba                      	rcall sound_driver_channel0_increment_offset_twice
0012de ce08                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
0012df 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0012e0 91d5                      	lpm r29, Z+
                                 
0012e1 30a5                      	cpi r26, 5
0012e2 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
0012e3 30a4                      	cpi r26, 4
0012e4 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
0012e5 30a3                      	cpi r26, 3
0012e6 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
0012e7 30a2                      	cpi r26, 2
0012e8 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
0012e9 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
0012ea 93c0 2818                 	sts pulse1_volume_macro, r28
0012ec 93d0 2819                 	sts pulse1_volume_macro+1, r29
0012ee d041                      	rcall sound_driver_channel0_instrument_change_read_header
0012ef 93c0 281c                 	sts pulse1_volume_macro_release, r28
0012f1 93d0 281b                 	sts pulse1_volume_macro_loop, r29
0012f3 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
0012f4 93c0 281d                 	sts pulse1_arpeggio_macro, r28
0012f6 93d0 281e                 	sts pulse1_arpeggio_macro+1, r29
0012f8 9220 2851                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0012fa 9220 2852                 	sts pulse1_fx_Qxy_target+1, zero
0012fc 9220 2857                 	sts pulse1_fx_Rxy_target, zero
0012fe 9220 2858                 	sts pulse1_fx_Rxy_target+1, zero
001300 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001301 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001302 93c0 2824                 	sts pulse1_pitch_macro, r28
001304 93d0 2825                 	sts pulse1_pitch_macro+1, r29
001306 9220 2851                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001308 9220 2852                 	sts pulse1_fx_Qxy_target+1, zero
00130a 9220 2857                 	sts pulse1_fx_Rxy_target, zero
00130c 9220 2858                 	sts pulse1_fx_Rxy_target+1, zero
00130e d021                      	rcall sound_driver_channel0_instrument_change_read_header
00130f 93c0 2828                 	sts pulse1_pitch_macro_release, r28
001311 93d0 2827                 	sts pulse1_pitch_macro_loop, r29
001313 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001314 93c0 282a                 	sts pulse1_hi_pitch_macro, r28
001316 93d0 282b                 	sts pulse1_hi_pitch_macro+1, r29
001318 9220 2851                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00131a 9220 2852                 	sts pulse1_fx_Qxy_target+1, zero
00131c 9220 2857                 	sts pulse1_fx_Rxy_target, zero
00131e 9220 2858                 	sts pulse1_fx_Rxy_target+1, zero
001320 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001321 93c0 282e                 	sts pulse1_hi_pitch_macro_release, r28
001323 93d0 282d                 	sts pulse1_hi_pitch_macro_loop, r29
001325 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001326 93c0 282f                 	sts pulse1_duty_macro, r28
001328 93d0 2830                 	sts pulse1_duty_macro+1, r29
00132a d005                      	rcall sound_driver_channel0_instrument_change_read_header
00132b 93c0 2833                 	sts pulse1_duty_macro_release, r28
00132d 93d0 2832                 	sts pulse1_duty_macro_loop, r29
00132f cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001330 93ef                      	push ZL
001331 93ff                      	push ZH
001332 2fec                      	mov ZL, r28
001333 2ffd                      	mov ZH, r29
001334 0fee                      	lsl ZL
001335 1fff                      	rol ZH
001336 91c5                      	lpm r28, Z+
001337 91d4                      	lpm r29, Z
001338 91ff                      	pop ZH
001339 91ef                      	pop ZL
00133a 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
00133b 93ef                      	push ZL
00133c 93ff                      	push ZH
00133d 2fec                      	mov ZL, r28
00133e 2ffd                      	mov ZH, r29
00133f 0fee                      	lsl ZL
001340 1fff                      	rol ZH
001341 91c5                      	lpm r28, Z+
001342 91d5                      	lpm r29, Z+
001343 93c0 2821                 	sts pulse1_arpeggio_macro_release, r28
001345 93d0 2820                 	sts pulse1_arpeggio_macro_loop, r29
001347 91c4                      	lpm r28, Z
001348 93c0 2822                 	sts pulse1_arpeggio_macro_mode, r28
00134a 91ff                      	pop ZH
00134b 91ef                      	pop ZL
00134c 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
00134d 91b0 281c                 	lds r27, pulse1_volume_macro_release
00134f 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001350 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001351 95b3                      	inc r27
001352 93b0 281a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001354 91b0 2821                 	lds r27, pulse1_arpeggio_macro_release
001356 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001357 f019                      	breq sound_driver_channel0_release_pitch
001358 95b3                      	inc r27
001359 93b0 281f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
00135b 91b0 2828                 	lds r27, pulse1_pitch_macro_release
00135d 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00135e f019                      	breq sound_driver_channel0_release_hi_pitch
00135f 95b3                      	inc r27
001360 93b0 2826                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001362 91b0 282e                 	lds r27, pulse1_hi_pitch_macro_release
001364 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001365 f019                      	breq sound_driver_channel0_release_duty
001366 95b3                      	inc r27
001367 93b0 282c                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001369 91b0 2833                 	lds r27, pulse1_duty_macro_release
00136b 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00136c f019                      	breq sound_driver_channel0_release_exit
00136d 95b3                      	inc r27
00136e 93b0 2831                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001370 d01d                      	rcall sound_driver_channel0_increment_offset
001371 cd75                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001372 91e0 2808                 	lds ZL, song_frames
001374 91f0 2809                 	lds ZH, song_frames+1
001376 91a0 280a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001378 91b0 280b                 	lds r27, song_frame_offset+1
00137a 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
00137b 93a0 280a                 	sts song_frame_offset, r26
00137d 93b0 280b                 	sts song_frame_offset+1, r27
                                 	//adiw r27:r26, 2 //offset for channel 1 (test)
00137f 0fea                      	add ZL, r26
001380 1ffb                      	adc ZH, r27
                                 
001381 91a5                      	lpm r26, Z+ //load the address of the next pattern
001382 91b4                      	lpm r27, Z
001383 0faa                      	lsl r26
001384 1fbb                      	rol r27
001385 93a0 2812                 	sts pulse1_pattern, r26
001387 93b0 2813                 	sts pulse1_pattern+1, r27
                                 
001389 9220 2816                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00138b 9220 2817                 	sts pulse1_pattern_offset+1, zero
00138d cd59                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
00138e 91e0 2816                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001390 91f0 2817                 	lds ZH, pulse1_pattern_offset+1
001392 9631                      	adiw Z, 1
001393 93e0 2816                 	sts pulse1_pattern_offset, ZL
001395 93f0 2817                 	sts pulse1_pattern_offset+1, ZH
001397 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001398 91e0 2816                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
00139a 91f0 2817                 	lds ZH, pulse1_pattern_offset+1
00139c 9632                      	adiw Z, 2 //increment the pointer twice
00139d 93e0 2816                 	sts pulse1_pattern_offset, ZL
00139f 93f0 2817                 	sts pulse1_pattern_offset+1, ZH
0013a1 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
0013a2 936f                      	push r22
0013a3 937f                      	push r23
0013a4 9160 280e                 	lds r22, song_speed
0013a6 2fa6                      	mov r26, r22
0013a7 50a1                      	subi r26, 1
0013a8 2fda                      	mov r29, r26
                                 
                                 sound_driver_calculate_delays_pulse1:
                                 sound_driver_calculate_delays_pulse1_Sxx:
0013a9 91b0 285d                 	lds r27, pulse1_fx_Sxx_pre
0013ab 91c0 285e                 	lds r28, pulse1_fx_Sxx_post
0013ad 9220 285d                  	sts pulse1_fx_Sxx_pre, zero
0013af 15b2                      	cp r27, zero
0013b0 f051                      	breq sound_driver_calculate_delays_pulse1_Sxx_post
0013b1 17b6                      	cp r27, r22 //compare the Gxx fx to the song speed
0013b2 f440                      	brsh sound_driver_calculate_delays_pulse1_Sxx_post
0013b3 93b0 2814                 	sts pulse1_pattern_delay, r27
0013b5 9220 2815                 	sts pulse1_pattern_delay+1, zero
0013b7 1bdb                      	sub r29, r27 //(song speed)-1-Sxx
0013b8 93d0 285e                 	sts pulse1_fx_Sxx_post, r29
0013ba c026                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
0013bb 15c2                      	cp r28, zero
0013bc f021                      	breq sound_driver_calculate_delays_pulse1_Gxx
0013bd 9220 285e                 	sts pulse1_fx_Sxx_post, zero
0013bf 2fac                      	mov r26, r28
0013c0 c00c                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
0013c1 91b0 284e                 	lds r27, pulse1_fx_Gxx_pre
0013c3 91c0 284f                 	lds r28, pulse1_fx_Gxx_post
0013c5 17b6                      	cp r27, r22 //compare the Gxx fx to the song speed
0013c6 f018                      	brlo sound_driver_calculate_delays_pulse1_Gxx_post
0013c7 e0b0                      	ldi r27, 0 //if the Gxx effect exceeds one row (the song speed), then reset the effect to 0
0013c8 9220 284e                 	sts pulse1_fx_Gxx_pre, zero
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
0013ca 15c2                      	cp r28, zero
0013cb f009                      	breq sound_driver_calculate_delays_pulse1_main
0013cc 2fac                      	mov r26, r28 //if there was a Gxx, use its post instead of the (song speed)-1
                                 	
                                 sound_driver_calculate_delays_pulse1_main:
0013cd 9170 2814                 	lds r23, pulse1_pattern_delay
0013cf 9f67                      	mul r22, r23
0013d0 0e0a                      	add r0, r26
0013d1 1c12                      	adc r1, zero
0013d2 0e0b                      	add r0, r27
0013d3 1c12                      	adc r1, zero
0013d4 9200 2814                 	sts pulse1_pattern_delay, r0
0013d6 9210 2815                 	sts pulse1_pattern_delay+1, r1
0013d8 9220 284f                 	sts pulse1_fx_Gxx_post, zero
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
0013da 15b2                      	cp r27, zero //check if the Gxx effect was enabled
0013db f029                      	breq sound_driver_calculate_delays_pulse2
0013dc 1bdb                      	sub r29, r27 //(song speed)-1-Gxx
0013dd 93a0 284f                 	sts pulse1_fx_Gxx_post, r26
0013df 9220 284e                 	sts pulse1_fx_Gxx_pre, zero
                                 
                                 sound_driver_calculate_delays_pulse2:
                                 sound_driver_calculate_delays_pulse2_Gxx:
0013e1 917f                      	pop r23
0013e2 916f                      	pop r22
0013e3 c006                      	rjmp sound_driver_instrument_routine
                                 
                                 
                                 
                                 sound_driver_channel0_decrement_frame_delay:
0013e4 50a1                      	subi r26, 1
0013e5 09b2                      	sbc r27, zero
0013e6 93a0 2814                 	sts pulse1_pattern_delay, r26
0013e8 93b0 2815                 	sts pulse1_pattern_delay+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine:
                                 sound_driver_instrument_routine_channel0_volume:
0013ea 91e0 2818                 	lds ZL, pulse1_volume_macro
0013ec 91f0 2819                 	lds ZH, pulse1_volume_macro+1
0013ee 9630                      	adiw Z, 0
0013ef f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0013f0 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0013f1 1fff                      	rol ZH
0013f2 91a0 281a                 	lds r26, pulse1_volume_macro_offset
0013f4 0fea                      	add ZL, r26
0013f5 1df2                      	adc ZH, zero
                                 
0013f6 91b0 281c                 	lds r27, pulse1_volume_macro_release
0013f8 17ba                      	cp r27, r26
0013f9 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0013fa 91a0 281b                 	lds r26, pulse1_volume_macro_loop
0013fc 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0013fd f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0013fe c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0013ff 95a3                      	inc r26 //increment the macro offset
001400 93a0 281a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
001402 91b4                      	lpm r27, Z //load volume data into r27
001403 3fbf                      	cpi r27, 0xFF //check for macro end flag
001404 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
001405 91b0 281c                 	lds r27, pulse1_volume_macro_release
001407 3fbf                      	cpi r27, 0xFF
001408 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
001409 91b0 281b                 	lds r27, pulse1_volume_macro_loop //load the loop index
00140b 93b0 281a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00140d cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
00140e 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00140f 93a0 281a                 	sts pulse1_volume_macro_offset, r26
001411 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
001412 eae8                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
001413 e2ff                      	ldi ZH, HIGH(volumes << 1)
001414 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
001415 0feb                      	add ZL, r27 //add offset to the table
001416 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
001417 91b0 2800                 	lds r27, pulse1_param //load main volume
001419 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00141a 91a0 284c                 	lds r26, pulse1_fx_7xy_value
00141c 30a0                      	cpi r26, 0x00
00141d f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
00141e 0feb                      	add ZL, r27 //offset the volume table by the main volume
00141f 1df2                      	adc ZH, zero
001420 91b4                      	lpm r27, Z
001421 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001423 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
001424 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
001426 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001427 91a0 284c                 	lds r26, pulse1_fx_7xy_value
001429 30a0                      	cpi r26, 0x00
00142a f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
00142b 93b0 2806                 	sts pulse1_output_volume, r27
00142d c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
00142e 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00142f f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
001430 f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
001431 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
001432 0feb                      	add ZL, r27 //offset the volume table by the main volume
001433 1df2                      	adc ZH, zero
001434 91b4                      	lpm r27, Z
001435 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001437 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
001438 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001439 0feb                      	add ZL, r27 //offset the volume table by the main volume
00143a 1df2                      	adc ZH, zero
00143b 91b4                      	lpm r27, Z
00143c 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00143e c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
00143f 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001440 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001441 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001442 93b0 2806                 	sts pulse1_output_volume, r27
001444 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
001445 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001446 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001448 91e0 281d                 	lds ZL, pulse1_arpeggio_macro
00144a 91f0 281e                 	lds ZH, pulse1_arpeggio_macro+1
00144c 9630                      	adiw Z, 0
00144d f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00144e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00144f 1fff                      	rol ZH
001450 91a0 281f                 	lds r26, pulse1_arpeggio_macro_offset
001452 0fea                      	add ZL, r26
001453 1df2                      	adc ZH, zero
                                 
001454 91b0 2821                 	lds r27, pulse1_arpeggio_macro_release
001456 17ba                      	cp r27, r26
001457 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
001458 91a0 2820                 	lds r26, pulse1_arpeggio_macro_loop
00145a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00145b f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00145c c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00145d 95a3                      	inc r26 //increment the macro offset
00145e 93a0 281f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
001460 91b4                      	lpm r27, Z //load arpeggio data into r27
001461 38b0                      	cpi r27, 0x80 //check for macro end flag
001462 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
001463 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
001464 50a1                      	subi r26, 1 //keep the offset at the end flag
001465 93a0 281f                 	sts pulse1_arpeggio_macro_offset, r26
001467 91b0 2822                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001469 30b1                      	cpi r27, 0x01
00146a f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
00146b 91b0 2821                 	lds r27, pulse1_arpeggio_macro_release
00146d 3fbf                      	cpi r27, 0xFF
00146e f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
00146f 91b0 2820                 	lds r27, pulse1_arpeggio_macro_loop
001471 3fbf                      	cpi r27, 0xFF
001472 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
001473 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
001474 91b0 2821                 	lds r27, pulse1_arpeggio_macro_release
001476 3fbf                      	cpi r27, 0xFF
001477 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
001478 91b0 2820                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
00147a 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00147b f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
00147c 91c0 2834                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
00147e 91d0 2835                 	lds r29, pulse1_fx_0xy_sequence+1
001480 9620                      	adiw r29:r28, 0
001481 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
001482 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
001483 93a0 281f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
001485 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
001486 93b0 281f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
001488 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
001489 91c0 2834                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
00148b 91d0 2835                 	lds r29, pulse1_fx_0xy_sequence+1
00148d 9620                      	adiw r29:r28, 0 //check for 0xy effect
00148e f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
00148f 95d6                      	lsr r29
001490 95c7                      	ror r28
001491 95d7                      	ror r29
001492 95c7                      	ror r28
001493 95d7                      	ror r29
001494 95c7                      	ror r28
001495 95d7                      	ror r29
001496 95c7                      	ror r28
001497 95d7                      	ror r29
001498 95d2                      	swap r29
                                 
001499 93c0 2834                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
00149b 93d0 2835                 	sts pulse1_fx_0xy_sequence+1, r29
00149d 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00149e 91a0 2807                 	lds r26, pulse1_note //load the current note index
0014a0 0fac                      	add r26, r28 //add the note offset
0014a1 c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0014a2 91a0 2807                 	lds r26, pulse1_note //load the current note index
0014a4 c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0014a5 9220 2823                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0014a7 9220 2829                 	sts pulse1_total_hi_pitch_offset, zero
0014a9 91a0 2822                 	lds r26, pulse1_arpeggio_macro_mode
0014ab 30a1                      	cpi r26, 0x01 //absolute mode
0014ac f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0014ad f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0014ae c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0014af 91a0 2807                 	lds r26, pulse1_note //load the current note index
0014b1 0fab                      	add r26, r27 //offset the note with the arpeggio data
0014b2 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0014b3 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0014b4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0014b5 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0014b6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0014b7 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0014b8 fda7                      	sbrc r26, 7 //check if result is negative
0014b9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0014ba c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0014bb 2fab                      	mov r26, r27 //move the arpeggio data into r26
0014bc c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0014bd 91a0 2807                 	lds r26, pulse1_note //load the current note index
0014bf 0fab                      	add r26, r27 //offset the note with the arpeggio data
0014c0 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0014c1 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0014c2 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0014c4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0014c5 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0014c6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0014c7 93a0 2807                 	sts pulse1_note, r26
0014c9 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
0014ca fda7                      	sbrc r26, 7 //check if result is negative
0014cb e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0014cc 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
0014ce e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0014cf e0f0                      	ldi ZH, HIGH(note_table << 1)
0014d0 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0014d1 0fea                      	add ZL, r26 //add offset
0014d2 1df2                      	adc ZH, zero
0014d3 91a5                      	lpm r26, Z+ //load bytes
0014d4 91b4                      	lpm r27, Z
0014d5 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
0014d7 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
0014d9 93a0 2840                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0014db 93b0 2841                 	sts pulse1_fx_3xx_target+1, r27
0014dd c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
0014de 91e0 2824                 	lds ZL, pulse1_pitch_macro
0014e0 91f0 2825                 	lds ZH, pulse1_pitch_macro+1
0014e2 9630                      	adiw Z, 0
0014e3 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
0014e4 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
0014e5 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0014e6 1fff                      	rol ZH
0014e7 91a0 2826                 	lds r26, pulse1_pitch_macro_offset
0014e9 0fea                      	add ZL, r26
0014ea 1df2                      	adc ZH, zero
                                 
0014eb 91b0 2828                 	lds r27, pulse1_pitch_macro_release
0014ed 17ba                      	cp r27, r26
0014ee f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0014ef 91a0 2827                 	lds r26, pulse1_pitch_macro_loop
0014f1 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0014f2 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0014f3 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0014f4 95a3                      	inc r26 //increment the macro offset
0014f5 93a0 2826                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0014f7 91b4                      	lpm r27, Z //load pitch data into r27
0014f8 38b0                      	cpi r27, 0x80 //check for macro end flag
0014f9 f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0014fa 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0014fb 93a0 2826                 	sts pulse1_pitch_macro_offset, r26
0014fd 91b0 2828                 	lds r27, pulse1_pitch_macro_release
0014ff 3fbf                      	cpi r27, 0xFF
001500 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
001501 91b0 2827                 	lds r27, pulse1_pitch_macro_loop //load the loop index
001503 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001504 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
001505 93b0 2826                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
001507 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
001508 91b0 2823                 	lds r27, pulse1_total_pitch_offset
00150a c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
00150b 91a0 2823                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
00150d 0fba                      	add r27, r26
00150e 93b0 2823                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
001510 91a0 2850                 	lds r26, pulse1_fx_Pxx
001512 0fba                      	add r27, r26
                                 
001513 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001514 937f                      	push r23
001515 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
001516 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001517 0367                      	mulsu r22, r23
001518 917f                      	pop r23
001519 916f                      	pop r22
                                 
00151a 9416                      	lsr r1 //shift out the fractional bits
00151b 9407                      	ror r0
00151c 9416                      	lsr r1
00151d 9407                      	ror r0
00151e 9416                      	lsr r1
00151f 9407                      	ror r0
001520 9416                      	lsr r1
001521 9407                      	ror r0
001522 fe13                      	sbrs r1, 3 //check if result was a negative number
001523 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
001524 efb0                      	ldi r27, 0xF0
001525 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
001526 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
001528 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00152a 0da0                      	add r26, r0 //offset the timer values
00152b 1db1                      	adc r27, r1
                                 	
00152c 91c0 2838                 	lds r28, pulse1_fx_1xx_total
00152e 91d0 2839                 	lds r29, pulse1_fx_1xx_total+1
001530 1bac                      	sub r26, r28
001531 0bbd                      	sbc r27, r29
001532 91c0 283c                 	lds r28, pulse1_fx_2xx_total
001534 91d0 283d                 	lds r29, pulse1_fx_2xx_total+1
001536 0fac                      	add r26, r28
001537 1fbd                      	adc r27, r29
001538 91c0 2855                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00153a 91d0 2856                 	lds r29, pulse1_fx_Qxy_total_offset+1
00153c 1bac                      	sub r26, r28
00153d 0bbd                      	sbc r27, r29
00153e 91c0 285b                 	lds r28, pulse1_fx_Rxy_total_offset
001540 91d0 285c                 	lds r29, pulse1_fx_Rxy_total_offset+1
001542 0fac                      	add r26, r28
001543 1fbd                      	adc r27, r29
                                 
001544 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
001546 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
001548 91e0 282a                 	lds ZL, pulse1_hi_pitch_macro
00154a 91f0 282b                 	lds ZH, pulse1_hi_pitch_macro+1
00154c 9630                      	adiw Z, 0
00154d f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
00154e c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
00154f 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001550 1fff                      	rol ZH
001551 91a0 282c                 	lds r26, pulse1_hi_pitch_macro_offset
001553 0fea                      	add ZL, r26
001554 1df2                      	adc ZH, zero
                                 
001555 91b0 282e                 	lds r27, pulse1_hi_pitch_macro_release
001557 17ba                      	cp r27, r26
001558 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
001559 91a0 282d                 	lds r26, pulse1_hi_pitch_macro_loop
00155b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00155c f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00155d c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
00155e 95a3                      	inc r26 //increment the macro offset
00155f 93a0 282c                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
001561 91b4                      	lpm r27, Z //load hi pitch data into r27
001562 38b0                      	cpi r27, 0x80 //check for macro end flag
001563 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
001564 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001565 93a0 282c                 	sts pulse1_hi_pitch_macro_offset, r26
001567 91b0 282e                 	lds r27, pulse1_hi_pitch_macro_release
001569 3fbf                      	cpi r27, 0xFF
00156a f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
00156b 91b0 282d                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
00156d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00156e f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00156f 93b0 282c                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
001571 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
001572 91b0 2829                 	lds r27, pulse1_total_hi_pitch_offset
001574 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
001575 91a0 2829                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
001577 0fba                      	add r27, r26
001578 93b0 2829                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
00157a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00157b 937f                      	push r23
00157c 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00157d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00157e 0367                      	mulsu r22, r23
00157f 917f                      	pop r23
001580 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
001581 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
001583 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
001585 0da0                      	add r26, r0 //offset the timer values
001586 1db1                      	adc r27, r1
001587 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
001589 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
00158b 91e0 282f                 	lds ZL, pulse1_duty_macro
00158d 91f0 2830                 	lds ZH, pulse1_duty_macro+1
00158f 9630                      	adiw Z, 0
001590 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
001591 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001592 1fff                      	rol ZH
001593 91a0 2831                 	lds r26, pulse1_duty_macro_offset
001595 0fea                      	add ZL, r26
001596 1df2                      	adc ZH, zero
                                 
001597 91b0 2833                 	lds r27, pulse1_duty_macro_release
001599 17ba                      	cp r27, r26
00159a f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
00159b 91a0 2832                 	lds r26, pulse1_duty_macro_loop
00159d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00159e f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00159f c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0015a0 95a3                      	inc r26 //increment the macro offset
0015a1 93a0 2831                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0015a3 91b4                      	lpm r27, Z //load pitch data into r27
0015a4 3fbf                      	cpi r27, 0xFF //check for macro end flag
0015a5 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0015a6 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0015a7 93a0 2831                 	sts pulse1_duty_macro_offset, r26
0015a9 91b0 2833                 	lds r27, pulse1_duty_macro_release
0015ab 3fbf                      	cpi r27, 0xFF
0015ac f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0015ad 91b0 2832                 	lds r27, pulse1_duty_macro_loop //load the loop index
0015af 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0015b0 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0015b1 93b0 2831                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0015b3 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0015b4 e7e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0015b5 e2ff                      	ldi ZH, HIGH(sequences << 1)
0015b6 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0015b7 1df2                      	adc ZH, zero
                                 
0015b8 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0015b9 95b7                      	ror r27
0015ba 95b7                      	ror r27
0015bb 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0015bd 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0015be 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0015bf 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0015c0 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0015c1 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0015c2 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0015c3 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0015c4 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0015c5 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0015c7 91e0 2836                 	lds ZL, pulse1_fx_1xx
0015c9 91f0 2837                 	lds ZH, pulse1_fx_1xx+1
0015cb 9630                      	adiw Z, 0
0015cc f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0015cd 91a0 2838                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0015cf 91b0 2839                 	lds r27, pulse1_fx_1xx_total+1
0015d1 0fae                      	add r26, ZL //increase the total offset by the rate
0015d2 1fbf                      	adc r27, ZH
0015d3 93a0 2838                 	sts pulse1_fx_1xx_total, r26
0015d5 93b0 2839                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0015d7 91e0 283a                 	lds ZL, pulse1_fx_2xx
0015d9 91f0 283b                 	lds ZH, pulse1_fx_2xx+1
0015db 9630                      	adiw Z, 0
0015dc f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0015dd 91a0 283c                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0015df 91b0 283d                 	lds r27, pulse1_fx_2xx_total+1
0015e1 0fae                      	add r26, ZL //increase the total offset by the rate
0015e2 1fbf                      	adc r27, ZH
0015e3 93a0 283c                 	sts pulse1_fx_2xx_total, r26
0015e5 93b0 283d                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0015e7 91e0 2842                 	lds ZL, pulse1_fx_3xx_speed
0015e9 91f0 2843                 	lds ZH, pulse1_fx_3xx_speed+1
0015eb 9630                      	adiw Z, 0
0015ec f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0015ed c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0015ee 91a0 283e                 	lds r26, pulse1_fx_3xx_start
0015f0 91b0 283f                 	lds r27, pulse1_fx_3xx_start+1
0015f2 9610                      	adiw r26:r27, 0
0015f3 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0015f4 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0015f5 91c0 2840                 	lds r28, pulse1_fx_3xx_target
0015f7 91d0 2841                 	lds r29, pulse1_fx_3xx_target+1
                                 
0015f9 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0015fa 07bd                      	cpc r27, r29
0015fb f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0015fc f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0015fd c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0015fe 9220 283e                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
001600 9220 283f                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
001602 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
001603 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
001604 0bdb                      	sbc r29, r27
001605 91a0 2844                 	lds r26, pulse1_fx_3xx_total_offset
001607 91b0 2845                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
001609 0fae                      	add r26, ZL //add the speed to the total offset
00160a 1fbf                      	adc r27, ZH
00160b 1bca                      	sub r28, r26 //invert the total difference with the total offset
00160c 0bdb                      	sbc r29, r27
00160d f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00160e 93a0 2844                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
001610 93b0 2845                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
001612 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
001614 91b0 0a8d                 	lds r27, TCB0_CCMPH
001616 1bac                      	sub r26, r28 //offset the current timer period with the total offset
001617 0bbd                      	sbc r27, r29
001618 93a0 0a8c                 	sts TCB0_CCMPL, r26
00161a 93b0 0a8d                 	sts TCB0_CCMPH, r27
00161c c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
00161d 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00161e 0bbd                      	sbc r27, r29
00161f 91c0 2844                 	lds r28, pulse1_fx_3xx_total_offset
001621 91d0 2845                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
001623 0fce                      	add r28, ZL //add the speed to the total offset
001624 1fdf                      	adc r29, ZH
001625 1bac                      	sub r26, r28 //invert the total difference with the total offset
001626 0bbd                      	sbc r27, r29
001627 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
001628 93c0 2844                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
00162a 93d0 2845                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
00162c 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
00162e 91d0 0a8d                 	lds r29, TCB0_CCMPH
001630 0fca                      	add r28, r26 //offset the current timer period with the total offset
001631 1fdb                      	adc r29, r27
001632 93c0 0a8c                 	sts TCB0_CCMPL, r28
001634 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
001636 91a0 2846                 	lds r26, pulse1_fx_4xy_speed
001638 15a2                      	cp r26, zero
001639 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
00163a c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00163b 91b0 2847                 	lds r27, pulse1_fx_4xy_depth
00163d 91c0 2848                 	lds r28, pulse1_fx_4xy_phase
00163f 0fca                      	add r28, r26 //increase the phase by the speed
001640 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001641 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
001642 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
001643 93c0 2848                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
001645 31c0                      	cpi r28, 16
001646 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
001647 32c0                      	cpi r28, 32
001648 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
001649 33c0                      	cpi r28, 48
00164a f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
00164b c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
00164c 70cf                      	andi r28, 0x0F //mask for values 0-15
00164d c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
00164e 6fc0                      	ori r28, 0xF0
00164f 95c0                      	com r28 //invert values 0-15
001650 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
001651 70cf                      	andi r28, 0x0F //mask for values 0-15
001652 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
001653 6fc0                      	ori r28, 0xF0
001654 95c0                      	com r28 //invert values 0-15
001655 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
001656 95b2                      	swap r27 //multiply depth by 16
001657 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001658 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001659 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
00165a 0fec                      	add ZL, r28 //offset the table by the depth+phase
00165b 1df2                      	adc ZH, zero
00165c 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00165d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00165e 937f                      	push r23
00165f 2f6c                      	mov r22, r28 //store the vibrato value into r22
001660 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001661 9f67                      	mul r22, r23
001662 917f                      	pop r23
001663 916f                      	pop r22
                                 
001664 9416                      	lsr r1 //shift out the fractional bits
001665 9407                      	ror r0
001666 9416                      	lsr r1
001667 9407                      	ror r0
001668 9416                      	lsr r1
001669 9407                      	ror r0
00166a 9416                      	lsr r1
00166b 9407                      	ror r0
                                 	
00166c 91a0 0a8c                 	lds r26, TCB0_CCMPL
00166e 91b0 0a8d                 	lds r27, TCB0_CCMPH
001670 0da0                      	add r26, r0
001671 1db1                      	adc r27, r1
001672 93a0 0a8c                 	sts TCB0_CCMPL, r26
001674 93b0 0a8d                 	sts TCB0_CCMPH, r27
001676 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
001677 95b2                      	swap r27 //multiply depth by 16
001678 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
001679 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00167a e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
00167b 0fec                      	add ZL, r28 //offset the table by the depth+phase
00167c 1df2                      	adc ZH, zero
00167d 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00167e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00167f 937f                      	push r23
001680 2f6c                      	mov r22, r28 //store the vibrato value into r22
001681 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001682 9f67                      	mul r22, r23
001683 917f                      	pop r23
001684 916f                      	pop r22
                                 
001685 9416                      	lsr r1 //shift out the fractional bits
001686 9407                      	ror r0
001687 9416                      	lsr r1
001688 9407                      	ror r0
001689 9416                      	lsr r1
00168a 9407                      	ror r0
00168b 9416                      	lsr r1
00168c 9407                      	ror r0
                                 
00168d 91a0 0a8c                 	lds r26, TCB0_CCMPL
00168f 91b0 0a8d                 	lds r27, TCB0_CCMPH
001691 19a0                      	sub r26, r0
001692 09b1                      	sbc r27, r1
001693 93a0 0a8c                 	sts TCB0_CCMPL, r26
001695 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
001697 91a0 2849                 	lds r26, pulse1_fx_7xy_speed
001699 15a2                      	cp r26, zero
00169a f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00169b 91b0 284a                 	lds r27, pulse1_fx_7xy_depth
00169d 91c0 284b                 	lds r28, pulse1_fx_7xy_phase
00169f 0fca                      	add r28, r26 //increase the phase by the speed
0016a0 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0016a1 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0016a2 e0c0                      	ldi r28, 0x00
0016a3 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0016a4 93c0 284b                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
0016a6 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0016a7 ffc4                      	sbrs r28, 4
0016a8 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
0016a9 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
0016aa 70cf                      	andi r28, 0x0F //mask for values 0-15
0016ab c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
0016ac 6fc0                      	ori r28, 0xF0
0016ad 95c0                      	com r28 //invert values 0-15
0016ae c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
0016af 95b2                      	swap r27 //multiply depth by 16
0016b0 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0016b1 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0016b2 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
0016b3 0fec                      	add ZL, r28 //offset the table by the depth+phase
0016b4 1df2                      	adc ZH, zero
0016b5 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0016b6 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0016b7 93c0 284c                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
0016b9 91b0 284d                 	lds r27, pulse1_fx_Axy
0016bb 15b2                      	cp r27, zero
0016bc f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0016bd 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0016bf 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0016c1 2fda                      	mov r29, r26 //copy fractional volume into r29
0016c2 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0016c3 95e2                      	swap r30
0016c4 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0016c5 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0016c6 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0016c7 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0016c8 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0016c9 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0016ca c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0016cb 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0016cc f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0016cd efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0016ce c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0016cf 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0016d0 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0016d1 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0016d2 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0016d4 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0016d5 95a2                      	swap r26
0016d6 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0016d7 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0016d8 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0016da 91e0 2851                 	lds ZL, pulse1_fx_Qxy_target
0016dc 91f0 2852                 	lds ZH, pulse1_fx_Qxy_target+1
0016de 9630                      	adiw Z, 0
0016df f199                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0016e0 91a0 2855                 	lds r26, pulse1_fx_Qxy_total_offset
0016e2 91b0 2856                 	lds r27, pulse1_fx_Qxy_total_offset+1
0016e4 91c0 0a8c                 	lds r28, TCB0_CCMPL
0016e6 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0016e8 1bec                      	sub ZL, r28 //calculate the difference to the target
0016e9 0bfd                      	sbc ZH, r29
0016ea f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0016eb f0e8                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0016ec 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0016ed 0bbf                      	sbc r27, ZH
                                 
0016ee 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0016ef 937f                      	push r23
0016f0 9160 2850                 	lds r22, pulse1_fx_Pxx
0016f2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0016f3 9f67                      	mul r22, r23
0016f4 917f                      	pop r23
0016f5 916f                      	pop r22
0016f6 9416                      	lsr r1 //shift out the fractional bits
0016f7 9407                      	ror r0
0016f8 9416                      	lsr r1
0016f9 9407                      	ror r0
0016fa 9416                      	lsr r1
0016fb 9407                      	ror r0
0016fc 9416                      	lsr r1
0016fd 9407                      	ror r0
                                 
0016fe 0da0                      	add r26, r0
0016ff 1db2                      	adc r27, zero
                                 
001700 93a0 2855                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
001702 93b0 2856                 	sts pulse1_fx_Qxy_total_offset+1, r27
001704 9220 2851                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
001706 9220 2852                 	sts pulse1_fx_Qxy_target+1, zero
001708 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
001709 91c0 2853                 	lds r28, pulse1_fx_Qxy_speed
00170b 91d0 2854                 	lds r29, pulse1_fx_Qxy_speed+1
00170d 0fac                      	add r26, r28 //increase the total offset by the speed
00170e 1fbd                      	adc r27, r29
00170f 93a0 2855                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
001711 93b0 2856                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
001713 91e0 2857                 	lds ZL, pulse1_fx_Rxy_target
001715 91f0 2858                 	lds ZH, pulse1_fx_Rxy_target+1
001717 9630                      	adiw Z, 0
001718 f199                      	breq sound_driver_channel0_fx_xy_routine //if the effect is not enabled, skip the routine
                                 
001719 91a0 285b                 	lds r26, pulse1_fx_Rxy_total_offset
00171b 91b0 285c                 	lds r27, pulse1_fx_Rxy_total_offset+1
00171d 91c0 0a8c                 	lds r28, TCB0_CCMPL
00171f 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
001721 1bce                      	sub r28, ZL //calculate the difference to the target
001722 0bdf                      	sbc r29, ZH
001723 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
001724 f0e8                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
001725 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
001726 0bbd                      	sbc r27, r29
                                 
001727 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001728 937f                      	push r23
001729 9160 2850                 	lds r22, pulse1_fx_Pxx
00172b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00172c 9f67                      	mul r22, r23
00172d 917f                      	pop r23
00172e 916f                      	pop r22
00172f 9416                      	lsr r1 //shift out the fractional bits
001730 9407                      	ror r0
001731 9416                      	lsr r1
001732 9407                      	ror r0
001733 9416                      	lsr r1
001734 9407                      	ror r0
001735 9416                      	lsr r1
001736 9407                      	ror r0
                                 
001737 0da0                      	add r26, r0
001738 1db2                      	adc r27, zero
                                 
001739 93a0 285b                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
00173b 93b0 285c                 	sts pulse1_fx_Rxy_total_offset+1, r27
00173d 9220 2857                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
00173f 9220 2858                 	sts pulse1_fx_Rxy_target+1, zero
001741 c00a                      	rjmp sound_driver_channel0_fx_xy_routine
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
001742 91c0 2859                 	lds r28, pulse1_fx_Rxy_speed
001744 91d0 285a                 	lds r29, pulse1_fx_Rxy_speed+1
001746 0fac                      	add r26, r28 //increase the total offset by the speed
001747 1fbd                      	adc r27, r29
001748 93a0 285b                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
00174a 93b0 285c                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 sound_driver_channel0_fx_xy_routine:
                                 
                                 sound_driver_exit:
00174c 91df                      	pop r29
00174d 91cf                      	pop r28
00174e c906                      	rjmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
00174f b7bf                      	in r27, CPU_SREG
001750 93bf                      	push r27
001751 94f8                      	cli
                                 
001752 0cdd                      	lsl pulse1_sequence //shifts sequence to the left
001753 1cd2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001754 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001755 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001757 91bf                      	pop r27
001758 bfbf                      	out CPU_SREG, r27
001759 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00175a 2dbf                      	mov r27, pulse1_sweep
00175b 70b7                      	andi r27, 0x07 //mask for period divider bits
00175c f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00175d 93df                      	push r29
00175e 2ddf                      	mov r29, pulse1_sweep
00175f 95d2                      	swap r29
001760 70d7                      	andi r29, 0x07 //mask for shift bits
001761 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001762 91df                      	pop r29
001763 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001764 91a0 0a8c                 	lds r26, TCB0_CCMPL
001766 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001768 95b6                      	lsr r27
001769 95a7                      	ror r26
00176a 95da                      	dec r29
00176b f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00176c fef7                      	sbrs pulse1_sweep, 7 //check the negate flag
00176d c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
00176e 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
00176f 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001770 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001772 0fad                      	add r26, r29
001773 91d0 0a8d                 	lds r29, TCB0_CCMPH
001775 1fbd                      	adc r27, r29
                                 
001776 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001778 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 
                                 	//sts pulse1_timerL, r26
                                 	//sts pulse1_timerH, r27
                                 
                                 /*	//Sweep Test
                                 	mov r29, pulse1_sweep //invert the negate bit
                                 	ldi r27, 0b10000000
                                 	eor r29, r27
                                 	ori r29, 0b01111111
                                 
                                 	lds r27, pulse1_sweep_param //reload the pulse sweep divider params
                                 	swap r27
                                 	ori r27, 0b10000000
                                 	and r27, r29
                                 	mov pulse1_sweep, r27
                                 	sbr channel_flags, 0b10000000*/
                                 	
00177a 91df                      	pop r29
00177b c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
00177c 94fa                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
00177d ff97                      	sbrs channel_flags, 7 //if the reload flag is set, reload the sweep divider
00177e 9508                      	ret
                                 
                                 pulse1_sweep_reload:
00177f 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001781 94f2                      	swap pulse1_sweep //bring data from high byte to low byte
001782 779f                      	cbr channel_flags, 0b10000000 //clear reload flag
001783 9508                      	ret
                                 
                                 pulse1_envelope_routine:
001784 fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
001785 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001786 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001787 f011                      	breq PC+3 //if the divider == 0, check loop flag
001788 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001789 9508                      	ret
                                 
00178a 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
00178c 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00178d ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
00178e c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
00178f e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001790 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001791 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001792 f409                      	brne PC+2 //if decay != 0, go decrement
001793 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001794 951a                      	dec pulse1_volume_decay
001795 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001796 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
001797 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001799 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00179a e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
00179b 9508                      	ret
                                 
                                 //CONVERTERS (TABLES)
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
00179c e4e4                      	ldi ZL, LOW(length << 1)
00179d e2ff                      	ldi ZH, HIGH(length << 1)
00179e 0fed                      	add ZL, r29
00179f 1df2                      	adc ZH, zero
0017a0 91d4                      	lpm r29, Z
0017a1 9508                      	ret
                                 
0017a2 7f05
0017a3 010a
0017a4 0214
0017a5 0328
0017a6 0450
0017a7 051e
0017a8 0607
0017a9 070d
0017aa 0806
0017ab 090c
0017ac 0a18
0017ad 0b30
0017ae 0c60
0017af 0d24
0017b0 0e08
0017b1 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0017b2 e7e0                      	ldi ZL, LOW(sequences << 1)
0017b3 e2ff                      	ldi ZH, HIGH(sequences << 1)
0017b4 0fed                      	add ZL, r29
0017b5 1df2                      	adc ZH, zero
0017b6 91d4                      	lpm r29, Z
0017b7 9508                      	ret
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
0017b8 0301
0017b9 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 fx:
0017ba 1111
0017bb 1116
0017bc 1132
0017bd 114e
0017be 1171                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
0017bf 117c
0017c0 1189
0017c1 118c
0017c2 118f
0017c3 1192                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
0017c4 1195
0017c5 119d
0017c6 11a0
0017c7 11a3
0017c8 11aa                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
0017c9 11b2
0017ca 11b3
0017cb 11b4
0017cc 11b7
0017cd 11fb                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
0017ce 123e
0017cf 1241
0017d0 1255
0017d1 1256
0017d2 1257                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
0017d3 1258                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0017d4 0000
0017d5 0000
0017d6 0000
0017d7 0000
0017d8 0000
0017d9 0000
0017da 0000
0017db 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0017dc 0100
0017dd 0101
0017de 0101
0017df 0101
0017e0 0101
0017e1 0101
0017e2 0101
0017e3 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0017e4 0100
0017e5 0101
0017e6 0101
0017e7 0101
0017e8 0101
0017e9 0101
0017ea 0101
0017eb 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0017ec 0100
0017ed 0101
0017ee 0101
0017ef 0101
0017f0 0101
0017f1 0202
0017f2 0202
0017f3 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
0017f4 0100
0017f5 0101
0017f6 0101
0017f7 0101
0017f8 0202
0017f9 0202
0017fa 0303
0017fb 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
0017fc 0100
0017fd 0101
0017fe 0101
0017ff 0202
001800 0302
001801 0303
001802 0404
001803 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
001804 0100
001805 0101
001806 0201
001807 0202
001808 0303
001809 0404
00180a 0504
00180b 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
00180c 0100
00180d 0101
00180e 0201
00180f 0302
001810 0403
001811 0504
001812 0605
001813 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
001814 0100
001815 0101
001816 0202
001817 0303
001818 0404
001819 0505
00181a 0606
00181b 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
00181c 0100
00181d 0101
00181e 0302
00181f 0403
001820 0504
001821 0606
001822 0707
001823 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
001824 0100
001825 0201
001826 0302
001827 0404
001828 0605
001829 0706
00182a 0808
00182b 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
00182c 0100
00182d 0201
00182e 0302
00182f 0504
001830 0605
001831 0807
001832 0908
001833 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
001834 0100
001835 0201
001836 0403
001837 0504
001838 0706
001839 0808
00183a 0a09
00183b 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
00183c 0100
00183d 0201
00183e 0403
00183f 0605
001840 0706
001841 0908
001842 0b0a
001843 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
001844 0100
001845 0201
001846 0403
001847 0605
001848 0807
001849 0a09
00184a 0c0b
00184b 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
00184c 0100
00184d 0302
00184e 0504
00184f 0706
001850 0908
001851 0b0a
001852 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  :  67 r0 :  54 r1 :  54 r2 : 204 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   6 r14:   4 r15:  13 r16:   7 r17:   6 r18:   0 r19:   0 r20:   0 
r21:   0 r22:  51 r23:  48 r24:   0 r25:  15 r26: 275 r27: 376 r28: 148 
r29: 114 r30:  92 r31:  87 
Registers used: 18 out of 35 (51.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  43 add   :  56 adiw  :  29 and   :   0 
andi  :  31 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   4 break :   0 breq  :  43 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  22 brlt  :   0 brmi  :   0 
brne  :  33 brpl  :   0 brsh  :   8 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   2 
clc   :   0 clh   :   0 cli   :   5 cln   :   0 clr   :   3 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   5 cp    :  25 cpc   :   4 
cpi   :  45 cpse  :   6 dec   :   7 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :   4 inc   :  13 
jmp   :   6 ld    :   0 ldd   :   0 ldi   :  98 lds   : 200 lpm   :  76 
lsl   :  20 lsr   :  47 mov   :  37 movw  :   0 mul   :  10 muls  :   0 
mulsu :   2 neg   :   0 nop   :   0 or    :   6 ori   :   5 out   :   7 
pop   :  38 push  :  35 rcall :  14 ret   :  13 reti  :   4 rjmp  : 132 
rol   :  13 ror   :  53 sbc   :  13 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   7 sbrc  :   8 sbrs  :   6 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   : 378 sub   :  17 subi  :  13 swap  :  16 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0030a8   4440   7988  12428   49152  25.3%
[.dseg] 0x002800 0x002863      0     99     99    6144   1.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 61 warnings
