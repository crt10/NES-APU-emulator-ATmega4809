
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Sat May 29 22:51:57 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of noise
002817                           noise_note: .byte 1 //the current note index in the period table
002818                           noise_adjusted_note: .byte 1 //the resultant note index after the arpeggio macro
                                 
002819                           song_frames: .byte 2
00281b                           song_frame_offset: .byte 2
00281d                           song_size: .byte 2
00281f                           song_tempo: .byte 2
002821                           song_tempo_correction: .byte 2
002823                           song_tempo_correction_cycles: .byte 1
002824                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002825                           song_fx_Bxx: .byte 1
002826                           song_fx_Cxx: .byte 1
002827                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002828                           pulse1_pattern: .byte 2
00282a                           pulse1_pattern_delay_rows: .byte 1
00282b                           pulse1_pattern_delay_frames: .byte 1
00282c                           pulse1_pattern_offset: .byte 2
                                 
00282e                           pulse1_volume_macro: .byte 2
002830                           pulse1_volume_macro_offset: .byte 1
002831                           pulse1_volume_macro_loop: .byte 1
002832                           pulse1_volume_macro_release: .byte 1
                                 
002833                           pulse1_arpeggio_macro: .byte 2
002835                           pulse1_arpeggio_macro_offset: .byte 1
002836                           pulse1_arpeggio_macro_loop: .byte 1
002837                           pulse1_arpeggio_macro_release: .byte 1
002838                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002839                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
00283b                           pulse1_pitch_macro: .byte 2
00283d                           pulse1_pitch_macro_offset: .byte 1
00283e                           pulse1_pitch_macro_loop: .byte 1
00283f                           pulse1_pitch_macro_release: .byte 1
                                 
002840                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002841                           pulse1_hi_pitch_macro: .byte 2
002843                           pulse1_hi_pitch_macro_offset: .byte 1
002844                           pulse1_hi_pitch_macro_loop: .byte 1
002845                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002846                           pulse1_duty_macro: .byte 2
002848                           pulse1_duty_macro_offset: .byte 1
002849                           pulse1_duty_macro_loop: .byte 1
00284a                           pulse1_duty_macro_release: .byte 1
                                 
00284b                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00284d                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00284f                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002851                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002853                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002855                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002857                           pulse1_fx_3xx_target: .byte 2 //target note period
002859                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00285b                           pulse1_fx_3xx_total_offset: .byte 2
00285d                           pulse1_fx_4xy_speed: .byte 1
00285e                           pulse1_fx_4xy_depth: .byte 1
00285f                           pulse1_fx_4xy_phase: .byte 1
002860                           pulse1_fx_7xy_speed: .byte 1
002861                           pulse1_fx_7xy_depth: .byte 1
002862                           pulse1_fx_7xy_phase: .byte 1
002863                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002864                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002865                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002866                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002867                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002869                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
00286a                           pulse1_fx_Qxy_target: .byte 2 //target note period
00286c                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00286e                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002870                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
002871                           pulse1_fx_Rxy_target: .byte 2 //target note period
002873                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002875                           pulse1_fx_Rxy_total_offset: .byte 2
002877                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002878                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002879                           pulse2_pattern: .byte 2
00287b                           pulse2_pattern_delay_rows: .byte 1
00287c                           pulse2_pattern_delay_frames: .byte 1
00287d                           pulse2_pattern_offset: .byte 2
                                 
00287f                           pulse2_volume_macro: .byte 2
002881                           pulse2_volume_macro_offset: .byte 1
002882                           pulse2_volume_macro_loop: .byte 1
002883                           pulse2_volume_macro_release: .byte 1
                                 
002884                           pulse2_arpeggio_macro: .byte 2
002886                           pulse2_arpeggio_macro_offset: .byte 1
002887                           pulse2_arpeggio_macro_loop: .byte 1
002888                           pulse2_arpeggio_macro_release: .byte 1
002889                           pulse2_arpeggio_macro_mode: .byte 1
                                 
00288a                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
00288c                           pulse2_pitch_macro: .byte 2
00288e                           pulse2_pitch_macro_offset: .byte 1
00288f                           pulse2_pitch_macro_loop: .byte 1
002890                           pulse2_pitch_macro_release: .byte 1
                                 
002891                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002892                           pulse2_hi_pitch_macro: .byte 2
002894                           pulse2_hi_pitch_macro_offset: .byte 1
002895                           pulse2_hi_pitch_macro_loop: .byte 1
002896                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002897                           pulse2_duty_macro: .byte 2
002899                           pulse2_duty_macro_offset: .byte 1
00289a                           pulse2_duty_macro_loop: .byte 1
00289b                           pulse2_duty_macro_release: .byte 1
                                 
00289c                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00289e                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028a0                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028a2                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028a4                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a6                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a8                           pulse2_fx_3xx_target: .byte 2 //target note period
0028aa                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028ac                           pulse2_fx_3xx_total_offset: .byte 2
0028ae                           pulse2_fx_4xy_speed: .byte 1
0028af                           pulse2_fx_4xy_depth: .byte 1
0028b0                           pulse2_fx_4xy_phase: .byte 1
0028b1                           pulse2_fx_7xy_speed: .byte 1
0028b2                           pulse2_fx_7xy_depth: .byte 1
0028b3                           pulse2_fx_7xy_phase: .byte 1
0028b4                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028b5                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b6                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b7                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b8                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028ba                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028bb                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028bd                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028bf                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028c1                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028c2                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028c4                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c6                           pulse2_fx_Rxy_total_offset: .byte 2
0028c8                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c9                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028ca                           triangle_pattern: .byte 2
0028cc                           triangle_pattern_delay_rows: .byte 1
0028cd                           triangle_pattern_delay_frames: .byte 1
0028ce                           triangle_pattern_offset: .byte 2
                                 
0028d0                           triangle_volume_macro: .byte 2
0028d2                           triangle_volume_macro_offset: .byte 1
0028d3                           triangle_volume_macro_loop: .byte 1
0028d4                           triangle_volume_macro_release: .byte 1
                                 
0028d5                           triangle_arpeggio_macro: .byte 2
0028d7                           triangle_arpeggio_macro_offset: .byte 1
0028d8                           triangle_arpeggio_macro_loop: .byte 1
0028d9                           triangle_arpeggio_macro_release: .byte 1
0028da                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028db                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028dd                           triangle_pitch_macro: .byte 2
0028df                           triangle_pitch_macro_offset: .byte 1
0028e0                           triangle_pitch_macro_loop: .byte 1
0028e1                           triangle_pitch_macro_release: .byte 1
                                 
0028e2                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028e3                           triangle_hi_pitch_macro: .byte 2
0028e5                           triangle_hi_pitch_macro_offset: .byte 1
0028e6                           triangle_hi_pitch_macro_loop: .byte 1
0028e7                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e8                           triangle_duty_macro: .byte 2
0028ea                           triangle_duty_macro_offset: .byte 1
0028eb                           triangle_duty_macro_loop: .byte 1
0028ec                           triangle_duty_macro_release: .byte 1
                                 
0028ed                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028ef                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028f1                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028f3                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028f5                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f7                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f9                           triangle_fx_3xx_target: .byte 2 //target note period
0028fb                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028fd                           triangle_fx_3xx_total_offset: .byte 2
0028ff                           triangle_fx_4xy_speed: .byte 1
002900                           triangle_fx_4xy_depth: .byte 1
002901                           triangle_fx_4xy_phase: .byte 1
002902                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002903                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002904                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002906                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002907                           triangle_fx_Qxy_target: .byte 2 //target note period
002909                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00290b                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00290d                           triangle_fx_Rxy_target_note: .byte 1 //target note index
00290e                           triangle_fx_Rxy_target: .byte 2 //target note period
002910                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002912                           triangle_fx_Rxy_total_offset: .byte 2
002914                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002915                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002916                           noise_pattern: .byte 2
002918                           noise_pattern_delay_rows: .byte 1
002919                           noise_pattern_delay_frames: .byte 1
00291a                           noise_pattern_offset: .byte 2
                                 
00291c                           noise_volume_macro: .byte 2
00291e                           noise_volume_macro_offset: .byte 1
00291f                           noise_volume_macro_loop: .byte 1
002920                           noise_volume_macro_release: .byte 1
                                 
002921                           noise_arpeggio_macro: .byte 2
002923                           noise_arpeggio_macro_offset: .byte 1
002924                           noise_arpeggio_macro_loop: .byte 1
002925                           noise_arpeggio_macro_release: .byte 1
002926                           noise_arpeggio_macro_mode: .byte 1
                                 
002927                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002929                           noise_pitch_macro: .byte 2
00292b                           noise_pitch_macro_offset: .byte 1
00292c                           noise_pitch_macro_loop: .byte 1
00292d                           noise_pitch_macro_release: .byte 1
                                 
00292e                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00292f                           noise_hi_pitch_macro: .byte 2
002931                           noise_hi_pitch_macro_offset: .byte 1
002932                           noise_hi_pitch_macro_loop: .byte 1
002933                           noise_hi_pitch_macro_release: .byte 1
                                 
002934                           noise_duty_macro: .byte 2
002936                           noise_duty_macro_offset: .byte 1
002937                           noise_duty_macro_loop: .byte 1
002938                           noise_duty_macro_release: .byte 1
                                 
002939                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00293b                           noise_fx_1xx: .byte 1 //refers to the rate in which to subtract the pitch from by the 1xx
00293c                           noise_fx_1xx_total: .byte 1 //the total pitch offset for 1xx
00293d                           noise_fx_2xx: .byte 1 //refers to the rate in which to add to the pitch by the 2xx
00293e                           noise_fx_2xx_total: .byte 1 //the total pitch offset for 2xx
00293f                           noise_fx_4xy_speed: .byte 1
002940                           noise_fx_4xy_depth: .byte 1
002941                           noise_fx_4xy_phase: .byte 1
002942                           noise_fx_4xy_offset: .byte 1
002943                           noise_fx_7xy_speed: .byte 1
002944                           noise_fx_7xy_depth: .byte 1
002945                           noise_fx_7xy_phase: .byte 1
002946                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002947                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002948                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002949                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00294a                           noise_fx_Pxx_total: .byte 1 //refers to the fine pitch offset set by the Pxx effect
00294b                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
00294c                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
00294d                           dpcm_pattern: .byte 2
00294f                           dpcm_pattern_delay_rows: .byte 1
002950                           dpcm_pattern_delay_frames: .byte 1
002951                           dpcm_pattern_offset: .byte 2
                                 
002953                           dpcm_sample: .byte 2
002955                           dpcm_sample_offset: .byte 2
                                 
002957                           dpcm_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002958                           dpcm_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002959                           dpcm_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
00295a                           dpcm_fx_Sxx_post: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 //NOTE: same idea with one
                                 .def zero = r2
                                 .def one = r3
                                 .def frame_sequence = r4
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r7
                                 .def pulse1_length_counter = r8
                                 .def pulse1_sweep = r9 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r10
                                 .def pulse2_length_counter = r11
                                 .def pulse2_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 .def dpcm_shift = r13
                                 .def dpcm_bit_counter = r14
                                 .def dpcm_period = r15
                                 .def dpcm_length_LOW = r23
                                 .def dpcm_length_HIGH = r24
                                 .def dpcm_output_volume = r5
                                 
                                 
                                 reset:
000000 940c 126a                 	jmp init
                                 
                                 .org RTC_CNT_vect
000006 940c 1629                 	jmp frame_counter_routine
                                 
                                 .org TCA0_OVF_vect
00000e 940c 1744                 	jmp dpcm_sequence_routine
                                 
                                 .org TCB0_INT_vect
000018 940c 1679                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 16c6                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 1713                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 171e                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(35): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(50): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(103): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(114): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(126): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(165): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(226): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(227): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(232): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(235): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(239): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(240): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(241): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(242): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(248): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(250): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(251): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(252): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(253): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(254): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(364): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
00126a edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
00126b 93c0 0034                 	sts CPU_CCP, r28
00126d e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
00126e 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001270 2422                      	clr zero
                                 	//ONE
001271 e0c1                      	ldi r28, 1
001272 2e3c                      	mov one, r28
                                 	//FRAME SEQUENCE
001273 2c42                      	mov frame_sequence, zero
                                 
                                 	//MEMORY
001274 e3c0                      	ldi r28, 0b00110000
001275 93c0 2800                 	sts pulse1_param, r28
001277 e8c0                      	ldi r28, 0b10000000
001278 93c0 2801                 	sts pulse1_sweep_param, r28
00127a efcf                      	ldi r28, 0xFF
00127b 93c0 2802                 	sts pulse1_timerL, r28
00127d 93c0 2803                 	sts pulse1_timerH, r28
00127f 93c0 2804                 	sts pulse1_length, r28
                                 
001281 e3c0                      	ldi r28, 0b00110000
001282 93c0 2808                 	sts pulse2_param, r28
001284 e8c0                      	ldi r28, 0b10000000
001285 93c0 2809                 	sts pulse2_sweep_param, r28
001287 efcf                      	ldi r28, 0xFF
001288 93c0 280a                 	sts pulse2_timerL, r28
00128a 93c0 280b                 	sts pulse2_timerH, r28
00128c 93c0 280c                 	sts pulse2_length, r28
                                 
00128e efcf                      	ldi r28, 0xFF
00128f 93c0 2810                 	sts triangle_timerL, r28
001291 93c0 2811                 	sts triangle_timerH, r28
                                 
001293 e3c0                      	ldi r28, 0b00110000
001294 93c0 2813                 	sts noise_param, r28
001296 e0cf                      	ldi r28, 0b00001111
001297 93c0 2814                 	sts noise_period, r28
                                 
001299 e0c6                      	ldi r28, 0x06
00129a 93c0 281b                 	sts song_frame_offset, r28
00129c 9220 281c                 	sts song_frame_offset+1, zero
00129e efcf                      	ldi r28, 0xFF
00129f 93c0 2825                 	sts song_fx_Bxx, r28
0012a1 9220 2826                 	sts song_fx_Cxx, zero
0012a3 9220 2827                 	sts song_fx_Dxx, zero
0012a5 e6ee                      	ldi ZL, LOW(song0_frames << 1)
0012a6 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
0012a7 93e0 2819                 	sts song_frames, ZL
0012a9 93f0 281a                 	sts song_frames+1, ZH
0012ab 91c5                      	lpm r28, Z+ //load the song size
0012ac 91d5                      	lpm r29, Z+
0012ad 93c0 281d                 	sts song_size, r28
0012af 93d0 281e                 	sts song_size+1, r29
0012b1 91c5                      	lpm r28, Z+ //load the song tempo
0012b2 91d5                      	lpm r29, Z+
0012b3 93c0 281f                 	sts song_tempo, r28
0012b5 93d0 2820                 	sts song_tempo+1, r29
0012b7 91c5                      	lpm r28, Z+
0012b8 91d5                      	lpm r29, Z+
0012b9 93c0 2821                 	sts song_tempo_correction, r28
0012bb 93d0 2822                 	sts song_tempo_correction+1, r29
0012bd 93d0 2823                 	sts song_tempo_correction_cycles, r29
0012bf 9220 2824                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0012c1 91c5                      	lpm r28, Z+
0012c2 91d5                      	lpm r29, Z+
0012c3 0fcc                      	lsl r28
0012c4 1fdd                      	rol r29
0012c5 93c0 2828                 	sts pulse1_pattern, r28
0012c7 93d0 2829                 	sts pulse1_pattern+1, r29
0012c9 9220 282a                 	sts pulse1_pattern_delay_rows, zero
0012cb 9230 282b                 	sts pulse1_pattern_delay_frames, one
0012cd 9220 282c                 	sts pulse1_pattern_offset, zero
0012cf 9220 282d                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0012d1 91c5                      	lpm r28, Z+
0012d2 91d5                      	lpm r29, Z+
0012d3 0fcc                      	lsl r28
0012d4 1fdd                      	rol r29
0012d5 93c0 2879                 	sts pulse2_pattern, r28
0012d7 93d0 287a                 	sts pulse2_pattern+1, r29
0012d9 9220 287b                 	sts pulse2_pattern_delay_rows, zero
0012db 9230 287c                 	sts pulse2_pattern_delay_frames, one
0012dd 9220 287d                 	sts pulse2_pattern_offset, zero
0012df 9220 287e                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0012e1 91c5                      	lpm r28, Z+
0012e2 91d5                      	lpm r29, Z+
0012e3 0fcc                      	lsl r28
0012e4 1fdd                      	rol r29
0012e5 93c0 28ca                 	sts triangle_pattern, r28
0012e7 93d0 28cb                 	sts triangle_pattern+1, r29
0012e9 9220 28cc                 	sts triangle_pattern_delay_rows, zero
0012eb 9230 28cd                 	sts triangle_pattern_delay_frames, one
0012ed 9220 28ce                 	sts triangle_pattern_offset, zero
0012ef 9220 28cf                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0012f1 91c5                      	lpm r28, Z+
0012f2 91d5                      	lpm r29, Z+
0012f3 0fcc                      	lsl r28
0012f4 1fdd                      	rol r29
0012f5 93c0 2916                 	sts noise_pattern, r28
0012f7 93d0 2917                 	sts noise_pattern+1, r29
0012f9 9220 2918                 	sts noise_pattern_delay_rows, zero
0012fb 9230 2919                 	sts noise_pattern_delay_frames, one
0012fd 9220 291a                 	sts noise_pattern_offset, zero
0012ff 9220 291b                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 4
001301 91c5                      	lpm r28, Z+
001302 91d5                      	lpm r29, Z+
001303 0fcc                      	lsl r28
001304 1fdd                      	rol r29
001305 93c0 294d                 	sts dpcm_pattern, r28
001307 93d0 294e                 	sts dpcm_pattern+1, r29
001309 9220 294f                 	sts dpcm_pattern_delay_rows, zero
00130b 9230 2950                 	sts dpcm_pattern_delay_frames, one
00130d 9220 2951                 	sts dpcm_pattern_offset, zero
00130f 9220 2952                 	sts dpcm_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
001311 efcf                      	ldi r28, 0xFF
001312 9220 2830                 	sts pulse1_volume_macro_offset, zero
001314 93c0 2831                 	sts pulse1_volume_macro_loop, r28
001316 93c0 2832                 	sts pulse1_volume_macro_release, r28
001318 9220 2835                 	sts pulse1_arpeggio_macro_offset, zero
00131a 93c0 2836                 	sts pulse1_arpeggio_macro_loop, r28
00131c 93c0 2837                 	sts pulse1_arpeggio_macro_release, r28
00131e 93c0 2838                 	sts pulse1_arpeggio_macro_mode, r28
001320 9220 283d                 	sts pulse1_pitch_macro_offset, zero
001322 93c0 283e                 	sts pulse1_pitch_macro_loop, r28
001324 93c0 283f                 	sts pulse1_pitch_macro_release, r28
001326 9220 2843                 	sts pulse1_hi_pitch_macro_offset, zero
001328 93c0 2844                 	sts pulse1_hi_pitch_macro_loop, r28
00132a 93c0 2845                 	sts pulse1_hi_pitch_macro_release, r28
00132c 9220 2848                 	sts pulse1_duty_macro_offset, zero
00132e 93c0 2849                 	sts pulse1_duty_macro_loop, r28
001330 93c0 284a                 	sts pulse1_duty_macro_release, r28
                                 
001332 9220 282e                 	sts pulse1_volume_macro, zero
001334 9220 282f                 	sts pulse1_volume_macro+1, zero
001336 9220 2833                 	sts pulse1_arpeggio_macro, zero
001338 9220 2834                 	sts pulse1_arpeggio_macro+1, zero
00133a 9220 2839                 	sts pulse1_total_pitch_offset, zero
00133c 9220 283a                 	sts pulse1_total_pitch_offset+1, zero
00133e 9220 283b                 	sts pulse1_pitch_macro, zero
001340 9220 283c                 	sts pulse1_pitch_macro+1, zero
001342 9220 2840                 	sts pulse1_total_hi_pitch_offset, zero
001344 9220 2841                 	sts pulse1_hi_pitch_macro, zero
001346 9220 2842                 	sts pulse1_hi_pitch_macro+1, zero
001348 9220 2846                 	sts pulse1_duty_macro, zero
00134a 9220 2847                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
00134c e00f                      	ldi pulse1_volume_divider, 0x0F
00134d 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00134f 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001350 9190 2800                 	lds pulse_channel_flags, pulse1_param
001352 7390                      	andi pulse_channel_flags, 0b00110000
001353 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001354 9220 2806                 	sts pulse1_output_volume, zero
001356 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001358 2e8c                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001359 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00135a 2e7c                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
00135b 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param
00135d 9492                      	swap pulse1_sweep //swap data from high byte and low byte
00135e 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
00135f efcf                      	ldi r28, 0xFF
001360 9220 284b                 	sts pulse1_fx_0xy_sequence, zero
001362 9220 284c                 	sts pulse1_fx_0xy_sequence+1, zero
001364 9220 284d                 	sts pulse1_fx_1xx, zero
001366 9220 284e                 	sts pulse1_fx_1xx+1, zero
001368 9220 284f                 	sts pulse1_fx_1xx_total, zero
00136a 9220 2850                 	sts pulse1_fx_1xx_total+1, zero
00136c 9220 2851                 	sts pulse1_fx_2xx, zero
00136e 9220 2852                 	sts pulse1_fx_2xx+1, zero
001370 9220 2853                 	sts pulse1_fx_2xx_total, zero
001372 9220 2854                 	sts pulse1_fx_2xx_total+1, zero
001374 9220 2855                 	sts pulse1_fx_3xx_start, zero
001376 9220 2856                 	sts pulse1_fx_3xx_start+1, zero
001378 9220 2857                 	sts pulse1_fx_3xx_target, zero
00137a 9220 2858                 	sts pulse1_fx_3xx_target+1, zero
00137c 9220 2859                 	sts pulse1_fx_3xx_speed, zero
00137e 9220 285a                 	sts pulse1_fx_3xx_speed+1, zero
001380 9220 285b                 	sts pulse1_fx_3xx_total_offset, zero
001382 9220 285c                 	sts pulse1_fx_3xx_total_offset+1, zero
001384 9220 285d                 	sts pulse1_fx_4xy_speed, zero
001386 9220 285e                 	sts pulse1_fx_4xy_depth, zero
001388 9220 285f                 	sts pulse1_fx_4xy_phase, zero
00138a 9220 2860                 	sts pulse1_fx_7xy_speed, zero
00138c 9220 2861                 	sts pulse1_fx_7xy_depth, zero
00138e 9220 2862                 	sts pulse1_fx_7xy_phase, zero
001390 9220 2863                 	sts pulse1_fx_7xy_value, zero
001392 9220 2864                 	sts pulse1_fx_Axy, zero
001394 93c0 2865                 	sts pulse1_fx_Gxx_pre, r28
001396 93c0 2866                 	sts pulse1_fx_Gxx_post, r28
001398 9220 2867                 	sts pulse1_fx_Pxx_total, zero
00139a 9220 2868                 	sts pulse1_fx_Pxx_total+1, zero
00139c 9220 2869                 	sts pulse1_fx_Qxy_target_note, zero
00139e 9220 286a                 	sts pulse1_fx_Qxy_target, zero
0013a0 9220 286b                 	sts pulse1_fx_Qxy_target+1, zero
0013a2 9220 286c                 	sts pulse1_fx_Qxy_speed, zero
0013a4 9220 286d                 	sts pulse1_fx_Qxy_speed+1, zero
0013a6 9220 286e                 	sts pulse1_fx_Qxy_total_offset, zero
0013a8 9220 286f                 	sts pulse1_fx_Qxy_total_offset+1, zero
0013aa 9220 2870                 	sts pulse1_fx_Rxy_target_note, zero
0013ac 9220 2871                 	sts pulse1_fx_Rxy_target, zero
0013ae 9220 2872                 	sts pulse1_fx_Rxy_target+1, zero
0013b0 9220 2873                 	sts pulse1_fx_Rxy_speed, zero
0013b2 9220 2874                 	sts pulse1_fx_Rxy_speed+1, zero
0013b4 9220 2875                 	sts pulse1_fx_Rxy_total_offset, zero
0013b6 9220 2876                 	sts pulse1_fx_Rxy_total_offset+1, zero
0013b8 93c0 2877                 	sts pulse1_fx_Sxx_pre, r28
0013ba 93c0 2878                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
0013bc efcf                      	ldi r28, 0xFF
0013bd 9220 2881                 	sts pulse2_volume_macro_offset, zero
0013bf 93c0 2882                 	sts pulse2_volume_macro_loop, r28
0013c1 93c0 2883                 	sts pulse2_volume_macro_release, r28
0013c3 9220 2886                 	sts pulse2_arpeggio_macro_offset, zero
0013c5 93c0 2887                 	sts pulse2_arpeggio_macro_loop, r28
0013c7 93c0 2888                 	sts pulse2_arpeggio_macro_release, r28
0013c9 93c0 2889                 	sts pulse2_arpeggio_macro_mode, r28
0013cb 9220 288e                 	sts pulse2_pitch_macro_offset, zero
0013cd 93c0 288f                 	sts pulse2_pitch_macro_loop, r28
0013cf 93c0 2890                 	sts pulse2_pitch_macro_release, r28
0013d1 9220 2894                 	sts pulse2_hi_pitch_macro_offset, zero
0013d3 93c0 2895                 	sts pulse2_hi_pitch_macro_loop, r28
0013d5 93c0 2896                 	sts pulse2_hi_pitch_macro_release, r28
0013d7 9220 2899                 	sts pulse2_duty_macro_offset, zero
0013d9 93c0 289a                 	sts pulse2_duty_macro_loop, r28
0013db 93c0 289b                 	sts pulse2_duty_macro_release, r28
                                 
0013dd 9220 287f                 	sts pulse2_volume_macro, zero
0013df 9220 2880                 	sts pulse2_volume_macro+1, zero
0013e1 9220 2884                 	sts pulse2_arpeggio_macro, zero
0013e3 9220 2885                 	sts pulse2_arpeggio_macro+1, zero
0013e5 9220 288a                 	sts pulse2_total_pitch_offset, zero
0013e7 9220 288b                 	sts pulse2_total_pitch_offset+1, zero
0013e9 9220 288c                 	sts pulse2_pitch_macro, zero
0013eb 9220 288d                 	sts pulse2_pitch_macro+1, zero
0013ed 9220 2891                 	sts pulse2_total_hi_pitch_offset, zero
0013ef 9220 2892                 	sts pulse2_hi_pitch_macro, zero
0013f1 9220 2893                 	sts pulse2_hi_pitch_macro+1, zero
0013f3 9220 2897                 	sts pulse2_duty_macro, zero
0013f5 9220 2898                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0013f7 e02f                      	ldi pulse2_volume_divider, 0x0F
0013f8 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0013fa 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0013fb 91d0 2808                 	lds r29, pulse2_param
0013fd 73d0                      	andi r29, 0b00110000
0013fe 62d0                      	sbr r29, 0b0100000 //set start flag
0013ff 95d2                      	swap r29
001400 2b9d                      	or pulse_channel_flags, r29
001401 9220 280e                 	sts pulse2_output_volume, zero
001403 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
001405 2ebc                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
001406 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001407 2eac                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
001408 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param
00140a 94c2                      	swap pulse2_sweep //swap data from high byte and low byte
00140b 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
00140c efcf                      	ldi r28, 0xFF
00140d 9220 289c                 	sts pulse2_fx_0xy_sequence, zero
00140f 9220 289d                 	sts pulse2_fx_0xy_sequence+1, zero
001411 9220 289e                 	sts pulse2_fx_1xx, zero
001413 9220 289f                 	sts pulse2_fx_1xx+1, zero
001415 9220 28a0                 	sts pulse2_fx_1xx_total, zero
001417 9220 28a1                 	sts pulse2_fx_1xx_total+1, zero
001419 9220 28a2                 	sts pulse2_fx_2xx, zero
00141b 9220 28a3                 	sts pulse2_fx_2xx+1, zero
00141d 9220 28a4                 	sts pulse2_fx_2xx_total, zero
00141f 9220 28a5                 	sts pulse2_fx_2xx_total+1, zero
001421 9220 28a6                 	sts pulse2_fx_3xx_start, zero
001423 9220 28a7                 	sts pulse2_fx_3xx_start+1, zero
001425 9220 28a8                 	sts pulse2_fx_3xx_target, zero
001427 9220 28a9                 	sts pulse2_fx_3xx_target+1, zero
001429 9220 28aa                 	sts pulse2_fx_3xx_speed, zero
00142b 9220 28ab                 	sts pulse2_fx_3xx_speed+1, zero
00142d 9220 28ac                 	sts pulse2_fx_3xx_total_offset, zero
00142f 9220 28ad                 	sts pulse2_fx_3xx_total_offset+1, zero
001431 9220 28ae                 	sts pulse2_fx_4xy_speed, zero
001433 9220 28af                 	sts pulse2_fx_4xy_depth, zero
001435 9220 28b0                 	sts pulse2_fx_4xy_phase, zero
001437 9220 28b1                 	sts pulse2_fx_7xy_speed, zero
001439 9220 28b2                 	sts pulse2_fx_7xy_depth, zero
00143b 9220 28b3                 	sts pulse2_fx_7xy_phase, zero
00143d 9220 28b4                 	sts pulse2_fx_7xy_value, zero
00143f 9220 28b5                 	sts pulse2_fx_Axy, zero
001441 93c0 28b6                 	sts pulse2_fx_Gxx_pre, r28
001443 93c0 28b7                 	sts pulse2_fx_Gxx_post, r28
001445 9220 28b8                 	sts pulse2_fx_Pxx_total, zero
001447 9220 28b9                 	sts pulse2_fx_Pxx_total+1, zero
001449 9220 28ba                 	sts pulse2_fx_Qxy_target_note, zero
00144b 9220 28bb                 	sts pulse2_fx_Qxy_target, zero
00144d 9220 28bc                 	sts pulse2_fx_Qxy_target+1, zero
00144f 9220 28bd                 	sts pulse2_fx_Qxy_speed, zero
001451 9220 28be                 	sts pulse2_fx_Qxy_speed+1, zero
001453 9220 28bf                 	sts pulse2_fx_Qxy_total_offset, zero
001455 9220 28c0                 	sts pulse2_fx_Qxy_total_offset+1, zero
001457 9220 28c1                 	sts pulse2_fx_Rxy_target_note, zero
001459 9220 28c2                 	sts pulse2_fx_Rxy_target, zero
00145b 9220 28c3                 	sts pulse2_fx_Rxy_target+1, zero
00145d 9220 28c4                 	sts pulse2_fx_Rxy_speed, zero
00145f 9220 28c5                 	sts pulse2_fx_Rxy_speed+1, zero
001461 9220 28c6                 	sts pulse2_fx_Rxy_total_offset, zero
001463 9220 28c7                 	sts pulse2_fx_Rxy_total_offset+1, zero
001465 93c0 28c8                 	sts pulse2_fx_Sxx_pre, r28
001467 93c0 28c9                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001469 efcf                      	ldi r28, 0xFF
00146a 9220 28d2                 	sts triangle_volume_macro_offset, zero
00146c 93c0 28d3                 	sts triangle_volume_macro_loop, r28
00146e 93c0 28d4                 	sts triangle_volume_macro_release, r28
001470 9220 28d7                 	sts triangle_arpeggio_macro_offset, zero
001472 93c0 28d8                 	sts triangle_arpeggio_macro_loop, r28
001474 93c0 28d9                 	sts triangle_arpeggio_macro_release, r28
001476 93c0 28da                 	sts triangle_arpeggio_macro_mode, r28
001478 9220 28df                 	sts triangle_pitch_macro_offset, zero
00147a 93c0 28e0                 	sts triangle_pitch_macro_loop, r28
00147c 93c0 28e1                 	sts triangle_pitch_macro_release, r28
00147e 9220 28e5                 	sts triangle_hi_pitch_macro_offset, zero
001480 93c0 28e6                 	sts triangle_hi_pitch_macro_loop, r28
001482 93c0 28e7                 	sts triangle_hi_pitch_macro_release, r28
001484 9220 28ea                 	sts triangle_duty_macro_offset, zero
001486 93c0 28eb                 	sts triangle_duty_macro_loop, r28
001488 93c0 28ec                 	sts triangle_duty_macro_release, r28
                                 
00148a 9220 28d0                 	sts triangle_volume_macro, zero
00148c 9220 28d1                 	sts triangle_volume_macro+1, zero
00148e 9220 28d5                 	sts triangle_arpeggio_macro, zero
001490 9220 28d6                 	sts triangle_arpeggio_macro+1, zero
001492 9220 28db                 	sts triangle_total_pitch_offset, zero
001494 9220 28dc                 	sts triangle_total_pitch_offset+1, zero
001496 9220 28dd                 	sts triangle_pitch_macro, zero
001498 9220 28de                 	sts triangle_pitch_macro+1, zero
00149a 9220 28e2                 	sts triangle_total_hi_pitch_offset, zero
00149c 9220 28e3                 	sts triangle_hi_pitch_macro, zero
00149e 9220 28e4                 	sts triangle_hi_pitch_macro+1, zero
0014a0 9220 28e8                 	sts triangle_duty_macro, zero
0014a2 9220 28e9                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
0014a4 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
0014a5 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
0014a6 efcf                      	ldi r28, 0xFF
0014a7 9220 28ed                 	sts triangle_fx_0xy_sequence, zero
0014a9 9220 28ee                 	sts triangle_fx_0xy_sequence+1, zero
0014ab 9220 28ef                 	sts triangle_fx_1xx, zero
0014ad 9220 28f0                 	sts triangle_fx_1xx+1, zero
0014af 9220 28f1                 	sts triangle_fx_1xx_total, zero
0014b1 9220 28f2                 	sts triangle_fx_1xx_total+1, zero
0014b3 9220 28f3                 	sts triangle_fx_2xx, zero
0014b5 9220 28f4                 	sts triangle_fx_2xx+1, zero
0014b7 9220 28f5                 	sts triangle_fx_2xx_total, zero
0014b9 9220 28f6                 	sts triangle_fx_2xx_total+1, zero
0014bb 9220 28f7                 	sts triangle_fx_3xx_start, zero
0014bd 9220 28f8                 	sts triangle_fx_3xx_start+1, zero
0014bf 9220 28f9                 	sts triangle_fx_3xx_target, zero
0014c1 9220 28fa                 	sts triangle_fx_3xx_target+1, zero
0014c3 9220 28fb                 	sts triangle_fx_3xx_speed, zero
0014c5 9220 28fc                 	sts triangle_fx_3xx_speed+1, zero
0014c7 9220 28fd                 	sts triangle_fx_3xx_total_offset, zero
0014c9 9220 28fe                 	sts triangle_fx_3xx_total_offset+1, zero
0014cb 9220 28ff                 	sts triangle_fx_4xy_speed, zero
0014cd 9220 2900                 	sts triangle_fx_4xy_depth, zero
0014cf 9220 2901                 	sts triangle_fx_4xy_phase, zero
0014d1 93c0 2902                 	sts triangle_fx_Gxx_pre, r28
0014d3 93c0 2903                 	sts triangle_fx_Gxx_post, r28
0014d5 9220 2904                 	sts triangle_fx_Pxx_total, zero
0014d7 9220 2905                 	sts triangle_fx_Pxx_total+1, zero
0014d9 9220 2906                 	sts triangle_fx_Qxy_target_note, zero
0014db 9220 2907                 	sts triangle_fx_Qxy_target, zero
0014dd 9220 2908                 	sts triangle_fx_Qxy_target+1, zero
0014df 9220 2909                 	sts triangle_fx_Qxy_speed, zero
0014e1 9220 290a                 	sts triangle_fx_Qxy_speed+1, zero
0014e3 9220 290b                 	sts triangle_fx_Qxy_total_offset, zero
0014e5 9220 290c                 	sts triangle_fx_Qxy_total_offset+1, zero
0014e7 9220 290d                 	sts triangle_fx_Rxy_target_note, zero
0014e9 9220 290e                 	sts triangle_fx_Rxy_target, zero
0014eb 9220 290f                 	sts triangle_fx_Rxy_target+1, zero
0014ed 9220 2910                 	sts triangle_fx_Rxy_speed, zero
0014ef 9220 2911                 	sts triangle_fx_Rxy_speed+1, zero
0014f1 9220 2912                 	sts triangle_fx_Rxy_total_offset, zero
0014f3 9220 2913                 	sts triangle_fx_Rxy_total_offset+1, zero
0014f5 93c0 2914                 	sts triangle_fx_Sxx_pre, r28
0014f7 93c0 2915                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0014f9 efcf                      	ldi r28, 0xFF
0014fa 9220 291e                 	sts noise_volume_macro_offset, zero
0014fc 93c0 291f                 	sts noise_volume_macro_loop, r28
0014fe 93c0 2920                 	sts noise_volume_macro_release, r28
001500 9220 2923                 	sts noise_arpeggio_macro_offset, zero
001502 93c0 2924                 	sts noise_arpeggio_macro_loop, r28
001504 93c0 2925                 	sts noise_arpeggio_macro_release, r28
001506 93c0 2926                 	sts noise_arpeggio_macro_mode, r28
001508 9220 292b                 	sts noise_pitch_macro_offset, zero
00150a 93c0 292c                 	sts noise_pitch_macro_loop, r28
00150c 93c0 292d                 	sts noise_pitch_macro_release, r28
00150e 9220 2931                 	sts noise_hi_pitch_macro_offset, zero
001510 93c0 2932                 	sts noise_hi_pitch_macro_loop, r28
001512 93c0 2933                 	sts noise_hi_pitch_macro_release, r28
001514 9220 2936                 	sts noise_duty_macro_offset, zero
001516 93c0 2937                 	sts noise_duty_macro_loop, r28
001518 93c0 2938                 	sts noise_duty_macro_release, r28
                                 
00151a 9220 291c                 	sts noise_volume_macro, zero
00151c 9220 291d                 	sts noise_volume_macro+1, zero
00151e 9220 2921                 	sts noise_arpeggio_macro, zero
001520 9220 2922                 	sts noise_arpeggio_macro+1, zero
001522 9220 2927                 	sts noise_total_pitch_offset, zero
001524 9220 2928                 	sts noise_total_pitch_offset+1, zero
001526 9220 2929                 	sts noise_pitch_macro, zero
001528 9220 292a                 	sts noise_pitch_macro+1, zero
00152a 9220 292e                 	sts noise_total_hi_pitch_offset, zero
00152c 9220 292f                 	sts noise_hi_pitch_macro, zero
00152e 9220 2930                 	sts noise_hi_pitch_macro+1, zero
001530 9220 2934                 	sts noise_duty_macro, zero
001532 9220 2935                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
001534 9220 2816                 	sts noise_output_volume, zero
001536 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001538 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001539 2f5c                      	mov noise_sequence_LOW, r28
00153a 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
00153b efcf                      	ldi r28, 0xFF
00153c 9220 2939                 	sts noise_fx_0xy_sequence, zero
00153e 9220 293a                 	sts noise_fx_0xy_sequence+1, zero
001540 9220 293b                 	sts noise_fx_1xx, zero
001542 9220 293c                 	sts noise_fx_1xx_total, zero
001544 9220 293d                 	sts noise_fx_2xx, zero
001546 9220 293e                 	sts noise_fx_2xx_total, zero
001548 9220 293f                 	sts noise_fx_4xy_speed, zero
00154a 9220 2940                 	sts noise_fx_4xy_depth, zero
00154c 9220 2941                 	sts noise_fx_4xy_phase, zero
00154e 9220 2942                 	sts noise_fx_4xy_offset, zero
001550 9220 2943                 	sts noise_fx_7xy_speed, zero
001552 9220 2944                 	sts noise_fx_7xy_depth, zero
001554 9220 2945                 	sts noise_fx_7xy_phase, zero
001556 9220 2946                 	sts noise_fx_7xy_value, zero
001558 9220 2947                 	sts noise_fx_Axy, zero
00155a 93c0 2948                 	sts noise_fx_Gxx_pre, r28
00155c 93c0 2949                 	sts noise_fx_Gxx_post, r28
00155e 9220 294a                 	sts noise_fx_Pxx_total, zero
001560 93c0 294b                 	sts noise_fx_Sxx_pre, r28
001562 93c0 294c                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 4 VOLUME
001564 2c52                      	mov dpcm_output_volume, zero
                                 
                                 	//CHANNEL 4 SAMPLE
001565 9220 2953                 	sts dpcm_sample, zero
001567 9220 2954                 	sts dpcm_sample+1, zero
001569 9220 2955                 	sts dpcm_sample_offset, zero
00156b 9220 2956                 	sts dpcm_sample_offset+1, zero
00156d 2cd2                      	mov dpcm_shift, zero
00156e 2ce2                      	mov dpcm_bit_counter, zero
00156f 2cf2                      	mov dpcm_period, zero
001570 2d72                      	mov dpcm_length_LOW, zero
001571 2d82                      	mov dpcm_length_HIGH, zero
                                 
                                 	//CHANNEL 4 FX
001572 93c0 2948                 	sts noise_fx_Gxx_pre, r28
001574 93c0 2949                 	sts noise_fx_Gxx_post, r28
001576 93c0 294b                 	sts noise_fx_Sxx_pre, r28
001578 93c0 294c                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
00157a efcf                      	ldi r28, 0xFF
00157b b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
00157c e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
00157d 93c0 0a81                 	sts TCB0_CTRLB, r28
00157f e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
001580 93c0 0a85                 	sts TCB0_INTCTRL, r28
001582 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001584 93c0 0a8c                 	sts TCB0_CCMPL, r28
001586 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001588 93c0 0a8d                 	sts TCB0_CCMPH, r28
00158a e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00158b 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
00158d e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00158e 93b0 0a91                 	sts TCB1_CTRLB, r27
001590 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001591 93b0 0a95                 	sts TCB1_INTCTRL, r27
001593 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001595 93b0 0a9c                 	sts TCB1_CCMPL, r27
001597 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001599 93b0 0a9d                 	sts TCB1_CCMPH, r27
00159b e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00159c 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
00159e e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00159f 93b0 0aa1                 	sts TCB2_CTRLB, r27
0015a1 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
0015a2 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
0015a4 93b0 0aac                 	sts TCB2_CCMPL, r27
0015a6 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
0015a8 93b0 0aad                 	sts TCB2_CCMPH, r27
0015aa e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
0015ab 93b0 0aa0                 	sts TCB2_CTRLA, r27
0015ad 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
0015ae e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0015af 93b0 0ab1                 	sts TCB3_CTRLB, r27
0015b1 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0015b2 93b0 0ab5                 	sts TCB3_INTCTRL, r27
0015b4 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0015b6 93b0 0abc                 	sts TCB3_CCMPL, r27
0015b8 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0015ba 93b0 0abd                 	sts TCB3_CCMPH, r27
0015bc e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0015bd 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 	//DPCM
0015bf e0c0                      	ldi r28, TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0015c0 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
0015c2 e0c1                      	ldi r28, TCA_SINGLE_OVF_bm //enable overflow interrupts
0015c3 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
0015c5 e0c2                      	ldi r28, TCA_SINGLE_CLKSEL_DIV2_gc //use prescaler divider of 2
0015c6 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//RTC
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Interrupts will be setup to interrupt every 240 Hz clock
                                 	//The 4th consecutive interrupt will clock the sound driver every 60 Hz, in which new audio data is read and written to the registers
                                 	//1st and 2nd interrupt will execute sequence 0 and 2. 3rd and 4th interrupt will execute sequence 1 and 3.
                                 	//Timer period Calculation: ((1/(tempo*4)) * 32768/2)
                                 	//The RTC timer is clocked at 32768 Hz
                                 	//The /2 comes from the prescaler divider used
                                 	//NOTE: The frame counter clock will not always be 60 Hz, and will depend on the song_tempo.
0015c8 e0b0                      	ldi r27, RTC_CLKSEL_INT32K_gc //internal 32kHz oscillator
0015c9 93b0 0147                 	sts RTC_CLKSEL, r27
0015cb 91b0 281f                 	lds r27, song_tempo
0015cd 91c0 2820                 	lds r28, song_tempo+1
0015cf 93b0 014a                 	sts RTC_PER, r27
0015d1 93c0 014b                 	sts RTC_PER + 1, r28
0015d3 e0b1                      	ldi r27, RTC_OVF_bm //overflow interrupts
0015d4 93b0 0142                 	sts RTC_INTCTRL, r27
0015d6 e0b9                      	ldi r27, RTC_PRESCALER_DIV2_gc | RTC_PITEN_bm //use prescaler divider of 16 and enable RTC
0015d7 93b0 0140                 	sts RTC_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0015d9 91c0 2806                 	lds r28, pulse1_output_volume
0015db 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0015dd fe70                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0015de c015                      	rjmp volume_mixer_pulse1_off
                                 
0015df 1482                      	cp pulse1_length_counter, zero //if length is zero, return
0015e0 f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0015e1 91e0 0a8c                 	lds r30, TCB0_CCMPL
0015e3 e5f9                      	ldi r31, 0x59
0015e4 17ef                      	cp r30, r31
0015e5 91e0 0a8d                 	lds r30, TCB0_CCMPH
0015e7 e0f0                      	ldi r31, 0x00
0015e8 07ef                      	cpc r30, r31
0015e9 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $595A
0015ea 91e0 0a8c                 	lds r30, TCB0_CCMPL
0015ec e5fa                      	ldi r31, 0x5A
0015ed 17ef                      	cp r30, r31
0015ee 91e0 0a8d                 	lds r30, TCB0_CCMPH
0015f0 e5f9                      	ldi r31, 0x59
0015f1 07ef                      	cpc r30, r31
0015f2 f408                      	brsh volume_mixer_pulse1_off
0015f3 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0015f4 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0015f5 fea0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0015f6 c015                      	rjmp volume_mixer_pulse2_off
                                 
0015f7 14b2                      	cp pulse2_length_counter, zero //if length is zero, return
0015f8 f099                      	breq volume_mixer_pulse2_off
                                 
0015f9 91e0 0a9c                 	lds r30, TCB1_CCMPL
0015fb e5f9                      	ldi r31, 0x59
0015fc 17ef                      	cp r30, r31
0015fd 91e0 0a9d                 	lds r30, TCB1_CCMPH
0015ff e0f0                      	ldi r31, 0x00
001600 07ef                      	cpc r30, r31
001601 f050                      	brlo volume_mixer_pulse2_off
                                 
001602 91e0 0a9c                 	lds r30, TCB1_CCMPL
001604 e5fa                      	ldi r31, 0x5A
001605 17ef                      	cp r30, r31
001606 91e0 0a9d                 	lds r30, TCB1_CCMPH
001608 e5f9                      	ldi r31, 0x59
001609 07ef                      	cpc r30, r31
00160a f408                      	brsh volume_mixer_pulse2_off
00160b c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
00160c 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
00160d 0fcd                      	add r28, r29
00160e e8e2                      	ldi ZL, LOW(pulse_volume_table << 1)
00160f e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
001610 0fec                      	add ZL, r28
001611 1df2                      	adc ZH, zero
001612 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001613 2fd4                      	mov r29, triangle_sequence
001614 fdd4                      	sbrc r29, 4 //check 5th bit
001615 95d0                      	com r29
001616 70df                      	andi r29, 0x0F
001617 2fed                      	mov r30, r29
001618 0fde                      	add r29, r30 //multiply the triangle volume by 3
001619 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_dpcm:
00161a 0dd5                      	add r29, dpcm_output_volume
                                 
                                 volume_mixer_tnd_noise:
00161b ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
00161c c004                      	rjmp volume_mixer_tnd_out
00161d 91e0 2816                 	lds r30, noise_output_volume
00161f 0fee                      	lsl r30 //multiply noise volume by 2
001620 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
001621 eae2                      	ldi ZL, LOW(tnd_volume_table << 1)
001622 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
001623 0fed                      	add ZL, r29
001624 1df2                      	adc ZH, zero
001625 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001626 0fcd                      	add r28, r29
001627 b9c1                      	out VPORTA_OUT, r28
001628 cfb0                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 frame_counter_routine:
001629 b7bf                      	in r27, CPU_SREG
00162a 93bf                      	push r27
00162b 94f8                      	cli
                                 
00162c 91b0 2822                 	lds r27, song_tempo_correction+1
00162e 91a0 2823                 	lds r26, song_tempo_correction_cycles
001630 17ab                      	cp r26, r27
001631 f071                      	breq frame_counter_routine_clear_offset
001632 15a2                      	cp r26, zero
001633 f0c1                      	breq frame_counter_routine_offset
                                 
                                 frame_counter_routine_sequence:
001634 95aa                      	dec r26
001635 93a0 2823                 	sts song_tempo_correction_cycles, r26
001637 2da4                      	mov r26, frame_sequence
001638 0c43                      	add frame_sequence, one
001639 30a0                      	cpi r26, 0x00
00163a f111                      	breq sequence_0_2
00163b 30a1                      	cpi r26, 0x01
00163c f141                      	breq sequence_1_3
00163d 30a2                      	cpi r26, 0x02
00163e f0f1                      	breq sequence_0_2
00163f c14d                      	rjmp sound_driver
                                 
                                 frame_counter_routine_clear_offset:
001640 95aa                      	dec r26
001641 93a0 2823                 	sts song_tempo_correction_cycles, r26
001643 91a0 281f                 	lds r26, song_tempo
001645 91b0 2820                 	lds r27, song_tempo+1
001647 93a0 014a                 	sts RTC_PER, r26
001649 93b0 014b                 	sts RTC_PER + 1, r27
00164b cfeb                      	rjmp frame_counter_routine_sequence+3
                                 
                                 frame_counter_routine_offset:
00164c 93cf                      	push r28
00164d 93b0 2823                 	sts song_tempo_correction_cycles, r27
00164f 91a0 281f                 	lds r26, song_tempo
001651 91b0 2820                 	lds r27, song_tempo+1
001653 91c0 2821                 	lds r28, song_tempo_correction
001655 0fac                      	add r26, r28
001656 1db2                      	adc r27, zero
001657 93a0 014a                 	sts RTC_PER, r26
001659 93b0 014b                 	sts RTC_PER + 1, r27
00165b 91cf                      	pop r28
00165c cfda                      	rjmp frame_counter_routine_sequence+3
                                 
                                 sequence_0_2:
                                 	//ENVELOPE
00165d d050                      	rcall pulse1_envelope_routine
00165e d09c                      	rcall pulse2_envelope_routine
                                 
00165f e0b3                      	ldi r27, RTC_CMP_bm | RTC_OVF_bm //clear OVF flag
001660 93b0 0143                 	sts RTC_INTFLAGS, r27
001662 91bf                      	pop r27
001663 bfbf                      	out CPU_SREG, r27
001664 9518                      	reti
                                 
                                 sequence_1_3:
                                 	//ENVELOPE
001665 d048                      	rcall pulse1_envelope_routine
001666 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001667 fc93                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001668 d01b                      	rcall pulse1_sweep_routine
001669 fcc3                      	sbrc pulse2_sweep, 3
00166a d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
00166b fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
00166c c002                      	rjmp sequence_1_3_pulse2_length
00166d 1082                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
00166e 948a                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
00166f fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001670 c002                      	rjmp sequence_1_3_exit
001671 10b2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001672 94ba                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001673 e0b1                      	ldi r27, RTC_OVF_bm //clear OVF flag
001674 93b0 0143                 	sts RTC_INTFLAGS, r27
001676 91bf                      	pop r27
001677 bfbf                      	out CPU_SREG, r27
001678 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001679 b7bf                      	in r27, CPU_SREG
00167a 93bf                      	push r27
00167b 94f8                      	cli
                                 
00167c 0c77                      	lsl pulse1_sequence //shifts sequence to the left
00167d 1c72                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00167e e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00167f 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001681 91bf                      	pop r27
001682 bfbf                      	out CPU_SREG, r27
001683 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001684 2db9                      	mov r27, pulse1_sweep
001685 70b7                      	andi r27, 0x07 //mask for period divider bits
001686 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001687 93df                      	push r29
001688 2dd9                      	mov r29, pulse1_sweep
001689 95d2                      	swap r29
00168a 70d7                      	andi r29, 0x07 //mask for shift bits
00168b f411                      	brne pulse1_sweep_routine_action_main //shift != 0
00168c 91df                      	pop r29
00168d c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
00168e 91a0 0a8c                 	lds r26, TCB0_CCMPL
001690 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001692 95b6                      	lsr r27
001693 95a7                      	ror r26
001694 95da                      	dec r29
001695 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001696 fe97                      	sbrs pulse1_sweep, 7 //check the negate flag
001697 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001698 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001699 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
00169a 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
00169c 0fad                      	add r26, r29
00169d 91d0 0a8d                 	lds r29, TCB0_CCMPH
00169f 1fbd                      	adc r27, r29
                                 
0016a0 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
0016a2 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0016a4 91df                      	pop r29
0016a5 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
0016a6 949a                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
0016a7 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
0016a8 9508                      	ret
                                 
                                 pulse1_sweep_reload:
0016a9 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0016ab 9492                      	swap pulse1_sweep //bring data from high byte to low byte
0016ac 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
0016ad 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
0016ae fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
0016af c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
0016b0 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0016b1 f011                      	breq PC+3 //if the divider == 0, check loop flag
0016b2 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0016b3 9508                      	ret
                                 
0016b4 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0016b6 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0016b7 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
0016b8 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0016b9 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0016ba 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
0016bb 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0016bc f409                      	brne PC+2 //if decay != 0, go decrement
0016bd 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0016be 951a                      	dec pulse1_volume_decay
0016bf 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0016c0 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
0016c1 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0016c3 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0016c4 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0016c5 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
0016c6 b7bf                      	in r27, CPU_SREG
0016c7 93bf                      	push r27
0016c8 94f8                      	cli
                                 
0016c9 0caa                      	lsl pulse2_sequence //shifts sequence to the left
0016ca 1ca2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0016cb e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0016cc 93b0 0a96                 	sts TCB1_INTFLAGS, r27
0016ce 91bf                      	pop r27
0016cf bfbf                      	out CPU_SREG, r27
0016d0 9518                      	reti
                                 
                                 pulse2_sweep_routine:
0016d1 2dbc                      	mov r27, pulse2_sweep
0016d2 70b7                      	andi r27, 0x07 //mask for period divider bits
0016d3 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0016d4 93df                      	push r29
0016d5 2ddc                      	mov r29, pulse2_sweep
0016d6 95d2                      	swap r29
0016d7 70d7                      	andi r29, 0x07 //mask for shift bits
0016d8 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
0016d9 91df                      	pop r29
0016da c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
0016db 91a0 0a9c                 	lds r26, TCB1_CCMPL
0016dd 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
0016df 95b6                      	lsr r27
0016e0 95a7                      	ror r26
0016e1 95da                      	dec r29
0016e2 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0016e3 fec7                      	sbrs pulse2_sweep, 7 //check the negate flag
0016e4 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0016e5 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
0016e6 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
0016e7 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
0016e9 0fad                      	add r26, r29
0016ea 91d0 0a9d                 	lds r29, TCB1_CCMPH
0016ec 1fbd                      	adc r27, r29
                                 
0016ed 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
0016ef 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0016f1 91df                      	pop r29
0016f2 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
0016f3 94ca                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
0016f4 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0016f5 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0016f6 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0016f8 94c2                      	swap pulse2_sweep //bring data from high byte to low byte
0016f9 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0016fa 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0016fb fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0016fc c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0016fd 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0016fe f011                      	breq PC+3 //if the divider == 0, check loop flag
0016ff 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
001700 9508                      	ret
                                 
001701 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
001703 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001704 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
001705 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001706 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001707 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001708 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
001709 f409                      	brne PC+2 //if decay != 0, go decrement
00170a 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
00170b 953a                      	dec pulse2_volume_decay
00170c 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
00170d 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
00170e 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
001710 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001711 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
001712 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
001713 b7bf                      	in r27, CPU_SREG
001714 93bf                      	push r27
001715 94f8                      	cli
                                 
001716 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
001717 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
001718 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001719 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
00171b 91bf                      	pop r27
00171c bfbf                      	out CPU_SREG, r27
00171d 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
00171e b7bf                      	in r27, CPU_SREG
00171f 93bf                      	push r27
001720 94f8                      	cli
                                 
001721 2fa5                      	mov r26, noise_sequence_LOW
001722 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
001723 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
001724 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
001725 27a5                      	eor r26, noise_sequence_LOW
001726 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001727 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
001728 9566                      	lsr noise_sequence_HIGH
001729 9557                      	ror noise_sequence_LOW
00172a c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
00172b 9566                      	lsr noise_sequence_HIGH
00172c 9557                      	ror noise_sequence_LOW
00172d 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
00172e c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
00172f 0faa                      	lsl r26
001730 1faa                      	rol r26
001731 1faa                      	rol r26 //move the 6th bit to the 0th bit place
001732 27a5                      	eor r26, noise_sequence_LOW
001733 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001734 c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
001735 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
001736 9566                      	lsr noise_sequence_HIGH
001737 9557                      	ror noise_sequence_LOW
001738 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
001739 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
00173a 9566                      	lsr noise_sequence_HIGH
00173b 9557                      	ror noise_sequence_LOW
00173c 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
00173d c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
00173e e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00173f 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
001741 91bf                      	pop r27
001742 bfbf                      	out CPU_SREG, r27
001743 9518                      	reti
                                 
                                 //DPCM ROUTINES
                                 dpcm_sequence_routine:
001744 b7bf                      	in r27, CPU_SREG
001745 93bf                      	push r27
001746 94f8                      	cli
                                 
001747 91e0 2953                 	lds ZL, dpcm_sample
001749 91f0 2954                 	lds ZH, dpcm_sample+1
                                 
                                 dpcm_check_counter:
00174b 14e2                      	cp dpcm_bit_counter, zero
00174c f009                      	breq dpcm_check_length
00174d c004                      	rjmp dpcm_shift_register
                                 dpcm_check_length:
00174e 1572                      	cp dpcm_length_LOW, zero
00174f 0582                      	cpc dpcm_length_HIGH, zero
001750 f129                      	breq dpcm_stop
001751 c004                      	rjmp dpcm_next_byte
                                 
                                 dpcm_shift_register:
001752 18e3                      	sub dpcm_bit_counter, one
001753 fcd0                      	sbrc dpcm_shift, 0
001754 c013                      	rjmp dpcm_volume_add
001755 c019                      	rjmp dpcm_volume_sub
                                 
                                 dpcm_next_byte:
001756 91a0 2955                 	lds r26, dpcm_sample_offset
001758 91b0 2956                 	lds r27, dpcm_sample_offset+1
00175a 0da3                      	add r26, one //increment sample offset
00175b 1db2                      	adc r27, zero
00175c 1973                      	sub dpcm_length_LOW, one //decrement dpcm sample length
00175d 0982                      	sbc dpcm_length_HIGH, zero
00175e 93a0 2955                 	sts dpcm_sample_offset, r26
001760 93b0 2956                 	sts dpcm_sample_offset+1, r27
                                 
001762 0fea                      	add ZL, r26 //offset data in sample table
001763 1ffb                      	adc ZH, r27
001764 90d4                      	lpm dpcm_shift, Z //load data byte into dpcm shift register
001765 e0a8                      	ldi r26, 0x08
001766 2eea                      	mov dpcm_bit_counter, r26 //reset bit counter to 8
001767 cfea                      	rjmp dpcm_shift_register
                                 
                                 dpcm_volume_add:
001768 94d6                      	lsr dpcm_shift //right shift
001769 e7ae                      	ldi r26, 0x7E //0x7E + 0x02 is the highest volume DPCM can have
00176a 165a                      	cp dpcm_output_volume, r26
00176b f478                      	brsh dpcm_sequence_exit //exit dpcm sequence if needed to prevent overflow
00176c 0c53                      	add dpcm_output_volume, one //add 2
00176d 0c53                      	add dpcm_output_volume, one
00176e c00c                      	rjmp dpcm_sequence_exit
                                 dpcm_volume_sub:
00176f 94d6                      	lsr dpcm_shift //right shift
001770 e0a2                      	ldi r26, 0x02 // 0x02 - 0x02 is the lowest volume DPCM can have
001771 165a                      	cp dpcm_output_volume, r26
001772 f040                      	brlo dpcm_sequence_exit //exit dpcm sequence if needed to prevent overflow
001773 1853                      	sub dpcm_output_volume, one //subtract 2
001774 1853                      	sub dpcm_output_volume, one
001775 c005                      	rjmp dpcm_sequence_exit
                                 
                                 dpcm_stop:
001776 e0a2                      	ldi r26, TCA_SINGLE_CLKSEL_DIV2_gc //use prescale divider of 2 and disable timer
001777 93a0 0a00                 	sts TCA0_SINGLE_CTRLA, r26
001779 2455                      	clr dpcm_output_volume
00177a c000                      	rjmp dpcm_sequence_exit
                                 
                                 dpcm_sequence_exit:
00177b e0b1                      	ldi r27, TCA_SINGLE_OVF_bm //clear OVF flag
00177c 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00177e 91bf                      	pop r27
00177f bfbf                      	out CPU_SREG, r27
001780 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001781 edec                      	ldi ZL, LOW(length << 1)
001782 e6f2                      	ldi ZH, HIGH(length << 1)
001783 0fed                      	add ZL, r29
001784 1df2                      	adc ZH, zero
001785 91d4                      	lpm r29, Z
001786 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001787 efec                      	ldi ZL, LOW(sequences << 1)
001788 e6f2                      	ldi ZH, HIGH(sequences << 1)
001789 0fed                      	add ZL, r29
00178a 1df2                      	adc ZH, zero
00178b 91d4                      	lpm r29, Z
00178c 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
00178d 2c42                      	mov frame_sequence, zero
00178e 93cf                      	push r28
00178f 93df                      	push r29
001790 93ef                      	push r30
001791 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001792 91a0 2825                 	lds r26, song_fx_Bxx
001794 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001795 f4a9                      	brne sound_driver_fx_Bxx_routine
001796 91a0 2826                 	lds r26, song_fx_Cxx
001798 11a2                      	cpse r26, zero
001799 c0a3                      	rjmp sound_driver_fx_Cxx_routine
00179a 91a0 2827                 	lds r26, song_fx_Dxx
00179c 11a2                      	cpse r26, zero
00179d c0ae                      	rjmp sound_driver_fx_Dxx_routine
                                 
00179e 91a0 281b                 	lds r26, song_frame_offset
0017a0 91b0 281c                 	lds r27, song_frame_offset+1
0017a2 91c0 281d                 	lds r28, song_size
0017a4 91d0 281e                 	lds r29, song_size+1
0017a6 17ac                      	cp r26, r28
0017a7 07bd                      	cpc r27, r29
0017a8 f408                      	brsh sound_driver_fx_song_loop
0017a9 c131                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
0017aa e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
0017ab 91e0 2819                 	lds ZL, song_frames
0017ad 91f0 281a                 	lds ZH, song_frames+1
0017af 27cc                      	clr r28 //initialize r29:r28 to 0
0017b0 27dd                      	clr r29
0017b1 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
0017b2 95aa                      	dec r26
0017b3 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
0017b4 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
0017b5 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
0017b6 9626                      	adiw r29:r28, 6 //add 6 to skip the first 6 bytes (first 6 bytes is the song size, tempo and tempo correction)
0017b7 93c0 281b                 	sts song_frame_offset, r28
0017b9 93d0 281c                 	sts song_frame_offset+1, r29
0017bb 0fec                      	add ZL, r28
0017bc 1ffd                      	adc ZH, r29
                                 
0017bd 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
0017be 91b5                      	lpm r27, Z+
0017bf 0faa                      	lsl r26
0017c0 1fbb                      	rol r27
0017c1 93a0 2828                 	sts pulse1_pattern, r26
0017c3 93b0 2829                 	sts pulse1_pattern+1, r27
0017c5 91a5                      	lpm r26, Z+
0017c6 91b5                      	lpm r27, Z+
0017c7 0faa                      	lsl r26
0017c8 1fbb                      	rol r27
0017c9 93a0 2879                 	sts pulse2_pattern, r26
0017cb 93b0 287a                 	sts pulse2_pattern+1, r27
0017cd 91a5                      	lpm r26, Z+
0017ce 91b5                      	lpm r27, Z+
0017cf 0faa                      	lsl r26
0017d0 1fbb                      	rol r27
0017d1 93a0 28ca                 	sts triangle_pattern, r26
0017d3 93b0 28cb                 	sts triangle_pattern+1, r27
0017d5 91a5                      	lpm r26, Z+
0017d6 91b5                      	lpm r27, Z+
0017d7 0faa                      	lsl r26
0017d8 1fbb                      	rol r27
0017d9 93a0 2916                 	sts noise_pattern, r26
0017db 93b0 2917                 	sts noise_pattern+1, r27
0017dd 91a5                      	lpm r26, Z+
0017de 91b5                      	lpm r27, Z+
0017df 0faa                      	lsl r26
0017e0 1fbb                      	rol r27
0017e1 93a0 294d                 	sts dpcm_pattern, r26
0017e3 93b0 294e                 	sts dpcm_pattern+1, r27
                                 
0017e5 9220 282c                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0017e7 9220 282d                 	sts pulse1_pattern_offset+1, zero
0017e9 9220 282a                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0017eb 9230 282b                 	sts pulse1_pattern_delay_frames, one
0017ed 9220 287d                 	sts pulse2_pattern_offset, zero
0017ef 9220 287e                 	sts pulse2_pattern_offset+1, zero
0017f1 9220 287b                 	sts pulse2_pattern_delay_rows, zero
0017f3 9230 287c                 	sts pulse2_pattern_delay_frames, one
0017f5 9220 28ce                 	sts triangle_pattern_offset, zero
0017f7 9220 28cf                 	sts triangle_pattern_offset+1, zero
0017f9 9220 28cc                 	sts triangle_pattern_delay_rows, zero
0017fb 9230 28cd                 	sts triangle_pattern_delay_frames, one
0017fd 9220 291a                 	sts noise_pattern_offset, zero
0017ff 9220 291b                 	sts noise_pattern_offset+1, zero
001801 9220 2918                 	sts noise_pattern_delay_rows, zero
001803 9230 2919                 	sts noise_pattern_delay_frames, one
001805 9220 2951                 	sts dpcm_pattern_offset, zero
001807 9220 2951                 	sts dpcm_pattern_offset, zero
001809 9220 294f                 	sts dpcm_pattern_delay_rows, zero
00180b 9230 2950                 	sts dpcm_pattern_delay_frames, one
                                 
00180d efaf                      	ldi r26, 0xFF
00180e 93a0 2865                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001810 93a0 2866                 	sts pulse1_fx_Gxx_post, r26
001812 93a0 2877                 	sts pulse1_fx_Sxx_pre, r26
001814 93a0 2878                 	sts pulse1_fx_Sxx_post, r26
001816 93a0 28b6                 	sts pulse2_fx_Gxx_pre, r26
001818 93a0 28b7                 	sts pulse2_fx_Gxx_post, r26
00181a 93a0 28c8                 	sts pulse2_fx_Sxx_pre, r26
00181c 93a0 28c9                 	sts pulse2_fx_Sxx_post, r26
00181e 93a0 2902                 	sts triangle_fx_Gxx_pre, r26
001820 93a0 2903                 	sts triangle_fx_Gxx_post, r26
001822 93a0 2914                 	sts triangle_fx_Sxx_pre, r26
001824 93a0 2915                 	sts triangle_fx_Sxx_post, r26
001826 93a0 2948                 	sts noise_fx_Gxx_pre, r26
001828 93a0 2949                 	sts noise_fx_Gxx_post, r26
00182a 93a0 294b                 	sts noise_fx_Sxx_pre, r26
00182c 93a0 294c                 	sts noise_fx_Sxx_post, r26
00182e 93a0 2957                 	sts dpcm_fx_Gxx_pre, r26
001830 93a0 2958                 	sts dpcm_fx_Gxx_post, r26
001832 93a0 2959                 	sts dpcm_fx_Sxx_pre, r26
001834 93a0 295a                 	sts dpcm_fx_Sxx_post, r26
                                 
001836 93a0 2825                 	sts song_fx_Bxx, r26 //reset all song effects
001838 9220 2826                 	sts song_fx_Cxx, zero
00183a 9220 2827                 	sts song_fx_Dxx, zero
00183c c09e                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
00183d 91ff                      	pop r31
00183e 91ef                      	pop r30
00183f 91df                      	pop r29
001840 91cf                      	pop r28
001841 91bf                      	pop r27
001842 bfbf                      	out CPU_SREG, r27
001843 94f8                      	cli //disable global interrupts
                                 		
001844 efaf                      	ldi r26, 0xFF
001845 93a0 2825                 	sts song_fx_Bxx, r26 //reset all song effects
001847 9220 2826                 	sts song_fx_Cxx, zero
001849 9220 2827                 	sts song_fx_Dxx, zero
00184b 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
00184c 91e0 2819                 	lds ZL, song_frames
00184e 91f0 281a                 	lds ZH, song_frames+1
001850 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001852 91b0 281c                 	lds r27, song_frame_offset+1
001854 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001855 93a0 281b                 	sts song_frame_offset, r26
001857 93b0 281c                 	sts song_frame_offset+1, r27
001859 0fea                      	add ZL, r26
00185a 1ffb                      	adc ZH, r27
                                 
00185b 91a5                      	lpm r26, Z+ //load the address of the next pattern
00185c 91b5                      	lpm r27, Z+
00185d 0faa                      	lsl r26
00185e 1fbb                      	rol r27
00185f 93a0 2828                 	sts pulse1_pattern, r26
001861 93b0 2829                 	sts pulse1_pattern+1, r27
001863 91a5                      	lpm r26, Z+
001864 91b5                      	lpm r27, Z+
001865 0faa                      	lsl r26
001866 1fbb                      	rol r27
001867 93a0 2879                 	sts pulse2_pattern, r26
001869 93b0 287a                 	sts pulse2_pattern+1, r27
00186b 91a5                      	lpm r26, Z+
00186c 91b5                      	lpm r27, Z+
00186d 0faa                      	lsl r26
00186e 1fbb                      	rol r27
00186f 93a0 28ca                 	sts triangle_pattern, r26
001871 93b0 28cb                 	sts triangle_pattern+1, r27
001873 91a5                      	lpm r26, Z+
001874 91b5                      	lpm r27, Z+
001875 0faa                      	lsl r26
001876 1fbb                      	rol r27
001877 93a0 2916                 	sts noise_pattern, r26
001879 93b0 2917                 	sts noise_pattern+1, r27
00187b 91a5                      	lpm r26, Z+
00187c 91b5                      	lpm r27, Z+
00187d 0faa                      	lsl r26
00187e 1fbb                      	rol r27
00187f 93a0 294d                 	sts dpcm_pattern, r26
001881 93b0 294e                 	sts dpcm_pattern+1, r27
                                 
001883 9220 282c                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001885 9220 282d                 	sts pulse1_pattern_offset+1, zero
001887 9220 282a                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001889 9230 282b                 	sts pulse1_pattern_delay_frames, one
00188b 9220 287d                 	sts pulse2_pattern_offset, zero
00188d 9220 287e                 	sts pulse2_pattern_offset+1, zero
00188f 9220 287b                 	sts pulse2_pattern_delay_rows, zero
001891 9230 287c                 	sts pulse2_pattern_delay_frames, one
001893 9220 28ce                 	sts triangle_pattern_offset, zero
001895 9220 28cf                 	sts triangle_pattern_offset+1, zero
001897 9220 28cc                 	sts triangle_pattern_delay_rows, zero
001899 9230 28cd                 	sts triangle_pattern_delay_frames, one
00189b 9220 291a                 	sts noise_pattern_offset, zero
00189d 9220 291b                 	sts noise_pattern_offset+1, zero
00189f 9220 2918                 	sts noise_pattern_delay_rows, zero
0018a1 9230 2919                 	sts noise_pattern_delay_frames, one
0018a3 9220 2951                 	sts dpcm_pattern_offset, zero
0018a5 9220 2951                 	sts dpcm_pattern_offset, zero
0018a7 9220 294f                 	sts dpcm_pattern_delay_rows, zero
0018a9 9230 2950                 	sts dpcm_pattern_delay_frames, one
                                 
0018ab efaf                      	ldi r26, 0xFF
0018ac 93a0 2865                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0018ae 93a0 2866                 	sts pulse1_fx_Gxx_post, r26
0018b0 93a0 2877                 	sts pulse1_fx_Sxx_pre, r26
0018b2 93a0 2878                 	sts pulse1_fx_Sxx_post, r26
0018b4 93a0 28b6                 	sts pulse2_fx_Gxx_pre, r26
0018b6 93a0 28b7                 	sts pulse2_fx_Gxx_post, r26
0018b8 93a0 28c8                 	sts pulse2_fx_Sxx_pre, r26
0018ba 93a0 28c9                 	sts pulse2_fx_Sxx_post, r26
0018bc 93a0 2902                 	sts triangle_fx_Gxx_pre, r26
0018be 93a0 2903                 	sts triangle_fx_Gxx_post, r26
0018c0 93a0 2914                 	sts triangle_fx_Sxx_pre, r26
0018c2 93a0 2915                 	sts triangle_fx_Sxx_post, r26
0018c4 93a0 2948                 	sts noise_fx_Gxx_pre, r26
0018c6 93a0 2949                 	sts noise_fx_Gxx_post, r26
0018c8 93a0 294b                 	sts noise_fx_Sxx_pre, r26
0018ca 93a0 294c                 	sts noise_fx_Sxx_post, r26
0018cc 93a0 2957                 	sts dpcm_fx_Gxx_pre, r26
0018ce 93a0 2958                 	sts dpcm_fx_Gxx_post, r26
0018d0 93a0 2959                 	sts dpcm_fx_Sxx_pre, r26
0018d2 93a0 295a                 	sts dpcm_fx_Sxx_post, r26
                                 
0018d4 93a0 2825                 	sts song_fx_Bxx, r26 //reset all song effects
0018d6 9220 2826                 	sts song_fx_Cxx, zero
0018d8 9220 2827                 	sts song_fx_Dxx, zero
0018da c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
0018db 91a0 282a                 	lds r26, pulse1_pattern_delay_rows
0018dd 91b0 282b                 	lds r27, pulse1_pattern_delay_frames
                                 sound_driver_channel0_decrement_frame_delay:
0018df 95ba                      	dec r27
0018e0 93b0 282b                 	sts pulse1_pattern_delay_frames, r27
                                 
0018e2 9610                      	adiw r27:r26, 0
0018e3 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
0018e4 c2e4                      	rjmp sound_driver_channel0_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel0_main:
0018e5 91e0 2828                 	lds ZL, pulse1_pattern //current pattern for pulse 1
0018e7 91f0 2829                 	lds ZH, pulse1_pattern+1
0018e9 91a0 282c                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
0018eb 91b0 282d                 	lds r27, pulse1_pattern_offset+1
0018ed 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0018ee 1ffb                      	adc ZH, r27
0018ef 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0018f0 35b7                      	cpi r27, 0x57
0018f1 f408                      	brsh sound_driver_channel0_check_if_volume
0018f2 c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
0018f3 36b7                      	cpi r27, 0x67
0018f4 f408                      	brsh sound_driver_channel0_check_if_delay
0018f5 c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0018f6 3eb3                      	cpi r27, 0xE3
0018f7 f408                      	brsh sound_driver_channel0_check_if_instrument
0018f8 c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
0018f9 f409                      	brne sound_driver_channel0_check_if_release
0018fa c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
0018fb 3eb4                      	cpi r27, 0xE4
0018fc f409                      	brne sound_driver_channel0_check_if_end
0018fd c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
0018fe 3fbf                      	cpi r27, 0xFF
0018ff f409                      	brne sound_driver_channel0_check_if_fx
001900 c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001901 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001902 91a4                      	lpm r26, Z //load the fx data into r26
001903 d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001904 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001905 e0e0                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001906 e6f3                      	ldi ZH, HIGH(channel0_fx << 1)
001907 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001908 0feb                      	add ZL, r27 //add offset
001909 1df2                      	adc ZH, zero
00190a 91c5                      	lpm r28, Z+ //load address bytes
00190b 91d4                      	lpm r29, Z
00190c 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00190d 2ffd                      	mov ZH, r29
00190e 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
00190f 93a0 284b                 	sts pulse1_fx_0xy_sequence, r26
001911 9220 284c                 	sts pulse1_fx_0xy_sequence+1, zero
001913 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
001914 9220 2851                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001916 9220 2852                 	sts pulse1_fx_2xx+1, zero
001918 9220 284b                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00191a 9220 284c                 	sts pulse1_fx_0xy_sequence+1, zero
00191c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00191d 937f                      	push r23
00191e 2f6a                      	mov r22, r26 //store the rate into r22
00191f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001920 9f67                      	mul r22, r23
001921 917f                      	pop r23
001922 916f                      	pop r22
                                 
001923 9416                      	lsr r1 //shift out the fractional bits
001924 9407                      	ror r0
001925 9416                      	lsr r1
001926 9407                      	ror r0
001927 9416                      	lsr r1
001928 9407                      	ror r0
001929 9416                      	lsr r1
00192a 9407                      	ror r0
00192b 9200 284d                 	sts pulse1_fx_1xx, r0
00192d 9210 284e                 	sts pulse1_fx_1xx+1, r1
00192f cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001930 9220 284d                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001932 9220 284e                 	sts pulse1_fx_1xx+1, zero
001934 9220 284b                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001936 9220 284c                 	sts pulse1_fx_0xy_sequence+1, zero
001938 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001939 937f                      	push r23
00193a 2f6a                      	mov r22, r26 //store the rate into r22
00193b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00193c 9f67                      	mul r22, r23
00193d 917f                      	pop r23
00193e 916f                      	pop r22
                                 
00193f 9416                      	lsr r1 //shift out the fractional bits
001940 9407                      	ror r0
001941 9416                      	lsr r1
001942 9407                      	ror r0
001943 9416                      	lsr r1
001944 9407                      	ror r0
001945 9416                      	lsr r1
001946 9407                      	ror r0
001947 9200 2851                 	sts pulse1_fx_2xx, r0
001949 9210 2852                 	sts pulse1_fx_2xx+1, r1
00194b cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00194c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00194d 937f                      	push r23
00194e 2f6a                      	mov r22, r26 //store the rate into r22
00194f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001950 9f67                      	mul r22, r23
001951 917f                      	pop r23
001952 916f                      	pop r22
                                 
001953 9416                      	lsr r1 //shift out the fractional bits
001954 9407                      	ror r0
001955 9416                      	lsr r1
001956 9407                      	ror r0
001957 9416                      	lsr r1
001958 9407                      	ror r0
001959 9416                      	lsr r1
00195a 9407                      	ror r0
00195b 9200 2859                 	sts pulse1_fx_3xx_speed, r0
00195d 9210 285a                 	sts pulse1_fx_3xx_speed+1, r1
                                 
00195f 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001960 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
001961 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
001962 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001964 91b0 0a8d                 	lds r27, TCB0_CCMPH
001966 93a0 2855                 	sts pulse1_fx_3xx_start, r26
001968 93b0 2856                 	sts pulse1_fx_3xx_start+1, r27
                                 
00196a 9220 285b                 	sts pulse1_fx_3xx_total_offset, zero
00196c 9220 285c                 	sts pulse1_fx_3xx_total_offset+1, zero
00196e cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
00196f 2fba                      	mov r27, r26
001970 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001971 95a2                      	swap r26
001972 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001973 93a0 285d                 	sts pulse1_fx_4xy_speed, r26
001975 93b0 285e                 	sts pulse1_fx_4xy_depth, r27
001977 9220 285f                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
001979 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
00197a 2fba                      	mov r27, r26
00197b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00197c 95a2                      	swap r26
00197d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00197e 93a0 2860                 	sts pulse1_fx_7xy_speed, r26
001980 93b0 2861                 	sts pulse1_fx_7xy_depth, r27
001982 9220 2862                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
001984 9220 2863                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001986 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001987 93a0 2864                 	sts pulse1_fx_Axy, r26
001989 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
00198a 93a0 2825                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00198c cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
00198d 93b0 2826                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00198f cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
001990 93b0 2827                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001992 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
001993 91b0 2800                 	lds r27, pulse1_param
001995 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001996 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001997 93b0 2800                 	sts pulse1_param, r27
001999 6096                      	sbr pulse_channel_flags, 6
00199a cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
00199b 93a0 2824                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00199d cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
00199e 15a2                      	cp r26, zero
00199f f051                      	breq sound_driver_channel0_fx_Gxx_invalid
0019a0 91b0 2824                 	lds r27, song_speed
0019a2 17ab                      	cp r26, r27
0019a3 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
0019a4 93a0 2865                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0019a6 e0b1                      	ldi r27, 0x01
0019a7 93b0 282a                 	sts pulse1_pattern_delay_rows, r27
0019a9 c22e                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
0019aa cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0019ab cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0019ac cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0019ad cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0019ae cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0019af 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019b0 937f                      	push r23
0019b1 2f6a                      	mov r22, r26
0019b2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019b3 0367                      	mulsu r22, r23
0019b4 917f                      	pop r23
0019b5 916f                      	pop r22
0019b6 9416                      	lsr r1 //shift out the fractional bits
0019b7 9407                      	ror r0
0019b8 9416                      	lsr r1
0019b9 9407                      	ror r0
0019ba 9416                      	lsr r1
0019bb 9407                      	ror r0
0019bc 9416                      	lsr r1
0019bd 9407                      	ror r0
0019be fe13                      	sbrs r1, 3 //check if result was a negative number
0019bf c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
0019c0 efb0                      	ldi r27, 0xF0
0019c1 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
0019c2 9200 2867                 	sts pulse1_fx_Pxx_total, r0
0019c4 9210 2868                 	sts pulse1_fx_Pxx_total+1, r1
0019c6 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
0019c7 91e0 2833                 	lds ZL, pulse1_arpeggio_macro
0019c9 91f0 2834                 	lds ZH, pulse1_arpeggio_macro+1
0019cb 9630                      	adiw Z, 0
0019cc f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
0019cd cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
0019ce 91e0 283b                 	lds ZL, pulse1_pitch_macro
0019d0 91f0 283c                 	lds ZH, pulse1_pitch_macro+1
0019d2 9630                      	adiw Z, 0
0019d3 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
0019d4 cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
0019d5 91e0 2841                 	lds ZL, pulse1_hi_pitch_macro
0019d7 91f0 2842                 	lds ZH, pulse1_hi_pitch_macro+1
0019d9 9630                      	adiw Z, 0
0019da f009                      	breq sound_driver_channel0_fx_Qxy_process
0019db cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
0019dc 2fba                      	mov r27, r26 //copy fx parameters into r27
0019dd 70bf                      	andi r27, 0x0F //mask note index offset
0019de 91c0 2869                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
0019e0 0fbc                      	add r27, r28
0019e1 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0019e2 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
0019e3 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
0019e4 93b0 2869                 	sts pulse1_fx_Qxy_target_note, r27
0019e6 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0019e7 e0f0                      	ldi ZH, HIGH(note_table << 1)
0019e8 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0019e9 0feb                      	add ZL, r27 //add offset
0019ea 1df2                      	adc ZH, zero
0019eb 91c5                      	lpm r28, Z+ //load bytes
0019ec 91d4                      	lpm r29, Z
0019ed 93c0 286a                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
0019ef 93d0 286b                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
0019f1 95a2                      	swap r26
0019f2 70af                      	andi r26, 0x0F //mask effect speed
0019f3 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0019f4 95a3                      	inc r26 //increment the speed by 1
                                 
0019f5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019f6 937f                      	push r23
0019f7 2f6a                      	mov r22, r26 //store the speed data into r27
0019f8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019f9 9f67                      	mul r22, r23
0019fa 917f                      	pop r23
0019fb 916f                      	pop r22
                                 
0019fc 9416                      	lsr r1 //shift out the fractional bits
0019fd 9407                      	ror r0
0019fe 9416                      	lsr r1
0019ff 9407                      	ror r0
001a00 9416                      	lsr r1
001a01 9407                      	ror r0
001a02 9416                      	lsr r1
001a03 9407                      	ror r0
                                 
001a04 9200 286c                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001a06 9210 286d                 	sts pulse1_fx_Qxy_speed+1, r1
001a08 cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001a09 91e0 2833                 	lds ZL, pulse1_arpeggio_macro
001a0b 91f0 2834                 	lds ZH, pulse1_arpeggio_macro+1
001a0d 9630                      	adiw Z, 0
001a0e f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001a0f ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001a10 91e0 283b                 	lds ZL, pulse1_pitch_macro
001a12 91f0 283c                 	lds ZH, pulse1_pitch_macro+1
001a14 9630                      	adiw Z, 0
001a15 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001a16 cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001a17 91e0 2841                 	lds ZL, pulse1_hi_pitch_macro
001a19 91f0 2842                 	lds ZH, pulse1_hi_pitch_macro+1
001a1b 9630                      	adiw Z, 0
001a1c f009                      	breq sound_driver_channel0_fx_Rxy_process
001a1d cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001a1e 2fba                      	mov r27, r26 //copy fx parameters into r27
001a1f 70bf                      	andi r27, 0x0F //mask note index offset
001a20 91c0 2870                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
001a22 1bcb                      	sub r28, r27
001a23 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001a24 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001a25 93c0 2870                 	sts pulse1_fx_Rxy_target_note, r28
001a27 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001a28 e0f0                      	ldi ZH, HIGH(note_table << 1)
001a29 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001a2a 0fec                      	add ZL, r28 //add offset
001a2b 1df2                      	adc ZH, zero
001a2c 91c5                      	lpm r28, Z+ //load bytes
001a2d 91d4                      	lpm r29, Z
001a2e 93c0 2871                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001a30 93d0 2872                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
001a32 95a2                      	swap r26
001a33 70af                      	andi r26, 0x0F //mask effect speed
001a34 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001a35 95a3                      	inc r26 //increment the speed by 1
                                 
001a36 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a37 937f                      	push r23
001a38 2f6a                      	mov r22, r26 //store the speed data into r27
001a39 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a3a 9f67                      	mul r22, r23
001a3b 917f                      	pop r23
001a3c 916f                      	pop r22
                                 
001a3d 9416                      	lsr r1 //shift out the fractional bits
001a3e 9407                      	ror r0
001a3f 9416                      	lsr r1
001a40 9407                      	ror r0
001a41 9416                      	lsr r1
001a42 9407                      	ror r0
001a43 9416                      	lsr r1
001a44 9407                      	ror r0
                                 
001a45 9200 2873                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001a47 9210 2874                 	sts pulse1_fx_Rxy_speed+1, r1
001a49 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
001a4a 15a2                      	cp r26, zero
001a4b f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001a4c 91b0 2824                 	lds r27, song_speed
001a4e 17ab                      	cp r26, r27
001a4f f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001a50 93a0 2877                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001a52 e0b1                      	ldi r27, 0x01
001a53 93b0 282a                 	sts pulse1_pattern_delay_rows, r27
001a55 c182                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
001a56 ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001a57 efec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001a58 e6f2                      	ldi ZH, HIGH(sequences << 1)
001a59 0fea                      	add ZL, r26 //offset the pointer
001a5a 1df2                      	adc ZH, zero
                                 
001a5b 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001a5c 95a7                      	ror r26
001a5d 95a7                      	ror r26
001a5e 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001a60 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001a61 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001a62 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001a63 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001a64 ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001a65 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
001a66 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001a67 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001a68 93c0 2800                 	sts pulse1_param, r28
001a6a ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001a6b ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001a6c ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001a6d ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001a6e ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001a6f 93b0 2807                 	sts pulse1_note, r27 //store the note index
001a71 93b0 2869                 	sts pulse1_fx_Qxy_target_note, r27
001a73 93b0 2870                 	sts pulse1_fx_Rxy_target_note, r27
001a75 e0a3                      	ldi r26, 0x03
001a76 e0b2                      	ldi r27, 0x02
001a77 93b0 2830                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001a79 93a0 2835                 	sts pulse1_arpeggio_macro_offset, r26
001a7b 93b0 283d                 	sts pulse1_pitch_macro_offset, r27
001a7d 93b0 2843                 	sts pulse1_hi_pitch_macro_offset, r27
001a7f 93b0 2848                 	sts pulse1_duty_macro_offset, r27
001a81 9220 2839                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001a83 9220 283a                 	sts pulse1_total_pitch_offset+1, zero
001a85 9220 2840                 	sts pulse1_total_hi_pitch_offset, zero
001a87 9220 284f                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001a89 9220 2850                 	sts pulse1_fx_1xx_total+1, zero
001a8b 9220 2853                 	sts pulse1_fx_2xx_total, zero
001a8d 9220 2854                 	sts pulse1_fx_2xx_total+1, zero
001a8f 9220 285b                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001a91 9220 285c                 	sts pulse1_fx_3xx_total_offset+1, zero
001a93 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001a95 91b0 0a8d                 	lds r27, TCB0_CCMPH
001a97 93a0 2855                 	sts pulse1_fx_3xx_start, r26
001a99 93b0 2856                 	sts pulse1_fx_3xx_start+1, r27
001a9b 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001a9d 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001a9e 9220 286a                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001aa0 9220 286b                 	sts pulse1_fx_Qxy_target+1, zero
001aa2 9220 286e                 	sts pulse1_fx_Qxy_total_offset, zero
001aa4 9220 286f                 	sts pulse1_fx_Qxy_total_offset+1, zero
001aa6 9220 2871                 	sts pulse1_fx_Rxy_target, zero
001aa8 9220 2872                 	sts pulse1_fx_Rxy_target+1, zero
001aaa 9220 2875                 	sts pulse1_fx_Rxy_total_offset, zero
001aac 9220 2876                 	sts pulse1_fx_Rxy_total_offset+1, zero
001aae d106                      	rcall sound_driver_channel0_increment_offset
001aaf ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001ab0 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
001ab1 91a0 2800                 	lds r26, pulse1_param
001ab3 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001ab4 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001ab5 93a0 2800                 	sts pulse1_param, r26
001ab7 6096                      	sbr pulse_channel_flags, 6
001ab8 d0fc                      	rcall sound_driver_channel0_increment_offset
001ab9 ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001aba 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001abb 93b0 282a                 	sts pulse1_pattern_delay_rows, r27
001abd d0f7                      	rcall sound_driver_channel0_increment_offset
001abe c10a                      	rjmp sound_driver_channel0_end
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001abf 9220 282e                 	sts pulse1_volume_macro, zero //reset all macro addresses
001ac1 9220 282f                 	sts pulse1_volume_macro+1, zero
001ac3 9220 2833                 	sts pulse1_arpeggio_macro, zero
001ac5 9220 2834                 	sts pulse1_arpeggio_macro+1, zero
001ac7 9220 283b                 	sts pulse1_pitch_macro, zero
001ac9 9220 283c                 	sts pulse1_pitch_macro+1, zero
001acb 9220 2841                 	sts pulse1_hi_pitch_macro, zero
001acd 9220 2842                 	sts pulse1_hi_pitch_macro+1, zero
001acf 9220 2846                 	sts pulse1_duty_macro, zero
001ad1 9220 2847                 	sts pulse1_duty_macro+1, zero
001ad3 9220 2839                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001ad5 9220 283a                 	sts pulse1_total_pitch_offset+1, zero
001ad7 9220 2840                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001ad9 9631                      	adiw Z, 1 //point to the byte next to the flag
001ada 91b4                      	lpm r27, Z //store the instrument offset into r27
001adb ebe1                      	ldi ZL, LOW(instruments) //point Z to instruments table
001adc e1f1                      	ldi ZH, HIGH(instruments)
001add 0feb                      	add ZL, r27 //point Z to offsetted instrument
001ade 1df2                      	adc ZH, zero
001adf 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001ae0 1fff                      	rol ZH
001ae1 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001ae2 91b4                      	lpm r27, Z
                                 
001ae3 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001ae4 1fbb                      	rol r27
001ae5 2fea                      	mov ZL, r26
001ae6 2ffb                      	mov ZH, r27
001ae7 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001ae8 9632                      	adiw Z, 2 //point Z to the address of the macro
001ae9 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001aea 95aa                      	dec r26
001aeb f019                      	breq sound_driver_channel0_instrument_change_exit
001aec 95b6                      	lsr r27
001aed f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001aee cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001aef e0a3                      	ldi r26, 0x03
001af0 e0b2                      	ldi r27, 0x02
001af1 93b0 2830                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001af3 93a0 2835                 	sts pulse1_arpeggio_macro_offset, r26
001af5 93b0 283d                 	sts pulse1_pitch_macro_offset, r27
001af7 93b0 2843                 	sts pulse1_hi_pitch_macro_offset, r27
001af9 93b0 2848                 	sts pulse1_duty_macro_offset, r27
001afb d0c3                      	rcall sound_driver_channel0_increment_offset_twice
001afc cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001afd 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001afe 91d5                      	lpm r29, Z+
                                 
001aff 30a5                      	cpi r26, 5
001b00 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001b01 30a4                      	cpi r26, 4
001b02 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001b03 30a3                      	cpi r26, 3
001b04 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001b05 30a2                      	cpi r26, 2
001b06 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001b07 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001b08 93c0 282e                 	sts pulse1_volume_macro, r28
001b0a 93d0 282f                 	sts pulse1_volume_macro+1, r29
001b0c d041                      	rcall sound_driver_channel0_instrument_change_read_header
001b0d 93c0 2832                 	sts pulse1_volume_macro_release, r28
001b0f 93d0 2831                 	sts pulse1_volume_macro_loop, r29
001b11 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001b12 93c0 2833                 	sts pulse1_arpeggio_macro, r28
001b14 93d0 2834                 	sts pulse1_arpeggio_macro+1, r29
001b16 9220 286a                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b18 9220 286b                 	sts pulse1_fx_Qxy_target+1, zero
001b1a 9220 2871                 	sts pulse1_fx_Rxy_target, zero
001b1c 9220 2872                 	sts pulse1_fx_Rxy_target+1, zero
001b1e d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001b1f cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001b20 93c0 283b                 	sts pulse1_pitch_macro, r28
001b22 93d0 283c                 	sts pulse1_pitch_macro+1, r29
001b24 9220 286a                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b26 9220 286b                 	sts pulse1_fx_Qxy_target+1, zero
001b28 9220 2871                 	sts pulse1_fx_Rxy_target, zero
001b2a 9220 2872                 	sts pulse1_fx_Rxy_target+1, zero
001b2c d021                      	rcall sound_driver_channel0_instrument_change_read_header
001b2d 93c0 283f                 	sts pulse1_pitch_macro_release, r28
001b2f 93d0 283e                 	sts pulse1_pitch_macro_loop, r29
001b31 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001b32 93c0 2841                 	sts pulse1_hi_pitch_macro, r28
001b34 93d0 2842                 	sts pulse1_hi_pitch_macro+1, r29
001b36 9220 286a                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b38 9220 286b                 	sts pulse1_fx_Qxy_target+1, zero
001b3a 9220 2871                 	sts pulse1_fx_Rxy_target, zero
001b3c 9220 2872                 	sts pulse1_fx_Rxy_target+1, zero
001b3e d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001b3f 93c0 2845                 	sts pulse1_hi_pitch_macro_release, r28
001b41 93d0 2844                 	sts pulse1_hi_pitch_macro_loop, r29
001b43 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001b44 93c0 2846                 	sts pulse1_duty_macro, r28
001b46 93d0 2847                 	sts pulse1_duty_macro+1, r29
001b48 d005                      	rcall sound_driver_channel0_instrument_change_read_header
001b49 93c0 284a                 	sts pulse1_duty_macro_release, r28
001b4b 93d0 2849                 	sts pulse1_duty_macro_loop, r29
001b4d cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001b4e 93ef                      	push ZL
001b4f 93ff                      	push ZH
001b50 2fec                      	mov ZL, r28
001b51 2ffd                      	mov ZH, r29
001b52 0fee                      	lsl ZL
001b53 1fff                      	rol ZH
001b54 91c5                      	lpm r28, Z+
001b55 91d4                      	lpm r29, Z
001b56 91ff                      	pop ZH
001b57 91ef                      	pop ZL
001b58 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001b59 93ef                      	push ZL
001b5a 93ff                      	push ZH
001b5b 2fec                      	mov ZL, r28
001b5c 2ffd                      	mov ZH, r29
001b5d 0fee                      	lsl ZL
001b5e 1fff                      	rol ZH
001b5f 91c5                      	lpm r28, Z+
001b60 91d5                      	lpm r29, Z+
001b61 93c0 2837                 	sts pulse1_arpeggio_macro_release, r28
001b63 93d0 2836                 	sts pulse1_arpeggio_macro_loop, r29
001b65 91c4                      	lpm r28, Z
001b66 93c0 2838                 	sts pulse1_arpeggio_macro_mode, r28
001b68 91ff                      	pop ZH
001b69 91ef                      	pop ZL
001b6a 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001b6b 91b0 2832                 	lds r27, pulse1_volume_macro_release
001b6d 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001b6e f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001b6f 95b3                      	inc r27
001b70 93b0 2830                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001b72 91b0 2837                 	lds r27, pulse1_arpeggio_macro_release
001b74 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001b75 f019                      	breq sound_driver_channel0_release_pitch
001b76 95b3                      	inc r27
001b77 93b0 2835                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001b79 91b0 283f                 	lds r27, pulse1_pitch_macro_release
001b7b 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001b7c f019                      	breq sound_driver_channel0_release_hi_pitch
001b7d 95b3                      	inc r27
001b7e 93b0 283d                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001b80 91b0 2845                 	lds r27, pulse1_hi_pitch_macro_release
001b82 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001b83 f019                      	breq sound_driver_channel0_release_duty
001b84 95b3                      	inc r27
001b85 93b0 2843                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001b87 91b0 284a                 	lds r27, pulse1_duty_macro_release
001b89 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001b8a f019                      	breq sound_driver_channel0_release_exit
001b8b 95b3                      	inc r27
001b8c 93b0 2848                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001b8e d026                      	rcall sound_driver_channel0_increment_offset
001b8f cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001b90 91e0 2819                 	lds ZL, song_frames
001b92 91f0 281a                 	lds ZH, song_frames+1
001b94 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001b96 91b0 281c                 	lds r27, song_frame_offset+1
001b98 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001b99 93a0 281b                 	sts song_frame_offset, r26
001b9b 93b0 281c                 	sts song_frame_offset+1, r27
                                 
001b9d 91c0 281d                 	lds r28, song_size
001b9f 91d0 281e                 	lds r29, song_size+1
001ba1 17ac                      	cp r26, r28
001ba2 07bd                      	cpc r27, r29
001ba3 f010                      	brlo sound_driver_channel0_next_pattern_exists
001ba4 940c 3168                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001ba6 0fea                      	add ZL, r26
001ba7 1ffb                      	adc ZH, r27
                                 
001ba8 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ba9 91b4                      	lpm r27, Z
001baa 0faa                      	lsl r26
001bab 1fbb                      	rol r27
001bac 93a0 2828                 	sts pulse1_pattern, r26
001bae 93b0 2829                 	sts pulse1_pattern+1, r27
                                 
001bb0 9220 282c                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001bb2 9220 282d                 	sts pulse1_pattern_offset+1, zero
001bb4 cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001bb5 91e0 282c                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001bb7 91f0 282d                 	lds ZH, pulse1_pattern_offset+1
001bb9 9631                      	adiw Z, 1
001bba 93e0 282c                 	sts pulse1_pattern_offset, ZL
001bbc 93f0 282d                 	sts pulse1_pattern_offset+1, ZH
001bbe 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001bbf 91e0 282c                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001bc1 91f0 282d                 	lds ZH, pulse1_pattern_offset+1
001bc3 9632                      	adiw Z, 2 //increment the pointer twice
001bc4 93e0 282c                 	sts pulse1_pattern_offset, ZL
001bc6 93f0 282d                 	sts pulse1_pattern_offset+1, ZH
001bc8 9508                      	ret
                                 
                                 sound_driver_channel0_end:
                                 sound_driver_channel0_check_Sxx_invalid:
001bc9 efbf                      	ldi r27, 0xFF
001bca 91a0 2878                 	lds r26, pulse1_fx_Sxx_post
001bcc 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
001bcd f419                      	brne sound_driver_channel0_check_Gxx_invalid
001bce 93b0 2878                 	sts pulse1_fx_Sxx_post, r27
001bd0 9508                      	ret
                                 sound_driver_channel0_check_Gxx_invalid:
001bd1 91a0 2866                 	lds r26, pulse1_fx_Gxx_post
001bd3 15a2                      	cp r26, zero
001bd4 f419                      	brne sound_driver_channel1
001bd5 93b0 2866                 	sts pulse1_fx_Gxx_post, r27
001bd7 9508                      	ret
                                 
                                 
                                 sound_driver_channel1:
001bd8 91a0 287b                 	lds r26, pulse2_pattern_delay_rows
001bda 91b0 287c                 	lds r27, pulse2_pattern_delay_frames
                                 sound_driver_channel1_decrement_frame_delay:
001bdc 95ba                      	dec r27
001bdd 93b0 287c                 	sts pulse2_pattern_delay_frames, r27
                                 
001bdf 9610                      	adiw r27:r26, 0
001be0 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001be1 c2d7                      	rjmp sound_driver_channel1_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel1_main:
001be2 91e0 2879                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001be4 91f0 287a                 	lds ZH, pulse2_pattern+1
001be6 91a0 287d                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001be8 91b0 287e                 	lds r27, pulse2_pattern_offset+1
001bea 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001beb 1ffb                      	adc ZH, r27
001bec 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001bed 35b7                      	cpi r27, 0x57
001bee f408                      	brsh sound_driver_channel1_check_if_volume
001bef c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001bf0 36b7                      	cpi r27, 0x67
001bf1 f408                      	brsh sound_driver_channel1_check_if_delay
001bf2 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001bf3 3eb3                      	cpi r27, 0xE3
001bf4 f408                      	brsh sound_driver_channel1_check_if_instrument
001bf5 c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001bf6 f409                      	brne sound_driver_channel1_check_if_release
001bf7 c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001bf8 3eb4                      	cpi r27, 0xE4
001bf9 f409                      	brne sound_driver_channel1_check_if_end
001bfa c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001bfb 3fbf                      	cpi r27, 0xFF
001bfc f409                      	brne sound_driver_channel1_check_if_fx
001bfd c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001bfe 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001bff 91a4                      	lpm r26, Z //load the fx data into r26
001c00 d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001c01 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001c02 e3e4                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001c03 e6f3                      	ldi ZH, HIGH(channel1_fx << 1)
001c04 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001c05 0feb                      	add ZL, r27 //add offset
001c06 1df2                      	adc ZH, zero
001c07 91c5                      	lpm r28, Z+ //load address bytes
001c08 91d4                      	lpm r29, Z
001c09 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001c0a 2ffd                      	mov ZH, r29
001c0b 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001c0c 93a0 289c                 	sts pulse2_fx_0xy_sequence, r26
001c0e 9220 289d                 	sts pulse2_fx_0xy_sequence+1, zero
001c10 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001c11 9220 28a2                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001c13 9220 28a3                 	sts pulse2_fx_2xx+1, zero
001c15 9220 289c                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c17 9220 289d                 	sts pulse2_fx_0xy_sequence+1, zero
001c19 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c1a 937f                      	push r23
001c1b 2f6a                      	mov r22, r26 //store the rate into r22
001c1c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c1d 9f67                      	mul r22, r23
001c1e 917f                      	pop r23
001c1f 916f                      	pop r22
                                 
001c20 9416                      	lsr r1 //shift out the fractional bits
001c21 9407                      	ror r0
001c22 9416                      	lsr r1
001c23 9407                      	ror r0
001c24 9416                      	lsr r1
001c25 9407                      	ror r0
001c26 9416                      	lsr r1
001c27 9407                      	ror r0
001c28 9200 289e                 	sts pulse2_fx_1xx, r0
001c2a 9210 289f                 	sts pulse2_fx_1xx+1, r1
001c2c cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001c2d 9220 289e                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001c2f 9220 289f                 	sts pulse2_fx_1xx+1, zero
001c31 9220 289c                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001c33 9220 289d                 	sts pulse2_fx_0xy_sequence+1, zero
001c35 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c36 937f                      	push r23
001c37 2f6a                      	mov r22, r26 //store the rate into r22
001c38 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c39 9f67                      	mul r22, r23
001c3a 917f                      	pop r23
001c3b 916f                      	pop r22
                                 
001c3c 9416                      	lsr r1 //shift out the fractional bits
001c3d 9407                      	ror r0
001c3e 9416                      	lsr r1
001c3f 9407                      	ror r0
001c40 9416                      	lsr r1
001c41 9407                      	ror r0
001c42 9416                      	lsr r1
001c43 9407                      	ror r0
001c44 9200 28a2                 	sts pulse2_fx_2xx, r0
001c46 9210 28a3                 	sts pulse2_fx_2xx+1, r1
001c48 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001c49 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c4a 937f                      	push r23
001c4b 2f6a                      	mov r22, r26 //store the rate into r22
001c4c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c4d 9f67                      	mul r22, r23
001c4e 917f                      	pop r23
001c4f 916f                      	pop r22
                                 
001c50 9416                      	lsr r1 //shift out the fractional bits
001c51 9407                      	ror r0
001c52 9416                      	lsr r1
001c53 9407                      	ror r0
001c54 9416                      	lsr r1
001c55 9407                      	ror r0
001c56 9416                      	lsr r1
001c57 9407                      	ror r0
001c58 9200 28aa                 	sts pulse2_fx_3xx_speed, r0
001c5a 9210 28ab                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001c5c 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001c5d c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001c5e cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001c5f 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001c61 91b0 0a9d                 	lds r27, TCB1_CCMPH
001c63 93a0 28a6                 	sts pulse2_fx_3xx_start, r26
001c65 93b0 28a7                 	sts pulse2_fx_3xx_start+1, r27
                                 
001c67 9220 28ac                 	sts pulse2_fx_3xx_total_offset, zero
001c69 9220 28ad                 	sts pulse2_fx_3xx_total_offset+1, zero
001c6b cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001c6c 2fba                      	mov r27, r26
001c6d 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001c6e 95a2                      	swap r26
001c6f 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001c70 93a0 28ae                 	sts pulse2_fx_4xy_speed, r26
001c72 93b0 28af                 	sts pulse2_fx_4xy_depth, r27
001c74 9220 28b0                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001c76 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001c77 2fba                      	mov r27, r26
001c78 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001c79 95a2                      	swap r26
001c7a 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001c7b 93a0 28b1                 	sts pulse2_fx_7xy_speed, r26
001c7d 93b0 28b2                 	sts pulse2_fx_7xy_depth, r27
001c7f 9220 28b3                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001c81 9220 28b4                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001c83 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001c84 93a0 28b5                 	sts pulse2_fx_Axy, r26
001c86 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001c87 93a0 2825                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001c89 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001c8a 93b0 2826                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001c8c cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001c8d 93b0 2827                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001c8f cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001c90 91b0 2808                 	lds r27, pulse2_param
001c92 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001c93 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001c94 93b0 2808                 	sts pulse2_param, r27
001c96 6092                      	sbr pulse_channel_flags, 2
001c97 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001c98 93a0 2824                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001c9a cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001c9b 15a2                      	cp r26, zero
001c9c f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001c9d 91b0 2824                 	lds r27, song_speed
001c9f 17ab                      	cp r26, r27
001ca0 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001ca1 93a0 28b6                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ca3 e0b1                      	ldi r27, 0x01
001ca4 93b0 287b                 	sts pulse2_pattern_delay_rows, r27
001ca6 c221                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001ca7 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001ca8 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001ca9 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001caa cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001cab cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001cac 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001cad 937f                      	push r23
001cae 2f6a                      	mov r22, r26
001caf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001cb0 0367                      	mulsu r22, r23
001cb1 917f                      	pop r23
001cb2 916f                      	pop r22
001cb3 9416                      	lsr r1 //shift out the fractional bits
001cb4 9407                      	ror r0
001cb5 9416                      	lsr r1
001cb6 9407                      	ror r0
001cb7 9416                      	lsr r1
001cb8 9407                      	ror r0
001cb9 9416                      	lsr r1
001cba 9407                      	ror r0
001cbb fe13                      	sbrs r1, 3 //check if result was a negative number
001cbc c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
001cbd efb0                      	ldi r27, 0xF0
001cbe 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001cbf 9200 28b8                 	sts pulse2_fx_Pxx_total, r0
001cc1 9210 28b9                 	sts pulse2_fx_Pxx_total+1, r1
001cc3 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001cc4 91e0 2884                 	lds ZL, pulse2_arpeggio_macro
001cc6 91f0 2885                 	lds ZH, pulse2_arpeggio_macro+1
001cc8 9630                      	adiw Z, 0
001cc9 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001cca cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001ccb 91e0 288c                 	lds ZL, pulse2_pitch_macro
001ccd 91f0 288d                 	lds ZH, pulse2_pitch_macro+1
001ccf 9630                      	adiw Z, 0
001cd0 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001cd1 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001cd2 91e0 2892                 	lds ZL, pulse2_hi_pitch_macro
001cd4 91f0 2893                 	lds ZH, pulse2_hi_pitch_macro+1
001cd6 9630                      	adiw Z, 0
001cd7 f009                      	breq sound_driver_channel1_fx_Qxy_process
001cd8 cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001cd9 2fba                      	mov r27, r26 //copy fx parameters into r27
001cda 70bf                      	andi r27, 0x0F //mask note index offset
001cdb 91c0 28ba                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
001cdd 0fbc                      	add r27, r28
001cde 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001cdf f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001ce0 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001ce1 93b0 28ba                 	sts pulse2_fx_Qxy_target_note, r27
001ce3 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001ce4 e0f0                      	ldi ZH, HIGH(note_table << 1)
001ce5 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001ce6 0feb                      	add ZL, r27 //add offset
001ce7 1df2                      	adc ZH, zero
001ce8 91c5                      	lpm r28, Z+ //load bytes
001ce9 91d4                      	lpm r29, Z
001cea 93c0 28bb                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001cec 93d0 28bc                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
001cee 95a2                      	swap r26
001cef 70af                      	andi r26, 0x0F //mask effect speed
001cf0 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001cf1 95a3                      	inc r26 //increment the speed by 1
                                 
001cf2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001cf3 937f                      	push r23
001cf4 2f6a                      	mov r22, r26 //store the speed data into r27
001cf5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001cf6 9f67                      	mul r22, r23
001cf7 917f                      	pop r23
001cf8 916f                      	pop r22
                                 
001cf9 9416                      	lsr r1 //shift out the fractional bits
001cfa 9407                      	ror r0
001cfb 9416                      	lsr r1
001cfc 9407                      	ror r0
001cfd 9416                      	lsr r1
001cfe 9407                      	ror r0
001cff 9416                      	lsr r1
001d00 9407                      	ror r0
                                 
001d01 9200 28bd                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001d03 9210 28be                 	sts pulse2_fx_Qxy_speed+1, r1
001d05 cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001d06 91e0 2884                 	lds ZL, pulse2_arpeggio_macro
001d08 91f0 2885                 	lds ZH, pulse2_arpeggio_macro+1
001d0a 9630                      	adiw Z, 0
001d0b f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001d0c ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001d0d 91e0 288c                 	lds ZL, pulse2_pitch_macro
001d0f 91f0 288d                 	lds ZH, pulse2_pitch_macro+1
001d11 9630                      	adiw Z, 0
001d12 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001d13 cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001d14 91e0 2892                 	lds ZL, pulse2_hi_pitch_macro
001d16 91f0 2893                 	lds ZH, pulse2_hi_pitch_macro+1
001d18 9630                      	adiw Z, 0
001d19 f009                      	breq sound_driver_channel1_fx_Rxy_process
001d1a cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001d1b 2fba                      	mov r27, r26 //copy fx parameters into r27
001d1c 70bf                      	andi r27, 0x0F //mask note index offset
001d1d 91c0 28c1                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
001d1f 1bcb                      	sub r28, r27
001d20 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001d21 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001d22 93c0 28c1                 	sts pulse2_fx_Rxy_target_note, r28
001d24 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001d25 e0f0                      	ldi ZH, HIGH(note_table << 1)
001d26 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001d27 0fec                      	add ZL, r28 //add offset
001d28 1df2                      	adc ZH, zero
001d29 91c5                      	lpm r28, Z+ //load bytes
001d2a 91d4                      	lpm r29, Z
001d2b 93c0 28c2                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001d2d 93d0 28c3                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
001d2f 95a2                      	swap r26
001d30 70af                      	andi r26, 0x0F //mask effect speed
001d31 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d32 95a3                      	inc r26 //increment the speed by 1
                                 
001d33 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d34 937f                      	push r23
001d35 2f6a                      	mov r22, r26 //store the speed data into r27
001d36 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d37 9f67                      	mul r22, r23
001d38 917f                      	pop r23
001d39 916f                      	pop r22
                                 
001d3a 9416                      	lsr r1 //shift out the fractional bits
001d3b 9407                      	ror r0
001d3c 9416                      	lsr r1
001d3d 9407                      	ror r0
001d3e 9416                      	lsr r1
001d3f 9407                      	ror r0
001d40 9416                      	lsr r1
001d41 9407                      	ror r0
                                 
001d42 9200 28c4                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001d44 9210 28c5                 	sts pulse2_fx_Rxy_speed+1, r1
001d46 ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001d47 15a2                      	cp r26, zero
001d48 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001d49 91b0 2824                 	lds r27, song_speed
001d4b 17ab                      	cp r26, r27
001d4c f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001d4d 93a0 28c8                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001d4f e0b1                      	ldi r27, 0x01
001d50 93b0 287b                 	sts pulse2_pattern_delay_rows, r27
001d52 c175                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001d53 ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001d54 efec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001d55 e6f2                      	ldi ZH, HIGH(sequences << 1)
001d56 0fea                      	add ZL, r26 //offset the pointer
001d57 1df2                      	adc ZH, zero
                                 
001d58 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001d59 95a7                      	ror r26
001d5a 95a7                      	ror r26
001d5b 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001d5d 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001d5e 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001d5f 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001d60 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001d61 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001d62 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001d63 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001d64 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001d65 93c0 2808                 	sts pulse2_param, r28
001d67 ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001d68 ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001d69 ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001d6a ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001d6b ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001d6c 93b0 280f                 	sts pulse2_note, r27 //store the note index
001d6e 93b0 28ba                 	sts pulse2_fx_Qxy_target_note, r27
001d70 93b0 28c1                 	sts pulse2_fx_Rxy_target_note, r27
001d72 e0a3                      	ldi r26, 0x03
001d73 e0b2                      	ldi r27, 0x02
001d74 93b0 2881                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001d76 93a0 2886                 	sts pulse2_arpeggio_macro_offset, r26
001d78 93b0 288e                 	sts pulse2_pitch_macro_offset, r27
001d7a 93b0 2894                 	sts pulse2_hi_pitch_macro_offset, r27
001d7c 93b0 2899                 	sts pulse2_duty_macro_offset, r27
001d7e 9220 288a                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001d80 9220 288b                 	sts pulse2_total_pitch_offset+1, zero
001d82 9220 2891                 	sts pulse2_total_hi_pitch_offset, zero
001d84 9220 28a0                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001d86 9220 28a1                 	sts pulse2_fx_1xx_total+1, zero
001d88 9220 28a4                 	sts pulse2_fx_2xx_total, zero
001d8a 9220 28a5                 	sts pulse2_fx_2xx_total+1, zero
001d8c 9220 28ac                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001d8e 9220 28ad                 	sts pulse2_fx_3xx_total_offset+1, zero
001d90 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001d92 91b0 0a9d                 	lds r27, TCB1_CCMPH
001d94 93a0 28a6                 	sts pulse2_fx_3xx_start, r26
001d96 93b0 28a7                 	sts pulse2_fx_3xx_start+1, r27
001d98 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001d9a 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001d9b 9220 28bb                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d9d 9220 28bc                 	sts pulse2_fx_Qxy_target+1, zero
001d9f 9220 28bf                 	sts pulse2_fx_Qxy_total_offset, zero
001da1 9220 28c0                 	sts pulse2_fx_Qxy_total_offset+1, zero
001da3 9220 28c2                 	sts pulse2_fx_Rxy_target, zero
001da5 9220 28c3                 	sts pulse2_fx_Rxy_target+1, zero
001da7 9220 28c6                 	sts pulse2_fx_Rxy_total_offset, zero
001da9 9220 28c7                 	sts pulse2_fx_Rxy_total_offset+1, zero
001dab d0f9                      	rcall sound_driver_channel1_increment_offset
001dac ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001dad 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
001dae 91a0 2808                 	lds r26, pulse2_param
001db0 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001db1 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001db2 93a0 2808                 	sts pulse2_param, r26
001db4 6092                      	sbr pulse_channel_flags, 2
001db5 d0ef                      	rcall sound_driver_channel1_increment_offset
001db6 ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001db7 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001db8 93b0 287b                 	sts pulse2_pattern_delay_rows, r27
001dba d0ea                      	rcall sound_driver_channel1_increment_offset
001dbb c0fd                      	rjmp sound_driver_channel1_end
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001dbc 9220 287f                 	sts pulse2_volume_macro, zero //reset all macro addresses
001dbe 9220 2880                 	sts pulse2_volume_macro+1, zero
001dc0 9220 2884                 	sts pulse2_arpeggio_macro, zero
001dc2 9220 2885                 	sts pulse2_arpeggio_macro+1, zero
001dc4 9220 288c                 	sts pulse2_pitch_macro, zero
001dc6 9220 288d                 	sts pulse2_pitch_macro+1, zero
001dc8 9220 2892                 	sts pulse2_hi_pitch_macro, zero
001dca 9220 2893                 	sts pulse2_hi_pitch_macro+1, zero
001dcc 9220 2897                 	sts pulse2_duty_macro, zero
001dce 9220 2898                 	sts pulse2_duty_macro+1, zero
001dd0 9220 288a                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001dd2 9220 288b                 	sts pulse2_total_pitch_offset+1, zero
001dd4 9220 2891                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001dd6 9631                      	adiw Z, 1 //point to the byte next to the flag
001dd7 91b4                      	lpm r27, Z //store the instrument offset into r27
001dd8 ebe1                      	ldi ZL, LOW(instruments) //point Z to instruments table
001dd9 e1f1                      	ldi ZH, HIGH(instruments)
001dda 0feb                      	add ZL, r27 //point Z to offsetted instrument
001ddb 1df2                      	adc ZH, zero
001ddc 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001ddd 1fff                      	rol ZH
001dde 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001ddf 91b4                      	lpm r27, Z
                                 
001de0 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001de1 1fbb                      	rol r27
001de2 2fea                      	mov ZL, r26
001de3 2ffb                      	mov ZH, r27
001de4 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001de5 9632                      	adiw Z, 2 //point Z to the address of the macro
001de6 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001de7 95aa                      	dec r26
001de8 f019                      	breq sound_driver_channel1_instrument_change_exit
001de9 95b6                      	lsr r27
001dea f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001deb cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001dec e0a3                      	ldi r26, 0x03
001ded e0b2                      	ldi r27, 0x02
001dee 93b0 2881                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001df0 93a0 2886                 	sts pulse2_arpeggio_macro_offset, r26
001df2 93b0 288e                 	sts pulse2_pitch_macro_offset, r27
001df4 93b0 2894                 	sts pulse2_hi_pitch_macro_offset, r27
001df6 93b0 2899                 	sts pulse2_duty_macro_offset, r27
001df8 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001df9 cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001dfa 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001dfb 91d5                      	lpm r29, Z+
                                 
001dfc 30a5                      	cpi r26, 5
001dfd f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001dfe 30a4                      	cpi r26, 4
001dff f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001e00 30a3                      	cpi r26, 3
001e01 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001e02 30a2                      	cpi r26, 2
001e03 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001e04 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001e05 93c0 287f                 	sts pulse2_volume_macro, r28
001e07 93d0 2880                 	sts pulse2_volume_macro+1, r29
001e09 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001e0a 93c0 2883                 	sts pulse2_volume_macro_release, r28
001e0c 93d0 2882                 	sts pulse2_volume_macro_loop, r29
001e0e cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001e0f 93c0 2884                 	sts pulse2_arpeggio_macro, r28
001e11 93d0 2885                 	sts pulse2_arpeggio_macro+1, r29
001e13 9220 28bb                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e15 9220 28bc                 	sts pulse2_fx_Qxy_target+1, zero
001e17 9220 28c2                 	sts pulse2_fx_Rxy_target, zero
001e19 9220 28c3                 	sts pulse2_fx_Rxy_target+1, zero
001e1b d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001e1c cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001e1d 93c0 288c                 	sts pulse2_pitch_macro, r28
001e1f 93d0 288d                 	sts pulse2_pitch_macro+1, r29
001e21 9220 28bb                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e23 9220 28bc                 	sts pulse2_fx_Qxy_target+1, zero
001e25 9220 28c2                 	sts pulse2_fx_Rxy_target, zero
001e27 9220 28c3                 	sts pulse2_fx_Rxy_target+1, zero
001e29 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001e2a 93c0 2890                 	sts pulse2_pitch_macro_release, r28
001e2c 93d0 288f                 	sts pulse2_pitch_macro_loop, r29
001e2e cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001e2f 93c0 2892                 	sts pulse2_hi_pitch_macro, r28
001e31 93d0 2893                 	sts pulse2_hi_pitch_macro+1, r29
001e33 9220 28bb                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e35 9220 28bc                 	sts pulse2_fx_Qxy_target+1, zero
001e37 9220 28c2                 	sts pulse2_fx_Rxy_target, zero
001e39 9220 28c3                 	sts pulse2_fx_Rxy_target+1, zero
001e3b d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001e3c 93c0 2896                 	sts pulse2_hi_pitch_macro_release, r28
001e3e 93d0 2895                 	sts pulse2_hi_pitch_macro_loop, r29
001e40 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001e41 93c0 2897                 	sts pulse2_duty_macro, r28
001e43 93d0 2898                 	sts pulse2_duty_macro+1, r29
001e45 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001e46 93c0 289b                 	sts pulse2_duty_macro_release, r28
001e48 93d0 289a                 	sts pulse2_duty_macro_loop, r29
001e4a cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001e4b 93ef                      	push ZL
001e4c 93ff                      	push ZH
001e4d 2fec                      	mov ZL, r28
001e4e 2ffd                      	mov ZH, r29
001e4f 0fee                      	lsl ZL
001e50 1fff                      	rol ZH
001e51 91c5                      	lpm r28, Z+
001e52 91d4                      	lpm r29, Z
001e53 91ff                      	pop ZH
001e54 91ef                      	pop ZL
001e55 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001e56 93ef                      	push ZL
001e57 93ff                      	push ZH
001e58 2fec                      	mov ZL, r28
001e59 2ffd                      	mov ZH, r29
001e5a 0fee                      	lsl ZL
001e5b 1fff                      	rol ZH
001e5c 91c5                      	lpm r28, Z+
001e5d 91d5                      	lpm r29, Z+
001e5e 93c0 2888                 	sts pulse2_arpeggio_macro_release, r28
001e60 93d0 2887                 	sts pulse2_arpeggio_macro_loop, r29
001e62 91c4                      	lpm r28, Z
001e63 93c0 2889                 	sts pulse2_arpeggio_macro_mode, r28
001e65 91ff                      	pop ZH
001e66 91ef                      	pop ZL
001e67 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001e68 91b0 2883                 	lds r27, pulse2_volume_macro_release
001e6a 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001e6b f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001e6c 95b3                      	inc r27
001e6d 93b0 2881                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001e6f 91b0 2888                 	lds r27, pulse2_arpeggio_macro_release
001e71 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001e72 f019                      	breq sound_driver_channel1_release_pitch
001e73 95b3                      	inc r27
001e74 93b0 2886                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001e76 91b0 2890                 	lds r27, pulse2_pitch_macro_release
001e78 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001e79 f019                      	breq sound_driver_channel1_release_hi_pitch
001e7a 95b3                      	inc r27
001e7b 93b0 288e                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001e7d 91b0 2896                 	lds r27, pulse2_hi_pitch_macro_release
001e7f 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001e80 f019                      	breq sound_driver_channel1_release_duty
001e81 95b3                      	inc r27
001e82 93b0 2894                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001e84 91b0 289b                 	lds r27, pulse2_duty_macro_release
001e86 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001e87 f019                      	breq sound_driver_channel1_release_exit
001e88 95b3                      	inc r27
001e89 93b0 2899                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001e8b d019                      	rcall sound_driver_channel1_increment_offset
001e8c cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001e8d 91e0 2819                 	lds ZL, song_frames
001e8f 91f0 281a                 	lds ZH, song_frames+1
001e91 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001e93 91b0 281c                 	lds r27, song_frame_offset+1
001e95 9612                      	adiw r27:r26, 2 //offset for channel 1
001e96 0fea                      	add ZL, r26
001e97 1ffb                      	adc ZH, r27
                                 
001e98 91a5                      	lpm r26, Z+ //load the address of the next pattern
001e99 91b4                      	lpm r27, Z
001e9a 0faa                      	lsl r26
001e9b 1fbb                      	rol r27
001e9c 93a0 2879                 	sts pulse2_pattern, r26
001e9e 93b0 287a                 	sts pulse2_pattern+1, r27
                                 
001ea0 9220 287d                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ea2 9220 287e                 	sts pulse2_pattern_offset+1, zero
001ea4 cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001ea5 91e0 287d                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001ea7 91f0 287e                 	lds ZH, pulse2_pattern_offset+1
001ea9 9631                      	adiw Z, 1
001eaa 93e0 287d                 	sts pulse2_pattern_offset, ZL
001eac 93f0 287e                 	sts pulse2_pattern_offset+1, ZH
001eae 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001eaf 91e0 287d                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001eb1 91f0 287e                 	lds ZH, pulse2_pattern_offset+1
001eb3 9632                      	adiw Z, 2 //increment the pointer twice
001eb4 93e0 287d                 	sts pulse2_pattern_offset, ZL
001eb6 93f0 287e                 	sts pulse2_pattern_offset+1, ZH
001eb8 9508                      	ret
                                 
                                 sound_driver_channel1_end:
                                 sound_driver_channel1_check_Sxx_invalid:
001eb9 efbf                      	ldi r27, 0xFF
001eba 91a0 28c9                 	lds r26, pulse2_fx_Sxx_post
001ebc 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
001ebd f419                      	brne sound_driver_channel1_check_Gxx_invalid
001ebe 93b0 28c9                 	sts pulse2_fx_Sxx_post, r27
001ec0 9508                      	ret
                                 sound_driver_channel1_check_Gxx_invalid:
001ec1 91a0 28b7                 	lds r26, pulse2_fx_Gxx_post
001ec3 15a2                      	cp r26, zero
001ec4 f419                      	brne sound_driver_channel2
001ec5 93b0 28b7                 	sts pulse2_fx_Gxx_post, r27
001ec7 9508                      	ret
                                 
                                 
                                 sound_driver_channel2:
001ec8 91a0 28cc                 	lds r26, triangle_pattern_delay_rows
001eca 91b0 28cd                 	lds r27, triangle_pattern_delay_frames
                                 sound_driver_channel2_decrement_frame_delay:
001ecc 95ba                      	dec r27
001ecd 93b0 28cd                 	sts triangle_pattern_delay_frames, r27
                                 
001ecf 9610                      	adiw r27:r26, 0
001ed0 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001ed1 c2bf                      	rjmp sound_driver_channel2_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel2_main:
001ed2 91e0 28ca                 	lds ZL, triangle_pattern //current pattern for triangle
001ed4 91f0 28cb                 	lds ZH, triangle_pattern+1
001ed6 91a0 28ce                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001ed8 91b0 28cf                 	lds r27, triangle_pattern_offset+1
001eda 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001edb 1ffb                      	adc ZH, r27
001edc 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001edd 35b7                      	cpi r27, 0x57
001ede f408                      	brsh sound_driver_channel2_check_if_volume
001edf c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001ee0 36b7                      	cpi r27, 0x67
001ee1 f408                      	brsh sound_driver_channel2_check_if_delay
001ee2 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001ee3 3eb3                      	cpi r27, 0xE3
001ee4 f408                      	brsh sound_driver_channel2_check_if_instrument
001ee5 c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001ee6 f409                      	brne sound_driver_channel2_check_if_release
001ee7 c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001ee8 3eb4                      	cpi r27, 0xE4
001ee9 f409                      	brne sound_driver_channel2_check_if_end
001eea c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001eeb 3fbf                      	cpi r27, 0xFF
001eec f409                      	brne sound_driver_channel2_check_if_fx
001eed c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001eee 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001eef 91a4                      	lpm r26, Z //load the fx data into r26
001ef0 d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001ef1 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001ef2 e6e8                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001ef3 e6f3                      	ldi ZH, HIGH(channel2_fx << 1)
001ef4 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001ef5 0feb                      	add ZL, r27 //add offset
001ef6 1df2                      	adc ZH, zero
001ef7 91c5                      	lpm r28, Z+ //load address bytes
001ef8 91d4                      	lpm r29, Z
001ef9 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001efa 2ffd                      	mov ZH, r29
001efb 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001efc 93a0 28ed                 	sts triangle_fx_0xy_sequence, r26
001efe 9220 28ee                 	sts triangle_fx_0xy_sequence+1, zero
001f00 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001f01 9220 28f3                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001f03 9220 28f4                 	sts triangle_fx_2xx+1, zero
001f05 9220 28ed                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f07 9220 28ee                 	sts triangle_fx_0xy_sequence+1, zero
001f09 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f0a 937f                      	push r23
001f0b 2f6a                      	mov r22, r26 //store the rate into r22
001f0c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f0d 9f67                      	mul r22, r23
001f0e 917f                      	pop r23
001f0f 916f                      	pop r22
                                 
001f10 9416                      	lsr r1 //shift out the fractional bits
001f11 9407                      	ror r0
001f12 9416                      	lsr r1
001f13 9407                      	ror r0
001f14 9416                      	lsr r1
001f15 9407                      	ror r0
001f16 9416                      	lsr r1
001f17 9407                      	ror r0
001f18 9200 28ef                 	sts triangle_fx_1xx, r0
001f1a 9210 28f0                 	sts triangle_fx_1xx+1, r1
001f1c cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001f1d 9220 28ef                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001f1f 9220 28f0                 	sts triangle_fx_1xx+1, zero
001f21 9220 28ed                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001f23 9220 28ee                 	sts triangle_fx_0xy_sequence+1, zero
001f25 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f26 937f                      	push r23
001f27 2f6a                      	mov r22, r26 //store the rate into r22
001f28 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f29 9f67                      	mul r22, r23
001f2a 917f                      	pop r23
001f2b 916f                      	pop r22
                                 
001f2c 9416                      	lsr r1 //shift out the fractional bits
001f2d 9407                      	ror r0
001f2e 9416                      	lsr r1
001f2f 9407                      	ror r0
001f30 9416                      	lsr r1
001f31 9407                      	ror r0
001f32 9416                      	lsr r1
001f33 9407                      	ror r0
001f34 9200 28f3                 	sts triangle_fx_2xx, r0
001f36 9210 28f4                 	sts triangle_fx_2xx+1, r1
001f38 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001f39 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f3a 937f                      	push r23
001f3b 2f6a                      	mov r22, r26 //store the rate into r22
001f3c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f3d 9f67                      	mul r22, r23
001f3e 917f                      	pop r23
001f3f 916f                      	pop r22
                                 
001f40 9416                      	lsr r1 //shift out the fractional bits
001f41 9407                      	ror r0
001f42 9416                      	lsr r1
001f43 9407                      	ror r0
001f44 9416                      	lsr r1
001f45 9407                      	ror r0
001f46 9416                      	lsr r1
001f47 9407                      	ror r0
001f48 9200 28fb                 	sts triangle_fx_3xx_speed, r0
001f4a 9210 28fc                 	sts triangle_fx_3xx_speed+1, r1
                                 
001f4c 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001f4d c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001f4e cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001f4f 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001f51 91b0 0aad                 	lds r27, TCB2_CCMPH
001f53 93a0 28f7                 	sts triangle_fx_3xx_start, r26
001f55 93b0 28f8                 	sts triangle_fx_3xx_start+1, r27
                                 
001f57 9220 28fd                 	sts triangle_fx_3xx_total_offset, zero
001f59 9220 28fe                 	sts triangle_fx_3xx_total_offset+1, zero
001f5b cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001f5c 2fba                      	mov r27, r26
001f5d 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001f5e 95a2                      	swap r26
001f5f 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001f60 93a0 28ff                 	sts triangle_fx_4xy_speed, r26
001f62 93b0 2900                 	sts triangle_fx_4xy_depth, r27
001f64 9220 2901                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001f66 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001f67 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001f68 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001f69 93a0 2825                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001f6b cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001f6c 93b0 2826                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001f6e cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001f6f 93b0 2827                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001f71 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001f72 15a2                      	cp r26, zero
001f73 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001f74 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001f75 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001f77 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001f78 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001f7a 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001f7c 9220 0aad                 	sts TCB2_CCMPH, zero
001f7e cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001f7f 93a0 2824                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001f81 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001f82 15a2                      	cp r26, zero
001f83 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001f84 91b0 2824                 	lds r27, song_speed
001f86 17ab                      	cp r26, r27
001f87 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001f88 93a0 2902                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001f8a e0b1                      	ldi r27, 0x01
001f8b 93b0 28cc                 	sts triangle_pattern_delay_rows, r27
001f8d c212                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001f8e cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001f8f cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001f90 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001f91 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001f92 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001f93 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f94 937f                      	push r23
001f95 2f6a                      	mov r22, r26
001f96 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f97 0367                      	mulsu r22, r23
001f98 917f                      	pop r23
001f99 916f                      	pop r22
001f9a 9416                      	lsr r1 //shift out the fractional bits
001f9b 9407                      	ror r0
001f9c 9416                      	lsr r1
001f9d 9407                      	ror r0
001f9e 9416                      	lsr r1
001f9f 9407                      	ror r0
001fa0 9416                      	lsr r1
001fa1 9407                      	ror r0
001fa2 fe13                      	sbrs r1, 3 //check if result was a negative number
001fa3 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001fa4 efb0                      	ldi r27, 0xF0
001fa5 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001fa6 9200 2904                 	sts triangle_fx_Pxx_total, r0
001fa8 9210 2905                 	sts triangle_fx_Pxx_total+1, r1
001faa cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001fab 91e0 28d5                 	lds ZL, triangle_arpeggio_macro
001fad 91f0 28d6                 	lds ZH, triangle_arpeggio_macro+1
001faf 9630                      	adiw Z, 0
001fb0 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001fb1 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001fb2 91e0 28dd                 	lds ZL, triangle_pitch_macro
001fb4 91f0 28de                 	lds ZH, triangle_pitch_macro+1
001fb6 9630                      	adiw Z, 0
001fb7 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001fb8 cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001fb9 91e0 28e3                 	lds ZL, triangle_hi_pitch_macro
001fbb 91f0 28e4                 	lds ZH, triangle_hi_pitch_macro+1
001fbd 9630                      	adiw Z, 0
001fbe f009                      	breq sound_driver_channel2_fx_Qxy_process
001fbf cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001fc0 2fba                      	mov r27, r26 //copy fx parameters into r27
001fc1 70bf                      	andi r27, 0x0F //mask note index offset
001fc2 91c0 2906                 	lds r28, triangle_fx_Qxy_target_note //load current note index
001fc4 0fbc                      	add r27, r28
001fc5 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001fc6 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001fc7 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001fc8 93b0 2906                 	sts triangle_fx_Qxy_target_note, r27
001fca e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001fcb e0f0                      	ldi ZH, HIGH(note_table << 1)
001fcc 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001fcd 0feb                      	add ZL, r27 //add offset
001fce 1df2                      	adc ZH, zero
001fcf 91c5                      	lpm r28, Z+ //load bytes
001fd0 91d4                      	lpm r29, Z
001fd1 93c0 2907                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001fd3 93d0 2908                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
001fd5 95a2                      	swap r26
001fd6 70af                      	andi r26, 0x0F //mask effect speed
001fd7 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001fd8 95a3                      	inc r26 //increment the speed by 1
                                 
001fd9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001fda 937f                      	push r23
001fdb 2f6a                      	mov r22, r26 //store the speed data into r27
001fdc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001fdd 9f67                      	mul r22, r23
001fde 917f                      	pop r23
001fdf 916f                      	pop r22
                                 
001fe0 9416                      	lsr r1 //shift out the fractional bits
001fe1 9407                      	ror r0
001fe2 9416                      	lsr r1
001fe3 9407                      	ror r0
001fe4 9416                      	lsr r1
001fe5 9407                      	ror r0
001fe6 9416                      	lsr r1
001fe7 9407                      	ror r0
                                 
001fe8 9200 2909                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001fea 9210 290a                 	sts triangle_fx_Qxy_speed+1, r1
001fec cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001fed 91e0 28d5                 	lds ZL, triangle_arpeggio_macro
001fef 91f0 28d6                 	lds ZH, triangle_arpeggio_macro+1
001ff1 9630                      	adiw Z, 0
001ff2 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001ff3 cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001ff4 91e0 28dd                 	lds ZL, triangle_pitch_macro
001ff6 91f0 28de                 	lds ZH, triangle_pitch_macro+1
001ff8 9630                      	adiw Z, 0
001ff9 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001ffa ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001ffb 91e0 28e3                 	lds ZL, triangle_hi_pitch_macro
001ffd 91f0 28e4                 	lds ZH, triangle_hi_pitch_macro+1
001fff 9630                      	adiw Z, 0
002000 f009                      	breq sound_driver_channel2_fx_Rxy_process
002001 ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
002002 2fba                      	mov r27, r26 //copy fx parameters into r27
002003 70bf                      	andi r27, 0x0F //mask note index offset
002004 91c0 290d                 	lds r28, triangle_fx_Rxy_target_note //load current note index
002006 1bcb                      	sub r28, r27
002007 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
002008 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
002009 93c0 290d                 	sts triangle_fx_Rxy_target_note, r28
00200b e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00200c e0f0                      	ldi ZH, HIGH(note_table << 1)
00200d 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00200e 0fec                      	add ZL, r28 //add offset
00200f 1df2                      	adc ZH, zero
002010 91c5                      	lpm r28, Z+ //load bytes
002011 91d4                      	lpm r29, Z
002012 93c0 290e                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
002014 93d0 290f                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
002016 95a2                      	swap r26
002017 70af                      	andi r26, 0x0F //mask effect speed
002018 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
002019 95a3                      	inc r26 //increment the speed by 1
                                 
00201a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00201b 937f                      	push r23
00201c 2f6a                      	mov r22, r26 //store the speed data into r27
00201d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00201e 9f67                      	mul r22, r23
00201f 917f                      	pop r23
002020 916f                      	pop r22
                                 
002021 9416                      	lsr r1 //shift out the fractional bits
002022 9407                      	ror r0
002023 9416                      	lsr r1
002024 9407                      	ror r0
002025 9416                      	lsr r1
002026 9407                      	ror r0
002027 9416                      	lsr r1
002028 9407                      	ror r0
                                 
002029 9200 2910                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
00202b 9210 2911                 	sts triangle_fx_Rxy_speed+1, r1
00202d cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
00202e 15a2                      	cp r26, zero
00202f f051                      	breq sound_driver_channel2_fx_Sxx_invalid
002030 91b0 2824                 	lds r27, song_speed
002032 17ab                      	cp r26, r27
002033 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
002034 93a0 2914                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002036 e0b1                      	ldi r27, 0x01
002037 93b0 28cc                 	sts triangle_pattern_delay_rows, r27
002039 c166                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
00203a ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
00203b ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
00203c ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
00203d ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
00203e ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
00203f ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
002040 93b0 2812                 	sts triangle_note, r27 //store the note index
002042 93b0 2906                 	sts triangle_fx_Qxy_target_note, r27
002044 93b0 290d                 	sts triangle_fx_Rxy_target_note, r27
002046 e0a3                      	ldi r26, 0x03
002047 e0b2                      	ldi r27, 0x02
002048 93b0 28d2                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
00204a 93a0 28d7                 	sts triangle_arpeggio_macro_offset, r26
00204c 93b0 28df                 	sts triangle_pitch_macro_offset, r27
00204e 93b0 28e5                 	sts triangle_hi_pitch_macro_offset, r27
002050 93b0 28ea                 	sts triangle_duty_macro_offset, r27
002052 9220 28db                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
002054 9220 28dc                 	sts triangle_total_pitch_offset+1, zero
002056 9220 28e2                 	sts triangle_total_hi_pitch_offset, zero
002058 9220 28f1                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00205a 9220 28f2                 	sts triangle_fx_1xx_total+1, zero
00205c 9220 28f5                 	sts triangle_fx_2xx_total, zero
00205e 9220 28f6                 	sts triangle_fx_2xx_total+1, zero
002060 9220 28fd                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
002062 9220 28fe                 	sts triangle_fx_3xx_total_offset+1, zero
002064 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002066 91b0 0aad                 	lds r27, TCB2_CCMPH
002068 93a0 28f7                 	sts triangle_fx_3xx_start, r26
00206a 93b0 28f8                 	sts triangle_fx_3xx_start+1, r27
00206c 9220 2907                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00206e 9220 2908                 	sts triangle_fx_Qxy_target+1, zero
002070 9220 290b                 	sts triangle_fx_Qxy_total_offset, zero
002072 9220 290c                 	sts triangle_fx_Qxy_total_offset+1, zero
002074 9220 290e                 	sts triangle_fx_Rxy_target, zero
002076 9220 290f                 	sts triangle_fx_Rxy_target+1, zero
002078 9220 2912                 	sts triangle_fx_Rxy_total_offset, zero
00207a 9220 2913                 	sts triangle_fx_Rxy_total_offset+1, zero
00207c e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00207d 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00207f d0fd                      	rcall sound_driver_channel2_increment_offset
002080 ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
002081 d0fb                      	rcall sound_driver_channel2_increment_offset
002082 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
002083 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
002084 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002085 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002087 ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
002088 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
00208a 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
00208c 9220 0aad                 	sts TCB2_CCMPH, zero
00208e ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
00208f 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002090 93b0 28cc                 	sts triangle_pattern_delay_rows, r27
002092 d0ea                      	rcall sound_driver_channel2_increment_offset
002093 c0fd                      	rjmp sound_driver_channel2_end
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
002094 9220 28d0                 	sts triangle_volume_macro, zero //reset all macro addresses
002096 9220 28d1                 	sts triangle_volume_macro+1, zero
002098 9220 28d5                 	sts triangle_arpeggio_macro, zero
00209a 9220 28d6                 	sts triangle_arpeggio_macro+1, zero
00209c 9220 28dd                 	sts triangle_pitch_macro, zero
00209e 9220 28de                 	sts triangle_pitch_macro+1, zero
0020a0 9220 28e3                 	sts triangle_hi_pitch_macro, zero
0020a2 9220 28e4                 	sts triangle_hi_pitch_macro+1, zero
0020a4 9220 28e8                 	sts triangle_duty_macro, zero
0020a6 9220 28e9                 	sts triangle_duty_macro+1, zero
0020a8 9220 28db                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
0020aa 9220 28dc                 	sts triangle_total_pitch_offset+1, zero
0020ac 9220 28e2                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0020ae 9631                      	adiw Z, 1 //point to the byte next to the flag
0020af 91b4                      	lpm r27, Z //store the instrument offset into r27
0020b0 ebe1                      	ldi ZL, LOW(instruments) //point Z to instruments table
0020b1 e1f1                      	ldi ZH, HIGH(instruments)
0020b2 0feb                      	add ZL, r27 //point Z to offsetted instrument
0020b3 1df2                      	adc ZH, zero
0020b4 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0020b5 1fff                      	rol ZH
0020b6 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0020b7 91b4                      	lpm r27, Z
                                 
0020b8 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0020b9 1fbb                      	rol r27
0020ba 2fea                      	mov ZL, r26
0020bb 2ffb                      	mov ZH, r27
0020bc 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0020bd 9632                      	adiw Z, 2 //point Z to the address of the macro
0020be e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
0020bf 95aa                      	dec r26
0020c0 f019                      	breq sound_driver_channel2_instrument_change_exit
0020c1 95b6                      	lsr r27
0020c2 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
0020c3 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
0020c4 e0a3                      	ldi r26, 0x03
0020c5 e0b2                      	ldi r27, 0x02
0020c6 93b0 28d2                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
0020c8 93a0 28d7                 	sts triangle_arpeggio_macro_offset, r26
0020ca 93b0 28df                 	sts triangle_pitch_macro_offset, r27
0020cc 93b0 28e5                 	sts triangle_hi_pitch_macro_offset, r27
0020ce 93b0 28ea                 	sts triangle_duty_macro_offset, r27
0020d0 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
0020d1 ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
0020d2 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0020d3 91d5                      	lpm r29, Z+
                                 
0020d4 30a5                      	cpi r26, 5
0020d5 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
0020d6 30a4                      	cpi r26, 4
0020d7 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
0020d8 30a3                      	cpi r26, 3
0020d9 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
0020da 30a2                      	cpi r26, 2
0020db f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
0020dc c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
0020dd 93c0 28d0                 	sts triangle_volume_macro, r28
0020df 93d0 28d1                 	sts triangle_volume_macro+1, r29
0020e1 d041                      	rcall sound_driver_channel2_instrument_change_read_header
0020e2 93c0 28d4                 	sts triangle_volume_macro_release, r28
0020e4 93d0 28d3                 	sts triangle_volume_macro_loop, r29
0020e6 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
0020e7 93c0 28d5                 	sts triangle_arpeggio_macro, r28
0020e9 93d0 28d6                 	sts triangle_arpeggio_macro+1, r29
0020eb 9220 2907                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0020ed 9220 2908                 	sts triangle_fx_Qxy_target+1, zero
0020ef 9220 290e                 	sts triangle_fx_Rxy_target, zero
0020f1 9220 290f                 	sts triangle_fx_Rxy_target+1, zero
0020f3 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
0020f4 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
0020f5 93c0 28dd                 	sts triangle_pitch_macro, r28
0020f7 93d0 28de                 	sts triangle_pitch_macro+1, r29
0020f9 9220 2907                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0020fb 9220 2908                 	sts triangle_fx_Qxy_target+1, zero
0020fd 9220 290e                 	sts triangle_fx_Rxy_target, zero
0020ff 9220 290f                 	sts triangle_fx_Rxy_target+1, zero
002101 d021                      	rcall sound_driver_channel2_instrument_change_read_header
002102 93c0 28e1                 	sts triangle_pitch_macro_release, r28
002104 93d0 28e0                 	sts triangle_pitch_macro_loop, r29
002106 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
002107 93c0 28e3                 	sts triangle_hi_pitch_macro, r28
002109 93d0 28e4                 	sts triangle_hi_pitch_macro+1, r29
00210b 9220 2907                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00210d 9220 2908                 	sts triangle_fx_Qxy_target+1, zero
00210f 9220 290e                 	sts triangle_fx_Rxy_target, zero
002111 9220 290f                 	sts triangle_fx_Rxy_target+1, zero
002113 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
002114 93c0 28e7                 	sts triangle_hi_pitch_macro_release, r28
002116 93d0 28e6                 	sts triangle_hi_pitch_macro_loop, r29
002118 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
002119 93c0 28e8                 	sts triangle_duty_macro, r28
00211b 93d0 28e9                 	sts triangle_duty_macro+1, r29
00211d d005                      	rcall sound_driver_channel2_instrument_change_read_header
00211e 93c0 28ec                 	sts triangle_duty_macro_release, r28
002120 93d0 28eb                 	sts triangle_duty_macro_loop, r29
002122 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
002123 93ef                      	push ZL
002124 93ff                      	push ZH
002125 2fec                      	mov ZL, r28
002126 2ffd                      	mov ZH, r29
002127 0fee                      	lsl ZL
002128 1fff                      	rol ZH
002129 91c5                      	lpm r28, Z+
00212a 91d4                      	lpm r29, Z
00212b 91ff                      	pop ZH
00212c 91ef                      	pop ZL
00212d 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
00212e 93ef                      	push ZL
00212f 93ff                      	push ZH
002130 2fec                      	mov ZL, r28
002131 2ffd                      	mov ZH, r29
002132 0fee                      	lsl ZL
002133 1fff                      	rol ZH
002134 91c5                      	lpm r28, Z+
002135 91d5                      	lpm r29, Z+
002136 93c0 28d9                 	sts triangle_arpeggio_macro_release, r28
002138 93d0 28d8                 	sts triangle_arpeggio_macro_loop, r29
00213a 91c4                      	lpm r28, Z
00213b 93c0 28da                 	sts triangle_arpeggio_macro_mode, r28
00213d 91ff                      	pop ZH
00213e 91ef                      	pop ZL
00213f 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
002140 91b0 28d4                 	lds r27, triangle_volume_macro_release
002142 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002143 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
002144 95b3                      	inc r27
002145 93b0 28d2                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
002147 91b0 28d9                 	lds r27, triangle_arpeggio_macro_release
002149 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00214a f019                      	breq sound_driver_channel2_release_pitch
00214b 95b3                      	inc r27
00214c 93b0 28d7                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
00214e 91b0 28e1                 	lds r27, triangle_pitch_macro_release
002150 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002151 f019                      	breq sound_driver_channel2_release_hi_pitch
002152 95b3                      	inc r27
002153 93b0 28df                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
002155 91b0 28e7                 	lds r27, triangle_hi_pitch_macro_release
002157 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002158 f019                      	breq sound_driver_channel2_release_duty
002159 95b3                      	inc r27
00215a 93b0 28e5                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
00215c 91b0 28ec                 	lds r27, triangle_duty_macro_release
00215e 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00215f f019                      	breq sound_driver_channel2_release_exit
002160 95b3                      	inc r27
002161 93b0 28ea                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
002163 d019                      	rcall sound_driver_channel2_increment_offset
002164 cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
002165 91e0 2819                 	lds ZL, song_frames
002167 91f0 281a                 	lds ZH, song_frames+1
002169 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00216b 91b0 281c                 	lds r27, song_frame_offset+1
00216d 9614                      	adiw r27:r26, 4 //offset for channel 2
00216e 0fea                      	add ZL, r26
00216f 1ffb                      	adc ZH, r27
                                 
002170 91a5                      	lpm r26, Z+ //load the address of the next pattern
002171 91b4                      	lpm r27, Z
002172 0faa                      	lsl r26
002173 1fbb                      	rol r27
002174 93a0 28ca                 	sts triangle_pattern, r26
002176 93b0 28cb                 	sts triangle_pattern+1, r27
                                 
002178 9220 28ce                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00217a 9220 28cf                 	sts triangle_pattern_offset+1, zero
00217c cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
00217d 91e0 28ce                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
00217f 91f0 28cf                 	lds ZH, triangle_pattern_offset+1
002181 9631                      	adiw Z, 1
002182 93e0 28ce                 	sts triangle_pattern_offset, ZL
002184 93f0 28cf                 	sts triangle_pattern_offset+1, ZH
002186 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002187 91e0 28ce                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
002189 91f0 28cf                 	lds ZH, triangle_pattern_offset+1
00218b 9632                      	adiw Z, 2 //increment the pointer twice
00218c 93e0 28ce                 	sts triangle_pattern_offset, ZL
00218e 93f0 28cf                 	sts triangle_pattern_offset+1, ZH
002190 9508                      	ret
                                 
                                 sound_driver_channel2_end:
                                 sound_driver_channel2_check_Sxx_invalid:
002191 efbf                      	ldi r27, 0xFF
002192 91a0 2915                 	lds r26, triangle_fx_Sxx_post
002194 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
002195 f419                      	brne sound_driver_channel2_check_Gxx_invalid
002196 93b0 2915                 	sts triangle_fx_Sxx_post, r27
002198 9508                      	ret
                                 sound_driver_channel2_check_Gxx_invalid:
002199 91a0 2903                 	lds r26, triangle_fx_Gxx_post
00219b 15a2                      	cp r26, zero
00219c f419                      	brne sound_driver_channel3
00219d 93b0 2903                 	sts triangle_fx_Gxx_post, r27
00219f 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3:
0021a0 91a0 2918                 	lds r26, noise_pattern_delay_rows
0021a2 91b0 2919                 	lds r27, noise_pattern_delay_frames
                                 sound_driver_channel3_decrement_frame_delay:
0021a4 95ba                      	dec r27
0021a5 93b0 2919                 	sts noise_pattern_delay_frames, r27
                                 
0021a7 9610                      	adiw r27:r26, 0
0021a8 f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
0021a9 c1b9                      	rjmp sound_driver_channel3_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel3_main:
0021aa 91e0 2916                 	lds ZL, noise_pattern //current pattern for noise
0021ac 91f0 2917                 	lds ZH, noise_pattern+1
0021ae 91a0 291a                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
0021b0 91b0 291b                 	lds r27, noise_pattern_offset+1
0021b2 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0021b3 1ffb                      	adc ZH, r27
0021b4 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
0021b5 35b7                      	cpi r27, 0x57
0021b6 f408                      	brsh sound_driver_channel3_check_if_volume
0021b7 c096                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
0021b8 36b7                      	cpi r27, 0x67
0021b9 f408                      	brsh sound_driver_channel3_check_if_delay
0021ba c0b1                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0021bb 3eb3                      	cpi r27, 0xE3
0021bc f408                      	brsh sound_driver_channel3_check_if_instrument
0021bd c0b7                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
0021be f409                      	brne sound_driver_channel3_check_if_release
0021bf c0ba                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
0021c0 3eb4                      	cpi r27, 0xE4
0021c1 f409                      	brne sound_driver_channel3_check_if_end
0021c2 c14b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
0021c3 3fbf                      	cpi r27, 0xFF
0021c4 f409                      	brne sound_driver_channel3_check_if_fx
0021c5 c16d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
0021c6 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0021c7 91a4                      	lpm r26, Z //load the fx data into r26
0021c8 d190                      	rcall sound_driver_channel3_increment_offset_twice
                                 
0021c9 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0021ca e9ec                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
0021cb e6f3                      	ldi ZH, HIGH(channel3_fx << 1)
0021cc 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0021cd 0feb                      	add ZL, r27 //add offset
0021ce 1df2                      	adc ZH, zero
0021cf 91c5                      	lpm r28, Z+ //load address bytes
0021d0 91d4                      	lpm r29, Z
0021d1 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0021d2 2ffd                      	mov ZH, r29
0021d3 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
0021d4 93a0 2939                 	sts noise_fx_0xy_sequence, r26
0021d6 9220 293a                 	sts noise_fx_0xy_sequence+1, zero
0021d8 cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
0021d9 9220 293d                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
0021db 9220 2939                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
0021dd 9220 293a                 	sts noise_fx_0xy_sequence+1, zero
0021df 93a0 293b                 	sts noise_fx_1xx, r26
0021e1 cfc8                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
0021e2 9220 293b                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
0021e4 9220 2939                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
0021e6 9220 293a                 	sts noise_fx_0xy_sequence+1, zero
0021e8 93a0 293d                 	sts noise_fx_2xx, r26
0021ea cfbf                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
0021eb cfbe                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
0021ec 2fba                      	mov r27, r26
0021ed 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0021ee 95a2                      	swap r26
0021ef 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0021f0 93a0 293f                 	sts noise_fx_4xy_speed, r26
0021f2 93b0 2940                 	sts noise_fx_4xy_depth, r27
0021f4 9220 2941                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
0021f6 9220 2942                 	sts noise_fx_4xy_offset, zero
0021f8 cfb1                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
0021f9 2fba                      	mov r27, r26
0021fa 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0021fb 95a2                      	swap r26
0021fc 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0021fd 93a0 2943                 	sts noise_fx_7xy_speed, r26
0021ff 93b0 2944                 	sts noise_fx_7xy_depth, r27
002201 9220 2945                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
002203 9220 2946                 	sts noise_fx_7xy_value, zero //reset the tremelo value
002205 cfa4                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
002206 93a0 2947                 	sts noise_fx_Axy, r26
002208 cfa1                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002209 93a0 2825                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00220b cf9e                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
00220c 93b0 2826                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00220e cf9b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
00220f 93b0 2827                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002211 cf98                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
002212 91b0 2813                 	lds r27, noise_param
002214 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
002215 2bba                      	or r27, r26 //move new VVVV bits into noise_param
002216 93b0 2813                 	sts noise_param, r27
002218 cf91                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002219 93a0 2824                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00221b cf8e                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
00221c 15a2                      	cp r26, zero
00221d f051                      	breq sound_driver_channel3_fx_Gxx_invalid
00221e 91b0 2824                 	lds r27, song_speed
002220 17ab                      	cp r26, r27
002221 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
002222 93a0 2948                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002224 e0b1                      	ldi r27, 0x01
002225 93b0 2918                 	sts noise_pattern_delay_rows, r27
002227 c14a                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
002228 cf81                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
002229 cf80                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
00222a cf7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
00222b cf7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
00222c cf7d                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
00222d 93a0 294a                 	sts noise_fx_Pxx_total, r26
00222f cf7a                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Qxy: //note slide up
002230 cf79                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Rxy: //note slide down
002231 cf78                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
002232 15a2                      	cp r26, zero
002233 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
002234 91b0 2824                 	lds r27, song_speed
002236 17ab                      	cp r26, r27
002237 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
002238 93a0 294b                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00223a e0b1                      	ldi r27, 0x01
00223b 93b0 2918                 	sts noise_pattern_delay_rows, r27
00223d c134                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
00223e cf6b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
00223f 95a6                      	lsr r26
002240 95a7                      	ror r26 //move mode bit to bit 7
002241 91b0 2814                 	lds r27, noise_period
002243 77bf                      	andi r27, 0b01111111
002244 2bba                      	or r27, r26 //store the new noise mode
002245 93b0 2813                 	sts noise_param, r27
                                 
002247 776f                      	andi noise_sequence_HIGH, 0b01111111
002248 2b6a                      	or noise_sequence_HIGH, r26
002249 cf60                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
00224a cf5f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
00224b cf5e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
00224c cf5d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
00224d cf5c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
00224e 93b0 2817                 	sts noise_note, r27
002250 93b0 2818                 	sts noise_adjusted_note, r27
002252 e0a3                      	ldi r26, 0x03
002253 e0b2                      	ldi r27, 0x02
002254 93b0 291e                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002256 93a0 2923                 	sts noise_arpeggio_macro_offset, r26
002258 93b0 292b                 	sts noise_pitch_macro_offset, r27
00225a 93b0 2931                 	sts noise_hi_pitch_macro_offset, r27
00225c 93b0 2936                 	sts noise_duty_macro_offset, r27
00225e 9220 2927                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
002260 9220 2928                 	sts noise_total_pitch_offset+1, zero
002262 9220 292e                 	sts noise_total_hi_pitch_offset, zero
002264 9220 293c                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002266 9220 293e                 	sts noise_fx_2xx_total, zero
002268 9220 2942                 	sts noise_fx_4xy_offset, zero
00226a d0e4                      	rcall sound_driver_channel3_increment_offset
00226b cf3e                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
00226c 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
00226d 91a0 2813                 	lds r26, noise_param
00226f 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
002270 2bab                      	or r26, r27 //move new VVVV bits into noise_param
002271 93a0 2813                 	sts noise_param, r26
002273 d0db                      	rcall sound_driver_channel3_increment_offset
002274 cf35                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
002275 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002276 93b0 2918                 	sts noise_pattern_delay_rows, r27
002278 d0d6                      	rcall sound_driver_channel3_increment_offset
002279 c0e9                      	rjmp sound_driver_channel3_end
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
00227a 9220 291c                 	sts noise_volume_macro, zero //reset all macro addresses
00227c 9220 291d                 	sts noise_volume_macro+1, zero
00227e 9220 2921                 	sts noise_arpeggio_macro, zero
002280 9220 2922                 	sts noise_arpeggio_macro+1, zero
002282 9220 2929                 	sts noise_pitch_macro, zero
002284 9220 292a                 	sts noise_pitch_macro+1, zero
002286 9220 292f                 	sts noise_hi_pitch_macro, zero
002288 9220 2930                 	sts noise_hi_pitch_macro+1, zero
00228a 9220 2934                 	sts noise_duty_macro, zero
00228c 9220 2935                 	sts noise_duty_macro+1, zero
00228e 9220 2927                 	sts noise_total_pitch_offset, zero //reset the pitch offset
002290 9220 2928                 	sts noise_total_pitch_offset+1, zero
002292 9220 292e                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
002294 9631                      	adiw Z, 1 //point to the byte next to the flag
002295 91b4                      	lpm r27, Z //store the instrument offset into r27
002296 ebe1                      	ldi ZL, LOW(instruments) //point Z to instruments table
002297 e1f1                      	ldi ZH, HIGH(instruments)
002298 0feb                      	add ZL, r27 //point Z to offsetted instrument
002299 1df2                      	adc ZH, zero
00229a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00229b 1fff                      	rol ZH
00229c 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00229d 91b4                      	lpm r27, Z
                                 
00229e 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
00229f 1fbb                      	rol r27
0022a0 2fea                      	mov ZL, r26
0022a1 2ffb                      	mov ZH, r27
0022a2 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0022a3 9632                      	adiw Z, 2 //point Z to the address of the macro
0022a4 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
0022a5 95aa                      	dec r26
0022a6 f019                      	breq sound_driver_channel3_instrument_change_exit
0022a7 95b6                      	lsr r27
0022a8 f078                      	brcs sound_driver_channel3_instrument_change_load_macro
0022a9 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
0022aa e0a3                      	ldi r26, 0x03
0022ab e0b2                      	ldi r27, 0x02
0022ac 93b0 291e                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0022ae 93a0 2923                 	sts noise_arpeggio_macro_offset, r26
0022b0 93b0 292b                 	sts noise_pitch_macro_offset, r27
0022b2 93b0 2931                 	sts noise_hi_pitch_macro_offset, r27
0022b4 93b0 2936                 	sts noise_duty_macro_offset, r27
0022b6 d0a2                      	rcall sound_driver_channel3_increment_offset_twice
0022b7 cef2                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
0022b8 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0022b9 91d5                      	lpm r29, Z+
                                 
0022ba 30a5                      	cpi r26, 5
0022bb f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
0022bc 30a4                      	cpi r26, 4
0022bd f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
0022be 30a3                      	cpi r26, 3
0022bf f099                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
0022c0 30a2                      	cpi r26, 2
0022c1 f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
0022c2 c024                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
0022c3 93c0 291c                 	sts noise_volume_macro, r28
0022c5 93d0 291d                 	sts noise_volume_macro+1, r29
0022c7 d029                      	rcall sound_driver_channel3_instrument_change_read_header
0022c8 93c0 2920                 	sts noise_volume_macro_release, r28
0022ca 93d0 291f                 	sts noise_volume_macro_loop, r29
0022cc cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
0022cd 93c0 2921                 	sts noise_arpeggio_macro, r28
0022cf 93d0 2922                 	sts noise_arpeggio_macro+1, r29
0022d1 d02a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
0022d2 cfd2                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
0022d3 93c0 2929                 	sts noise_pitch_macro, r28
0022d5 93d0 292a                 	sts noise_pitch_macro+1, r29
0022d7 d019                      	rcall sound_driver_channel3_instrument_change_read_header
0022d8 93c0 292d                 	sts noise_pitch_macro_release, r28
0022da 93d0 292c                 	sts noise_pitch_macro_loop, r29
0022dc cfc8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
0022dd 93c0 292f                 	sts noise_hi_pitch_macro, r28
0022df 93d0 2930                 	sts noise_hi_pitch_macro+1, r29
0022e1 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
0022e2 93c0 2933                 	sts noise_hi_pitch_macro_release, r28
0022e4 93d0 2932                 	sts noise_hi_pitch_macro_loop, r29
0022e6 cfbe                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
0022e7 93c0 2934                 	sts noise_duty_macro, r28
0022e9 93d0 2935                 	sts noise_duty_macro+1, r29
0022eb d005                      	rcall sound_driver_channel3_instrument_change_read_header
0022ec 93c0 2938                 	sts noise_duty_macro_release, r28
0022ee 93d0 2937                 	sts noise_duty_macro_loop, r29
0022f0 cfb4                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
0022f1 93ef                      	push ZL
0022f2 93ff                      	push ZH
0022f3 2fec                      	mov ZL, r28
0022f4 2ffd                      	mov ZH, r29
0022f5 0fee                      	lsl ZL
0022f6 1fff                      	rol ZH
0022f7 91c5                      	lpm r28, Z+
0022f8 91d4                      	lpm r29, Z
0022f9 91ff                      	pop ZH
0022fa 91ef                      	pop ZL
0022fb 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
0022fc 93ef                      	push ZL
0022fd 93ff                      	push ZH
0022fe 2fec                      	mov ZL, r28
0022ff 2ffd                      	mov ZH, r29
002300 0fee                      	lsl ZL
002301 1fff                      	rol ZH
002302 91c5                      	lpm r28, Z+
002303 91d5                      	lpm r29, Z+
002304 93c0 2925                 	sts noise_arpeggio_macro_release, r28
002306 93d0 2924                 	sts noise_arpeggio_macro_loop, r29
002308 91c4                      	lpm r28, Z
002309 93c0 2926                 	sts noise_arpeggio_macro_mode, r28
00230b 91ff                      	pop ZH
00230c 91ef                      	pop ZL
00230d 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
00230e 91b0 2920                 	lds r27, noise_volume_macro_release
002310 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002311 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
002312 95b3                      	inc r27
002313 93b0 291e                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
002315 91b0 2925                 	lds r27, noise_arpeggio_macro_release
002317 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002318 f019                      	breq sound_driver_channel3_release_pitch
002319 95b3                      	inc r27
00231a 93b0 2923                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
00231c 91b0 292d                 	lds r27, noise_pitch_macro_release
00231e 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00231f f019                      	breq sound_driver_channel3_release_hi_pitch
002320 95b3                      	inc r27
002321 93b0 292b                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
002323 91b0 2933                 	lds r27, noise_hi_pitch_macro_release
002325 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002326 f019                      	breq sound_driver_channel3_release_duty
002327 95b3                      	inc r27
002328 93b0 2931                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
00232a 91b0 2938                 	lds r27, noise_duty_macro_release
00232c 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00232d f019                      	breq sound_driver_channel3_release_exit
00232e 95b3                      	inc r27
00232f 93b0 2936                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
002331 d01d                      	rcall sound_driver_channel3_increment_offset
002332 ce77                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
002333 91e0 2819                 	lds ZL, song_frames
002335 91f0 281a                 	lds ZH, song_frames+1
002337 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002339 91b0 281c                 	lds r27, song_frame_offset+1
00233b 93a0 281b                 	sts song_frame_offset, r26
00233d 93b0 281c                 	sts song_frame_offset+1, r27
00233f 9616                      	adiw r27:r26, 6 //offset for channel 3
002340 0fea                      	add ZL, r26
002341 1ffb                      	adc ZH, r27
                                 
002342 91a5                      	lpm r26, Z+ //load the address of the next pattern
002343 91b4                      	lpm r27, Z
002344 0faa                      	lsl r26
002345 1fbb                      	rol r27
002346 93a0 2916                 	sts noise_pattern, r26
002348 93b0 2917                 	sts noise_pattern+1, r27
                                 
00234a 9220 291a                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00234c 9220 291b                 	sts noise_pattern_offset+1, zero
00234e ce5b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
00234f 91e0 291a                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002351 91f0 291b                 	lds ZH, noise_pattern_offset+1
002353 9631                      	adiw Z, 1
002354 93e0 291a                 	sts noise_pattern_offset, ZL
002356 93f0 291b                 	sts noise_pattern_offset+1, ZH
002358 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002359 91e0 291a                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
00235b 91f0 291b                 	lds ZH, noise_pattern_offset+1
00235d 9632                      	adiw Z, 2 //increment the pointer twice
00235e 93e0 291a                 	sts noise_pattern_offset, ZL
002360 93f0 291b                 	sts noise_pattern_offset+1, ZH
002362 9508                      	ret
                                 
                                 sound_driver_channel3_end:
                                 sound_driver_channel3_check_Sxx_invalid:
002363 efbf                      	ldi r27, 0xFF
002364 91a0 294c                 	lds r26, noise_fx_Sxx_post
002366 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
002367 f419                      	brne sound_driver_channel3_check_Gxx_invalid
002368 93b0 294c                 	sts noise_fx_Sxx_post, r27
00236a 9508                      	ret
                                 sound_driver_channel3_check_Gxx_invalid:
00236b 91a0 2949                 	lds r26, noise_fx_Gxx_post
00236d 15a2                      	cp r26, zero
00236e f419                      	brne sound_driver_channel4
00236f 93b0 2949                 	sts noise_fx_Gxx_post, r27
002371 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel4:
002372 91a0 294f                 	lds r26, dpcm_pattern_delay_rows
002374 91b0 2950                 	lds r27, dpcm_pattern_delay_frames
                                 sound_driver_channel4_decrement_frame_delay:
002376 95ba                      	dec r27
002377 93b0 2950                 	sts dpcm_pattern_delay_frames, r27
                                 
002379 9610                      	adiw r27:r26, 0
00237a f009                      	breq sound_driver_channel4_main //if the pattern delay is 0, proceed with sound driver procedures
00237b c0cc                      	rjmp sound_driver_channel4_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel4_main:
00237c 91e0 294d                 	lds ZL, dpcm_pattern //current pattern for dpcm
00237e 91f0 294e                 	lds ZH, dpcm_pattern+1
002380 91a0 2951                 	lds r26, dpcm_pattern_offset //current offset in the pattern for dpcm
002382 91b0 2952                 	lds r27, dpcm_pattern_offset+1
002384 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
002385 1ffb                      	adc ZH, r27
002386 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel4_check_if_note: //check if data is a note (0x00 - 0x56)
002387 35b7                      	cpi r27, 0x57
002388 f408                      	brsh sound_driver_channel4_check_if_volume
002389 c056                      	rjmp sound_driver_channel4_note
                                 sound_driver_channel4_check_if_volume: //check if data is volume (0x57-0x66)
00238a 36b7                      	cpi r27, 0x67
00238b f408                      	brsh sound_driver_channel4_check_if_delay
00238c c080                      	rjmp sound_driver_channel4_volume
                                 sound_driver_channel4_check_if_delay: //check if data is a delay (0x67 - 0xE2)
00238d 3eb3                      	cpi r27, 0xE3
00238e f408                      	brsh sound_driver_channel4_check_if_instrument
00238f c07f                      	rjmp sound_driver_channel4_delay
                                 sound_driver_channel4_check_if_instrument: //check for instrument flag (0xE3)
002390 f409                      	brne sound_driver_channel4_check_if_release
002391 c082                      	rjmp sound_driver_channel4_instrument_change 
                                 sound_driver_channel4_check_if_release: //check for note release flag (0xE4)
002392 3eb4                      	cpi r27, 0xE4
002393 f409                      	brne sound_driver_channel4_check_if_end
002394 c081                      	rjmp sound_driver_channel4_release
                                 sound_driver_channel4_check_if_end:
002395 3fbf                      	cpi r27, 0xFF
002396 f409                      	brne sound_driver_channel4_check_if_fx
002397 c080                      	rjmp sound_driver_channel4_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel4_check_if_fx: //fx flags (0xE5 - 0xFE)
002398 9631                      	adiw Z, 1 //point Z to the byte next to the flag
002399 91a4                      	lpm r26, Z //load the fx data into r26
00239a d0a3                      	rcall sound_driver_channel4_increment_offset_twice
                                 
00239b 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
00239c ede0                      	ldi ZL, LOW(channel4_fx << 1) //load in note table
00239d e6f3                      	ldi ZH, HIGH(channel4_fx << 1)
00239e 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00239f 0feb                      	add ZL, r27 //add offset
0023a0 1df2                      	adc ZH, zero
0023a1 91c5                      	lpm r28, Z+ //load address bytes
0023a2 91d4                      	lpm r29, Z
0023a3 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0023a4 2ffd                      	mov ZH, r29
0023a5 9409                      	ijmp
                                 
                                 
                                 
                                 sound_driver_channel4_fx_0xy: //arpeggio
0023a6 cfd5                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_1xx: //pitch slide up
0023a7 cfd4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_2xx: //pitch slide down
0023a8 cfd3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_3xx: //automatic portamento
0023a9 cfd2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_4xy: //vibrato
0023aa cfd1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_7xy: //tremelo
0023ab cfd0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Axy: //volume slide
0023ac cfcf                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel4_fx_Bxx:
0023ad 93a0 2825                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0023af cfcc                      	rjmp sound_driver_channel4_main
                                 
                                 //HALT
                                 sound_driver_channel4_fx_Cxx:
0023b0 93b0 2826                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0023b2 cfc9                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel4_fx_Dxx:
0023b3 93b0 2827                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0023b5 cfc6                      	rjmp sound_driver_channel4_main
                                 
                                 sound_driver_channel4_fx_Exx: //volume
0023b6 cfc5                      	rjmp sound_driver_channel4_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel4_fx_Fxx:
0023b7 93a0 2824                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0023b9 cfc2                      	rjmp sound_driver_channel4_main
                                 
                                 //DELAY
                                 sound_driver_channel4_fx_Gxx:
0023ba 15a2                      	cp r26, zero
0023bb f051                      	breq sound_driver_channel4_fx_Gxx_invalid
0023bc 91b0 2824                 	lds r27, song_speed
0023be 17ab                      	cp r26, r27
0023bf f430                      	brsh sound_driver_channel4_fx_Gxx_invalid
0023c0 93a0 2957                 	sts dpcm_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0023c2 e0b1                      	ldi r27, 0x01
0023c3 93b0 294f                 	sts dpcm_pattern_delay_rows, r27
0023c5 c091                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Gxx_invalid:
0023c6 cfb5                      	rjmp sound_driver_channel4_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Hxy: //hardware sweep up
0023c7 cfb4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixy: //hardware sweep down
0023c8 cfb3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Hxx: //FDS modulation depth
0023c9 cfb2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixx: //FDS modulation speed
0023ca cfb1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Pxx: //fine pitch
0023cb cfb0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Qxy: //note slide up
0023cc cfaf                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Rxy: //note slide down
0023cd cfae                      	rjmp sound_driver_channel4_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel4_fx_Sxx:
0023ce 15a2                      	cp r26, zero
0023cf f051                      	breq sound_driver_channel4_fx_Sxx_invalid
0023d0 91b0 2824                 	lds r27, song_speed
0023d2 17ab                      	cp r26, r27
0023d3 f430                      	brsh sound_driver_channel4_fx_Sxx_invalid
0023d4 93a0 2959                 	sts dpcm_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0023d6 e0b1                      	ldi r27, 0x01
0023d7 93b0 294f                 	sts dpcm_pattern_delay_rows, r27
0023d9 c07d                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Sxx_invalid:
0023da cfa1                      	rjmp sound_driver_channel4_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Vxx: //duty
0023db cfa0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Wxx: //DPCM sample speed
0023dc cf9f                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Xxx: //DPCM sample retrigger
0023dd cf9e                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Yxx: //DPCM sample offset
0023de cf9d                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Zxx: //DPCM sample delta counter
0023df cf9c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_note:
0023e0 9631                      	adiw Z, 1 //point to the byte next to the flag
0023e1 90f4                      	lpm dpcm_period, Z //store the DPCM sample rate
0023e2 e4ed                      	ldi ZL, LOW(dpcm_samples) //point Z to dpcm_samples table
0023e3 e1f0                      	ldi ZH, HIGH(dpcm_samples)
0023e4 0feb                      	add ZL, r27 //point Z to offsetted sample
0023e5 1df2                      	adc ZH, zero
0023e6 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the samples's address
0023e7 1fff                      	rol ZH
0023e8 91a5                      	lpm r26, Z+ //r26:r27 now points to the sample
0023e9 91b4                      	lpm r27, Z
                                 
0023ea 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the sample's data
0023eb 1fbb                      	rol r27
0023ec 2fea                      	mov ZL, r26
0023ed 2ffb                      	mov ZH, r27
0023ee 91b4                      	lpm r27, Z //get sample length
0023ef ef70                      	ldi dpcm_length_LOW, 0b11110000
0023f0 e08f                      	ldi dpcm_length_HIGH, 0b00001111
0023f1 95b2                      	swap r27
0023f2 237b                      	and dpcm_length_LOW, r27
0023f3 238b                      	and dpcm_length_HIGH, r27
                                 
0023f4 93e0 2953                 	sts dpcm_sample, ZL //store address to sample
0023f6 93f0 2954                 	sts dpcm_sample+1, ZH
0023f8 9230 2955                 	sts dpcm_sample_offset, one //reset sample offset to 1 (0th byte contains length)
0023fa 9220 2956                 	sts dpcm_sample_offset+1, zero
                                 
0023fc 2ce2                      	mov dpcm_bit_counter, zero
                                 
0023fd e6e2                      	ldi ZL, LOW(dpcm_period_table << 1) //load in dpcm period table
0023fe e0f1                      	ldi ZH, HIGH(dpcm_period_table << 1)
0023ff 0cff                      	lsl dpcm_period //double the offset for the period table because we are getting byte data
002400 0def                      	add ZL, dpcm_period //add offset
002401 1df2                      	adc ZH, zero
002402 91a5                      	lpm r26, Z+ //load bytes
002403 91b4                      	lpm r27, Z
002404 93a0 0a26                 	sts TCA0_SINGLE_PER, r26 //load the LOW bits for timer
002406 93b0 0a27                 	sts TCA0_SINGlE_PER + 1, r27 //load the HIGH bits for timer
002408 e0a3                      	ldi r26, TCA_SINGLE_CLKSEL_DIV2_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 2 and enable timer
002409 93a0 0a00                 	sts TCA0_SINGLE_CTRLA, r26
                                 
00240b d032                      	rcall sound_driver_channel4_increment_offset_twice
00240c cf6f                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_volume:
00240d d026                      	rcall sound_driver_channel4_increment_offset
00240e cf6d                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_delay:
00240f 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002410 93b0 294f                 	sts dpcm_pattern_delay_rows, r27
002412 d021                      	rcall sound_driver_channel4_increment_offset
002413 c034                      	rjmp sound_driver_channel4_end
                                 
                                 
                                 
                                 sound_driver_channel4_instrument_change:
002414 d029                      	rcall sound_driver_channel4_increment_offset_twice
002415 cf66                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_release:
002416 d01d                      	rcall sound_driver_channel4_increment_offset
002417 cf64                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_next_pattern:
002418 91e0 2819                 	lds ZL, song_frames
00241a 91f0 281a                 	lds ZH, song_frames+1
00241c 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00241e 91b0 281c                 	lds r27, song_frame_offset+1
002420 93a0 281b                 	sts song_frame_offset, r26
002422 93b0 281c                 	sts song_frame_offset+1, r27
002424 9618                      	adiw r27:r26, 8 //offset for channel 4
002425 0fea                      	add ZL, r26
002426 1ffb                      	adc ZH, r27
                                 
002427 91a5                      	lpm r26, Z+ //load the address of the next pattern
002428 91b4                      	lpm r27, Z
002429 0faa                      	lsl r26
00242a 1fbb                      	rol r27
00242b 93a0 294d                 	sts dpcm_pattern, r26
00242d 93b0 294e                 	sts dpcm_pattern+1, r27
                                 
00242f 9220 2951                 	sts dpcm_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002431 9220 2952                 	sts dpcm_pattern_offset+1, zero
002433 cf48                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_increment_offset:
002434 91e0 2951                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002436 91f0 2952                 	lds ZH, dpcm_pattern_offset+1
002438 9631                      	adiw Z, 1
002439 93e0 2951                 	sts dpcm_pattern_offset, ZL
00243b 93f0 2952                 	sts dpcm_pattern_offset+1, ZH
00243d 9508                      	ret
                                 
                                 sound_driver_channel4_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00243e 91e0 2951                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002440 91f0 2952                 	lds ZH, dpcm_pattern_offset+1
002442 9632                      	adiw Z, 2 //increment the pointer twice
002443 93e0 2951                 	sts dpcm_pattern_offset, ZL
002445 93f0 2952                 	sts dpcm_pattern_offset+1, ZH
002447 9508                      	ret
                                 
                                 sound_driver_channel4_end:
                                 sound_driver_channel4_check_Sxx_invalid:
002448 efbf                      	ldi r27, 0xFF
002449 91a0 295a                 	lds r26, dpcm_fx_Sxx_post
00244b 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
00244c f419                      	brne sound_driver_channel4_check_Gxx_invalid
00244d 93b0 295a                 	sts dpcm_fx_Sxx_post, r27
00244f 9508                      	ret
                                 sound_driver_channel4_check_Gxx_invalid:
002450 91a0 2958                 	lds r26, dpcm_fx_Gxx_post
002452 15a2                      	cp r26, zero
002453 f419                      	brne sound_driver_calculate_delays
002454 93b0 2958                 	sts dpcm_fx_Gxx_post, r27
002456 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
002457 91f0 2824                 	lds r31, song_speed
                                 
                                 sound_driver_calculate_delays_pulse1:
002459 91a0 282b                 	lds r26, pulse1_pattern_delay_frames
00245b 11a2                      	cpse r26, zero
00245c c044                      	rjmp sound_driver_calculate_delays_pulse2
00245d c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
00245e 2faf                      	mov r26, r31 //move speed into r26
00245f 91b0 282a                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002461 15b2                      	cp r27, zero
002462 f409                      	brne PC+2
002463 c03d                      	rjmp sound_driver_calculate_delays_pulse2
002464 95ba                      	dec r27
002465 93b0 282a                 	sts pulse1_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002467 efbf                      	ldi r27, 0xFF
002468 91c0 2877                 	lds r28, pulse1_fx_Sxx_pre
00246a 91d0 2878                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
00246c 17cb                      	cp r28, r27
00246d f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
00246e c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
00246f 17db                      	cp r29, r27
002470 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
002471 c014                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
002472 91c0 2865                 	lds r28, pulse1_fx_Gxx_pre
002474 91d0 2866                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
002476 17cb                      	cp r28, r27
002477 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
002478 c011                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
002479 17db                      	cp r29, r27
00247a f121                      	breq sound_driver_calculate_delays_pulse1_store
00247b c018                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
00247c 93b0 2877                 	sts pulse1_fx_Sxx_pre, r27
00247e 1bac                      	sub r26, r28 //(song speed)-Sxx
00247f 93a0 2878                 	sts pulse1_fx_Sxx_post, r26
002481 93c0 282b                 	sts pulse1_pattern_delay_frames, r28
002483 11a2                      	cpse r26, zero
002484 c01c                      	rjmp sound_driver_calculate_delays_pulse2
002485 c012                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
002486 93b0 2878                 	sts pulse1_fx_Sxx_post, r27
002488 2fad                      	mov r26, r29
002489 c015                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
00248a 93b0 2865                 	sts pulse1_fx_Gxx_pre, r27
00248c 1bac                      	sub r26, r28 //(song speed)-Gxx
00248d 93a0 2866                 	sts pulse1_fx_Gxx_post, r26
00248f 93c0 282b                 	sts pulse1_pattern_delay_frames, r28
002491 11a2                      	cpse r26, zero
002492 c00e                      	rjmp sound_driver_calculate_delays_pulse2
002493 c004                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
002494 93b0 2866                 	sts pulse1_fx_Gxx_post, r27
002496 2fad                      	mov r26, r29
002497 c007                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid:
002498 9220 282b                 	sts pulse1_pattern_delay_frames, zero
00249a 940e 18e5                 	call sound_driver_channel0_main
00249c 91f0 2824                 	lds r31, song_speed
00249e cfba                      	rjmp sound_driver_calculate_delays_pulse1
                                 
                                 sound_driver_calculate_delays_pulse1_store:
00249f 93a0 282b                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
0024a1 91a0 287c                 	lds r26, pulse2_pattern_delay_frames
0024a3 11a2                      	cpse r26, zero
0024a4 c044                      	rjmp sound_driver_calculate_delays_triangle
0024a5 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
0024a6 2faf                      	mov r26, r31 //move the speed to r26
0024a7 91b0 287b                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
0024a9 15b2                      	cp r27, zero
0024aa f409                      	brne PC+2
0024ab c03d                      	rjmp sound_driver_calculate_delays_triangle
0024ac 95ba                      	dec r27
0024ad 93b0 287b                 	sts pulse2_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
0024af efbf                      	ldi r27, 0xFF
0024b0 91c0 28c8                 	lds r28, pulse2_fx_Sxx_pre
0024b2 91d0 28c9                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
0024b4 17cb                      	cp r28, r27
0024b5 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
0024b6 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
0024b7 17db                      	cp r29, r27
0024b8 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
0024b9 c014                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
0024ba 91c0 28b6                 	lds r28, pulse2_fx_Gxx_pre
0024bc 91d0 28b7                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
0024be 17cb                      	cp r28, r27
0024bf f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
0024c0 c011                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
0024c1 17db                      	cp r29, r27
0024c2 f121                      	breq sound_driver_calculate_delays_pulse2_store
0024c3 c018                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
0024c4 93b0 28c8                 	sts pulse2_fx_Sxx_pre, r27
0024c6 1bac                      	sub r26, r28 //(song speed)-Sxx
0024c7 93a0 28c9                 	sts pulse2_fx_Sxx_post, r26
0024c9 93c0 287c                 	sts pulse2_pattern_delay_frames, r28
0024cb 11a2                      	cpse r26, zero
0024cc c01c                      	rjmp sound_driver_calculate_delays_triangle
0024cd c012                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
0024ce 93b0 28c9                 	sts pulse2_fx_Sxx_post, r27
0024d0 2fad                      	mov r26, r29
0024d1 c015                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
0024d2 93b0 28b6                 	sts pulse2_fx_Gxx_pre, r27
0024d4 1bac                      	sub r26, r28 //(song speed)-1-Gxx
0024d5 93a0 28b7                 	sts pulse2_fx_Gxx_post, r26
0024d7 93c0 287c                 	sts pulse2_pattern_delay_frames, r28
0024d9 11a2                      	cpse r26, zero
0024da c00e                      	rjmp sound_driver_calculate_delays_triangle
0024db c004                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
0024dc 93b0 28b7                 	sts pulse2_fx_Gxx_post, r27
0024de 2fad                      	mov r26, r29
0024df c007                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid:
0024e0 9220 287c                 	sts pulse2_pattern_delay_frames, zero
0024e2 940e 1be2                 	call sound_driver_channel1_main
0024e4 91f0 2824                 	lds r31, song_speed
0024e6 cfba                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_store:
0024e7 93a0 287c                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
0024e9 91a0 28cd                 	lds r26, triangle_pattern_delay_frames
0024eb 11a2                      	cpse r26, zero
0024ec c044                      	rjmp sound_driver_calculate_delays_noise
0024ed c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
0024ee 2faf                      	mov r26, r31 //move the speed to r26
0024ef 91b0 28cc                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
0024f1 15b2                      	cp r27, zero
0024f2 f409                      	brne PC+2
0024f3 c03d                      	rjmp sound_driver_calculate_delays_noise
0024f4 95ba                      	dec r27
0024f5 93b0 28cc                 	sts triangle_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
0024f7 efbf                      	ldi r27, 0xFF
0024f8 91c0 2914                 	lds r28, triangle_fx_Sxx_pre
0024fa 91d0 2915                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
0024fc 17cb                      	cp r28, r27
0024fd f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
0024fe c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
0024ff 17db                      	cp r29, r27
002500 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
002501 c014                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
002502 91c0 2902                 	lds r28, triangle_fx_Gxx_pre
002504 91d0 2903                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
002506 17cb                      	cp r28, r27
002507 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
002508 c011                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
002509 17db                      	cp r29, r27
00250a f121                      	breq sound_driver_calculate_delays_triangle_store
00250b c018                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
00250c 93b0 2914                 	sts triangle_fx_Sxx_pre, r27
00250e 1bac                      	sub r26, r28 //(song speed)-Sxx
00250f 93a0 2915                 	sts triangle_fx_Sxx_post, r26
002511 93c0 28cd                 	sts triangle_pattern_delay_frames, r28
002513 11a2                      	cpse r26, zero
002514 c01c                      	rjmp sound_driver_calculate_delays_noise
002515 c012                      	rjmp sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
002516 93b0 2915                 	sts triangle_fx_Sxx_post, r27
002518 2fad                      	mov r26, r29
002519 c015                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
00251a 93b0 2902                 	sts triangle_fx_Gxx_pre, r27
00251c 1bac                      	sub r26, r28 //(song speed)-Gxx
00251d 93a0 2903                 	sts triangle_fx_Gxx_post, r26
00251f 93c0 28cd                 	sts triangle_pattern_delay_frames, r28
002521 11a2                      	cpse r26, zero
002522 c00e                      	rjmp sound_driver_calculate_delays_noise
002523 c004                      	rjmp sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
002524 93b0 2903                 	sts triangle_fx_Gxx_post, r27
002526 2fad                      	mov r26, r29
002527 c007                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid:
002528 9220 28cd                 	sts triangle_pattern_delay_frames, zero
00252a 940e 1ed2                 	call sound_driver_channel2_main
00252c 91f0 2824                 	lds r31, song_speed
00252e cfba                      	rjmp sound_driver_calculate_delays_triangle
                                 
                                 sound_driver_calculate_delays_triangle_store:
00252f 93a0 28cd                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
002531 91a0 2919                 	lds r26, noise_pattern_delay_frames
002533 11a2                      	cpse r26, zero
002534 c044                      	rjmp sound_driver_calculate_delays_dpcm
002535 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
002536 2faf                      	mov r26, r31 //move the speed to r26
002537 91b0 2918                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
002539 15b2                      	cp r27, zero
00253a f409                      	brne PC+2
00253b c03d                      	rjmp sound_driver_calculate_delays_dpcm
00253c 95ba                      	dec r27
00253d 93b0 2918                 	sts noise_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
00253f efbf                      	ldi r27, 0xFF
002540 91c0 294b                 	lds r28, noise_fx_Sxx_pre
002542 91d0 294c                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
002544 17cb                      	cp r28, r27
002545 f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
002546 c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
002547 17db                      	cp r29, r27
002548 f009                      	breq sound_driver_calculate_delays_noise_Gxx
002549 c014                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
00254a 91c0 2948                 	lds r28, noise_fx_Gxx_pre
00254c 91d0 2949                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
00254e 17cb                      	cp r28, r27
00254f f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002550 c011                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002551 17db                      	cp r29, r27
002552 f121                      	breq sound_driver_calculate_delays_noise_store
002553 c018                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
002554 93b0 294b                 	sts noise_fx_Sxx_pre, r27
002556 1bac                      	sub r26, r28 //(song speed)-Sxx
002557 93a0 294c                 	sts noise_fx_Sxx_post, r26
002559 93c0 2919                 	sts noise_pattern_delay_frames, r28
00255b 11a2                      	cpse r26, zero
00255c c01c                      	rjmp sound_driver_calculate_delays_dpcm
00255d c012                      	rjmp sound_driver_calculate_delays_noise_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
00255e 93b0 294c                 	sts noise_fx_Sxx_post, r27
002560 2fad                      	mov r26, r29
002561 c015                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002562 93b0 2948                 	sts noise_fx_Gxx_pre, r27
002564 1bac                      	sub r26, r28 //(song speed)-Gxx
002565 93a0 2949                 	sts noise_fx_Gxx_post, r26
002567 93c0 2919                 	sts noise_pattern_delay_frames, r28
002569 11a2                      	cpse r26, zero
00256a c00e                      	rjmp sound_driver_calculate_delays_dpcm
00256b c004                      	rjmp sound_driver_calculate_delays_noise_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
00256c 93b0 2949                 	sts noise_fx_Gxx_post, r27
00256e 2fad                      	mov r26, r29
00256f c007                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Sxx_Gxx_invalid:
002570 9220 2919                 	sts noise_pattern_delay_frames, zero
002572 940e 21aa                 	call sound_driver_channel3_main
002574 91f0 2824                 	lds r31, song_speed
002576 cfba                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_noise_store:
002577 93a0 2919                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
002579 91a0 2950                 	lds r26, dpcm_pattern_delay_frames
00257b 11a2                      	cpse r26, zero
00257c c044                      	rjmp sound_driver_instrument_fx_routine
00257d c000                      	rjmp sound_driver_calculate_delays_dpcm_main
                                 
                                 sound_driver_calculate_delays_dpcm_main:
00257e 2faf                      	mov r26, r31 //move the speed to r26
00257f 91b0 294f                 	lds r27, dpcm_pattern_delay_rows //decrement the delay rows
002581 15b2                      	cp r27, zero
002582 f409                      	brne PC+2
002583 c03d                      	rjmp sound_driver_instrument_fx_routine
002584 95ba                      	dec r27
002585 93b0 294f                 	sts dpcm_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx:
002587 efbf                      	ldi r27, 0xFF
002588 91c0 2959                 	lds r28, dpcm_fx_Sxx_pre
00258a 91d0 295a                 	lds r29, dpcm_fx_Sxx_post
                                 sound_driver_calculate_delays_dpcm_Sxx_check_pre:
00258c 17cb                      	cp r28, r27
00258d f009                      	breq sound_driver_calculate_delays_dpcm_Sxx_check_post
00258e c00d                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_pre
                                 sound_driver_calculate_delays_dpcm_Sxx_check_post:
00258f 17db                      	cp r29, r27
002590 f009                      	breq sound_driver_calculate_delays_dpcm_Gxx
002591 c014                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx:
002592 91c0 2957                 	lds r28, dpcm_fx_Gxx_pre
002594 91d0 2958                 	lds r29, dpcm_fx_Gxx_post
                                 sound_driver_calculate_delays_dpcm_Gxx_check_pre:
002596 17cb                      	cp r28, r27
002597 f009                      	breq sound_driver_calculate_delays_dpcm_Gxx_check_post
002598 c011                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_pre
                                 sound_driver_calculate_delays_dpcm_Gxx_check_post:
002599 17db                      	cp r29, r27
00259a f121                      	breq sound_driver_calculate_delays_dpcm_store
00259b c018                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_pre:
00259c 93b0 2959                 	sts dpcm_fx_Sxx_pre, r27
00259e 1bac                      	sub r26, r28 //(song speed)-Sxx
00259f 93a0 295a                 	sts dpcm_fx_Sxx_post, r26
0025a1 93c0 2950                 	sts dpcm_pattern_delay_frames, r28
0025a3 11a2                      	cpse r26, zero
0025a4 c01c                      	rjmp sound_driver_instrument_fx_routine
0025a5 c012                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_post:
0025a6 93b0 295a                 	sts dpcm_fx_Sxx_post, r27
0025a8 2fad                      	mov r26, r29
0025a9 c015                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx_pre:
0025aa 93b0 2957                 	sts dpcm_fx_Gxx_pre, r27
0025ac 1bac                      	sub r26, r28 //(song speed)-Gxx
0025ad 93a0 2958                 	sts dpcm_fx_Gxx_post, r26
0025af 93c0 2950                 	sts dpcm_pattern_delay_frames, r28
0025b1 11a2                      	cpse r26, zero
0025b2 c00e                      	rjmp sound_driver_instrument_fx_routine
0025b3 c004                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_dpcm_Gxx_post:
0025b4 93b0 2958                 	sts dpcm_fx_Gxx_post, r27
0025b6 2fad                      	mov r26, r29
0025b7 c007                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid:
0025b8 9220 2950                 	sts dpcm_pattern_delay_frames, zero
0025ba 940e 237c                 	call sound_driver_channel4_main
0025bc 91f0 2824                 	lds r31, song_speed
0025be cfba                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_dpcm_store:
0025bf 93a0 2950                 	sts dpcm_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
0025c1 91e0 282e                 	lds ZL, pulse1_volume_macro
0025c3 91f0 282f                 	lds ZH, pulse1_volume_macro+1
0025c5 9630                      	adiw Z, 0
0025c6 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0025c7 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0025c8 1fff                      	rol ZH
0025c9 91a0 2830                 	lds r26, pulse1_volume_macro_offset
0025cb 0fea                      	add ZL, r26
0025cc 1df2                      	adc ZH, zero
                                 
0025cd 91b0 2832                 	lds r27, pulse1_volume_macro_release
0025cf 17ba                      	cp r27, r26
0025d0 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0025d1 91a0 2831                 	lds r26, pulse1_volume_macro_loop
0025d3 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025d4 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025d5 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0025d6 95a3                      	inc r26 //increment the macro offset
0025d7 93a0 2830                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0025d9 91b4                      	lpm r27, Z //load volume data into r27
0025da 3fbf                      	cpi r27, 0xFF //check for macro end flag
0025db f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0025dc 91b0 2832                 	lds r27, pulse1_volume_macro_release
0025de 3fbf                      	cpi r27, 0xFF
0025df f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0025e0 91b0 2831                 	lds r27, pulse1_volume_macro_loop //load the loop index
0025e2 93b0 2830                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0025e4 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0025e5 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0025e6 93a0 2830                 	sts pulse1_volume_macro_offset, r26
0025e8 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0025e9 e0e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0025ea e6f4                      	ldi ZH, HIGH(volumes << 1)
0025eb 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0025ec 0feb                      	add ZL, r27 //add offset to the table
0025ed 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0025ee 91b0 2800                 	lds r27, pulse1_param //load main volume
0025f0 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0025f1 91a0 2863                 	lds r26, pulse1_fx_7xy_value
0025f3 30a0                      	cpi r26, 0x00
0025f4 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0025f5 0feb                      	add ZL, r27 //offset the volume table by the main volume
0025f6 1df2                      	adc ZH, zero
0025f7 91b4                      	lpm r27, Z
0025f8 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0025fa c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0025fb 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0025fd 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0025fe 91a0 2863                 	lds r26, pulse1_fx_7xy_value
002600 30a0                      	cpi r26, 0x00
002601 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
002602 93b0 2806                 	sts pulse1_output_volume, r27
002604 c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
002605 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002606 f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
002607 f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
002608 0feb                      	add ZL, r27 //offset the volume table by the main volume
002609 1df2                      	adc ZH, zero
00260a 91b4                      	lpm r27, Z
00260b 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00260d c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
00260e e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00260f 0feb                      	add ZL, r27 //offset the volume table by the main volume
002610 1df2                      	adc ZH, zero
002611 91b4                      	lpm r27, Z
002612 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002614 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
002615 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002616 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002617 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002618 93b0 2806                 	sts pulse1_output_volume, r27
00261a c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
00261b e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00261c 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00261e 91e0 2833                 	lds ZL, pulse1_arpeggio_macro
002620 91f0 2834                 	lds ZH, pulse1_arpeggio_macro+1
002622 9630                      	adiw Z, 0
002623 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002624 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002625 1fff                      	rol ZH
002626 91a0 2835                 	lds r26, pulse1_arpeggio_macro_offset
002628 0fea                      	add ZL, r26
002629 1df2                      	adc ZH, zero
                                 
00262a 91b0 2837                 	lds r27, pulse1_arpeggio_macro_release
00262c 17ba                      	cp r27, r26
00262d f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00262e 91a0 2836                 	lds r26, pulse1_arpeggio_macro_loop
002630 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002631 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002632 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
002633 95a3                      	inc r26 //increment the macro offset
002634 93a0 2835                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
002636 91b4                      	lpm r27, Z //load arpeggio data into r27
002637 38b0                      	cpi r27, 0x80 //check for macro end flag
002638 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002639 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
00263a 50a1                      	subi r26, 1 //keep the offset at the end flag
00263b 93a0 2835                 	sts pulse1_arpeggio_macro_offset, r26
00263d 91b0 2838                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00263f 30b1                      	cpi r27, 0x01
002640 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
002641 91b0 2837                 	lds r27, pulse1_arpeggio_macro_release
002643 3fbf                      	cpi r27, 0xFF
002644 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
002645 91b0 2836                 	lds r27, pulse1_arpeggio_macro_loop
002647 3fbf                      	cpi r27, 0xFF
002648 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002649 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
00264a 91b0 2837                 	lds r27, pulse1_arpeggio_macro_release
00264c 3fbf                      	cpi r27, 0xFF
00264d f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
00264e 91b0 2836                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
002650 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002651 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
002652 91c0 284b                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
002654 91d0 284c                 	lds r29, pulse1_fx_0xy_sequence+1
002656 9620                      	adiw r29:r28, 0
002657 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002658 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002659 93a0 2835                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
00265b cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
00265c 93b0 2835                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
00265e cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
00265f 91c0 284b                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
002661 91d0 284c                 	lds r29, pulse1_fx_0xy_sequence+1
002663 9620                      	adiw r29:r28, 0 //check for 0xy effect
002664 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
002665 95d6                      	lsr r29
002666 95c7                      	ror r28
002667 95d7                      	ror r29
002668 95c7                      	ror r28
002669 95d7                      	ror r29
00266a 95c7                      	ror r28
00266b 95d7                      	ror r29
00266c 95c7                      	ror r28
00266d 95d7                      	ror r29
00266e 95d2                      	swap r29
                                 
00266f 93c0 284b                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
002671 93d0 284c                 	sts pulse1_fx_0xy_sequence+1, r29
002673 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002674 91a0 2807                 	lds r26, pulse1_note //load the current note index
002676 0fac                      	add r26, r28 //add the note offset
002677 c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002678 91a0 2807                 	lds r26, pulse1_note //load the current note index
00267a c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
00267b 9220 2839                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00267d 9220 283a                 	sts pulse1_total_pitch_offset+1, zero
00267f 9220 2840                 	sts pulse1_total_hi_pitch_offset, zero
002681 91a0 2838                 	lds r26, pulse1_arpeggio_macro_mode
002683 30a1                      	cpi r26, 0x01 //absolute mode
002684 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
002685 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
002686 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
002687 91a0 2807                 	lds r26, pulse1_note //load the current note index
002689 0fab                      	add r26, r27 //offset the note with the arpeggio data
00268a fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00268b c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
00268c 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00268d f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
00268e e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00268f c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
002690 fda7                      	sbrc r26, 7 //check if result is negative
002691 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002692 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
002693 2fab                      	mov r26, r27 //move the arpeggio data into r26
002694 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
002695 91a0 2807                 	lds r26, pulse1_note //load the current note index
002697 0fab                      	add r26, r27 //offset the note with the arpeggio data
002698 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002699 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
00269a 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
00269c 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00269d f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
00269e e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00269f 93a0 2807                 	sts pulse1_note, r26
0026a1 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
0026a2 fda7                      	sbrc r26, 7 //check if result is negative
0026a3 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0026a4 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
0026a6 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0026a7 e0f0                      	ldi ZH, HIGH(note_table << 1)
0026a8 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0026a9 0fea                      	add ZL, r26 //add offset
0026aa 1df2                      	adc ZH, zero
0026ab 91a5                      	lpm r26, Z+ //load bytes
0026ac 91b4                      	lpm r27, Z
0026ad 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
0026af 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
0026b1 93a0 2857                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0026b3 93b0 2858                 	sts pulse1_fx_3xx_target+1, r27
0026b5 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
0026b6 91e0 283b                 	lds ZL, pulse1_pitch_macro
0026b8 91f0 283c                 	lds ZH, pulse1_pitch_macro+1
0026ba 9630                      	adiw Z, 0
0026bb f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
0026bc c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
0026bd 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0026be 1fff                      	rol ZH
0026bf 91a0 283d                 	lds r26, pulse1_pitch_macro_offset
0026c1 0fea                      	add ZL, r26
0026c2 1df2                      	adc ZH, zero
                                 
0026c3 91b0 283f                 	lds r27, pulse1_pitch_macro_release
0026c5 17ba                      	cp r27, r26
0026c6 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0026c7 91a0 283e                 	lds r26, pulse1_pitch_macro_loop
0026c9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026ca f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026cb c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0026cc 95a3                      	inc r26 //increment the macro offset
0026cd 93a0 283d                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0026cf 91b4                      	lpm r27, Z //load pitch data into r27
0026d0 38b0                      	cpi r27, 0x80 //check for macro end flag
0026d1 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0026d2 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0026d3 93a0 283d                 	sts pulse1_pitch_macro_offset, r26
0026d5 91b0 283f                 	lds r27, pulse1_pitch_macro_release
0026d7 3fbf                      	cpi r27, 0xFF
0026d8 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0026d9 91b0 283e                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0026db 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0026dc f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0026dd 93b0 283d                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0026df cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0026e0 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0026e1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026e2 937f                      	push r23
0026e3 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0026e4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026e5 0367                      	mulsu r22, r23
0026e6 917f                      	pop r23
0026e7 916f                      	pop r22
                                 
0026e8 9416                      	lsr r1 //shift out the fractional bits
0026e9 9407                      	ror r0
0026ea 9416                      	lsr r1
0026eb 9407                      	ror r0
0026ec 9416                      	lsr r1
0026ed 9407                      	ror r0
0026ee 9416                      	lsr r1
0026ef 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
0026f0 fe13                      	sbrs r1, 3 //check if result was a negative number
0026f1 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0026f2 efc0                      	ldi r28, 0xF0
0026f3 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
0026f4 70b7                      	andi r27, 0b00000111
0026f5 f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
0026f6 e0b1                      	ldi r27, 0x01
0026f7 0e0b                      	add r0, r27
0026f8 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0026f9 91a0 2839                 	lds r26, pulse1_total_pitch_offset
0026fb 91b0 283a                 	lds r27, pulse1_total_pitch_offset+1
0026fd 0e0a                      	add r0, r26
0026fe 1e1b                      	adc r1, r27
0026ff 9200 2839                 	sts pulse1_total_pitch_offset, r0
002701 9210 283a                 	sts pulse1_total_pitch_offset+1, r1
002703 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002705 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002707 0da0                      	add r26, r0 //offset the timer values
002708 1db1                      	adc r27, r1
                                 	
002709 91c0 284f                 	lds r28, pulse1_fx_1xx_total
00270b 91d0 2850                 	lds r29, pulse1_fx_1xx_total+1
00270d 1bac                      	sub r26, r28
00270e 0bbd                      	sbc r27, r29
00270f 91c0 2853                 	lds r28, pulse1_fx_2xx_total
002711 91d0 2854                 	lds r29, pulse1_fx_2xx_total+1
002713 0fac                      	add r26, r28
002714 1fbd                      	adc r27, r29
002715 91c0 2867                 	lds r28, pulse1_fx_Pxx_total
002717 91d0 2868                 	lds r29, pulse1_fx_Pxx_total+1
002719 0fac                      	add r26, r28
00271a 1fbd                      	adc r27, r29
00271b 91c0 286e                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00271d 91d0 286f                 	lds r29, pulse1_fx_Qxy_total_offset+1
00271f 1bac                      	sub r26, r28
002720 0bbd                      	sbc r27, r29
002721 91c0 2875                 	lds r28, pulse1_fx_Rxy_total_offset
002723 91d0 2876                 	lds r29, pulse1_fx_Rxy_total_offset+1
002725 0fac                      	add r26, r28
002726 1fbd                      	adc r27, r29
                                 
002727 e5c9                      	ldi r28, 0x59
002728 e0d0                      	ldi r29, 0x00
002729 17ac                      	cp r26, r28
00272a 07bd                      	cpc r27, r29
00272b f030                      	brlo sound_driver_instrument_routine_channel0_pitch_min
                                 
00272c e5ca                      	ldi r28, 0x5A
00272d e5d9                      	ldi r29, 0x59
00272e 17ac                      	cp r26, r28
00272f 07bd                      	cpc r27, r29
002730 f420                      	brsh sound_driver_instrument_routine_channel0_pitch_max
002731 c006                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_min:
002732 e5c9                      	ldi r28, 0x59
002733 e0d0                      	ldi r29, 0x00
002734 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_max:
002735 e5c9                      	ldi r28, 0x59
002736 e5d9                      	ldi r29, 0x59
002737 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_store:
002738 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00273a 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
00273c 91e0 2841                 	lds ZL, pulse1_hi_pitch_macro
00273e 91f0 2842                 	lds ZH, pulse1_hi_pitch_macro+1
002740 9630                      	adiw Z, 0
002741 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
002742 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
002743 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002744 1fff                      	rol ZH
002745 91a0 2843                 	lds r26, pulse1_hi_pitch_macro_offset
002747 0fea                      	add ZL, r26
002748 1df2                      	adc ZH, zero
                                 
002749 91b0 2845                 	lds r27, pulse1_hi_pitch_macro_release
00274b 17ba                      	cp r27, r26
00274c f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00274d 91a0 2844                 	lds r26, pulse1_hi_pitch_macro_loop
00274f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002750 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002751 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
002752 95a3                      	inc r26 //increment the macro offset
002753 93a0 2843                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
002755 91b4                      	lpm r27, Z //load hi pitch data into r27
002756 38b0                      	cpi r27, 0x80 //check for macro end flag
002757 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
002758 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002759 93a0 2843                 	sts pulse1_hi_pitch_macro_offset, r26
00275b 91b0 2845                 	lds r27, pulse1_hi_pitch_macro_release
00275d 3fbf                      	cpi r27, 0xFF
00275e f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
00275f 91b0 2844                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
002761 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002762 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002763 93b0 2843                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
002765 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
002766 91b0 2840                 	lds r27, pulse1_total_hi_pitch_offset
002768 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
002769 91a0 2840                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
00276b 0fba                      	add r27, r26
00276c 93b0 2840                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
00276e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00276f 937f                      	push r23
002770 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002771 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002772 0367                      	mulsu r22, r23
002773 917f                      	pop r23
002774 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
002775 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002777 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002779 0da0                      	add r26, r0 //offset the timer values
00277a 1db1                      	adc r27, r1
00277b 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00277d 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
00277f 91e0 2846                 	lds ZL, pulse1_duty_macro
002781 91f0 2847                 	lds ZH, pulse1_duty_macro+1
002783 9630                      	adiw Z, 0
002784 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
002785 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002786 1fff                      	rol ZH
002787 91a0 2848                 	lds r26, pulse1_duty_macro_offset
002789 0fea                      	add ZL, r26
00278a 1df2                      	adc ZH, zero
                                 
00278b 91b0 284a                 	lds r27, pulse1_duty_macro_release
00278d 17ba                      	cp r27, r26
00278e f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
00278f 91a0 2849                 	lds r26, pulse1_duty_macro_loop
002791 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002792 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002793 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
002794 95a3                      	inc r26 //increment the macro offset
002795 93a0 2848                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
002797 91b4                      	lpm r27, Z //load pitch data into r27
002798 3fbf                      	cpi r27, 0xFF //check for macro end flag
002799 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
00279a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00279b 93a0 2848                 	sts pulse1_duty_macro_offset, r26
00279d 91b0 284a                 	lds r27, pulse1_duty_macro_release
00279f 3fbf                      	cpi r27, 0xFF
0027a0 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0027a1 91b0 2849                 	lds r27, pulse1_duty_macro_loop //load the loop index
0027a3 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0027a4 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0027a5 93b0 2848                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0027a7 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0027a8 efec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0027a9 e6f2                      	ldi ZH, HIGH(sequences << 1)
0027aa 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0027ab 1df2                      	adc ZH, zero
                                 
0027ac 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0027ad 95b7                      	ror r27
0027ae 95b7                      	ror r27
0027af 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0027b1 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0027b2 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0027b3 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0027b4 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0027b5 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0027b6 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
0027b7 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0027b8 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0027b9 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0027bb 91e0 284d                 	lds ZL, pulse1_fx_1xx
0027bd 91f0 284e                 	lds ZH, pulse1_fx_1xx+1
0027bf 9630                      	adiw Z, 0
0027c0 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0027c1 91a0 284f                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0027c3 91b0 2850                 	lds r27, pulse1_fx_1xx_total+1
0027c5 0fae                      	add r26, ZL //increase the total offset by the rate
0027c6 1fbf                      	adc r27, ZH
0027c7 93a0 284f                 	sts pulse1_fx_1xx_total, r26
0027c9 93b0 2850                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0027cb 91e0 2851                 	lds ZL, pulse1_fx_2xx
0027cd 91f0 2852                 	lds ZH, pulse1_fx_2xx+1
0027cf 9630                      	adiw Z, 0
0027d0 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0027d1 91a0 2853                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0027d3 91b0 2854                 	lds r27, pulse1_fx_2xx_total+1
0027d5 0fae                      	add r26, ZL //increase the total offset by the rate
0027d6 1fbf                      	adc r27, ZH
0027d7 93a0 2853                 	sts pulse1_fx_2xx_total, r26
0027d9 93b0 2854                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0027db 91e0 2859                 	lds ZL, pulse1_fx_3xx_speed
0027dd 91f0 285a                 	lds ZH, pulse1_fx_3xx_speed+1
0027df 9630                      	adiw Z, 0
0027e0 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0027e1 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0027e2 91a0 2855                 	lds r26, pulse1_fx_3xx_start
0027e4 91b0 2856                 	lds r27, pulse1_fx_3xx_start+1
0027e6 9610                      	adiw r26:r27, 0
0027e7 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0027e8 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0027e9 91c0 2857                 	lds r28, pulse1_fx_3xx_target
0027eb 91d0 2858                 	lds r29, pulse1_fx_3xx_target+1
                                 
0027ed 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0027ee 07bd                      	cpc r27, r29
0027ef f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0027f0 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0027f1 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0027f2 9220 2855                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0027f4 9220 2856                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0027f6 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0027f7 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0027f8 0bdb                      	sbc r29, r27
0027f9 91a0 285b                 	lds r26, pulse1_fx_3xx_total_offset
0027fb 91b0 285c                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0027fd 0fae                      	add r26, ZL //add the speed to the total offset
0027fe 1fbf                      	adc r27, ZH
0027ff 1bca                      	sub r28, r26 //invert the total difference with the total offset
002800 0bdb                      	sbc r29, r27
002801 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002802 93a0 285b                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
002804 93b0 285c                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
002806 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
002808 91b0 0a8d                 	lds r27, TCB0_CCMPH
00280a 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00280b 0bbd                      	sbc r27, r29
00280c 93a0 0a8c                 	sts TCB0_CCMPL, r26
00280e 93b0 0a8d                 	sts TCB0_CCMPH, r27
002810 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002811 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002812 0bbd                      	sbc r27, r29
002813 91c0 285b                 	lds r28, pulse1_fx_3xx_total_offset
002815 91d0 285c                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
002817 0fce                      	add r28, ZL //add the speed to the total offset
002818 1fdf                      	adc r29, ZH
002819 1bac                      	sub r26, r28 //invert the total difference with the total offset
00281a 0bbd                      	sbc r27, r29
00281b f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00281c 93c0 285b                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
00281e 93d0 285c                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
002820 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
002822 91d0 0a8d                 	lds r29, TCB0_CCMPH
002824 0fca                      	add r28, r26 //offset the current timer period with the total offset
002825 1fdb                      	adc r29, r27
002826 93c0 0a8c                 	sts TCB0_CCMPL, r28
002828 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
00282a 91a0 285d                 	lds r26, pulse1_fx_4xy_speed
00282c 15a2                      	cp r26, zero
00282d f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
00282e c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00282f 91b0 285e                 	lds r27, pulse1_fx_4xy_depth
002831 91c0 285f                 	lds r28, pulse1_fx_4xy_phase
002833 0fca                      	add r28, r26 //increase the phase by the speed
002834 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002835 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002836 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
002837 93c0 285f                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002839 31c0                      	cpi r28, 16
00283a f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
00283b 32c0                      	cpi r28, 32
00283c f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
00283d 33c0                      	cpi r28, 48
00283e f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
00283f c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
002840 70cf                      	andi r28, 0x0F //mask for values 0-15
002841 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
002842 6fc0                      	ori r28, 0xF0
002843 95c0                      	com r28 //invert values 0-15
002844 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
002845 70cf                      	andi r28, 0x0F //mask for values 0-15
002846 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
002847 6fc0                      	ori r28, 0xF0
002848 95c0                      	com r28 //invert values 0-15
002849 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
00284a 95b2                      	swap r27 //multiply depth by 16
00284b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00284c e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00284d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00284e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00284f 1df2                      	adc ZH, zero
002850 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002851 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002852 937f                      	push r23
002853 2f6c                      	mov r22, r28 //store the vibrato value into r22
002854 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002855 9f67                      	mul r22, r23
002856 917f                      	pop r23
002857 916f                      	pop r22
                                 
002858 9416                      	lsr r1 //shift out the fractional bits
002859 9407                      	ror r0
00285a 9416                      	lsr r1
00285b 9407                      	ror r0
00285c 9416                      	lsr r1
00285d 9407                      	ror r0
00285e 9416                      	lsr r1
00285f 9407                      	ror r0
                                 	
002860 91a0 0a8c                 	lds r26, TCB0_CCMPL
002862 91b0 0a8d                 	lds r27, TCB0_CCMPH
002864 0da0                      	add r26, r0
002865 1db1                      	adc r27, r1
002866 93a0 0a8c                 	sts TCB0_CCMPL, r26
002868 93b0 0a8d                 	sts TCB0_CCMPH, r27
00286a c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
00286b 95b2                      	swap r27 //multiply depth by 16
00286c 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00286d e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00286e e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00286f 0fec                      	add ZL, r28 //offset the table by the depth+phase
002870 1df2                      	adc ZH, zero
002871 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002872 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002873 937f                      	push r23
002874 2f6c                      	mov r22, r28 //store the vibrato value into r22
002875 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002876 9f67                      	mul r22, r23
002877 917f                      	pop r23
002878 916f                      	pop r22
                                 
002879 9416                      	lsr r1 //shift out the fractional bits
00287a 9407                      	ror r0
00287b 9416                      	lsr r1
00287c 9407                      	ror r0
00287d 9416                      	lsr r1
00287e 9407                      	ror r0
00287f 9416                      	lsr r1
002880 9407                      	ror r0
                                 
002881 91a0 0a8c                 	lds r26, TCB0_CCMPL
002883 91b0 0a8d                 	lds r27, TCB0_CCMPH
002885 19a0                      	sub r26, r0
002886 09b1                      	sbc r27, r1
002887 93a0 0a8c                 	sts TCB0_CCMPL, r26
002889 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
00288b 91a0 2860                 	lds r26, pulse1_fx_7xy_speed
00288d 15a2                      	cp r26, zero
00288e f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00288f 91b0 2861                 	lds r27, pulse1_fx_7xy_depth
002891 91c0 2862                 	lds r28, pulse1_fx_7xy_phase
002893 0fca                      	add r28, r26 //increase the phase by the speed
002894 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002895 f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002896 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
002897 93c0 2862                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
002899 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
00289a ffc4                      	sbrs r28, 4
00289b c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
00289c c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
00289d 70cf                      	andi r28, 0x0F //mask for values 0-15
00289e c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
00289f 6fc0                      	ori r28, 0xF0
0028a0 95c0                      	com r28 //invert values 0-15
0028a1 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
0028a2 95b2                      	swap r27 //multiply depth by 16
0028a3 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0028a4 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0028a5 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0028a6 0fec                      	add ZL, r28 //offset the table by the depth+phase
0028a7 1df2                      	adc ZH, zero
0028a8 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0028a9 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0028aa 93c0 2863                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
0028ac 91b0 2864                 	lds r27, pulse1_fx_Axy
0028ae 15b2                      	cp r27, zero
0028af f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0028b0 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0028b2 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0028b4 2fda                      	mov r29, r26 //copy fractional volume into r29
0028b5 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0028b6 95e2                      	swap r30
0028b7 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0028b8 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0028b9 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0028ba f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0028bb 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0028bc fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0028bd c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0028be 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0028bf f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0028c0 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0028c1 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0028c2 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0028c3 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0028c4 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0028c5 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0028c7 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0028c8 95a2                      	swap r26
0028c9 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0028ca 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0028cb 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0028cd 91e0 286a                 	lds ZL, pulse1_fx_Qxy_target
0028cf 91f0 286b                 	lds ZH, pulse1_fx_Qxy_target+1
0028d1 9630                      	adiw Z, 0
0028d2 f129                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0028d3 91a0 286e                 	lds r26, pulse1_fx_Qxy_total_offset
0028d5 91b0 286f                 	lds r27, pulse1_fx_Qxy_total_offset+1
0028d7 91c0 0a8c                 	lds r28, TCB0_CCMPL
0028d9 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0028db 1bec                      	sub ZL, r28 //calculate the difference to the target
0028dc 0bfd                      	sbc ZH, r29
0028dd f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0028de f078                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0028df 9220 286e                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
0028e1 9220 286f                 	sts pulse1_fx_Qxy_total_offset+1, zero
0028e3 9220 286a                 	sts pulse1_fx_Qxy_target, zero
0028e5 9220 286b                 	sts pulse1_fx_Qxy_target+1, zero
0028e7 91b0 2869                 	lds r27, pulse1_fx_Qxy_target_note
0028e9 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
0028eb 93b0 2870                 	sts pulse1_fx_Rxy_target_note, r27
0028ed c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0028ee 91c0 286c                 	lds r28, pulse1_fx_Qxy_speed
0028f0 91d0 286d                 	lds r29, pulse1_fx_Qxy_speed+1
0028f2 0fac                      	add r26, r28 //increase the total offset by the speed
0028f3 1fbd                      	adc r27, r29
0028f4 93a0 286e                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0028f6 93b0 286f                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0028f8 91e0 2871                 	lds ZL, pulse1_fx_Rxy_target
0028fa 91f0 2872                 	lds ZH, pulse1_fx_Rxy_target+1
0028fc 9630                      	adiw Z, 0
0028fd f129                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0028fe 91a0 2875                 	lds r26, pulse1_fx_Rxy_total_offset
002900 91b0 2876                 	lds r27, pulse1_fx_Rxy_total_offset+1
002902 91c0 0a8c                 	lds r28, TCB0_CCMPL
002904 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002906 1bce                      	sub r28, ZL //calculate the difference to the target
002907 0bdf                      	sbc r29, ZH
002908 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
002909 f078                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
00290a 9220 2875                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
00290c 9220 2876                 	sts pulse1_fx_Rxy_total_offset+1, zero
00290e 9220 2871                 	sts pulse1_fx_Rxy_target, zero
002910 9220 2872                 	sts pulse1_fx_Rxy_target+1, zero
002912 91b0 2870                 	lds r27, pulse1_fx_Rxy_target_note
002914 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
002916 93b0 2869                 	sts pulse1_fx_Qxy_target_note, r27
002918 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
002919 91c0 2873                 	lds r28, pulse1_fx_Rxy_speed
00291b 91d0 2874                 	lds r29, pulse1_fx_Rxy_speed+1
00291d 0fac                      	add r26, r28 //increase the total offset by the speed
00291e 1fbd                      	adc r27, r29
00291f 93a0 2875                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002921 93b0 2876                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
002923 91e0 287f                 	lds ZL, pulse2_volume_macro
002925 91f0 2880                 	lds ZH, pulse2_volume_macro+1
002927 9630                      	adiw Z, 0
002928 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
002929 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00292a 1fff                      	rol ZH
00292b 91a0 2881                 	lds r26, pulse2_volume_macro_offset
00292d 0fea                      	add ZL, r26
00292e 1df2                      	adc ZH, zero
                                 
00292f 91b0 2883                 	lds r27, pulse2_volume_macro_release
002931 17ba                      	cp r27, r26
002932 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
002933 91a0 2882                 	lds r26, pulse2_volume_macro_loop
002935 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002936 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002937 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
002938 95a3                      	inc r26 //increment the macro offset
002939 93a0 2881                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
00293b 91b4                      	lpm r27, Z //load volume data into r27
00293c 3fbf                      	cpi r27, 0xFF //check for macro end flag
00293d f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
00293e 91b0 2883                 	lds r27, pulse2_volume_macro_release
002940 3fbf                      	cpi r27, 0xFF
002941 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
002942 91b0 2882                 	lds r27, pulse2_volume_macro_loop //load the loop index
002944 93b0 2881                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
002946 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
002947 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002948 93a0 2881                 	sts pulse2_volume_macro_offset, r26
00294a cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
00294b e0e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
00294c e6f4                      	ldi ZH, HIGH(volumes << 1)
00294d 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
00294e 0feb                      	add ZL, r27 //add offset to the table
00294f 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
002950 91b0 2808                 	lds r27, pulse2_param //load main volume
002952 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002953 91a0 28b4                 	lds r26, pulse2_fx_7xy_value
002955 30a0                      	cpi r26, 0x00
002956 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
002957 0feb                      	add ZL, r27 //offset the volume table by the main volume
002958 1df2                      	adc ZH, zero
002959 91b4                      	lpm r27, Z
00295a 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00295c c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
00295d 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
00295f 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002960 91a0 28b4                 	lds r26, pulse2_fx_7xy_value
002962 30a0                      	cpi r26, 0x00
002963 f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
002964 93b0 280e                 	sts pulse2_output_volume, r27
002966 c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
002967 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002968 f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002969 f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
00296a 0feb                      	add ZL, r27 //offset the volume table by the main volume
00296b 1df2                      	adc ZH, zero
00296c 91b4                      	lpm r27, Z
00296d 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00296f c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
002970 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002971 0feb                      	add ZL, r27 //offset the volume table by the main volume
002972 1df2                      	adc ZH, zero
002973 91b4                      	lpm r27, Z
002974 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002976 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
002977 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002978 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002979 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00297a 93b0 280e                 	sts pulse2_output_volume, r27
00297c c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
00297d e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00297e 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002980 91e0 2884                 	lds ZL, pulse2_arpeggio_macro
002982 91f0 2885                 	lds ZH, pulse2_arpeggio_macro+1
002984 9630                      	adiw Z, 0
002985 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002986 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002987 1fff                      	rol ZH
002988 91a0 2886                 	lds r26, pulse2_arpeggio_macro_offset
00298a 0fea                      	add ZL, r26
00298b 1df2                      	adc ZH, zero
                                 
00298c 91b0 2888                 	lds r27, pulse2_arpeggio_macro_release
00298e 17ba                      	cp r27, r26
00298f f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002990 91a0 2887                 	lds r26, pulse2_arpeggio_macro_loop
002992 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002993 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002994 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
002995 95a3                      	inc r26 //increment the macro offset
002996 93a0 2886                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
002998 91b4                      	lpm r27, Z //load arpeggio data into r27
002999 38b0                      	cpi r27, 0x80 //check for macro end flag
00299a f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
00299b c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
00299c 50a1                      	subi r26, 1 //keep the offset at the end flag
00299d 93a0 2886                 	sts pulse2_arpeggio_macro_offset, r26
00299f 91b0 2889                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0029a1 30b1                      	cpi r27, 0x01
0029a2 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
0029a3 91b0 2888                 	lds r27, pulse2_arpeggio_macro_release
0029a5 3fbf                      	cpi r27, 0xFF
0029a6 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
0029a7 91b0 2887                 	lds r27, pulse2_arpeggio_macro_loop
0029a9 3fbf                      	cpi r27, 0xFF
0029aa f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0029ab c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
0029ac 91b0 2888                 	lds r27, pulse2_arpeggio_macro_release
0029ae 3fbf                      	cpi r27, 0xFF
0029af f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
0029b0 91b0 2887                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
0029b2 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0029b3 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
0029b4 91c0 289c                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
0029b6 91d0 289d                 	lds r29, pulse2_fx_0xy_sequence+1
0029b8 9620                      	adiw r29:r28, 0
0029b9 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0029ba 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0029bb 93a0 2886                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
0029bd cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
0029be 93b0 2886                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
0029c0 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
0029c1 91c0 289c                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
0029c3 91d0 289d                 	lds r29, pulse2_fx_0xy_sequence+1
0029c5 9620                      	adiw r29:r28, 0 //check for 0xy effect
0029c6 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
0029c7 95d6                      	lsr r29
0029c8 95c7                      	ror r28
0029c9 95d7                      	ror r29
0029ca 95c7                      	ror r28
0029cb 95d7                      	ror r29
0029cc 95c7                      	ror r28
0029cd 95d7                      	ror r29
0029ce 95c7                      	ror r28
0029cf 95d7                      	ror r29
0029d0 95d2                      	swap r29
                                 
0029d1 93c0 289c                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
0029d3 93d0 289d                 	sts pulse2_fx_0xy_sequence+1, r29
0029d5 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0029d6 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029d8 0fac                      	add r26, r28 //add the note offset
0029d9 c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0029da 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029dc c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0029dd 9220 288a                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0029df 9220 288b                 	sts pulse2_total_pitch_offset+1, zero
0029e1 9220 2891                 	sts pulse2_total_hi_pitch_offset, zero
0029e3 91a0 2889                 	lds r26, pulse2_arpeggio_macro_mode
0029e5 30a1                      	cpi r26, 0x01 //absolute mode
0029e6 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0029e7 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0029e8 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0029e9 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029eb 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029ec fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029ed c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0029ee 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029ef f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0029f0 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029f1 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0029f2 fda7                      	sbrc r26, 7 //check if result is negative
0029f3 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029f4 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0029f5 2fab                      	mov r26, r27 //move the arpeggio data into r26
0029f6 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0029f7 91a0 280f                 	lds r26, pulse2_note //load the current note index
0029f9 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029fa fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029fb c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0029fc 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0029fe 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029ff f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002a00 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002a01 93a0 280f                 	sts pulse2_note, r26
002a03 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
002a04 fda7                      	sbrc r26, 7 //check if result is negative
002a05 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002a06 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
002a08 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002a09 e0f0                      	ldi ZH, HIGH(note_table << 1)
002a0a 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002a0b 0fea                      	add ZL, r26 //add offset
002a0c 1df2                      	adc ZH, zero
002a0d 91a5                      	lpm r26, Z+ //load bytes
002a0e 91b4                      	lpm r27, Z
002a0f 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
002a11 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
002a13 93a0 28a8                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002a15 93b0 28a9                 	sts pulse2_fx_3xx_target+1, r27
002a17 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
002a18 91e0 288c                 	lds ZL, pulse2_pitch_macro
002a1a 91f0 288d                 	lds ZH, pulse2_pitch_macro+1
002a1c 9630                      	adiw Z, 0
002a1d f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002a1e c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002a1f 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a20 1fff                      	rol ZH
002a21 91a0 288e                 	lds r26, pulse2_pitch_macro_offset
002a23 0fea                      	add ZL, r26
002a24 1df2                      	adc ZH, zero
                                 
002a25 91b0 2890                 	lds r27, pulse2_pitch_macro_release
002a27 17ba                      	cp r27, r26
002a28 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a29 91a0 288f                 	lds r26, pulse2_pitch_macro_loop
002a2b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a2c f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a2d c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002a2e 95a3                      	inc r26 //increment the macro offset
002a2f 93a0 288e                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002a31 91b4                      	lpm r27, Z //load pitch data into r27
002a32 38b0                      	cpi r27, 0x80 //check for macro end flag
002a33 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002a34 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a35 93a0 288e                 	sts pulse2_pitch_macro_offset, r26
002a37 91b0 2890                 	lds r27, pulse2_pitch_macro_release
002a39 3fbf                      	cpi r27, 0xFF
002a3a f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002a3b 91b0 288f                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002a3d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a3e f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002a3f 93b0 288e                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002a41 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002a42 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002a43 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a44 937f                      	push r23
002a45 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002a46 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a47 0367                      	mulsu r22, r23
002a48 917f                      	pop r23
002a49 916f                      	pop r22
                                 
002a4a 9416                      	lsr r1 //shift out the fractional bits
002a4b 9407                      	ror r0
002a4c 9416                      	lsr r1
002a4d 9407                      	ror r0
002a4e 9416                      	lsr r1
002a4f 9407                      	ror r0
002a50 9416                      	lsr r1
002a51 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
002a52 fe13                      	sbrs r1, 3 //check if result was a negative number
002a53 c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002a54 efc0                      	ldi r28, 0xF0
002a55 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
002a56 70b7                      	andi r27, 0b00000111
002a57 f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
002a58 e0b1                      	ldi r27, 0x01
002a59 0e0b                      	add r0, r27
002a5a 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002a5b 91a0 288a                 	lds r26, pulse2_total_pitch_offset
002a5d 91b0 288b                 	lds r27, pulse2_total_pitch_offset+1
002a5f 0e0a                      	add r0, r26
002a60 1e1b                      	adc r1, r27
002a61 9200 288a                 	sts pulse2_total_pitch_offset, r0
002a63 9210 288b                 	sts pulse2_total_pitch_offset+1, r1
002a65 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002a67 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002a69 0da0                      	add r26, r0 //offset the timer values
002a6a 1db1                      	adc r27, r1
                                 	
002a6b 91c0 28a0                 	lds r28, pulse2_fx_1xx_total
002a6d 91d0 28a1                 	lds r29, pulse2_fx_1xx_total+1
002a6f 1bac                      	sub r26, r28
002a70 0bbd                      	sbc r27, r29
002a71 91c0 28a4                 	lds r28, pulse2_fx_2xx_total
002a73 91d0 28a5                 	lds r29, pulse2_fx_2xx_total+1
002a75 0fac                      	add r26, r28
002a76 1fbd                      	adc r27, r29
002a77 91c0 28b8                 	lds r28, pulse2_fx_Pxx_total
002a79 91d0 28b9                 	lds r29, pulse2_fx_Pxx_total+1
002a7b 0fac                      	add r26, r28
002a7c 1fbd                      	adc r27, r29
002a7d 91c0 28bf                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002a7f 91d0 28c0                 	lds r29, pulse2_fx_Qxy_total_offset+1
002a81 1bac                      	sub r26, r28
002a82 0bbd                      	sbc r27, r29
002a83 91c0 28c6                 	lds r28, pulse2_fx_Rxy_total_offset
002a85 91d0 28c7                 	lds r29, pulse2_fx_Rxy_total_offset+1
002a87 0fac                      	add r26, r28
002a88 1fbd                      	adc r27, r29
                                 
002a89 e5c9                      	ldi r28, 0x59
002a8a e0d0                      	ldi r29, 0x00
002a8b 17ac                      	cp r26, r28
002a8c 07bd                      	cpc r27, r29
002a8d f030                      	brlo sound_driver_instrument_routine_channel1_pitch_min
                                 
002a8e e5ca                      	ldi r28, 0x5A
002a8f e5d9                      	ldi r29, 0x59
002a90 17ac                      	cp r26, r28
002a91 07bd                      	cpc r27, r29
002a92 f420                      	brsh sound_driver_instrument_routine_channel1_pitch_max
002a93 c006                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_min:
002a94 e5c9                      	ldi r28, 0x59
002a95 e0d0                      	ldi r29, 0x00
002a96 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_max:
002a97 e5c9                      	ldi r28, 0x59
002a98 e5d9                      	ldi r29, 0x59
002a99 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_store:
002a9a 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a9c 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002a9e 91e0 2892                 	lds ZL, pulse2_hi_pitch_macro
002aa0 91f0 2893                 	lds ZH, pulse2_hi_pitch_macro+1
002aa2 9630                      	adiw Z, 0
002aa3 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002aa4 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002aa5 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002aa6 1fff                      	rol ZH
002aa7 91a0 2894                 	lds r26, pulse2_hi_pitch_macro_offset
002aa9 0fea                      	add ZL, r26
002aaa 1df2                      	adc ZH, zero
                                 
002aab 91b0 2896                 	lds r27, pulse2_hi_pitch_macro_release
002aad 17ba                      	cp r27, r26
002aae f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002aaf 91a0 2895                 	lds r26, pulse2_hi_pitch_macro_loop
002ab1 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ab2 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ab3 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002ab4 95a3                      	inc r26 //increment the macro offset
002ab5 93a0 2894                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002ab7 91b4                      	lpm r27, Z //load hi pitch data into r27
002ab8 38b0                      	cpi r27, 0x80 //check for macro end flag
002ab9 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002aba 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002abb 93a0 2894                 	sts pulse2_hi_pitch_macro_offset, r26
002abd 91b0 2896                 	lds r27, pulse2_hi_pitch_macro_release
002abf 3fbf                      	cpi r27, 0xFF
002ac0 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002ac1 91b0 2895                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002ac3 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002ac4 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002ac5 93b0 2894                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002ac7 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002ac8 91b0 2891                 	lds r27, pulse2_total_hi_pitch_offset
002aca c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002acb 91a0 2891                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002acd 0fba                      	add r27, r26
002ace 93b0 2891                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002ad0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ad1 937f                      	push r23
002ad2 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002ad3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ad4 0367                      	mulsu r22, r23
002ad5 917f                      	pop r23
002ad6 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002ad7 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002ad9 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002adb 0da0                      	add r26, r0 //offset the timer values
002adc 1db1                      	adc r27, r1
002add 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002adf 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002ae1 91e0 2897                 	lds ZL, pulse2_duty_macro
002ae3 91f0 2898                 	lds ZH, pulse2_duty_macro+1
002ae5 9630                      	adiw Z, 0
002ae6 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002ae7 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002ae8 1fff                      	rol ZH
002ae9 91a0 2899                 	lds r26, pulse2_duty_macro_offset
002aeb 0fea                      	add ZL, r26
002aec 1df2                      	adc ZH, zero
                                 
002aed 91b0 289b                 	lds r27, pulse2_duty_macro_release
002aef 17ba                      	cp r27, r26
002af0 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002af1 91a0 289a                 	lds r26, pulse2_duty_macro_loop
002af3 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002af4 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002af5 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002af6 95a3                      	inc r26 //increment the macro offset
002af7 93a0 2899                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002af9 91b4                      	lpm r27, Z //load pitch data into r27
002afa 3fbf                      	cpi r27, 0xFF //check for macro end flag
002afb f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002afc 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002afd 93a0 2899                 	sts pulse2_duty_macro_offset, r26
002aff 91b0 289b                 	lds r27, pulse2_duty_macro_release
002b01 3fbf                      	cpi r27, 0xFF
002b02 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002b03 91b0 289a                 	lds r27, pulse2_duty_macro_loop //load the loop index
002b05 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002b06 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002b07 93b0 2899                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002b09 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002b0a efec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002b0b e6f2                      	ldi ZH, HIGH(sequences << 1)
002b0c 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002b0d 1df2                      	adc ZH, zero
                                 
002b0e 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002b0f 95b7                      	ror r27
002b10 95b7                      	ror r27
002b11 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002b13 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002b14 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002b15 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002b16 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002b17 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002b18 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002b19 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002b1a 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002b1b 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002b1d 91e0 289e                 	lds ZL, pulse2_fx_1xx
002b1f 91f0 289f                 	lds ZH, pulse2_fx_1xx+1
002b21 9630                      	adiw Z, 0
002b22 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002b23 91a0 28a0                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002b25 91b0 28a1                 	lds r27, pulse2_fx_1xx_total+1
002b27 0fae                      	add r26, ZL //increase the total offset by the rate
002b28 1fbf                      	adc r27, ZH
002b29 93a0 28a0                 	sts pulse2_fx_1xx_total, r26
002b2b 93b0 28a1                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002b2d 91e0 28a2                 	lds ZL, pulse2_fx_2xx
002b2f 91f0 28a3                 	lds ZH, pulse2_fx_2xx+1
002b31 9630                      	adiw Z, 0
002b32 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002b33 91a0 28a4                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002b35 91b0 28a5                 	lds r27, pulse2_fx_2xx_total+1
002b37 0fae                      	add r26, ZL //increase the total offset by the rate
002b38 1fbf                      	adc r27, ZH
002b39 93a0 28a4                 	sts pulse2_fx_2xx_total, r26
002b3b 93b0 28a5                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002b3d 91e0 28aa                 	lds ZL, pulse2_fx_3xx_speed
002b3f 91f0 28ab                 	lds ZH, pulse2_fx_3xx_speed+1
002b41 9630                      	adiw Z, 0
002b42 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002b43 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002b44 91a0 28a6                 	lds r26, pulse2_fx_3xx_start
002b46 91b0 28a7                 	lds r27, pulse2_fx_3xx_start+1
002b48 9610                      	adiw r26:r27, 0
002b49 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002b4a c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002b4b 91c0 28a8                 	lds r28, pulse2_fx_3xx_target
002b4d 91d0 28a9                 	lds r29, pulse2_fx_3xx_target+1
                                 
002b4f 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002b50 07bd                      	cpc r27, r29
002b51 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002b52 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002b53 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002b54 9220 28a6                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002b56 9220 28a7                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002b58 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002b59 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002b5a 0bdb                      	sbc r29, r27
002b5b 91a0 28ac                 	lds r26, pulse2_fx_3xx_total_offset
002b5d 91b0 28ad                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002b5f 0fae                      	add r26, ZL //add the speed to the total offset
002b60 1fbf                      	adc r27, ZH
002b61 1bca                      	sub r28, r26 //invert the total difference with the total offset
002b62 0bdb                      	sbc r29, r27
002b63 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b64 93a0 28ac                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002b66 93b0 28ad                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002b68 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002b6a 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b6c 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002b6d 0bbd                      	sbc r27, r29
002b6e 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b70 93b0 0a9d                 	sts TCB1_CCMPH, r27
002b72 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002b73 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002b74 0bbd                      	sbc r27, r29
002b75 91c0 28ac                 	lds r28, pulse2_fx_3xx_total_offset
002b77 91d0 28ad                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002b79 0fce                      	add r28, ZL //add the speed to the total offset
002b7a 1fdf                      	adc r29, ZH
002b7b 1bac                      	sub r26, r28 //invert the total difference with the total offset
002b7c 0bbd                      	sbc r27, r29
002b7d f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b7e 93c0 28ac                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002b80 93d0 28ad                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002b82 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002b84 91d0 0a9d                 	lds r29, TCB1_CCMPH
002b86 0fca                      	add r28, r26 //offset the current timer period with the total offset
002b87 1fdb                      	adc r29, r27
002b88 93c0 0a9c                 	sts TCB1_CCMPL, r28
002b8a 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002b8c 91a0 28ae                 	lds r26, pulse2_fx_4xy_speed
002b8e 15a2                      	cp r26, zero
002b8f f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002b90 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002b91 91b0 28af                 	lds r27, pulse2_fx_4xy_depth
002b93 91c0 28b0                 	lds r28, pulse2_fx_4xy_phase
002b95 0fca                      	add r28, r26 //increase the phase by the speed
002b96 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002b97 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002b98 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002b99 93c0 28b0                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002b9b 31c0                      	cpi r28, 16
002b9c f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002b9d 32c0                      	cpi r28, 32
002b9e f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002b9f 33c0                      	cpi r28, 48
002ba0 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002ba1 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002ba2 70cf                      	andi r28, 0x0F //mask for values 0-15
002ba3 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002ba4 6fc0                      	ori r28, 0xF0
002ba5 95c0                      	com r28 //invert values 0-15
002ba6 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002ba7 70cf                      	andi r28, 0x0F //mask for values 0-15
002ba8 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002ba9 6fc0                      	ori r28, 0xF0
002baa 95c0                      	com r28 //invert values 0-15
002bab c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002bac 95b2                      	swap r27 //multiply depth by 16
002bad 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002bae e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002baf e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002bb0 0fec                      	add ZL, r28 //offset the table by the depth+phase
002bb1 1df2                      	adc ZH, zero
002bb2 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002bb3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002bb4 937f                      	push r23
002bb5 2f6c                      	mov r22, r28 //store the vibrato value into r22
002bb6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002bb7 9f67                      	mul r22, r23
002bb8 917f                      	pop r23
002bb9 916f                      	pop r22
                                 
002bba 9416                      	lsr r1 //shift out the fractional bits
002bbb 9407                      	ror r0
002bbc 9416                      	lsr r1
002bbd 9407                      	ror r0
002bbe 9416                      	lsr r1
002bbf 9407                      	ror r0
002bc0 9416                      	lsr r1
002bc1 9407                      	ror r0
                                 	
002bc2 91a0 0a9c                 	lds r26, TCB1_CCMPL
002bc4 91b0 0a9d                 	lds r27, TCB1_CCMPH
002bc6 0da0                      	add r26, r0
002bc7 1db1                      	adc r27, r1
002bc8 93a0 0a9c                 	sts TCB1_CCMPL, r26
002bca 93b0 0a9d                 	sts TCB1_CCMPH, r27
002bcc c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002bcd 95b2                      	swap r27 //multiply depth by 16
002bce 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002bcf e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002bd0 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002bd1 0fec                      	add ZL, r28 //offset the table by the depth+phase
002bd2 1df2                      	adc ZH, zero
002bd3 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002bd4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002bd5 937f                      	push r23
002bd6 2f6c                      	mov r22, r28 //store the vibrato value into r22
002bd7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002bd8 9f67                      	mul r22, r23
002bd9 917f                      	pop r23
002bda 916f                      	pop r22
                                 
002bdb 9416                      	lsr r1 //shift out the fractional bits
002bdc 9407                      	ror r0
002bdd 9416                      	lsr r1
002bde 9407                      	ror r0
002bdf 9416                      	lsr r1
002be0 9407                      	ror r0
002be1 9416                      	lsr r1
002be2 9407                      	ror r0
                                 
002be3 91a0 0a9c                 	lds r26, TCB1_CCMPL
002be5 91b0 0a9d                 	lds r27, TCB1_CCMPH
002be7 19a0                      	sub r26, r0
002be8 09b1                      	sbc r27, r1
002be9 93a0 0a9c                 	sts TCB1_CCMPL, r26
002beb 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002bed 91a0 28b1                 	lds r26, pulse2_fx_7xy_speed
002bef 15a2                      	cp r26, zero
002bf0 f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002bf1 91b0 28b2                 	lds r27, pulse2_fx_7xy_depth
002bf3 91c0 28b3                 	lds r28, pulse2_fx_7xy_phase
002bf5 0fca                      	add r28, r26 //increase the phase by the speed
002bf6 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002bf7 f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002bf8 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002bf9 93c0 28b3                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002bfb 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002bfc ffc4                      	sbrs r28, 4
002bfd c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002bfe c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002bff 70cf                      	andi r28, 0x0F //mask for values 0-15
002c00 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002c01 6fc0                      	ori r28, 0xF0
002c02 95c0                      	com r28 //invert values 0-15
002c03 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002c04 95b2                      	swap r27 //multiply depth by 16
002c05 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002c06 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002c07 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002c08 0fec                      	add ZL, r28 //offset the table by the depth+phase
002c09 1df2                      	adc ZH, zero
002c0a 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002c0b 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002c0c 93c0 28b4                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002c0e 91b0 28b5                 	lds r27, pulse2_fx_Axy
002c10 15b2                      	cp r27, zero
002c11 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002c12 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002c14 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002c16 2fda                      	mov r29, r26 //copy fractional volume into r29
002c17 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002c18 95e2                      	swap r30
002c19 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002c1a 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002c1b 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002c1c f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002c1d 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002c1e fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002c1f c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002c20 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002c21 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002c22 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002c23 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002c24 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002c25 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002c26 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002c27 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002c29 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002c2a 95a2                      	swap r26
002c2b 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002c2c 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002c2d 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002c2f 91e0 28bb                 	lds ZL, pulse2_fx_Qxy_target
002c31 91f0 28bc                 	lds ZH, pulse2_fx_Qxy_target+1
002c33 9630                      	adiw Z, 0
002c34 f129                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002c35 91a0 28bf                 	lds r26, pulse2_fx_Qxy_total_offset
002c37 91b0 28c0                 	lds r27, pulse2_fx_Qxy_total_offset+1
002c39 91c0 0a9c                 	lds r28, TCB1_CCMPL
002c3b 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002c3d 1bec                      	sub ZL, r28 //calculate the difference to the target
002c3e 0bfd                      	sbc ZH, r29
002c3f f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002c40 f078                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002c41 9220 28bf                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
002c43 9220 28c0                 	sts pulse2_fx_Qxy_total_offset+1, zero
002c45 9220 28bb                 	sts pulse2_fx_Qxy_target, zero
002c47 9220 28bc                 	sts pulse2_fx_Qxy_target+1, zero
002c49 91b0 28ba                 	lds r27, pulse2_fx_Qxy_target_note
002c4b 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002c4d 93b0 28c1                 	sts pulse2_fx_Rxy_target_note, r27
002c4f c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002c50 91c0 28bd                 	lds r28, pulse2_fx_Qxy_speed
002c52 91d0 28be                 	lds r29, pulse2_fx_Qxy_speed+1
002c54 0fac                      	add r26, r28 //increase the total offset by the speed
002c55 1fbd                      	adc r27, r29
002c56 93a0 28bf                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002c58 93b0 28c0                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002c5a 91e0 28c2                 	lds ZL, pulse2_fx_Rxy_target
002c5c 91f0 28c3                 	lds ZH, pulse2_fx_Rxy_target+1
002c5e 9630                      	adiw Z, 0
002c5f f129                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002c60 91a0 28c6                 	lds r26, pulse2_fx_Rxy_total_offset
002c62 91b0 28c7                 	lds r27, pulse2_fx_Rxy_total_offset+1
002c64 91c0 0a9c                 	lds r28, TCB1_CCMPL
002c66 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002c68 1bce                      	sub r28, ZL //calculate the difference to the target
002c69 0bdf                      	sbc r29, ZH
002c6a f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002c6b f078                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002c6c 9220 28c6                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
002c6e 9220 28c7                 	sts pulse2_fx_Rxy_total_offset+1, zero
002c70 9220 28c2                 	sts pulse2_fx_Rxy_target, zero
002c72 9220 28c3                 	sts pulse2_fx_Rxy_target+1, zero
002c74 91b0 28c1                 	lds r27, pulse2_fx_Rxy_target_note
002c76 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002c78 93b0 28ba                 	sts pulse2_fx_Qxy_target_note, r27
002c7a c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002c7b 91c0 28c4                 	lds r28, pulse2_fx_Rxy_speed
002c7d 91d0 28c5                 	lds r29, pulse2_fx_Rxy_speed+1
002c7f 0fac                      	add r26, r28 //increase the total offset by the speed
002c80 1fbd                      	adc r27, r29
002c81 93a0 28c6                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002c83 93b0 28c7                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002c85 91e0 28d0                 	lds ZL, triangle_volume_macro
002c87 91f0 28d1                 	lds ZH, triangle_volume_macro+1
002c89 9630                      	adiw Z, 0
002c8a f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002c8b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c8c 1fff                      	rol ZH
002c8d 91a0 28d2                 	lds r26, triangle_volume_macro_offset
002c8f 0fea                      	add ZL, r26
002c90 1df2                      	adc ZH, zero
                                 
002c91 91b0 28d4                 	lds r27, triangle_volume_macro_release
002c93 17ba                      	cp r27, r26
002c94 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002c95 91a0 28d3                 	lds r26, triangle_volume_macro_loop
002c97 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c98 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c99 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002c9a 95a3                      	inc r26 //increment the macro offset
002c9b 93a0 28d2                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002c9d 91b4                      	lpm r27, Z //load volume data into r27
002c9e 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c9f f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002ca0 91b0 28d4                 	lds r27, triangle_volume_macro_release
002ca2 3fbf                      	cpi r27, 0xFF
002ca3 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002ca4 91b0 28d3                 	lds r27, triangle_volume_macro_loop //load the loop index
002ca6 93b0 28d2                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002ca8 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002ca9 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002caa 93a0 28d2                 	sts triangle_volume_macro_offset, r26
002cac cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002cad 15b2                      	cp r27, zero
002cae f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002caf 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002cb1 30b1                      	cpi r27, TCB_CAPT_bm
002cb2 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002cb3 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002cb4 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002cb6 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002cb7 9220 0aa5                 	sts TCB2_INTCTRL, zero
002cb9 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002cbb 9220 0aad                 	sts TCB2_CCMPH, zero
002cbd c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002cbe 91e0 28d5                 	lds ZL, triangle_arpeggio_macro
002cc0 91f0 28d6                 	lds ZH, triangle_arpeggio_macro+1
002cc2 9630                      	adiw Z, 0
002cc3 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002cc4 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002cc5 1fff                      	rol ZH
002cc6 91a0 28d7                 	lds r26, triangle_arpeggio_macro_offset
002cc8 0fea                      	add ZL, r26
002cc9 1df2                      	adc ZH, zero
                                 
002cca 91b0 28d9                 	lds r27, triangle_arpeggio_macro_release
002ccc 17ba                      	cp r27, r26
002ccd f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002cce 91a0 28d8                 	lds r26, triangle_arpeggio_macro_loop
002cd0 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002cd1 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002cd2 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002cd3 95a3                      	inc r26 //increment the macro offset
002cd4 93a0 28d7                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002cd6 91b4                      	lpm r27, Z //load arpeggio data into r27
002cd7 38b0                      	cpi r27, 0x80 //check for macro end flag
002cd8 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002cd9 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002cda 50a1                      	subi r26, 1 //keep the offset at the end flag
002cdb 93a0 28d7                 	sts triangle_arpeggio_macro_offset, r26
002cdd 91b0 28da                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002cdf 30b1                      	cpi r27, 0x01
002ce0 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002ce1 91b0 28d9                 	lds r27, triangle_arpeggio_macro_release
002ce3 3fbf                      	cpi r27, 0xFF
002ce4 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002ce5 91b0 28d8                 	lds r27, triangle_arpeggio_macro_loop
002ce7 3fbf                      	cpi r27, 0xFF
002ce8 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002ce9 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002cea 91b0 28d9                 	lds r27, triangle_arpeggio_macro_release
002cec 3fbf                      	cpi r27, 0xFF
002ced f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002cee 91b0 28d8                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002cf0 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002cf1 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002cf2 91c0 28ed                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002cf4 91d0 28ee                 	lds r29, triangle_fx_0xy_sequence+1
002cf6 9620                      	adiw r29:r28, 0
002cf7 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002cf8 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002cf9 93a0 28d7                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002cfb cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002cfc 93b0 28d7                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002cfe cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002cff 91c0 28ed                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002d01 91d0 28ee                 	lds r29, triangle_fx_0xy_sequence+1
002d03 9620                      	adiw r29:r28, 0 //check for 0xy effect
002d04 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
002d05 95d6                      	lsr r29
002d06 95c7                      	ror r28
002d07 95d7                      	ror r29
002d08 95c7                      	ror r28
002d09 95d7                      	ror r29
002d0a 95c7                      	ror r28
002d0b 95d7                      	ror r29
002d0c 95c7                      	ror r28
002d0d 95d7                      	ror r29
002d0e 95d2                      	swap r29
                                 
002d0f 93c0 28ed                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002d11 93d0 28ee                 	sts triangle_fx_0xy_sequence+1, r29
002d13 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002d14 91a0 2812                 	lds r26, triangle_note //load the current note index
002d16 0fac                      	add r26, r28 //add the note offset
002d17 c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002d18 91a0 2812                 	lds r26, triangle_note //load the current note index
002d1a c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002d1b 9220 28db                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002d1d 9220 28dc                 	sts triangle_total_pitch_offset+1, zero
002d1f 9220 28e2                 	sts triangle_total_hi_pitch_offset, zero
002d21 91a0 28da                 	lds r26, triangle_arpeggio_macro_mode
002d23 30a1                      	cpi r26, 0x01 //absolute mode
002d24 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002d25 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002d26 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002d27 91a0 2812                 	lds r26, triangle_note //load the current note index
002d29 0fab                      	add r26, r27 //offset the note with the arpeggio data
002d2a fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002d2b c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002d2c 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002d2d f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002d2e e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002d2f c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002d30 fda7                      	sbrc r26, 7 //check if result is negative
002d31 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002d32 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002d33 2fab                      	mov r26, r27 //move the arpeggio data into r26
002d34 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002d35 91a0 2812                 	lds r26, triangle_note //load the current note index
002d37 0fab                      	add r26, r27 //offset the note with the arpeggio data
002d38 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002d39 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002d3a 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002d3c 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002d3d f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002d3e e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002d3f 93a0 2812                 	sts triangle_note, r26
002d41 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002d42 fda7                      	sbrc r26, 7 //check if result is negative
002d43 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002d44 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002d46 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002d47 e0f0                      	ldi ZH, HIGH(note_table << 1)
002d48 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002d49 0fea                      	add ZL, r26 //add offset
002d4a 1df2                      	adc ZH, zero
002d4b 91a5                      	lpm r26, Z+ //load bytes
002d4c 91b4                      	lpm r27, Z
002d4d 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002d4f 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002d51 93a0 28f9                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002d53 93b0 28fa                 	sts triangle_fx_3xx_target+1, r27
002d55 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002d56 91e0 28dd                 	lds ZL, triangle_pitch_macro
002d58 91f0 28de                 	lds ZH, triangle_pitch_macro+1
002d5a 9630                      	adiw Z, 0
002d5b f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002d5c c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002d5d 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d5e 1fff                      	rol ZH
002d5f 91a0 28df                 	lds r26, triangle_pitch_macro_offset
002d61 0fea                      	add ZL, r26
002d62 1df2                      	adc ZH, zero
                                 
002d63 91b0 28e1                 	lds r27, triangle_pitch_macro_release
002d65 17ba                      	cp r27, r26
002d66 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d67 91a0 28e0                 	lds r26, triangle_pitch_macro_loop
002d69 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d6a f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d6b c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002d6c 95a3                      	inc r26 //increment the macro offset
002d6d 93a0 28df                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002d6f 91b4                      	lpm r27, Z //load pitch data into r27
002d70 38b0                      	cpi r27, 0x80 //check for macro end flag
002d71 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002d72 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d73 93a0 28df                 	sts triangle_pitch_macro_offset, r26
002d75 91b0 28e1                 	lds r27, triangle_pitch_macro_release
002d77 3fbf                      	cpi r27, 0xFF
002d78 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002d79 91b0 28e0                 	lds r27, triangle_pitch_macro_loop //load the loop index
002d7b 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d7c f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002d7d 93b0 28df                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002d7f cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002d80 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002d81 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d82 937f                      	push r23
002d83 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002d84 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d85 0367                      	mulsu r22, r23
002d86 917f                      	pop r23
002d87 916f                      	pop r22
                                 
002d88 9416                      	lsr r1 //shift out the fractional bits
002d89 9407                      	ror r0
002d8a 9416                      	lsr r1
002d8b 9407                      	ror r0
002d8c 9416                      	lsr r1
002d8d 9407                      	ror r0
002d8e 9416                      	lsr r1
002d8f 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
002d90 fe13                      	sbrs r1, 3 //check if result was a negative number
002d91 c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002d92 efc0                      	ldi r28, 0xF0
002d93 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
002d94 70b7                      	andi r27, 0b00000111
002d95 f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
002d96 e0b1                      	ldi r27, 0x01
002d97 0e0b                      	add r0, r27
002d98 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002d99 91a0 28db                 	lds r26, triangle_total_pitch_offset
002d9b 91b0 28dc                 	lds r27, triangle_total_pitch_offset+1
002d9d 0e0a                      	add r0, r26
002d9e 1e1b                      	adc r1, r27
002d9f 9200 28db                 	sts triangle_total_pitch_offset, r0
002da1 9210 28dc                 	sts triangle_total_pitch_offset+1, r1
002da3 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002da5 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002da7 0da0                      	add r26, r0 //offset the timer values
002da8 1db1                      	adc r27, r1
                                 	
002da9 91c0 28f1                 	lds r28, triangle_fx_1xx_total
002dab 91d0 28f2                 	lds r29, triangle_fx_1xx_total+1
002dad 1bac                      	sub r26, r28
002dae 0bbd                      	sbc r27, r29
002daf 91c0 28f5                 	lds r28, triangle_fx_2xx_total
002db1 91d0 28f6                 	lds r29, triangle_fx_2xx_total+1
002db3 0fac                      	add r26, r28
002db4 1fbd                      	adc r27, r29
002db5 91c0 2904                 	lds r28, triangle_fx_Pxx_total
002db7 91d0 2905                 	lds r29, triangle_fx_Pxx_total+1
002db9 0fac                      	add r26, r28
002dba 1fbd                      	adc r27, r29
002dbb 91c0 290b                 	lds r28, triangle_fx_Qxy_total_offset
002dbd 91d0 290c                 	lds r29, triangle_fx_Qxy_total_offset+1
002dbf 1bac                      	sub r26, r28
002dc0 0bbd                      	sbc r27, r29
002dc1 91c0 2912                 	lds r28, triangle_fx_Rxy_total_offset
002dc3 91d0 2913                 	lds r29, triangle_fx_Rxy_total_offset+1
002dc5 0fac                      	add r26, r28
002dc6 1fbd                      	adc r27, r29
                                 
002dc7 e5c9                      	ldi r28, 0x59
002dc8 e0d0                      	ldi r29, 0x00
002dc9 17ac                      	cp r26, r28
002dca 07bd                      	cpc r27, r29
002dcb f030                      	brlo sound_driver_instrument_routine_channel2_pitch_min
                                 
002dcc e5ca                      	ldi r28, 0x5A
002dcd e5d9                      	ldi r29, 0x59
002dce 17ac                      	cp r26, r28
002dcf 07bd                      	cpc r27, r29
002dd0 f420                      	brsh sound_driver_instrument_routine_channel2_pitch_max
002dd1 c006                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_min:
002dd2 e5c9                      	ldi r28, 0x59
002dd3 e0d0                      	ldi r29, 0x00
002dd4 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_max:
002dd5 e5c9                      	ldi r28, 0x59
002dd6 e5d9                      	ldi r29, 0x59
002dd7 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_store:
002dd8 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002dda 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002ddc 91e0 28e3                 	lds ZL, triangle_hi_pitch_macro
002dde 91f0 28e4                 	lds ZH, triangle_hi_pitch_macro+1
002de0 9630                      	adiw Z, 0
002de1 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002de2 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002de3 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002de4 1fff                      	rol ZH
002de5 91a0 28e5                 	lds r26, triangle_hi_pitch_macro_offset
002de7 0fea                      	add ZL, r26
002de8 1df2                      	adc ZH, zero
                                 
002de9 91b0 28e7                 	lds r27, triangle_hi_pitch_macro_release
002deb 17ba                      	cp r27, r26
002dec f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002ded 91a0 28e6                 	lds r26, triangle_hi_pitch_macro_loop
002def 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002df0 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002df1 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002df2 95a3                      	inc r26 //increment the macro offset
002df3 93a0 28e5                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002df5 91b4                      	lpm r27, Z //load hi pitch data into r27
002df6 38b0                      	cpi r27, 0x80 //check for macro end flag
002df7 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002df8 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002df9 93a0 28e5                 	sts triangle_hi_pitch_macro_offset, r26
002dfb 91b0 28e7                 	lds r27, triangle_hi_pitch_macro_release
002dfd 3fbf                      	cpi r27, 0xFF
002dfe f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002dff 91b0 28e6                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002e01 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002e02 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002e03 93b0 28e5                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002e05 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002e06 91b0 28e2                 	lds r27, triangle_total_hi_pitch_offset
002e08 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002e09 91a0 28e2                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002e0b 0fba                      	add r27, r26
002e0c 93b0 28e2                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002e0e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e0f 937f                      	push r23
002e10 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002e11 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e12 0367                      	mulsu r22, r23
002e13 917f                      	pop r23
002e14 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002e15 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002e17 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002e19 0da0                      	add r26, r0 //offset the timer values
002e1a 1db1                      	adc r27, r1
002e1b 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002e1d 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002e1f 91e0 28ef                 	lds ZL, triangle_fx_1xx
002e21 91f0 28f0                 	lds ZH, triangle_fx_1xx+1
002e23 9630                      	adiw Z, 0
002e24 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002e25 91a0 28f1                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002e27 91b0 28f2                 	lds r27, triangle_fx_1xx_total+1
002e29 0fae                      	add r26, ZL //increase the total offset by the rate
002e2a 1fbf                      	adc r27, ZH
002e2b 93a0 28f1                 	sts triangle_fx_1xx_total, r26
002e2d 93b0 28f2                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002e2f 91e0 28f3                 	lds ZL, triangle_fx_2xx
002e31 91f0 28f4                 	lds ZH, triangle_fx_2xx+1
002e33 9630                      	adiw Z, 0
002e34 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002e35 91a0 28f5                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002e37 91b0 28f6                 	lds r27, triangle_fx_2xx_total+1
002e39 0fae                      	add r26, ZL //increase the total offset by the rate
002e3a 1fbf                      	adc r27, ZH
002e3b 93a0 28f5                 	sts triangle_fx_2xx_total, r26
002e3d 93b0 28f6                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002e3f 91e0 28fb                 	lds ZL, triangle_fx_3xx_speed
002e41 91f0 28fc                 	lds ZH, triangle_fx_3xx_speed+1
002e43 9630                      	adiw Z, 0
002e44 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002e45 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002e46 91a0 28f7                 	lds r26, triangle_fx_3xx_start
002e48 91b0 28f8                 	lds r27, triangle_fx_3xx_start+1
002e4a 9610                      	adiw r26:r27, 0
002e4b f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002e4c c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002e4d 91c0 28f9                 	lds r28, triangle_fx_3xx_target
002e4f 91d0 28fa                 	lds r29, triangle_fx_3xx_target+1
                                 
002e51 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002e52 07bd                      	cpc r27, r29
002e53 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002e54 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002e55 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002e56 9220 28f7                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002e58 9220 28f8                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002e5a c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002e5b 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002e5c 0bdb                      	sbc r29, r27
002e5d 91a0 28fd                 	lds r26, triangle_fx_3xx_total_offset
002e5f 91b0 28fe                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002e61 0fae                      	add r26, ZL //add the speed to the total offset
002e62 1fbf                      	adc r27, ZH
002e63 1bca                      	sub r28, r26 //invert the total difference with the total offset
002e64 0bdb                      	sbc r29, r27
002e65 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e66 93a0 28fd                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002e68 93b0 28fe                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002e6a 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002e6c 91b0 0aad                 	lds r27, TCB2_CCMPH
002e6e 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002e6f 0bbd                      	sbc r27, r29
002e70 93a0 0aac                 	sts TCB2_CCMPL, r26
002e72 93b0 0aad                 	sts TCB2_CCMPH, r27
002e74 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002e75 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002e76 0bbd                      	sbc r27, r29
002e77 91c0 28fd                 	lds r28, triangle_fx_3xx_total_offset
002e79 91d0 28fe                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002e7b 0fce                      	add r28, ZL //add the speed to the total offset
002e7c 1fdf                      	adc r29, ZH
002e7d 1bac                      	sub r26, r28 //invert the total difference with the total offset
002e7e 0bbd                      	sbc r27, r29
002e7f f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002e80 93c0 28fd                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002e82 93d0 28fe                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002e84 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002e86 91d0 0aad                 	lds r29, TCB2_CCMPH
002e88 0fca                      	add r28, r26 //offset the current timer period with the total offset
002e89 1fdb                      	adc r29, r27
002e8a 93c0 0aac                 	sts TCB2_CCMPL, r28
002e8c 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002e8e 91a0 28ff                 	lds r26, triangle_fx_4xy_speed
002e90 15a2                      	cp r26, zero
002e91 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002e92 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002e93 91b0 2900                 	lds r27, triangle_fx_4xy_depth
002e95 91c0 2901                 	lds r28, triangle_fx_4xy_phase
002e97 0fca                      	add r28, r26 //increase the phase by the speed
002e98 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002e99 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002e9a e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002e9b 93c0 2901                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002e9d 31c0                      	cpi r28, 16
002e9e f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002e9f 32c0                      	cpi r28, 32
002ea0 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002ea1 33c0                      	cpi r28, 48
002ea2 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002ea3 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002ea4 70cf                      	andi r28, 0x0F //mask for values 0-15
002ea5 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002ea6 6fc0                      	ori r28, 0xF0
002ea7 95c0                      	com r28 //invert values 0-15
002ea8 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002ea9 70cf                      	andi r28, 0x0F //mask for values 0-15
002eaa c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002eab 6fc0                      	ori r28, 0xF0
002eac 95c0                      	com r28 //invert values 0-15
002ead c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002eae 95b2                      	swap r27 //multiply depth by 16
002eaf 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002eb0 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002eb1 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002eb2 0fec                      	add ZL, r28 //offset the table by the depth+phase
002eb3 1df2                      	adc ZH, zero
002eb4 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002eb5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002eb6 937f                      	push r23
002eb7 2f6c                      	mov r22, r28 //store the vibrato value into r22
002eb8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002eb9 9f67                      	mul r22, r23
002eba 917f                      	pop r23
002ebb 916f                      	pop r22
                                 
002ebc 9416                      	lsr r1 //shift out the fractional bits
002ebd 9407                      	ror r0
002ebe 9416                      	lsr r1
002ebf 9407                      	ror r0
002ec0 9416                      	lsr r1
002ec1 9407                      	ror r0
002ec2 9416                      	lsr r1
002ec3 9407                      	ror r0
                                 	
002ec4 91a0 0aac                 	lds r26, TCB2_CCMPL
002ec6 91b0 0aad                 	lds r27, TCB2_CCMPH
002ec8 0da0                      	add r26, r0
002ec9 1db1                      	adc r27, r1
002eca 93a0 0aac                 	sts TCB2_CCMPL, r26
002ecc 93b0 0aad                 	sts TCB2_CCMPH, r27
002ece c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002ecf 95b2                      	swap r27 //multiply depth by 16
002ed0 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002ed1 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002ed2 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002ed3 0fec                      	add ZL, r28 //offset the table by the depth+phase
002ed4 1df2                      	adc ZH, zero
002ed5 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002ed6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ed7 937f                      	push r23
002ed8 2f6c                      	mov r22, r28 //store the vibrato value into r22
002ed9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002eda 9f67                      	mul r22, r23
002edb 917f                      	pop r23
002edc 916f                      	pop r22
                                 
002edd 9416                      	lsr r1 //shift out the fractional bits
002ede 9407                      	ror r0
002edf 9416                      	lsr r1
002ee0 9407                      	ror r0
002ee1 9416                      	lsr r1
002ee2 9407                      	ror r0
002ee3 9416                      	lsr r1
002ee4 9407                      	ror r0
                                 
002ee5 91a0 0aac                 	lds r26, TCB2_CCMPL
002ee7 91b0 0aad                 	lds r27, TCB2_CCMPH
002ee9 19a0                      	sub r26, r0
002eea 09b1                      	sbc r27, r1
002eeb 93a0 0aac                 	sts TCB2_CCMPL, r26
002eed 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002eef 91e0 2907                 	lds ZL, triangle_fx_Qxy_target
002ef1 91f0 2908                 	lds ZH, triangle_fx_Qxy_target+1
002ef3 9630                      	adiw Z, 0
002ef4 f129                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002ef5 91a0 290b                 	lds r26, triangle_fx_Qxy_total_offset
002ef7 91b0 290c                 	lds r27, triangle_fx_Qxy_total_offset+1
002ef9 91c0 0aac                 	lds r28, TCB2_CCMPL
002efb 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002efd 1bec                      	sub ZL, r28 //calculate the difference to the target
002efe 0bfd                      	sbc ZH, r29
002eff f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002f00 f078                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002f01 9220 290b                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
002f03 9220 290c                 	sts triangle_fx_Qxy_total_offset+1, zero
002f05 9220 2907                 	sts triangle_fx_Qxy_target, zero
002f07 9220 2908                 	sts triangle_fx_Qxy_target+1, zero
002f09 91b0 2906                 	lds r27, triangle_fx_Qxy_target_note
002f0b 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002f0d 93b0 290d                 	sts triangle_fx_Rxy_target_note, r27
002f0f c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002f10 91c0 2909                 	lds r28, triangle_fx_Qxy_speed
002f12 91d0 290a                 	lds r29, triangle_fx_Qxy_speed+1
002f14 0fac                      	add r26, r28 //increase the total offset by the speed
002f15 1fbd                      	adc r27, r29
002f16 93a0 290b                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002f18 93b0 290c                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002f1a 91e0 290e                 	lds ZL, triangle_fx_Rxy_target
002f1c 91f0 290f                 	lds ZH, triangle_fx_Rxy_target+1
002f1e 9630                      	adiw Z, 0
002f1f f129                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002f20 91a0 2912                 	lds r26, triangle_fx_Rxy_total_offset
002f22 91b0 2913                 	lds r27, triangle_fx_Rxy_total_offset+1
002f24 91c0 0aac                 	lds r28, TCB2_CCMPL
002f26 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002f28 1bce                      	sub r28, ZL //calculate the difference to the target
002f29 0bdf                      	sbc r29, ZH
002f2a f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002f2b f078                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002f2c 9220 2912                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002f2e 9220 2913                 	sts triangle_fx_Rxy_total_offset+1, zero
002f30 9220 290e                 	sts triangle_fx_Rxy_target, zero
002f32 9220 290f                 	sts triangle_fx_Rxy_target+1, zero
002f34 91b0 290d                 	lds r27, triangle_fx_Rxy_target_note
002f36 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002f38 93b0 2906                 	sts triangle_fx_Qxy_target_note, r27
002f3a c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002f3b 91c0 2910                 	lds r28, triangle_fx_Rxy_speed
002f3d 91d0 2911                 	lds r29, triangle_fx_Rxy_speed+1
002f3f 0fac                      	add r26, r28 //increase the total offset by the speed
002f40 1fbd                      	adc r27, r29
002f41 93a0 2912                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002f43 93b0 2913                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002f45 91e0 291c                 	lds ZL, noise_volume_macro
002f47 91f0 291d                 	lds ZH, noise_volume_macro+1
002f49 9630                      	adiw Z, 0
002f4a f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002f4b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f4c 1fff                      	rol ZH
002f4d 91a0 291e                 	lds r26, noise_volume_macro_offset
002f4f 0fea                      	add ZL, r26
002f50 1df2                      	adc ZH, zero
                                 
002f51 91b0 2920                 	lds r27, noise_volume_macro_release
002f53 17ba                      	cp r27, r26
002f54 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002f55 91a0 291f                 	lds r26, noise_volume_macro_loop
002f57 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f58 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f59 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002f5a 95a3                      	inc r26 //increment the macro offset
002f5b 93a0 291e                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002f5d 91b4                      	lpm r27, Z //load volume data into r27
002f5e 3fbf                      	cpi r27, 0xFF //check for macro end flag
002f5f f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002f60 91b0 2920                 	lds r27, noise_volume_macro_release
002f62 3fbf                      	cpi r27, 0xFF
002f63 f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002f64 91b0 291f                 	lds r27, noise_volume_macro_loop //load the loop index
002f66 93b0 291e                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002f68 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002f69 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002f6a 93a0 291e                 	sts noise_volume_macro_offset, r26
002f6c cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002f6d e0e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002f6e e6f4                      	ldi ZH, HIGH(volumes << 1)
002f6f 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002f70 0feb                      	add ZL, r27 //add offset to the table
002f71 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002f72 91b0 2813                 	lds r27, noise_param //load main volume
002f74 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f75 91a0 2946                 	lds r26, noise_fx_7xy_value
002f77 30a0                      	cpi r26, 0x00
002f78 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002f79 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f7a 1df2                      	adc ZH, zero
002f7b 91b4                      	lpm r27, Z
002f7c 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f7e c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002f7f 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002f81 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002f82 91a0 2946                 	lds r26, noise_fx_7xy_value
002f84 30a0                      	cpi r26, 0x00
002f85 f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002f86 93b0 2816                 	sts noise_output_volume, r27
002f88 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002f89 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f8a f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002f8b f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002f8c 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f8d 1df2                      	adc ZH, zero
002f8e 91b4                      	lpm r27, Z
002f8f 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f91 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002f92 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f93 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f94 1df2                      	adc ZH, zero
002f95 91b4                      	lpm r27, Z
002f96 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002f98 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002f99 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f9a f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f9b f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002f9c 93b0 2816                 	sts noise_output_volume, r27
002f9e c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002f9f e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002fa0 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002fa2 91e0 2921                 	lds ZL, noise_arpeggio_macro
002fa4 91f0 2922                 	lds ZH, noise_arpeggio_macro+1
002fa6 9630                      	adiw Z, 0
002fa7 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002fa8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002fa9 1fff                      	rol ZH
002faa 91a0 2923                 	lds r26, noise_arpeggio_macro_offset
002fac 0fea                      	add ZL, r26
002fad 1df2                      	adc ZH, zero
                                 
002fae 91b0 2925                 	lds r27, noise_arpeggio_macro_release
002fb0 17ba                      	cp r27, r26
002fb1 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002fb2 91a0 2924                 	lds r26, noise_arpeggio_macro_loop
002fb4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002fb5 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002fb6 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002fb7 95a3                      	inc r26 //increment the macro offset
002fb8 93a0 2923                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002fba 91b4                      	lpm r27, Z //load arpeggio data into r27
002fbb 38b0                      	cpi r27, 0x80 //check for macro end flag
002fbc f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002fbd c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002fbe 50a1                      	subi r26, 1 //keep the offset at the end flag
002fbf 93a0 2923                 	sts noise_arpeggio_macro_offset, r26
002fc1 91b0 2926                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002fc3 30b1                      	cpi r27, 0x01
002fc4 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002fc5 91b0 2925                 	lds r27, noise_arpeggio_macro_release
002fc7 3fbf                      	cpi r27, 0xFF
002fc8 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002fc9 91b0 2924                 	lds r27, noise_arpeggio_macro_loop
002fcb 3fbf                      	cpi r27, 0xFF
002fcc f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002fcd c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002fce 91b0 2925                 	lds r27, noise_arpeggio_macro_release
002fd0 3fbf                      	cpi r27, 0xFF
002fd1 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002fd2 91b0 2924                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002fd4 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002fd5 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002fd6 91c0 2939                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002fd8 91d0 293a                 	lds r29, noise_fx_0xy_sequence+1
002fda 9620                      	adiw r29:r28, 0
002fdb f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002fdc 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002fdd 93a0 2923                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002fdf cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002fe0 93b0 2923                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002fe2 cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002fe3 91c0 2939                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002fe5 91d0 293a                 	lds r29, noise_fx_0xy_sequence+1
002fe7 9620                      	adiw r29:r28, 0 //check for 0xy effect
002fe8 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
002fe9 95d6                      	lsr r29
002fea 95c7                      	ror r28
002feb 95d7                      	ror r29
002fec 95c7                      	ror r28
002fed 95d7                      	ror r29
002fee 95c7                      	ror r28
002fef 95d7                      	ror r29
002ff0 95c7                      	ror r28
002ff1 95d7                      	ror r29
002ff2 95d2                      	swap r29
                                 
002ff3 93c0 2939                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002ff5 93d0 293a                 	sts noise_fx_0xy_sequence+1, r29
002ff7 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002ff8 91a0 2817                 	lds r26, noise_note //load the current note index
002ffa 0fac                      	add r26, r28 //add the note offset
002ffb c01c                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002ffc 91a0 2817                 	lds r26, noise_note //load the current note index
002ffe c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002fff 9220 2927                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
003001 9220 2928                 	sts noise_total_pitch_offset+1, zero
003003 9220 292e                 	sts noise_total_hi_pitch_offset, zero
003005 91a0 2926                 	lds r26, noise_arpeggio_macro_mode
003007 30a1                      	cpi r26, 0x01 //absolute mode
003008 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
003009 f031                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
00300a c007                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
00300b 91a0 2817                 	lds r26, noise_note //load the current note index
00300d 0fab                      	add r26, r27 //offset the note with the arpeggio data
00300e 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
00300f c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
003010 2fab                      	mov r26, r27 //move the arpeggio data into r26
003011 c006                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
003012 91a0 2817                 	lds r26, noise_note //load the current note index
003014 0fab                      	add r26, r27 //offset the note with the arpeggio data
003015 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
003016 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
003018 93a0 2818                 	sts noise_adjusted_note, r26
00301a c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
00301b 91e0 2929                 	lds ZL, noise_pitch_macro
00301d 91f0 292a                 	lds ZH, noise_pitch_macro+1
00301f 9630                      	adiw Z, 0
003020 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
003021 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
003022 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003023 1fff                      	rol ZH
003024 91a0 292b                 	lds r26, noise_pitch_macro_offset
003026 0fea                      	add ZL, r26
003027 1df2                      	adc ZH, zero
                                 
003028 91b0 292d                 	lds r27, noise_pitch_macro_release
00302a 17ba                      	cp r27, r26
00302b f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
00302c 91a0 292c                 	lds r26, noise_pitch_macro_loop
00302e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00302f f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003030 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
003031 95a3                      	inc r26 //increment the macro offset
003032 93a0 292b                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
003034 91b4                      	lpm r27, Z //load pitch data into r27
003035 38b0                      	cpi r27, 0x80 //check for macro end flag
003036 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
003037 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003038 93a0 292b                 	sts noise_pitch_macro_offset, r26
00303a 91b0 292d                 	lds r27, noise_pitch_macro_release
00303c 3fbf                      	cpi r27, 0xFF
00303d f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
00303e 91b0 292c                 	lds r27, noise_pitch_macro_loop //load the loop index
003040 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003041 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
003042 93b0 292b                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
003044 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
003045 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
003046 91a0 2927                 	lds r26, noise_total_pitch_offset
003048 0fba                      	add r27, r26
003049 93b0 2927                 	sts noise_total_pitch_offset, r27
00304b 91a0 2818                 	lds r26, noise_adjusted_note
00304d 1bab                      	sub r26, r27
                                 	
00304e 91b0 293c                 	lds r27, noise_fx_1xx_total
003050 0fab                      	add r26, r27
003051 91b0 293e                 	lds r27, noise_fx_2xx_total
003053 1bab                      	sub r26, r27
003054 91b0 2942                 	lds r27, noise_fx_4xy_offset
003056 1bab                      	sub r26, r27
003057 91b0 294a                 	lds r27, noise_fx_Pxx_total
003059 1bab                      	sub r26, r27
                                 
00305a 70af                      	andi r26, 0x0F
                                 
00305b e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
00305c e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
00305d 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00305e 0fea                      	add ZL, r26 //add offset
00305f 1df2                      	adc ZH, zero
003060 91a5                      	lpm r26, Z+ //load bytes
003061 91b4                      	lpm r27, Z
003062 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
003064 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
003066 91e0 292f                 	lds ZL, noise_hi_pitch_macro
003068 91f0 2930                 	lds ZH, noise_hi_pitch_macro+1
00306a 9630                      	adiw Z, 0
00306b f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
00306c c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
00306d 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00306e 1fff                      	rol ZH
00306f 91a0 2931                 	lds r26, noise_hi_pitch_macro_offset
003071 0fea                      	add ZL, r26
003072 1df2                      	adc ZH, zero
                                 
003073 91b0 2933                 	lds r27, noise_hi_pitch_macro_release
003075 17ba                      	cp r27, r26
003076 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
003077 91a0 2932                 	lds r26, noise_hi_pitch_macro_loop
003079 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00307a f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00307b c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
00307c 95a3                      	inc r26 //increment the macro offset
00307d 93a0 2931                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
00307f 91b4                      	lpm r27, Z //load hi pitch data into r27
003080 38b0                      	cpi r27, 0x80 //check for macro end flag
003081 f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
003082 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003083 93a0 2931                 	sts noise_hi_pitch_macro_offset, r26
003085 91b0 2933                 	lds r27, noise_hi_pitch_macro_release
003087 3fbf                      	cpi r27, 0xFF
003088 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
003089 91b0 2932                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
00308b 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00308c f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00308d 93b0 2931                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
00308f cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
003090 91b0 292e                 	lds r27, noise_total_hi_pitch_offset
003092 c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
003093 91a0 292e                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
003095 0fba                      	add r27, r26
003096 93b0 292e                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
003098 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003099 937f                      	push r23
00309a 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00309b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00309c 0367                      	mulsu r22, r23
00309d 917f                      	pop r23
00309e 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
00309f 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
0030a1 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
0030a3 0da0                      	add r26, r0 //offset the timer values
0030a4 1db1                      	adc r27, r1
0030a5 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
0030a7 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
0030a9 91e0 2934                 	lds ZL, noise_duty_macro
0030ab 91f0 2935                 	lds ZH, noise_duty_macro+1
0030ad 9630                      	adiw Z, 0
0030ae f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
0030af 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0030b0 1fff                      	rol ZH
0030b1 91a0 2936                 	lds r26, noise_duty_macro_offset
0030b3 0fea                      	add ZL, r26
0030b4 1df2                      	adc ZH, zero
                                 
0030b5 91b0 2938                 	lds r27, noise_duty_macro_release
0030b7 17ba                      	cp r27, r26
0030b8 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
0030b9 91a0 2937                 	lds r26, noise_duty_macro_loop
0030bb 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0030bc f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0030bd c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
0030be 95a3                      	inc r26 //increment the macro offset
0030bf 93a0 2936                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
0030c1 91b4                      	lpm r27, Z //load pitch data into r27
0030c2 3fbf                      	cpi r27, 0xFF //check for macro end flag
0030c3 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
0030c4 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0030c5 93a0 2936                 	sts noise_duty_macro_offset, r26
0030c7 91b0 2938                 	lds r27, noise_duty_macro_release
0030c9 3fbf                      	cpi r27, 0xFF
0030ca f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
0030cb 91b0 2937                 	lds r27, noise_duty_macro_loop //load the loop index
0030cd 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0030ce f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0030cf 93b0 2936                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
0030d1 cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
0030d2 95b6                      	lsr r27
0030d3 95b7                      	ror r27 //move mode bit to bit 7
0030d4 91c0 2814                 	lds r28, noise_period
0030d6 77cf                      	andi r28, 0b01111111
0030d7 2bcb                      	or r28, r27 //store the new noise mode
0030d8 93c0 2814                 	sts noise_period, r28
                                 
0030da 776f                      	andi noise_sequence_HIGH, 0b01111111
0030db 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
0030dc 91e0 293b                 	lds ZL, noise_fx_1xx
0030de 30e0                      	cpi ZL, 0
0030df f029                      	breq sound_driver_channel3_fx_2xx_routine
                                 
0030e0 91a0 293c                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
0030e2 0fae                      	add r26, ZL //increase the total offset by the rate
0030e3 93a0 293c                 	sts noise_fx_1xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
0030e5 91e0 293d                 	lds ZL, noise_fx_2xx
0030e7 30e0                      	cpi ZL, 0
0030e8 f029                      	breq sound_driver_channel3_fx_3xx_routine
                                 
0030e9 91a0 293e                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
0030eb 0fae                      	add r26, ZL //increase the total offset by the rate
0030ec 93a0 293e                 	sts noise_fx_2xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
0030ee 91a0 293f                 	lds r26, noise_fx_4xy_speed
0030f0 15a2                      	cp r26, zero
0030f1 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
0030f2 c033                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
0030f3 91b0 2940                 	lds r27, noise_fx_4xy_depth
0030f5 91c0 2941                 	lds r28, noise_fx_4xy_phase
0030f7 0fca                      	add r28, r26 //increase the phase by the speed
0030f8 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0030f9 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0030fa e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
0030fb 93c0 2941                 	sts noise_fx_4xy_phase, r28 //store the new phase
0030fd 31c0                      	cpi r28, 16
0030fe f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
0030ff 32c0                      	cpi r28, 32
003100 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
003101 33c0                      	cpi r28, 48
003102 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
003103 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
003104 70cf                      	andi r28, 0x0F //mask for values 0-15
003105 c014                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
003106 6fc0                      	ori r28, 0xF0
003107 95c0                      	com r28 //invert values 0-15
003108 c011                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
003109 70cf                      	andi r28, 0x0F //mask for values 0-15
00310a c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
00310b 6fc0                      	ori r28, 0xF0
00310c 95c0                      	com r28 //invert values 0-15
00310d c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
00310e 95b2                      	swap r27 //multiply depth by 16
00310f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003110 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003111 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003112 0fec                      	add ZL, r28 //offset the table by the depth+phase
003113 1df2                      	adc ZH, zero
003114 91c4                      	lpm r28, Z //load the tremelo value into r28
003115 95c2                      	swap r28
003116 70cf                      	andi r28, 0x0F
                                 
003117 93c0 2942                 	sts noise_fx_4xy_offset, r28
003119 c00c                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
00311a 95b2                      	swap r27 //multiply depth by 16
00311b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00311c e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00311d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00311e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00311f 1df2                      	adc ZH, zero
003120 91c4                      	lpm r28, Z //load the vibrato value into r28
003121 95c2                      	swap r28
003122 70cf                      	andi r28, 0x0F
                                 
003123 95c1                      	neg r28
003124 93c0 2942                 	sts noise_fx_4xy_offset, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
003126 91a0 2943                 	lds r26, noise_fx_7xy_speed
003128 15a2                      	cp r26, zero
003129 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00312a 91b0 2944                 	lds r27, noise_fx_7xy_depth
00312c 91c0 2945                 	lds r28, noise_fx_7xy_phase
00312e 0fca                      	add r28, r26 //increase the phase by the speed
00312f 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
003130 f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
003131 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
003132 93c0 2945                 	sts noise_fx_7xy_phase, r28 //store the new phase
003134 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
003135 ffc4                      	sbrs r28, 4
003136 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
003137 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
003138 70cf                      	andi r28, 0x0F //mask for values 0-15
003139 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
00313a 6fc0                      	ori r28, 0xF0
00313b 95c0                      	com r28 //invert values 0-15
00313c c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
00313d 95b2                      	swap r27 //multiply depth by 16
00313e 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00313f e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003140 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003141 0fec                      	add ZL, r28 //offset the table by the depth+phase
003142 1df2                      	adc ZH, zero
003143 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003144 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
003145 93c0 2946                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
003147 91b0 2947                 	lds r27, noise_fx_Axy
003149 15b2                      	cp r27, zero
00314a f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00314b 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
00314d 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
00314f 2fda                      	mov r29, r26 //copy fractional volume into r29
003150 2fec                      	mov r30, r28 //copy the noise_param into r30
003151 95e2                      	swap r30
003152 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
003153 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
003154 17ed                      	cp r30, r29 //compare the fractional and integer volumes
003155 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
003156 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
003157 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
003158 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
003159 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00315a f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00315b efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
00315c c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
00315d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00315e f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00315f e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
003160 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
003162 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
003163 95a2                      	swap r26
003164 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
003165 2bca                      	or r28, r26 //store the new volume back into noise_param
003166 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Qxy_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
                                 
                                 
                                 
                                 sound_driver_exit:
003168 91ff                      	pop r31
003169 91ef                      	pop r30
00316a 91df                      	pop r29
00316b 91cf                      	pop r28
00316c 940c 1665                 	jmp sequence_1_3
                                 
                                 
                                 
                                 //TABLES
00316e 7f05
00316f 010a
003170 0214
003171 0328
003172 0450
003173 051e
003174 0607
003175 070d
003176 0806
003177 090c
003178 0a18
003179 0b30
00317a 0c60
00317b 0d24
00317c 0e08
00317d 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
00317e 0301
00317f fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
003180 190f
003181 1914
003182 1930
003183 194c
003184 196f                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
003185 197a
003186 1987
003187 198a
003188 198d
003189 1990                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
00318a 1993
00318b 199b
00318c 199e
00318d 19ab
00318e 19ac                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
00318f 19ad
003190 19ae
003191 19af
003192 19c7
003193 1a09                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
003194 1a4a
003195 1a57
003196 1a6b
003197 1a6c
003198 1a6d                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
003199 1a6e                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
00319a 1c0c
00319b 1c11
00319c 1c2d
00319d 1c49
00319e 1c6c                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
00319f 1c77
0031a0 1c84
0031a1 1c87
0031a2 1c8a
0031a3 1c8d                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
0031a4 1c90
0031a5 1c98
0031a6 1c9b
0031a7 1ca8
0031a8 1ca9                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
0031a9 1caa
0031aa 1cab
0031ab 1cac
0031ac 1cc4
0031ad 1d06                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
0031ae 1d47
0031af 1d54
0031b0 1d68
0031b1 1d69
0031b2 1d6a                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
0031b3 1d6b                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
0031b4 1efc
0031b5 1f01
0031b6 1f1d
0031b7 1f39
0031b8 1f5c                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
0031b9 1f67
0031ba 1f68
0031bb 1f69
0031bc 1f6c
0031bd 1f6f                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
0031be 1f72
0031bf 1f7f
0031c0 1f82
0031c1 1f8f
0031c2 1f90                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
0031c3 1f91
0031c4 1f92
0031c5 1f93
0031c6 1fab
0031c7 1fed                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
0031c8 202e
0031c9 203b
0031ca 203c
0031cb 203d
0031cc 203e                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
0031cd 203f                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
0031ce 21d4
0031cf 21d9
0031d0 21e2
0031d1 21eb
0031d2 21ec                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
0031d3 21f9
0031d4 2206
0031d5 2209
0031d6 220c
0031d7 220f                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
0031d8 2212
0031d9 2219
0031da 221c
0031db 2229
0031dc 222a                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
0031dd 222b
0031de 222c
0031df 222d
0031e0 2230
0031e1 2231                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
0031e2 2232
0031e3 223f
0031e4 224a
0031e5 224b
0031e6 224c                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
0031e7 224d                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 channel4_fx:
0031e8 23a6
0031e9 23a7
0031ea 23a8
0031eb 23a9
0031ec 23aa                      	.dw sound_driver_channel4_fx_0xy, sound_driver_channel4_fx_1xx, sound_driver_channel4_fx_2xx, sound_driver_channel4_fx_3xx, sound_driver_channel4_fx_4xy
0031ed 23ab
0031ee 23ac
0031ef 23ad
0031f0 23b0
0031f1 23b3                      	.dw sound_driver_channel4_fx_7xy, sound_driver_channel4_fx_Axy, sound_driver_channel4_fx_Bxx, sound_driver_channel4_fx_Cxx, sound_driver_channel4_fx_Dxx
0031f2 23b6
0031f3 23b7
0031f4 23ba
0031f5 23c7
0031f6 23c8                      	.dw sound_driver_channel4_fx_Exx, sound_driver_channel4_fx_Fxx, sound_driver_channel4_fx_Gxx, sound_driver_channel4_fx_Hxy, sound_driver_channel4_fx_Ixy
0031f7 23c9
0031f8 23ca
0031f9 23cb
0031fa 23cc
0031fb 23cd                      	.dw sound_driver_channel4_fx_Hxx, sound_driver_channel4_fx_Ixx, sound_driver_channel4_fx_Pxx, sound_driver_channel4_fx_Qxy, sound_driver_channel4_fx_Rxy
0031fc 23ce
0031fd 23db
0031fe 23dc
0031ff 23dd
003200 23de                      	.dw sound_driver_channel4_fx_Sxx, sound_driver_channel4_fx_Vxx, sound_driver_channel4_fx_Wxx, sound_driver_channel4_fx_Xxx, sound_driver_channel4_fx_Yxx
003201 23df                      	.dw sound_driver_channel4_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
003202 0000
003203 0000
003204 0000
003205 0000
003206 0000
003207 0000
003208 0000
003209 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
00320a 0100
00320b 0101
00320c 0101
00320d 0101
00320e 0101
00320f 0101
003210 0101
003211 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
003212 0100
003213 0101
003214 0101
003215 0101
003216 0101
003217 0101
003218 0101
003219 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
00321a 0100
00321b 0101
00321c 0101
00321d 0101
00321e 0101
00321f 0202
003220 0202
003221 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
003222 0100
003223 0101
003224 0101
003225 0101
003226 0202
003227 0202
003228 0303
003229 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
00322a 0100
00322b 0101
00322c 0101
00322d 0202
00322e 0302
00322f 0303
003230 0404
003231 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
003232 0100
003233 0101
003234 0201
003235 0202
003236 0303
003237 0404
003238 0504
003239 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
00323a 0100
00323b 0101
00323c 0201
00323d 0302
00323e 0403
00323f 0504
003240 0605
003241 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
003242 0100
003243 0101
003244 0202
003245 0303
003246 0404
003247 0505
003248 0606
003249 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
00324a 0100
00324b 0101
00324c 0302
00324d 0403
00324e 0504
00324f 0606
003250 0707
003251 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
003252 0100
003253 0201
003254 0302
003255 0404
003256 0605
003257 0706
003258 0808
003259 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
00325a 0100
00325b 0201
00325c 0302
00325d 0504
00325e 0605
00325f 0807
003260 0908
003261 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
003262 0100
003263 0201
003264 0403
003265 0504
003266 0706
003267 0808
003268 0a09
003269 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
00326a 0100
00326b 0201
00326c 0403
00326d 0605
00326e 0706
00326f 0908
003270 0b0a
003271 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
003272 0100
003273 0201
003274 0403
003275 0605
003276 0807
003277 0a09
003278 0c0b
003279 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
00327a 0100
00327b 0302
00327c 0504
00327d 0706
00327e 0908
00327f 0b0a
003280 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 260 r0 : 148 r1 : 160 r2 : 691 r3 :  25 r4 :   4 
r5 :   9 r6 :   0 r7 :   6 r8 :   4 r9 :   9 r10:   6 r11:   4 r12:   9 
r13:   5 r14:   5 r15:   4 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 138 r23: 129 r24:   5 r25:  24 r26:1029 r27:1245 r28: 670 
r29: 356 r30: 345 r31: 329 
Registers used: 32 out of 35 (91.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 136 add   : 190 adiw  : 100 and   :   2 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   6 brcs  :  13 break :   0 breq  : 177 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  77 brlt  :   0 brmi  :   0 
brne  : 133 brpl  :   0 brsh  :  38 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   5 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   7 cln   :   0 clr   :   6 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 131 cpc   :  16 
cpi   : 175 cpse  :  26 dec   :  27 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   5 in    :   6 inc   :  46 
jmp   :   9 ld    :   0 ldd   :   0 ldi   : 314 lds   : 703 lpm   : 286 
lsl   :  83 lsr   : 137 mov   : 138 movw  :   0 mul   :  21 muls  :   0 
mulsu :  10 neg   :   1 nop   :   0 or    :  24 ori   :  12 out   :  10 
pop   :  99 push  :  91 rcall :  56 ret   :  44 reti  :   8 rjmp  : 580 
rol   :  59 ror   : 156 sbc   :  31 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  26 sbrs  :  18 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1412 sub   :  57 subi  :  38 swap  :  47 tst   :   0 wdr   :   0 

Instructions used: 55 out of 114 (48.2%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x006504  15908   9832  25740   49152  52.4%
[.dseg] 0x002800 0x00295b      0    347    347    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 50 warnings
