
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Wed Jan 20 18:28:00 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           song_frames: .byte 2
002815                           song_frame_offset: .byte 2
002817                           song_size: .byte 2
002819                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281a                           song_fx_Bxx: .byte 1
00281b                           song_fx_Cxx: .byte 1
00281c                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
00281d                           pulse1_pattern: .byte 2
00281f                           pulse1_pattern_delay_rows: .byte 1
002820                           pulse1_pattern_delay_frames: .byte 1
002821                           pulse1_pattern_offset: .byte 2
                                 
002823                           pulse1_volume_macro: .byte 2
002825                           pulse1_volume_macro_offset: .byte 1
002826                           pulse1_volume_macro_loop: .byte 1
002827                           pulse1_volume_macro_release: .byte 1
                                 
002828                           pulse1_arpeggio_macro: .byte 2
00282a                           pulse1_arpeggio_macro_offset: .byte 1
00282b                           pulse1_arpeggio_macro_loop: .byte 1
00282c                           pulse1_arpeggio_macro_release: .byte 1
00282d                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00282e                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00282f                           pulse1_pitch_macro: .byte 2
002831                           pulse1_pitch_macro_offset: .byte 1
002832                           pulse1_pitch_macro_loop: .byte 1
002833                           pulse1_pitch_macro_release: .byte 1
                                 
002834                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002835                           pulse1_hi_pitch_macro: .byte 2
002837                           pulse1_hi_pitch_macro_offset: .byte 1
002838                           pulse1_hi_pitch_macro_loop: .byte 1
002839                           pulse1_hi_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_duty_macro: .byte 2
00283c                           pulse1_duty_macro_offset: .byte 1
00283d                           pulse1_duty_macro_loop: .byte 1
00283e                           pulse1_duty_macro_release: .byte 1
                                 
00283f                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002841                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002843                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002845                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002847                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002849                           pulse1_fx_3xx_start: .byte 2 //the starting note period
00284b                           pulse1_fx_3xx_target: .byte 2 //target note period
00284d                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00284f                           pulse1_fx_3xx_total_offset: .byte 2
002851                           pulse1_fx_4xy_speed: .byte 1
002852                           pulse1_fx_4xy_depth: .byte 1
002853                           pulse1_fx_4xy_phase: .byte 1
002854                           pulse1_fx_7xy_speed: .byte 1
002855                           pulse1_fx_7xy_depth: .byte 1
002856                           pulse1_fx_7xy_phase: .byte 1
002857                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002858                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002859                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00285a                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00285b                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
00285c                           pulse1_fx_Qxy_target: .byte 2 //target note period
00285e                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002860                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002862                           pulse1_fx_Rxy_target: .byte 2 //target note period
002864                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002866                           pulse1_fx_Rxy_total_offset: .byte 2
002868                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002869                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
00286a                           pulse2_pattern: .byte 2
00286c                           pulse2_pattern_delay_rows: .byte 1
00286d                           pulse2_pattern_delay_frames: .byte 1
00286e                           pulse2_pattern_offset: .byte 2
                                 
002870                           pulse2_volume_macro: .byte 2
002872                           pulse2_volume_macro_offset: .byte 1
002873                           pulse2_volume_macro_loop: .byte 1
002874                           pulse2_volume_macro_release: .byte 1
                                 
002875                           pulse2_arpeggio_macro: .byte 2
002877                           pulse2_arpeggio_macro_offset: .byte 1
002878                           pulse2_arpeggio_macro_loop: .byte 1
002879                           pulse2_arpeggio_macro_release: .byte 1
00287a                           pulse2_arpeggio_macro_mode: .byte 1
                                 
00287b                           pulse2_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00287c                           pulse2_pitch_macro: .byte 2
00287e                           pulse2_pitch_macro_offset: .byte 1
00287f                           pulse2_pitch_macro_loop: .byte 1
002880                           pulse2_pitch_macro_release: .byte 1
                                 
002881                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002882                           pulse2_hi_pitch_macro: .byte 2
002884                           pulse2_hi_pitch_macro_offset: .byte 1
002885                           pulse2_hi_pitch_macro_loop: .byte 1
002886                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002887                           pulse2_duty_macro: .byte 2
002889                           pulse2_duty_macro_offset: .byte 1
00288a                           pulse2_duty_macro_loop: .byte 1
00288b                           pulse2_duty_macro_release: .byte 1
                                 
00288c                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00288e                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002890                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002892                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002894                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002896                           pulse2_fx_3xx_start: .byte 2 //the starting note period
002898                           pulse2_fx_3xx_target: .byte 2 //target note period
00289a                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00289c                           pulse2_fx_3xx_total_offset: .byte 2
00289e                           pulse2_fx_4xy_speed: .byte 1
00289f                           pulse2_fx_4xy_depth: .byte 1
0028a0                           pulse2_fx_4xy_phase: .byte 1
0028a1                           pulse2_fx_7xy_speed: .byte 1
0028a2                           pulse2_fx_7xy_depth: .byte 1
0028a3                           pulse2_fx_7xy_phase: .byte 1
0028a4                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028a5                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028a6                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028a7                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028a8                           pulse2_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
0028a9                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028ab                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028ad                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028af                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028b1                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028b3                           pulse2_fx_Rxy_total_offset: .byte 2
0028b5                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028b6                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028b7                           triangle_pattern: .byte 2
0028b9                           triangle_pattern_delay_rows: .byte 1
0028ba                           triangle_pattern_delay_frames: .byte 1
0028bb                           triangle_pattern_offset: .byte 2
                                 
0028bd                           triangle_volume_macro: .byte 2
0028bf                           triangle_volume_macro_offset: .byte 1
0028c0                           triangle_volume_macro_loop: .byte 1
0028c1                           triangle_volume_macro_release: .byte 1
                                 
0028c2                           triangle_arpeggio_macro: .byte 2
0028c4                           triangle_arpeggio_macro_offset: .byte 1
0028c5                           triangle_arpeggio_macro_loop: .byte 1
0028c6                           triangle_arpeggio_macro_release: .byte 1
0028c7                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028c8                           triangle_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
0028c9                           triangle_pitch_macro: .byte 2
0028cb                           triangle_pitch_macro_offset: .byte 1
0028cc                           triangle_pitch_macro_loop: .byte 1
0028cd                           triangle_pitch_macro_release: .byte 1
                                 
0028ce                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028cf                           triangle_hi_pitch_macro: .byte 2
0028d1                           triangle_hi_pitch_macro_offset: .byte 1
0028d2                           triangle_hi_pitch_macro_loop: .byte 1
0028d3                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028d4                           triangle_duty_macro: .byte 2
0028d6                           triangle_duty_macro_offset: .byte 1
0028d7                           triangle_duty_macro_loop: .byte 1
0028d8                           triangle_duty_macro_release: .byte 1
                                 
0028d9                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028db                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028dd                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028df                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028e1                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028e3                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028e5                           triangle_fx_3xx_target: .byte 2 //target note period
0028e7                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028e9                           triangle_fx_3xx_total_offset: .byte 2
0028eb                           triangle_fx_4xy_speed: .byte 1
0028ec                           triangle_fx_4xy_depth: .byte 1
0028ed                           triangle_fx_4xy_phase: .byte 1
0028ee                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028ef                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028f0                           triangle_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
0028f1                           triangle_fx_Qxy_target: .byte 2 //target note period
0028f3                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028f5                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028f7                           triangle_fx_Rxy_target: .byte 2 //target note period
0028f9                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028fb                           triangle_fx_Rxy_total_offset: .byte 2
0028fd                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028fe                           triangle_fx_Sxx_post: .byte 1
                                 
                                 
0028ff                           noise_pattern_delay: .byte 1
002900                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 
                                 reset:
000000 940c 128f                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 163f                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 156c                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1577                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 156c                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 158e                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 15db                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 1628                 	jmp triangle_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(61): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(103): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(114): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(120): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(126): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(141): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(142): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(143): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(160): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(164): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(165): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(166): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(167): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(168): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(169): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(170): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(173): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(174): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(175): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(179): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(180): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(181): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(182): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(184): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(185): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(186): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(187): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(189): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(190): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(191): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(192): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(193): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(194): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(197): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(198): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(199): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(311): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(312): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(314): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(319): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(320): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(322): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(323): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(324): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(325): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(326): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(327): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(329): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(333): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(334): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(335): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(336): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(338): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(339): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(341): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(345): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(349): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(350): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(351): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(352): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(354): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(355): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(356): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(359): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(360): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(363): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(364): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(366): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(373): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(374): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
00128f edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
001290 93c0 0034                 	sts CPU_CCP, r28
001292 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
001293 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001295 2422                      	clr zero
                                 
                                 	//MEMORY
001296 e3c0                      	ldi r28, 0b00110000
001297 93c0 2800                 	sts pulse1_param, r28
001299 e8c0                      	ldi r28, 0b10000000
00129a 93c0 2801                 	sts pulse1_sweep_param, r28
00129c efcf                      	ldi r28, 0xFF
00129d 93c0 2802                 	sts pulse1_timerL, r28
00129f 93c0 2803                 	sts pulse1_timerH, r28
0012a1 93c0 2804                 	sts pulse1_length, r28
                                 
0012a3 e3c0                      	ldi r28, 0b00110000
0012a4 93c0 2808                 	sts pulse2_param, r28
0012a6 e8c0                      	ldi r28, 0b10000000
0012a7 93c0 2809                 	sts pulse2_sweep_param, r28
0012a9 efcf                      	ldi r28, 0xFF
0012aa 93c0 280a                 	sts pulse2_timerL, r28
0012ac 93c0 280b                 	sts pulse2_timerH, r28
0012ae 93c0 280c                 	sts pulse2_length, r28
                                 
0012b0 efcf                      	ldi r28, 0xFF
0012b1 93c0 2810                 	sts triangle_timerL, r28
0012b3 93c0 2811                 	sts triangle_timerH, r28
                                 
0012b5 e0c2                      	ldi r28, 0x02
0012b6 93c0 2815                 	sts song_frame_offset, r28
0012b8 9220 2816                 	sts song_frame_offset+1, zero
0012ba efcf                      	ldi r28, 0xFF
0012bb 93c0 281a                 	sts song_fx_Bxx, r28
0012bd 9220 281b                 	sts song_fx_Cxx, zero
0012bf 9220 281c                 	sts song_fx_Dxx, zero
0012c1 e0e2                      	ldi ZL, LOW(song0_frames << 1)
0012c2 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
0012c3 93e0 2813                 	sts song_frames, ZL
0012c5 93f0 2814                 	sts song_frames+1, ZH
0012c7 91c5                      	lpm r28, Z+ //load the song size
0012c8 91d5                      	lpm r29, Z+
0012c9 93c0 2817                 	sts song_size, r28
0012cb 93d0 2818                 	sts song_size+1, r29
0012cd 9220 2819                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0012cf 91c5                      	lpm r28, Z+
0012d0 91d5                      	lpm r29, Z+
0012d1 0fcc                      	lsl r28
0012d2 1fdd                      	rol r29
0012d3 93c0 281d                 	sts pulse1_pattern, r28
0012d5 93d0 281e                 	sts pulse1_pattern+1, r29
0012d7 9220 281f                 	sts pulse1_pattern_delay_rows, zero
0012d9 9220 2820                 	sts pulse1_pattern_delay_frames, zero
0012db 9220 2821                 	sts pulse1_pattern_offset, zero
0012dd 9220 2822                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0012df 91c5                      	lpm r28, Z+
0012e0 91d5                      	lpm r29, Z+
0012e1 0fcc                      	lsl r28
0012e2 1fdd                      	rol r29
0012e3 93c0 286a                 	sts pulse2_pattern, r28
0012e5 93d0 286b                 	sts pulse2_pattern+1, r29
0012e7 9220 286c                 	sts pulse2_pattern_delay_rows, zero
0012e9 9220 286d                 	sts pulse2_pattern_delay_frames, zero
0012eb 9220 286e                 	sts pulse2_pattern_offset, zero
0012ed 9220 286f                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0012ef 91c5                      	lpm r28, Z+
0012f0 91d5                      	lpm r29, Z+
0012f1 0fcc                      	lsl r28
0012f2 1fdd                      	rol r29
0012f3 93c0 28b7                 	sts triangle_pattern, r28
0012f5 93d0 28b8                 	sts triangle_pattern+1, r29
0012f7 9220 28b9                 	sts triangle_pattern_delay_rows, zero
0012f9 9220 28ba                 	sts triangle_pattern_delay_frames, zero
0012fb 9220 28bb                 	sts triangle_pattern_offset, zero
0012fd 9220 28bc                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0012ff efcf                      	ldi r28, 0xFF
001300 9220 2825                 	sts pulse1_volume_macro_offset, zero
001302 93c0 2826                 	sts pulse1_volume_macro_loop, r28
001304 93c0 2827                 	sts pulse1_volume_macro_release, r28
001306 9220 282a                 	sts pulse1_arpeggio_macro_offset, zero
001308 93c0 282b                 	sts pulse1_arpeggio_macro_loop, r28
00130a 93c0 282c                 	sts pulse1_arpeggio_macro_release, r28
00130c 93c0 282d                 	sts pulse1_arpeggio_macro_mode, r28
00130e 9220 2831                 	sts pulse1_pitch_macro_offset, zero
001310 93c0 2832                 	sts pulse1_pitch_macro_loop, r28
001312 93c0 2833                 	sts pulse1_pitch_macro_release, r28
001314 9220 2837                 	sts pulse1_hi_pitch_macro_offset, zero
001316 93c0 2838                 	sts pulse1_hi_pitch_macro_loop, r28
001318 93c0 2839                 	sts pulse1_hi_pitch_macro_release, r28
00131a 9220 283c                 	sts pulse1_duty_macro_offset, zero
00131c 93c0 283d                 	sts pulse1_duty_macro_loop, r28
00131e 93c0 283e                 	sts pulse1_duty_macro_release, r28
                                 
001320 9220 2823                 	sts pulse1_volume_macro, zero
001322 9220 2824                 	sts pulse1_volume_macro+1, zero
001324 9220 2828                 	sts pulse1_arpeggio_macro, zero
001326 9220 2829                 	sts pulse1_arpeggio_macro+1, zero
001328 9220 282e                 	sts pulse1_total_pitch_offset, zero
00132a 9220 282f                 	sts pulse1_pitch_macro, zero
00132c 9220 2830                 	sts pulse1_pitch_macro+1, zero
00132e 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero
001330 9220 2835                 	sts pulse1_hi_pitch_macro, zero
001332 9220 2836                 	sts pulse1_hi_pitch_macro+1, zero
001334 9220 283a                 	sts pulse1_duty_macro, zero
001336 9220 283b                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001338 e00f                      	ldi pulse1_volume_divider, 0x0F
001339 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00133b 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
00133c 9190 2800                 	lds pulse_channel_flags, pulse1_param
00133e 7390                      	andi pulse_channel_flags, 0b00110000
00133f 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001340 9220 2806                 	sts pulse1_output_volume, zero
001342 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001344 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001345 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001346 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001347 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
001349 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
00134a 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
00134b efcf                      	ldi r28, 0xFF
00134c 9220 283f                 	sts pulse1_fx_0xy_sequence, zero
00134e 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
001350 9220 2841                 	sts pulse1_fx_1xx, zero
001352 9220 2842                 	sts pulse1_fx_1xx+1, zero
001354 9220 2843                 	sts pulse1_fx_1xx_total, zero
001356 9220 2844                 	sts pulse1_fx_1xx_total+1, zero
001358 9220 2845                 	sts pulse1_fx_2xx, zero
00135a 9220 2846                 	sts pulse1_fx_2xx+1, zero
00135c 9220 2847                 	sts pulse1_fx_2xx_total, zero
00135e 9220 2848                 	sts pulse1_fx_2xx_total+1, zero
001360 9220 2849                 	sts pulse1_fx_3xx_start, zero
001362 9220 284a                 	sts pulse1_fx_3xx_start+1, zero
001364 9220 284b                 	sts pulse1_fx_3xx_target, zero
001366 9220 284c                 	sts pulse1_fx_3xx_target+1, zero
001368 9220 284d                 	sts pulse1_fx_3xx_speed, zero
00136a 9220 284e                 	sts pulse1_fx_3xx_speed+1, zero
00136c 9220 284f                 	sts pulse1_fx_3xx_total_offset, zero
00136e 9220 2850                 	sts pulse1_fx_3xx_total_offset+1, zero
001370 9220 2851                 	sts pulse1_fx_4xy_speed, zero
001372 9220 2852                 	sts pulse1_fx_4xy_depth, zero
001374 9220 2853                 	sts pulse1_fx_4xy_phase, zero
001376 9220 2854                 	sts pulse1_fx_7xy_speed, zero
001378 9220 2855                 	sts pulse1_fx_7xy_depth, zero
00137a 9220 2856                 	sts pulse1_fx_7xy_phase, zero
00137c 9220 2857                 	sts pulse1_fx_7xy_value, zero
00137e 9220 2858                 	sts pulse1_fx_Axy, zero
001380 93c0 2859                 	sts pulse1_fx_Gxx_pre, r28
001382 93c0 285a                 	sts pulse1_fx_Gxx_post, r28
001384 9220 285b                 	sts pulse1_fx_Pxx, zero
001386 9220 285c                 	sts pulse1_fx_Qxy_target, zero
001388 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
00138a 9220 285e                 	sts pulse1_fx_Qxy_speed, zero
00138c 9220 285f                 	sts pulse1_fx_Qxy_speed+1, zero
00138e 9220 2860                 	sts pulse1_fx_Qxy_total_offset, zero
001390 9220 2861                 	sts pulse1_fx_Qxy_total_offset+1, zero
001392 9220 2862                 	sts pulse1_fx_Rxy_target, zero
001394 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
001396 9220 2864                 	sts pulse1_fx_Rxy_speed, zero
001398 9220 2865                 	sts pulse1_fx_Rxy_speed+1, zero
00139a 9220 2866                 	sts pulse1_fx_Rxy_total_offset, zero
00139c 9220 2867                 	sts pulse1_fx_Rxy_total_offset+1, zero
00139e 93c0 2868                 	sts pulse1_fx_Sxx_pre, r28
0013a0 93c0 2869                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
0013a2 efcf                      	ldi r28, 0xFF
0013a3 9220 2872                 	sts pulse2_volume_macro_offset, zero
0013a5 93c0 2873                 	sts pulse2_volume_macro_loop, r28
0013a7 93c0 2874                 	sts pulse2_volume_macro_release, r28
0013a9 9220 2877                 	sts pulse2_arpeggio_macro_offset, zero
0013ab 93c0 2878                 	sts pulse2_arpeggio_macro_loop, r28
0013ad 93c0 2879                 	sts pulse2_arpeggio_macro_release, r28
0013af 93c0 287a                 	sts pulse2_arpeggio_macro_mode, r28
0013b1 9220 287e                 	sts pulse2_pitch_macro_offset, zero
0013b3 93c0 287f                 	sts pulse2_pitch_macro_loop, r28
0013b5 93c0 2880                 	sts pulse2_pitch_macro_release, r28
0013b7 9220 2884                 	sts pulse2_hi_pitch_macro_offset, zero
0013b9 93c0 2885                 	sts pulse2_hi_pitch_macro_loop, r28
0013bb 93c0 2886                 	sts pulse2_hi_pitch_macro_release, r28
0013bd 9220 2889                 	sts pulse2_duty_macro_offset, zero
0013bf 93c0 288a                 	sts pulse2_duty_macro_loop, r28
0013c1 93c0 288b                 	sts pulse2_duty_macro_release, r28
                                 
0013c3 9220 2870                 	sts pulse2_volume_macro, zero
0013c5 9220 2871                 	sts pulse2_volume_macro+1, zero
0013c7 9220 2875                 	sts pulse2_arpeggio_macro, zero
0013c9 9220 2876                 	sts pulse2_arpeggio_macro+1, zero
0013cb 9220 287b                 	sts pulse2_total_pitch_offset, zero
0013cd 9220 287c                 	sts pulse2_pitch_macro, zero
0013cf 9220 287d                 	sts pulse2_pitch_macro+1, zero
0013d1 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero
0013d3 9220 2882                 	sts pulse2_hi_pitch_macro, zero
0013d5 9220 2883                 	sts pulse2_hi_pitch_macro+1, zero
0013d7 9220 2887                 	sts pulse2_duty_macro, zero
0013d9 9220 2888                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0013db e02f                      	ldi pulse2_volume_divider, 0x0F
0013dc 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0013de 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0013df 91d0 2808                 	lds r29, pulse2_param
0013e1 73d0                      	andi r29, 0b00110000
0013e2 62d0                      	sbr r29, 0b0100000 //set start flag
0013e3 95d2                      	swap r29
0013e4 2b9d                      	or pulse_channel_flags, r29
0013e5 9220 280e                 	sts pulse2_output_volume, zero
0013e7 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0013e9 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0013ea e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0013eb 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0013ec 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0013ee 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
0013ef 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0013f0 efcf                      	ldi r28, 0xFF
0013f1 9220 288c                 	sts pulse2_fx_0xy_sequence, zero
0013f3 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
0013f5 9220 288e                 	sts pulse2_fx_1xx, zero
0013f7 9220 288f                 	sts pulse2_fx_1xx+1, zero
0013f9 9220 2890                 	sts pulse2_fx_1xx_total, zero
0013fb 9220 2891                 	sts pulse2_fx_1xx_total+1, zero
0013fd 9220 2892                 	sts pulse2_fx_2xx, zero
0013ff 9220 2893                 	sts pulse2_fx_2xx+1, zero
001401 9220 2894                 	sts pulse2_fx_2xx_total, zero
001403 9220 2895                 	sts pulse2_fx_2xx_total+1, zero
001405 9220 2896                 	sts pulse2_fx_3xx_start, zero
001407 9220 2897                 	sts pulse2_fx_3xx_start+1, zero
001409 9220 2898                 	sts pulse2_fx_3xx_target, zero
00140b 9220 2899                 	sts pulse2_fx_3xx_target+1, zero
00140d 9220 289a                 	sts pulse2_fx_3xx_speed, zero
00140f 9220 289b                 	sts pulse2_fx_3xx_speed+1, zero
001411 9220 289c                 	sts pulse2_fx_3xx_total_offset, zero
001413 9220 289d                 	sts pulse2_fx_3xx_total_offset+1, zero
001415 9220 289e                 	sts pulse2_fx_4xy_speed, zero
001417 9220 289f                 	sts pulse2_fx_4xy_depth, zero
001419 9220 28a0                 	sts pulse2_fx_4xy_phase, zero
00141b 9220 28a1                 	sts pulse2_fx_7xy_speed, zero
00141d 9220 28a2                 	sts pulse2_fx_7xy_depth, zero
00141f 9220 28a3                 	sts pulse2_fx_7xy_phase, zero
001421 9220 28a4                 	sts pulse2_fx_7xy_value, zero
001423 9220 28a5                 	sts pulse2_fx_Axy, zero
001425 93c0 28a6                 	sts pulse2_fx_Gxx_pre, r28
001427 93c0 28a7                 	sts pulse2_fx_Gxx_post, r28
001429 9220 28a8                 	sts pulse2_fx_Pxx, zero
00142b 9220 28a9                 	sts pulse2_fx_Qxy_target, zero
00142d 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
00142f 9220 28ab                 	sts pulse2_fx_Qxy_speed, zero
001431 9220 28ac                 	sts pulse2_fx_Qxy_speed+1, zero
001433 9220 28ad                 	sts pulse2_fx_Qxy_total_offset, zero
001435 9220 28ae                 	sts pulse2_fx_Qxy_total_offset+1, zero
001437 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001439 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
00143b 9220 28b1                 	sts pulse2_fx_Rxy_speed, zero
00143d 9220 28b2                 	sts pulse2_fx_Rxy_speed+1, zero
00143f 9220 28b3                 	sts pulse2_fx_Rxy_total_offset, zero
001441 9220 28b4                 	sts pulse2_fx_Rxy_total_offset+1, zero
001443 93c0 28b5                 	sts pulse2_fx_Sxx_pre, r28
001445 93c0 28b6                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
001447 efcf                      	ldi r28, 0xFF
001448 9220 28bf                 	sts triangle_volume_macro_offset, zero
00144a 93c0 28c0                 	sts triangle_volume_macro_loop, r28
00144c 93c0 28c1                 	sts triangle_volume_macro_release, r28
00144e 9220 28c4                 	sts triangle_arpeggio_macro_offset, zero
001450 93c0 28c5                 	sts triangle_arpeggio_macro_loop, r28
001452 93c0 28c6                 	sts triangle_arpeggio_macro_release, r28
001454 93c0 28c7                 	sts triangle_arpeggio_macro_mode, r28
001456 9220 28cb                 	sts triangle_pitch_macro_offset, zero
001458 93c0 28cc                 	sts triangle_pitch_macro_loop, r28
00145a 93c0 28cd                 	sts triangle_pitch_macro_release, r28
00145c 9220 28d1                 	sts triangle_hi_pitch_macro_offset, zero
00145e 93c0 28d2                 	sts triangle_hi_pitch_macro_loop, r28
001460 93c0 28d3                 	sts triangle_hi_pitch_macro_release, r28
001462 9220 28d6                 	sts triangle_duty_macro_offset, zero
001464 93c0 28d7                 	sts triangle_duty_macro_loop, r28
001466 93c0 28d8                 	sts triangle_duty_macro_release, r28
                                 
001468 9220 28bd                 	sts triangle_volume_macro, zero
00146a 9220 28be                 	sts triangle_volume_macro+1, zero
00146c 9220 28c2                 	sts triangle_arpeggio_macro, zero
00146e 9220 28c3                 	sts triangle_arpeggio_macro+1, zero
001470 9220 28c8                 	sts triangle_total_pitch_offset, zero
001472 9220 28c9                 	sts triangle_pitch_macro, zero
001474 9220 28ca                 	sts triangle_pitch_macro+1, zero
001476 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero
001478 9220 28cf                 	sts triangle_hi_pitch_macro, zero
00147a 9220 28d0                 	sts triangle_hi_pitch_macro+1, zero
00147c 9220 28d4                 	sts triangle_duty_macro, zero
00147e 9220 28d5                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 SEQUENCE
001480 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
001481 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 3 FX
001482 efcf                      	ldi r28, 0xFF
001483 9220 28d9                 	sts triangle_fx_0xy_sequence, zero
001485 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
001487 9220 28db                 	sts triangle_fx_1xx, zero
001489 9220 28dc                 	sts triangle_fx_1xx+1, zero
00148b 9220 28dd                 	sts triangle_fx_1xx_total, zero
00148d 9220 28de                 	sts triangle_fx_1xx_total+1, zero
00148f 9220 28df                 	sts triangle_fx_2xx, zero
001491 9220 28e0                 	sts triangle_fx_2xx+1, zero
001493 9220 28e1                 	sts triangle_fx_2xx_total, zero
001495 9220 28e2                 	sts triangle_fx_2xx_total+1, zero
001497 9220 28e3                 	sts triangle_fx_3xx_start, zero
001499 9220 28e4                 	sts triangle_fx_3xx_start+1, zero
00149b 9220 28e5                 	sts triangle_fx_3xx_target, zero
00149d 9220 28e6                 	sts triangle_fx_3xx_target+1, zero
00149f 9220 28e7                 	sts triangle_fx_3xx_speed, zero
0014a1 9220 28e8                 	sts triangle_fx_3xx_speed+1, zero
0014a3 9220 28e9                 	sts triangle_fx_3xx_total_offset, zero
0014a5 9220 28ea                 	sts triangle_fx_3xx_total_offset+1, zero
0014a7 9220 28eb                 	sts triangle_fx_4xy_speed, zero
0014a9 9220 28ec                 	sts triangle_fx_4xy_depth, zero
0014ab 9220 28ed                 	sts triangle_fx_4xy_phase, zero
0014ad 93c0 28ee                 	sts triangle_fx_Gxx_pre, r28
0014af 93c0 28ef                 	sts triangle_fx_Gxx_post, r28
0014b1 9220 28f0                 	sts triangle_fx_Pxx, zero
0014b3 9220 28f1                 	sts triangle_fx_Qxy_target, zero
0014b5 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
0014b7 9220 28f3                 	sts triangle_fx_Qxy_speed, zero
0014b9 9220 28f4                 	sts triangle_fx_Qxy_speed+1, zero
0014bb 9220 28f5                 	sts triangle_fx_Qxy_total_offset, zero
0014bd 9220 28f6                 	sts triangle_fx_Qxy_total_offset+1, zero
0014bf 9220 28f7                 	sts triangle_fx_Rxy_target, zero
0014c1 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
0014c3 9220 28f9                 	sts triangle_fx_Rxy_speed, zero
0014c5 9220 28fa                 	sts triangle_fx_Rxy_speed+1, zero
0014c7 9220 28fb                 	sts triangle_fx_Rxy_total_offset, zero
0014c9 9220 28fc                 	sts triangle_fx_Rxy_total_offset+1, zero
0014cb 93c0 28fd                 	sts triangle_fx_Sxx_pre, r28
0014cd 93c0 28fe                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//PINS
0014cf efcf                      	ldi r28, 0xFF
0014d0 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0014d1 e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0014d2 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
0014d4 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0014d5 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
0014d7 e1c5                      	ldi r28, 0x15 //set the period for CMP0
0014d8 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
0014da e0c5                      	ldi r28, 0x05
0014db 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
0014dd e2cb                      	ldi r28, 0x2B //set the period for CMP1
0014de 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
0014e0 e0ca                      	ldi r28, 0x0A
0014e1 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
0014e3 e4c1                      	ldi r28, 0x41 //set the period for CMP2
0014e4 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
0014e6 e0cf                      	ldi r28, 0x0F
0014e7 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
0014e9 e5c7                      	ldi r28, 0x57 //set the period for OVF
0014ea 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
0014ec e1c4                      	ldi r28, 0x14
0014ed 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
0014ef e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0014f0 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0014f2 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
0014f3 93c0 0a81                 	sts TCB0_CTRLB, r28
0014f5 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
0014f6 93c0 0a85                 	sts TCB0_INTCTRL, r28
0014f8 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
0014fa 93c0 0a8c                 	sts TCB0_CCMPL, r28
0014fc 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
0014fe 93c0 0a8d                 	sts TCB0_CCMPH, r28
001500 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001501 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001503 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001504 93b0 0a91                 	sts TCB1_CTRLB, r27
001506 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001507 93b0 0a95                 	sts TCB1_INTCTRL, r27
001509 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00150b 93b0 0a9c                 	sts TCB1_CCMPL, r27
00150d 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
00150f 93b0 0a9d                 	sts TCB1_CCMPH, r27
001511 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001512 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001514 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001515 93b0 0aa1                 	sts TCB2_CTRLB, r27
001517 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001518 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00151a 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
00151c 93b0 0aac                 	sts TCB2_CCMPL, r27
00151e 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
001520 93b0 0aad                 	sts TCB2_CCMPH, r27
001522 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001523 93b0 0aa0                 	sts TCB2_CTRLA, r27
001525 9478                      	sei //global interrupt enable
                                 
                                 volume_mixer:
001526 91c0 2806                 	lds r28, pulse1_output_volume
001528 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
00152a fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
00152b c015                      	rjmp volume_mixer_pulse1_off
                                 
00152c 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
00152d f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
00152e 91e0 0a8c                 	lds r30, TCB0_CCMPL
001530 e5f9                      	ldi r31, 0x059
001531 17ef                      	cp r30, r31
001532 91e0 0a8d                 	lds r30, TCB0_CCMPH
001534 e0f0                      	ldi r31, 0x00
001535 07ef                      	cpc r30, r31
001536 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
001537 91e0 0a8c                 	lds r30, TCB0_CCMPL
001539 e6f6                      	ldi r31, 0x66
00153a 17ef                      	cp r30, r31
00153b 91e0 0a8d                 	lds r30, TCB0_CCMPH
00153d e5f9                      	ldi r31, 0x59
00153e 07ef                      	cpc r30, r31
00153f f408                      	brsh volume_mixer_pulse1_off
001540 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
001541 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
001542 fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
001543 c015                      	rjmp volume_mixer_pulse2_off
                                 
001544 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
001545 f099                      	breq volume_mixer_pulse2_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
001546 91e0 0a9c                 	lds r30, TCB1_CCMPL
001548 e5f9                      	ldi r31, 0x059
001549 17ef                      	cp r30, r31
00154a 91e0 0a9d                 	lds r30, TCB1_CCMPH
00154c e0f0                      	ldi r31, 0x00
00154d 07ef                      	cpc r30, r31
00154e f050                      	brlo volume_mixer_pulse2_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
00154f 91e0 0a9c                 	lds r30, TCB1_CCMPL
001551 e6f6                      	ldi r31, 0x66
001552 17ef                      	cp r30, r31
001553 91e0 0a9d                 	lds r30, TCB1_CCMPH
001555 e5f9                      	ldi r31, 0x59
001556 07ef                      	cpc r30, r31
001557 f408                      	brsh volume_mixer_pulse2_off
001558 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001559 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
00155a 0fcd                      	add r28, r29
00155b e1e6                      	ldi ZL, LOW(pulse_volume_table << 1)
00155c e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
00155d 0fec                      	add ZL, r28
00155e 1df2                      	adc ZH, zero
00155f 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001560 2fd4                      	mov r29, triangle_sequence
001561 fdd4                      	sbrc r29, 4 //check 5th bit
001562 95d0                      	com r29
001563 70df                      	andi r29, 0x0F
                                 
                                 volume_mixer_tnd_out:
001564 e3e6                      	ldi ZL, LOW(tnd_volume_table << 1)
001565 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
001566 0fed                      	add ZL, r29
001567 1df2                      	adc ZH, zero
001568 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001569 0fcd                      	add r28, r29
00156a b9c1                      	out VPORTA_OUT, r28
00156b cfba                      	rjmp volume_mixer
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
00156c b7bf                      	in r27, CPU_SREG
00156d 93bf                      	push r27
00156e 94f8                      	cli
                                 
                                 	//ENVELOPE
00156f d053                      	rcall pulse1_envelope_routine
001570 d09f                      	rcall pulse2_envelope_routine
                                 
001571 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
001572 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001574 91bf                      	pop r27
001575 bfbf                      	out CPU_SREG, r27
001576 9518                      	reti
                                 
                                 sequence_1_3:
001577 b7bf                      	in r27, CPU_SREG
001578 93bf                      	push r27
001579 94f8                      	cli
                                 
                                 	//ENVELOPE
00157a d048                      	rcall pulse1_envelope_routine
00157b d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
00157c fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
00157d d01b                      	rcall pulse1_sweep_routine
00157e fcf3                      	sbrc pulse2_sweep, 3
00157f d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001580 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001581 c002                      	rjmp sequence_1_3_pulse2_length
001582 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001583 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001584 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001585 c002                      	rjmp sequence_1_3_exit
001586 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001587 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001588 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
001589 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00158b 91bf                      	pop r27
00158c bfbf                      	out CPU_SREG, r27
00158d 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
00158e b7bf                      	in r27, CPU_SREG
00158f 93bf                      	push r27
001590 94f8                      	cli
                                 
001591 0caa                      	lsl pulse1_sequence //shifts sequence to the left
001592 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001593 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001594 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001596 91bf                      	pop r27
001597 bfbf                      	out CPU_SREG, r27
001598 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001599 2dbc                      	mov r27, pulse1_sweep
00159a 70b7                      	andi r27, 0x07 //mask for period divider bits
00159b f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00159c 93df                      	push r29
00159d 2ddc                      	mov r29, pulse1_sweep
00159e 95d2                      	swap r29
00159f 70d7                      	andi r29, 0x07 //mask for shift bits
0015a0 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
0015a1 91df                      	pop r29
0015a2 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
0015a3 91a0 0a8c                 	lds r26, TCB0_CCMPL
0015a5 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
0015a7 95b6                      	lsr r27
0015a8 95a7                      	ror r26
0015a9 95da                      	dec r29
0015aa f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0015ab fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
0015ac c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0015ad 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
0015ae 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
0015af 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
0015b1 0fad                      	add r26, r29
0015b2 91d0 0a8d                 	lds r29, TCB0_CCMPH
0015b4 1fbd                      	adc r27, r29
                                 
0015b5 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
0015b7 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0015b9 91df                      	pop r29
0015ba c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
0015bb 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
0015bc ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
0015bd 9508                      	ret
                                 
                                 pulse1_sweep_reload:
0015be 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0015c0 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
0015c1 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
0015c2 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
0015c3 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
0015c4 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
0015c5 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0015c6 f011                      	breq PC+3 //if the divider == 0, check loop flag
0015c7 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0015c8 9508                      	ret
                                 
0015c9 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0015cb 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0015cc ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
0015cd c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0015ce e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0015cf 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
0015d0 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0015d1 f409                      	brne PC+2 //if decay != 0, go decrement
0015d2 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0015d3 951a                      	dec pulse1_volume_decay
0015d4 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0015d5 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
0015d6 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0015d8 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0015d9 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0015da 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
0015db b7bf                      	in r27, CPU_SREG
0015dc 93bf                      	push r27
0015dd 94f8                      	cli
                                 
0015de 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
0015df 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0015e0 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0015e1 93b0 0a96                 	sts TCB1_INTFLAGS, r27
0015e3 91bf                      	pop r27
0015e4 bfbf                      	out CPU_SREG, r27
0015e5 9518                      	reti
                                 
                                 pulse2_sweep_routine:
0015e6 2dbf                      	mov r27, pulse2_sweep
0015e7 70b7                      	andi r27, 0x07 //mask for period divider bits
0015e8 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0015e9 93df                      	push r29
0015ea 2ddf                      	mov r29, pulse2_sweep
0015eb 95d2                      	swap r29
0015ec 70d7                      	andi r29, 0x07 //mask for shift bits
0015ed f411                      	brne pulse2_sweep_routine_action_main //shift != 0
0015ee 91df                      	pop r29
0015ef c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
0015f0 91a0 0a9c                 	lds r26, TCB1_CCMPL
0015f2 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
0015f4 95b6                      	lsr r27
0015f5 95a7                      	ror r26
0015f6 95da                      	dec r29
0015f7 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0015f8 fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
0015f9 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0015fa 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
0015fb 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
0015fc 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
0015fe 0fad                      	add r26, r29
0015ff 91d0 0a9d                 	lds r29, TCB1_CCMPH
001601 1fbd                      	adc r27, r29
                                 
001602 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
001604 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001606 91df                      	pop r29
001607 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
001608 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
001609 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
00160a 9508                      	ret
                                 
                                 pulse2_sweep_reload:
00160b 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
00160d 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
00160e 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
00160f 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
001610 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
001611 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
001612 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
001613 f011                      	breq PC+3 //if the divider == 0, check loop flag
001614 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
001615 9508                      	ret
                                 
001616 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
001618 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001619 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
00161a c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
00161b e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
00161c 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
00161d 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
00161e f409                      	brne PC+2 //if decay != 0, go decrement
00161f 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001620 953a                      	dec pulse2_volume_decay
001621 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
001622 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
001623 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
001625 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001626 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
001627 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
001628 b7bf                      	in r27, CPU_SREG
001629 93bf                      	push r27
00162a 94f8                      	cli
                                 
00162b 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
00162c 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
00162d e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00162e 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
001630 91bf                      	pop r27
001631 bfbf                      	out CPU_SREG, r27
001632 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001633 e3e8                      	ldi ZL, LOW(length << 1)
001634 e5f3                      	ldi ZH, HIGH(length << 1)
001635 0fed                      	add ZL, r29
001636 1df2                      	adc ZH, zero
001637 91d4                      	lpm r29, Z
001638 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001639 e5e8                      	ldi ZL, LOW(sequences << 1)
00163a e5f3                      	ldi ZH, HIGH(sequences << 1)
00163b 0fed                      	add ZL, r29
00163c 1df2                      	adc ZH, zero
00163d 91d4                      	lpm r29, Z
00163e 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
00163f b7bf                      	in r27, CPU_SREG
001640 93bf                      	push r27
001641 94f8                      	cli
001642 93cf                      	push r28
001643 93df                      	push r29
001644 93ef                      	push r30
001645 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001646 91a0 281a                 	lds r26, song_fx_Bxx
001648 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001649 f4a9                      	brne sound_driver_fx_Bxx_routine
00164a 91a0 281b                 	lds r26, song_fx_Cxx
00164c 11a2                      	cpse r26, zero
00164d c05b                      	rjmp sound_driver_fx_Cxx_routine
00164e 91a0 281c                 	lds r26, song_fx_Dxx
001650 11a2                      	cpse r26, zero
001651 c068                      	rjmp sound_driver_fx_Dxx_routine
                                 
001652 91a0 2815                 	lds r26, song_frame_offset
001654 91b0 2816                 	lds r27, song_frame_offset+1
001656 91c0 2817                 	lds r28, song_size
001658 91d0 2818                 	lds r29, song_size+1
00165a 17ac                      	cp r26, r28
00165b 07bd                      	cpc r27, r29
00165c f408                      	brsh sound_driver_fx_song_loop
00165d c0a3                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
00165e e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
00165f 91e0 2813                 	lds ZL, song_frames
001661 91f0 2814                 	lds ZH, song_frames+1
001663 27cc                      	clr r28 //initialize r29:r28 to 0
001664 27dd                      	clr r29
001665 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001666 95aa                      	dec r26
001667 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001668 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001669 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
00166a 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
00166b 93c0 2815                 	sts song_frame_offset, r28
00166d 93d0 2816                 	sts song_frame_offset+1, r29
00166f 0fec                      	add ZL, r28
001670 1ffd                      	adc ZH, r29
                                 
001671 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
001672 91b5                      	lpm r27, Z+
001673 0faa                      	lsl r26
001674 1fbb                      	rol r27
001675 93a0 281d                 	sts pulse1_pattern, r26
001677 93b0 281e                 	sts pulse1_pattern+1, r27
001679 91a5                      	lpm r26, Z+
00167a 91b5                      	lpm r27, Z+
00167b 0faa                      	lsl r26
00167c 1fbb                      	rol r27
00167d 93a0 286a                 	sts pulse2_pattern, r26
00167f 93b0 286b                 	sts pulse2_pattern+1, r27
001681 91a5                      	lpm r26, Z+
001682 91b5                      	lpm r27, Z+
001683 0faa                      	lsl r26
001684 1fbb                      	rol r27
001685 93a0 28b7                 	sts triangle_pattern, r26
001687 93b0 28b8                 	sts triangle_pattern+1, r27
                                 
001689 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00168b 9220 2822                 	sts pulse1_pattern_offset+1, zero
00168d 9220 281f                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00168f 9220 2820                 	sts pulse1_pattern_delay_frames, zero
001691 9220 286e                 	sts pulse2_pattern_offset, zero
001693 9220 286f                 	sts pulse2_pattern_offset+1, zero
001695 9220 286c                 	sts pulse2_pattern_delay_rows, zero
001697 9220 286d                 	sts pulse2_pattern_delay_frames, zero
001699 9220 28bb                 	sts triangle_pattern_offset, zero
00169b 9220 28bc                 	sts triangle_pattern_offset+1, zero
00169d 9220 28b9                 	sts triangle_pattern_delay_rows, zero
00169f 9220 28ba                 	sts triangle_pattern_delay_frames, zero
                                 
0016a1 efaf                      	ldi r26, 0xFF
0016a2 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
0016a4 9220 281b                 	sts song_fx_Cxx, zero
0016a6 9220 281c                 	sts song_fx_Dxx, zero
0016a8 c058                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0016a9 91ff                      	pop r31
0016aa 91ef                      	pop r30
0016ab 91df                      	pop r29
0016ac 91cf                      	pop r28
0016ad 91bf                      	pop r27
0016ae bfbf                      	out CPU_SREG, r27
0016af 94f8                      	cli //disable global interrupts
                                 		
0016b0 efaf                      	ldi r26, 0xFF
0016b1 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
0016b3 9220 281b                 	sts song_fx_Cxx, zero
0016b5 9220 281c                 	sts song_fx_Dxx, zero
                                 
0016b7 9220 2806                 	sts pulse1_output_volume, zero //mute all channels
0016b9 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0016ba 91e0 2813                 	lds ZL, song_frames
0016bc 91f0 2814                 	lds ZH, song_frames+1
0016be 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0016c0 91b0 2816                 	lds r27, song_frame_offset+1
0016c2 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0016c3 93a0 2815                 	sts song_frame_offset, r26
0016c5 93b0 2816                 	sts song_frame_offset+1, r27
0016c7 0fea                      	add ZL, r26
0016c8 1ffb                      	adc ZH, r27
                                 
0016c9 91a5                      	lpm r26, Z+ //load the address of the next pattern
0016ca 91b5                      	lpm r27, Z+
0016cb 0faa                      	lsl r26
0016cc 1fbb                      	rol r27
0016cd 93a0 281d                 	sts pulse1_pattern, r26
0016cf 93b0 281e                 	sts pulse1_pattern+1, r27
0016d1 91a5                      	lpm r26, Z+
0016d2 91b5                      	lpm r27, Z+
0016d3 0faa                      	lsl r26
0016d4 1fbb                      	rol r27
0016d5 93a0 286a                 	sts pulse2_pattern, r26
0016d7 93b0 286b                 	sts pulse2_pattern+1, r27
0016d9 91a5                      	lpm r26, Z+
0016da 91b5                      	lpm r27, Z+
0016db 0faa                      	lsl r26
0016dc 1fbb                      	rol r27
0016dd 93a0 28b7                 	sts triangle_pattern, r26
0016df 93b0 28b8                 	sts triangle_pattern+1, r27
                                 
0016e1 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0016e3 9220 2822                 	sts pulse1_pattern_offset+1, zero
0016e5 9220 281f                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0016e7 9220 2820                 	sts pulse1_pattern_delay_frames, zero
0016e9 9220 286e                 	sts pulse2_pattern_offset, zero
0016eb 9220 286f                 	sts pulse2_pattern_offset+1, zero
0016ed 9220 286c                 	sts pulse2_pattern_delay_rows, zero
0016ef 9220 286d                 	sts pulse2_pattern_delay_frames, zero
0016f1 9220 28bb                 	sts triangle_pattern_offset, zero
0016f3 9220 28bc                 	sts triangle_pattern_offset+1, zero
0016f5 9220 28b9                 	sts triangle_pattern_delay_rows, zero
0016f7 9220 28ba                 	sts triangle_pattern_delay_frames, zero
                                 
0016f9 efaf                      	ldi r26, 0xFF
0016fa 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
0016fc 9220 281b                 	sts song_fx_Cxx, zero
0016fe 9220 281c                 	sts song_fx_Dxx, zero
001700 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001701 91a0 281f                 	lds r26, pulse1_pattern_delay_rows
001703 91b0 2820                 	lds r27, pulse1_pattern_delay_frames
001705 9610                      	adiw r27:r26, 0
001706 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
001707 c2c2                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001708 91e0 281d                 	lds ZL, pulse1_pattern //current pattern for pulse 1
00170a 91f0 281e                 	lds ZH, pulse1_pattern+1
00170c 91a0 2821                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
00170e 91b0 2822                 	lds r27, pulse1_pattern_offset+1
001710 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001711 1ffb                      	adc ZH, r27
001712 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
001713 35b7                      	cpi r27, 0x57
001714 f408                      	brsh sound_driver_channel0_check_if_volume
001715 c16b                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001716 36b7                      	cpi r27, 0x67
001717 f408                      	brsh sound_driver_channel0_check_if_delay
001718 c1a3                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001719 3eb3                      	cpi r27, 0xE3
00171a f408                      	brsh sound_driver_channel0_check_if_instrument
00171b c1aa                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
00171c f409                      	brne sound_driver_channel0_check_if_release
00171d c1ad                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
00171e 3eb4                      	cpi r27, 0xE4
00171f f409                      	brne sound_driver_channel0_check_if_end
001720 c254                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001721 3fbf                      	cpi r27, 0xFF
001722 f409                      	brne sound_driver_channel0_check_if_fx
001723 c276                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001724 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001725 91a4                      	lpm r26, Z //load the fx data into r26
001726 d299                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001727 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001728 e5ec                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001729 e5f3                      	ldi ZH, HIGH(channel0_fx << 1)
00172a 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00172b 0feb                      	add ZL, r27 //add offset
00172c 1df2                      	adc ZH, zero
00172d 91c5                      	lpm r28, Z+ //load address bytes
00172e 91d4                      	lpm r29, Z
00172f 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001730 2ffd                      	mov ZH, r29
001731 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001732 93a0 283f                 	sts pulse1_fx_0xy_sequence, r26
001734 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
001736 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
001737 9220 2845                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001739 9220 2846                 	sts pulse1_fx_2xx+1, zero
00173b 9220 283f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00173d 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
00173f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001740 937f                      	push r23
001741 2f6a                      	mov r22, r26 //store the rate into r22
001742 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001743 9f67                      	mul r22, r23
001744 917f                      	pop r23
001745 916f                      	pop r22
                                 
001746 9416                      	lsr r1 //shift out the fractional bits
001747 9407                      	ror r0
001748 9416                      	lsr r1
001749 9407                      	ror r0
00174a 9416                      	lsr r1
00174b 9407                      	ror r0
00174c 9416                      	lsr r1
00174d 9407                      	ror r0
00174e 9200 2841                 	sts pulse1_fx_1xx, r0
001750 9210 2842                 	sts pulse1_fx_1xx+1, r1
001752 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001753 9220 2841                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001755 9220 2842                 	sts pulse1_fx_1xx+1, zero
001757 9220 283f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001759 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
00175b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00175c 937f                      	push r23
00175d 2f6a                      	mov r22, r26 //store the rate into r22
00175e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00175f 9f67                      	mul r22, r23
001760 917f                      	pop r23
001761 916f                      	pop r22
                                 
001762 9416                      	lsr r1 //shift out the fractional bits
001763 9407                      	ror r0
001764 9416                      	lsr r1
001765 9407                      	ror r0
001766 9416                      	lsr r1
001767 9407                      	ror r0
001768 9416                      	lsr r1
001769 9407                      	ror r0
00176a 9200 2845                 	sts pulse1_fx_2xx, r0
00176c 9210 2846                 	sts pulse1_fx_2xx+1, r1
00176e cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00176f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001770 937f                      	push r23
001771 2f6a                      	mov r22, r26 //store the rate into r22
001772 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001773 9f67                      	mul r22, r23
001774 917f                      	pop r23
001775 916f                      	pop r22
                                 
001776 9416                      	lsr r1 //shift out the fractional bits
001777 9407                      	ror r0
001778 9416                      	lsr r1
001779 9407                      	ror r0
00177a 9416                      	lsr r1
00177b 9407                      	ror r0
00177c 9416                      	lsr r1
00177d 9407                      	ror r0
00177e 9200 284d                 	sts pulse1_fx_3xx_speed, r0
001780 9210 284e                 	sts pulse1_fx_3xx_speed+1, r1
                                 
001782 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001783 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
001784 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
001785 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001787 91b0 0a8d                 	lds r27, TCB0_CCMPH
001789 93a0 2849                 	sts pulse1_fx_3xx_start, r26
00178b 93b0 284a                 	sts pulse1_fx_3xx_start+1, r27
                                 
00178d 9220 284f                 	sts pulse1_fx_3xx_total_offset, zero
00178f 9220 2850                 	sts pulse1_fx_3xx_total_offset+1, zero
001791 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
001792 2fba                      	mov r27, r26
001793 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001794 95a2                      	swap r26
001795 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001796 93a0 2851                 	sts pulse1_fx_4xy_speed, r26
001798 93b0 2852                 	sts pulse1_fx_4xy_depth, r27
00179a 9220 2853                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
00179c cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
00179d 2fba                      	mov r27, r26
00179e 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00179f 95a2                      	swap r26
0017a0 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0017a1 93a0 2854                 	sts pulse1_fx_7xy_speed, r26
0017a3 93b0 2855                 	sts pulse1_fx_7xy_depth, r27
0017a5 9220 2856                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0017a7 9220 2857                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0017a9 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0017aa 93a0 2858                 	sts pulse1_fx_Axy, r26
0017ac cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0017ad 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0017af cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0017b0 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0017b2 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0017b3 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0017b5 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0017b6 91b0 2800                 	lds r27, pulse1_param
0017b8 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0017b9 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0017ba 93b0 2800                 	sts pulse1_param, r27
0017bc 6096                      	sbr pulse_channel_flags, 6
0017bd cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
0017be 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0017c0 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0017c1 15a2                      	cp r26, zero
0017c2 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
0017c3 91b0 2819                 	lds r27, song_speed
0017c5 17ab                      	cp r26, r27
0017c6 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
0017c7 93a0 2859                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0017c9 e0b1                      	ldi r27, 0x01
0017ca 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
0017cc c200                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
0017cd cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0017ce cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0017cf cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0017d0 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0017d1 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0017d2 93a0 285b                 	sts pulse1_fx_Pxx, r26
0017d4 cf33                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
0017d5 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
0017d7 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
0017d9 9630                      	adiw Z, 0
0017da f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
0017db cf2c                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
0017dc 91e0 282f                 	lds ZL, pulse1_pitch_macro
0017de 91f0 2830                 	lds ZH, pulse1_pitch_macro+1
0017e0 9630                      	adiw Z, 0
0017e1 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
0017e2 cf25                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
0017e3 91e0 2835                 	lds ZL, pulse1_hi_pitch_macro
0017e5 91f0 2836                 	lds ZH, pulse1_hi_pitch_macro+1
0017e7 9630                      	adiw Z, 0
0017e8 f009                      	breq sound_driver_channel0_fx_Qxy_process
0017e9 cf1e                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
0017ea 2fba                      	mov r27, r26 //copy fx parameters into r27
0017eb 70bf                      	andi r27, 0x0F //mask note index offset
0017ec 91c0 2807                 	lds r28, pulse1_note //load current note index
0017ee 0fbc                      	add r27, r28
0017ef 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0017f0 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
0017f1 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
0017f2 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
0017f3 e0f0                      	ldi ZH, HIGH(note_table << 1)
0017f4 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0017f5 0feb                      	add ZL, r27 //add offset
0017f6 1df2                      	adc ZH, zero
0017f7 91c5                      	lpm r28, Z+ //load bytes
0017f8 91d4                      	lpm r29, Z
0017f9 93c0 285c                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
0017fb 93d0 285d                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0017fd 95a2                      	swap r26
0017fe 70af                      	andi r26, 0x0F //mask effect speed
0017ff 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001800 95a3                      	inc r26 //increment the speed by 1
                                 
001801 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001802 937f                      	push r23
001803 2f6a                      	mov r22, r26 //store the speed data into r27
001804 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001805 9f67                      	mul r22, r23
001806 917f                      	pop r23
001807 916f                      	pop r22
                                 
001808 9416                      	lsr r1 //shift out the fractional bits
001809 9407                      	ror r0
00180a 9416                      	lsr r1
00180b 9407                      	ror r0
00180c 9416                      	lsr r1
00180d 9407                      	ror r0
00180e 9416                      	lsr r1
00180f 9407                      	ror r0
                                 
001810 9200 285e                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001812 9210 285f                 	sts pulse1_fx_Qxy_speed+1, r1
001814 9220 2860                 	sts pulse1_fx_Qxy_total_offset, zero
001816 9220 2861                 	sts pulse1_fx_Qxy_total_offset+1, zero
001818 ceef                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001819 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
00181b 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
00181d 9630                      	adiw Z, 0
00181e f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
00181f cee8                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001820 91e0 282f                 	lds ZL, pulse1_pitch_macro
001822 91f0 2830                 	lds ZH, pulse1_pitch_macro+1
001824 9630                      	adiw Z, 0
001825 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001826 cee1                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001827 91e0 2835                 	lds ZL, pulse1_hi_pitch_macro
001829 91f0 2836                 	lds ZH, pulse1_hi_pitch_macro+1
00182b 9630                      	adiw Z, 0
00182c f009                      	breq sound_driver_channel0_fx_Rxy_process
00182d ceda                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
00182e 2fba                      	mov r27, r26 //copy fx parameters into r27
00182f 70bf                      	andi r27, 0x0F //mask note index offset
001830 91c0 2807                 	lds r28, pulse1_note //load current note index
001832 1bcb                      	sub r28, r27
001833 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001834 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001835 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001836 e0f0                      	ldi ZH, HIGH(note_table << 1)
001837 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001838 0fec                      	add ZL, r28 //add offset
001839 1df2                      	adc ZH, zero
00183a 91c5                      	lpm r28, Z+ //load bytes
00183b 91d4                      	lpm r29, Z
00183c 93c0 2862                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
00183e 93d0 2863                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001840 95a2                      	swap r26
001841 70af                      	andi r26, 0x0F //mask effect speed
001842 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001843 95a3                      	inc r26 //increment the speed by 1
                                 
001844 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001845 937f                      	push r23
001846 2f6a                      	mov r22, r26 //store the speed data into r27
001847 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001848 9f67                      	mul r22, r23
001849 917f                      	pop r23
00184a 916f                      	pop r22
                                 
00184b 9416                      	lsr r1 //shift out the fractional bits
00184c 9407                      	ror r0
00184d 9416                      	lsr r1
00184e 9407                      	ror r0
00184f 9416                      	lsr r1
001850 9407                      	ror r0
001851 9416                      	lsr r1
001852 9407                      	ror r0
                                 
001853 9200 2864                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001855 9210 2865                 	sts pulse1_fx_Rxy_speed+1, r1
001857 9220 2866                 	sts pulse1_fx_Rxy_total_offset, zero
001859 9220 2867                 	sts pulse1_fx_Rxy_total_offset+1, zero
00185b ceac                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
00185c 15a2                      	cp r26, zero
00185d f051                      	breq sound_driver_channel0_fx_Sxx_invalid
00185e 91b0 2819                 	lds r27, song_speed
001860 17ab                      	cp r26, r27
001861 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001862 93a0 2868                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001864 e0b1                      	ldi r27, 0x01
001865 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
001867 c165                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
001868 ce9f                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001869 e5e8                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00186a e5f3                      	ldi ZH, HIGH(sequences << 1)
00186b 0fea                      	add ZL, r26 //offset the pointer
00186c 1df2                      	adc ZH, zero
                                 
00186d 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00186e 95a7                      	ror r26
00186f 95a7                      	ror r26
001870 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001872 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001873 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001874 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001875 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001876 ce91                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001877 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001878 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001879 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00187a 93c0 2800                 	sts pulse1_param, r28
00187c ce8b                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
00187d ce8a                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
00187e ce89                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
00187f ce88                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001880 ce87                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001881 93b0 2807                 	sts pulse1_note, r27 //store the note index
001883 e0a3                      	ldi r26, 0x03
001884 e0b2                      	ldi r27, 0x02
001885 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001887 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
001889 93b0 2831                 	sts pulse1_pitch_macro_offset, r27
00188b 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27
00188d 93b0 283c                 	sts pulse1_duty_macro_offset, r27
00188f 9220 282e                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001891 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero
001893 9220 2843                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001895 9220 2844                 	sts pulse1_fx_1xx_total+1, zero
001897 9220 2847                 	sts pulse1_fx_2xx_total, zero
001899 9220 2848                 	sts pulse1_fx_2xx_total+1, zero
00189b 9220 284f                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
00189d 9220 2850                 	sts pulse1_fx_3xx_total_offset+1, zero
00189f 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0018a1 91b0 0a8d                 	lds r27, TCB0_CCMPH
0018a3 93a0 2849                 	sts pulse1_fx_3xx_start, r26
0018a5 93b0 284a                 	sts pulse1_fx_3xx_start+1, r27
0018a7 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
0018a9 6097                      	sbr pulse_channel_flags, 7 //set reload flag
0018aa 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0018ac 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
0018ae 9220 2860                 	sts pulse1_fx_Qxy_total_offset, zero
0018b0 9220 2861                 	sts pulse1_fx_Qxy_total_offset+1, zero
0018b2 9220 2862                 	sts pulse1_fx_Rxy_target, zero
0018b4 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
0018b6 9220 2866                 	sts pulse1_fx_Rxy_total_offset, zero
0018b8 9220 2867                 	sts pulse1_fx_Rxy_total_offset+1, zero
0018ba d0fb                      	rcall sound_driver_channel0_increment_offset
0018bb ce4c                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
0018bc 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0018bd 91a0 2800                 	lds r26, pulse1_param
0018bf 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0018c0 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
0018c1 93a0 2800                 	sts pulse1_param, r26
0018c3 6096                      	sbr pulse_channel_flags, 6
0018c4 d0f1                      	rcall sound_driver_channel0_increment_offset
0018c5 ce42                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
0018c6 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0018c7 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
0018c9 d0ec                      	rcall sound_driver_channel0_increment_offset
0018ca c102                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
0018cb 9220 2823                 	sts pulse1_volume_macro, zero //reset all macro addresses
0018cd 9220 2824                 	sts pulse1_volume_macro+1, zero
0018cf 9220 2828                 	sts pulse1_arpeggio_macro, zero
0018d1 9220 2829                 	sts pulse1_arpeggio_macro+1, zero
0018d3 9220 282f                 	sts pulse1_pitch_macro, zero
0018d5 9220 2830                 	sts pulse1_pitch_macro+1, zero
0018d7 9220 2835                 	sts pulse1_hi_pitch_macro, zero
0018d9 9220 2836                 	sts pulse1_hi_pitch_macro+1, zero
0018db 9220 283a                 	sts pulse1_duty_macro, zero
0018dd 9220 283b                 	sts pulse1_duty_macro+1, zero
0018df 9220 282e                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
0018e1 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0018e3 9631                      	adiw Z, 1 //point to the byte next to the flag
0018e4 91b4                      	lpm r27, Z //store the instrument offset into r27
0018e5 e6ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
0018e6 e1f0                      	ldi ZH, HIGH(instruments)
0018e7 0feb                      	add ZL, r27 //point Z to offsetted instrument
0018e8 1df2                      	adc ZH, zero
0018e9 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0018ea 1fff                      	rol ZH
0018eb 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0018ec 91b4                      	lpm r27, Z
                                 
0018ed 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0018ee 1fbb                      	rol r27
0018ef 2fea                      	mov ZL, r26
0018f0 2ffb                      	mov ZH, r27
0018f1 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0018f2 9632                      	adiw Z, 2 //point Z to the address of the macro
0018f3 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
0018f4 95aa                      	dec r26
0018f5 f019                      	breq sound_driver_channel0_instrument_change_exit
0018f6 95b6                      	lsr r27
0018f7 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
0018f8 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
0018f9 e0a3                      	ldi r26, 0x03
0018fa e0b2                      	ldi r27, 0x02
0018fb 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0018fd 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
0018ff 93b0 2831                 	sts pulse1_pitch_macro_offset, r27
001901 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27
001903 93b0 283c                 	sts pulse1_duty_macro_offset, r27
001905 d0ba                      	rcall sound_driver_channel0_increment_offset_twice
001906 ce01                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001907 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001908 91d5                      	lpm r29, Z+
                                 
001909 30a5                      	cpi r26, 5
00190a f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
00190b 30a4                      	cpi r26, 4
00190c f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
00190d 30a3                      	cpi r26, 3
00190e f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
00190f 30a2                      	cpi r26, 2
001910 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001911 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001912 93c0 2823                 	sts pulse1_volume_macro, r28
001914 93d0 2824                 	sts pulse1_volume_macro+1, r29
001916 d041                      	rcall sound_driver_channel0_instrument_change_read_header
001917 93c0 2827                 	sts pulse1_volume_macro_release, r28
001919 93d0 2826                 	sts pulse1_volume_macro_loop, r29
00191b cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
00191c 93c0 2828                 	sts pulse1_arpeggio_macro, r28
00191e 93d0 2829                 	sts pulse1_arpeggio_macro+1, r29
001920 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001922 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
001924 9220 2862                 	sts pulse1_fx_Rxy_target, zero
001926 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
001928 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001929 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
00192a 93c0 282f                 	sts pulse1_pitch_macro, r28
00192c 93d0 2830                 	sts pulse1_pitch_macro+1, r29
00192e 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001930 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
001932 9220 2862                 	sts pulse1_fx_Rxy_target, zero
001934 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
001936 d021                      	rcall sound_driver_channel0_instrument_change_read_header
001937 93c0 2833                 	sts pulse1_pitch_macro_release, r28
001939 93d0 2832                 	sts pulse1_pitch_macro_loop, r29
00193b cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
00193c 93c0 2835                 	sts pulse1_hi_pitch_macro, r28
00193e 93d0 2836                 	sts pulse1_hi_pitch_macro+1, r29
001940 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001942 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
001944 9220 2862                 	sts pulse1_fx_Rxy_target, zero
001946 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
001948 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001949 93c0 2839                 	sts pulse1_hi_pitch_macro_release, r28
00194b 93d0 2838                 	sts pulse1_hi_pitch_macro_loop, r29
00194d cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
00194e 93c0 283a                 	sts pulse1_duty_macro, r28
001950 93d0 283b                 	sts pulse1_duty_macro+1, r29
001952 d005                      	rcall sound_driver_channel0_instrument_change_read_header
001953 93c0 283e                 	sts pulse1_duty_macro_release, r28
001955 93d0 283d                 	sts pulse1_duty_macro_loop, r29
001957 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001958 93ef                      	push ZL
001959 93ff                      	push ZH
00195a 2fec                      	mov ZL, r28
00195b 2ffd                      	mov ZH, r29
00195c 0fee                      	lsl ZL
00195d 1fff                      	rol ZH
00195e 91c5                      	lpm r28, Z+
00195f 91d4                      	lpm r29, Z
001960 91ff                      	pop ZH
001961 91ef                      	pop ZL
001962 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001963 93ef                      	push ZL
001964 93ff                      	push ZH
001965 2fec                      	mov ZL, r28
001966 2ffd                      	mov ZH, r29
001967 0fee                      	lsl ZL
001968 1fff                      	rol ZH
001969 91c5                      	lpm r28, Z+
00196a 91d5                      	lpm r29, Z+
00196b 93c0 282c                 	sts pulse1_arpeggio_macro_release, r28
00196d 93d0 282b                 	sts pulse1_arpeggio_macro_loop, r29
00196f 91c4                      	lpm r28, Z
001970 93c0 282d                 	sts pulse1_arpeggio_macro_mode, r28
001972 91ff                      	pop ZH
001973 91ef                      	pop ZL
001974 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001975 91b0 2827                 	lds r27, pulse1_volume_macro_release
001977 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001978 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001979 95b3                      	inc r27
00197a 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
00197c 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
00197e 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00197f f019                      	breq sound_driver_channel0_release_pitch
001980 95b3                      	inc r27
001981 93b0 282a                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001983 91b0 2833                 	lds r27, pulse1_pitch_macro_release
001985 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001986 f019                      	breq sound_driver_channel0_release_hi_pitch
001987 95b3                      	inc r27
001988 93b0 2831                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
00198a 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_release
00198c 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00198d f019                      	breq sound_driver_channel0_release_duty
00198e 95b3                      	inc r27
00198f 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001991 91b0 283e                 	lds r27, pulse1_duty_macro_release
001993 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001994 f019                      	breq sound_driver_channel0_release_exit
001995 95b3                      	inc r27
001996 93b0 283c                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001998 d01d                      	rcall sound_driver_channel0_increment_offset
001999 cd6e                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
00199a 91e0 2813                 	lds ZL, song_frames
00199c 91f0 2814                 	lds ZH, song_frames+1
00199e 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0019a0 91b0 2816                 	lds r27, song_frame_offset+1
0019a2 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0019a3 93a0 2815                 	sts song_frame_offset, r26
0019a5 93b0 2816                 	sts song_frame_offset+1, r27
0019a7 0fea                      	add ZL, r26
0019a8 1ffb                      	adc ZH, r27
                                 
0019a9 91a5                      	lpm r26, Z+ //load the address of the next pattern
0019aa 91b4                      	lpm r27, Z
0019ab 0faa                      	lsl r26
0019ac 1fbb                      	rol r27
0019ad 93a0 281d                 	sts pulse1_pattern, r26
0019af 93b0 281e                 	sts pulse1_pattern+1, r27
                                 
0019b1 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0019b3 9220 2822                 	sts pulse1_pattern_offset+1, zero
0019b5 cd52                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
0019b6 91e0 2821                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0019b8 91f0 2822                 	lds ZH, pulse1_pattern_offset+1
0019ba 9631                      	adiw Z, 1
0019bb 93e0 2821                 	sts pulse1_pattern_offset, ZL
0019bd 93f0 2822                 	sts pulse1_pattern_offset+1, ZH
0019bf 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0019c0 91e0 2821                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0019c2 91f0 2822                 	lds ZH, pulse1_pattern_offset+1
0019c4 9632                      	adiw Z, 2 //increment the pointer twice
0019c5 93e0 2821                 	sts pulse1_pattern_offset, ZL
0019c7 93f0 2822                 	sts pulse1_pattern_offset+1, ZH
0019c9 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
0019ca 95ba                      	dec r27
0019cb 93b0 2820                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
0019cd 91a0 286c                 	lds r26, pulse2_pattern_delay_rows
0019cf 91b0 286d                 	lds r27, pulse2_pattern_delay_frames
0019d1 9610                      	adiw r27:r26, 0
0019d2 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
0019d3 c2be                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
0019d4 91e0 286a                 	lds ZL, pulse2_pattern //current pattern for pulse 2
0019d6 91f0 286b                 	lds ZH, pulse2_pattern+1
0019d8 91a0 286e                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
0019da 91b0 286f                 	lds r27, pulse2_pattern_offset+1
0019dc 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0019dd 1ffb                      	adc ZH, r27
0019de 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
0019df 35b7                      	cpi r27, 0x57
0019e0 f408                      	brsh sound_driver_channel1_check_if_volume
0019e1 c16b                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
0019e2 36b7                      	cpi r27, 0x67
0019e3 f408                      	brsh sound_driver_channel1_check_if_delay
0019e4 c1a3                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0019e5 3eb3                      	cpi r27, 0xE3
0019e6 f408                      	brsh sound_driver_channel1_check_if_instrument
0019e7 c1aa                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
0019e8 f409                      	brne sound_driver_channel1_check_if_release
0019e9 c1ad                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
0019ea 3eb4                      	cpi r27, 0xE4
0019eb f409                      	brne sound_driver_channel1_check_if_end
0019ec c254                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
0019ed 3fbf                      	cpi r27, 0xFF
0019ee f409                      	brne sound_driver_channel1_check_if_fx
0019ef c276                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
0019f0 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0019f1 91a4                      	lpm r26, Z //load the fx data into r26
0019f2 d295                      	rcall sound_driver_channel1_increment_offset_twice
                                 
0019f3 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0019f4 e9e0                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
0019f5 e5f3                      	ldi ZH, HIGH(channel1_fx << 1)
0019f6 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0019f7 0feb                      	add ZL, r27 //add offset
0019f8 1df2                      	adc ZH, zero
0019f9 91c5                      	lpm r28, Z+ //load address bytes
0019fa 91d4                      	lpm r29, Z
0019fb 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0019fc 2ffd                      	mov ZH, r29
0019fd 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
0019fe 93a0 288c                 	sts pulse2_fx_0xy_sequence, r26
001a00 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
001a02 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001a03 9220 2892                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001a05 9220 2893                 	sts pulse2_fx_2xx+1, zero
001a07 9220 288c                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001a09 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
001a0b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a0c 937f                      	push r23
001a0d 2f6a                      	mov r22, r26 //store the rate into r22
001a0e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a0f 9f67                      	mul r22, r23
001a10 917f                      	pop r23
001a11 916f                      	pop r22
                                 
001a12 9416                      	lsr r1 //shift out the fractional bits
001a13 9407                      	ror r0
001a14 9416                      	lsr r1
001a15 9407                      	ror r0
001a16 9416                      	lsr r1
001a17 9407                      	ror r0
001a18 9416                      	lsr r1
001a19 9407                      	ror r0
001a1a 9200 288e                 	sts pulse2_fx_1xx, r0
001a1c 9210 288f                 	sts pulse2_fx_1xx+1, r1
001a1e cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001a1f 9220 288e                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001a21 9220 288f                 	sts pulse2_fx_1xx+1, zero
001a23 9220 288c                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001a25 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
001a27 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a28 937f                      	push r23
001a29 2f6a                      	mov r22, r26 //store the rate into r22
001a2a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a2b 9f67                      	mul r22, r23
001a2c 917f                      	pop r23
001a2d 916f                      	pop r22
                                 
001a2e 9416                      	lsr r1 //shift out the fractional bits
001a2f 9407                      	ror r0
001a30 9416                      	lsr r1
001a31 9407                      	ror r0
001a32 9416                      	lsr r1
001a33 9407                      	ror r0
001a34 9416                      	lsr r1
001a35 9407                      	ror r0
001a36 9200 2892                 	sts pulse2_fx_2xx, r0
001a38 9210 2893                 	sts pulse2_fx_2xx+1, r1
001a3a cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001a3b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a3c 937f                      	push r23
001a3d 2f6a                      	mov r22, r26 //store the rate into r22
001a3e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a3f 9f67                      	mul r22, r23
001a40 917f                      	pop r23
001a41 916f                      	pop r22
                                 
001a42 9416                      	lsr r1 //shift out the fractional bits
001a43 9407                      	ror r0
001a44 9416                      	lsr r1
001a45 9407                      	ror r0
001a46 9416                      	lsr r1
001a47 9407                      	ror r0
001a48 9416                      	lsr r1
001a49 9407                      	ror r0
001a4a 9200 289a                 	sts pulse2_fx_3xx_speed, r0
001a4c 9210 289b                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001a4e 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001a4f c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001a50 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001a51 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001a53 91b0 0a9d                 	lds r27, TCB1_CCMPH
001a55 93a0 2896                 	sts pulse2_fx_3xx_start, r26
001a57 93b0 2897                 	sts pulse2_fx_3xx_start+1, r27
                                 
001a59 9220 289c                 	sts pulse2_fx_3xx_total_offset, zero
001a5b 9220 289d                 	sts pulse2_fx_3xx_total_offset+1, zero
001a5d cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001a5e 2fba                      	mov r27, r26
001a5f 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001a60 95a2                      	swap r26
001a61 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001a62 93a0 289e                 	sts pulse2_fx_4xy_speed, r26
001a64 93b0 289f                 	sts pulse2_fx_4xy_depth, r27
001a66 9220 28a0                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001a68 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001a69 2fba                      	mov r27, r26
001a6a 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001a6b 95a2                      	swap r26
001a6c 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001a6d 93a0 28a1                 	sts pulse2_fx_7xy_speed, r26
001a6f 93b0 28a2                 	sts pulse2_fx_7xy_depth, r27
001a71 9220 28a3                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001a73 9220 28a4                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001a75 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001a76 93a0 28a5                 	sts pulse2_fx_Axy, r26
001a78 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001a79 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001a7b cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001a7c 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001a7e cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001a7f 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001a81 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001a82 91b0 2808                 	lds r27, pulse2_param
001a84 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001a85 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001a86 93b0 2808                 	sts pulse2_param, r27
001a88 6092                      	sbr pulse_channel_flags, 2
001a89 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001a8a 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001a8c cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001a8d 15a2                      	cp r26, zero
001a8e f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001a8f 91b0 2819                 	lds r27, song_speed
001a91 17ab                      	cp r26, r27
001a92 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001a93 93a0 28a6                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001a95 e0b1                      	ldi r27, 0x01
001a96 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
001a98 c1fc                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001a99 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001a9a cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001a9b cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001a9c cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001a9d cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001a9e 93a0 28a8                 	sts pulse2_fx_Pxx, r26
001aa0 cf33                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001aa1 91e0 2875                 	lds ZL, pulse2_arpeggio_macro
001aa3 91f0 2876                 	lds ZH, pulse2_arpeggio_macro+1
001aa5 9630                      	adiw Z, 0
001aa6 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001aa7 cf2c                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001aa8 91e0 287c                 	lds ZL, pulse2_pitch_macro
001aaa 91f0 287d                 	lds ZH, pulse2_pitch_macro+1
001aac 9630                      	adiw Z, 0
001aad f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001aae cf25                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001aaf 91e0 2882                 	lds ZL, pulse2_hi_pitch_macro
001ab1 91f0 2883                 	lds ZH, pulse2_hi_pitch_macro+1
001ab3 9630                      	adiw Z, 0
001ab4 f009                      	breq sound_driver_channel1_fx_Qxy_process
001ab5 cf1e                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001ab6 2fba                      	mov r27, r26 //copy fx parameters into r27
001ab7 70bf                      	andi r27, 0x0F //mask note index offset
001ab8 91c0 280f                 	lds r28, pulse2_note //load current note index
001aba 0fbc                      	add r27, r28
001abb 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001abc f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001abd e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001abe e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001abf e0f0                      	ldi ZH, HIGH(note_table << 1)
001ac0 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001ac1 0feb                      	add ZL, r27 //add offset
001ac2 1df2                      	adc ZH, zero
001ac3 91c5                      	lpm r28, Z+ //load bytes
001ac4 91d4                      	lpm r29, Z
001ac5 93c0 28a9                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001ac7 93d0 28aa                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001ac9 95a2                      	swap r26
001aca 70af                      	andi r26, 0x0F //mask effect speed
001acb 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001acc 95a3                      	inc r26 //increment the speed by 1
                                 
001acd 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ace 937f                      	push r23
001acf 2f6a                      	mov r22, r26 //store the speed data into r27
001ad0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ad1 9f67                      	mul r22, r23
001ad2 917f                      	pop r23
001ad3 916f                      	pop r22
                                 
001ad4 9416                      	lsr r1 //shift out the fractional bits
001ad5 9407                      	ror r0
001ad6 9416                      	lsr r1
001ad7 9407                      	ror r0
001ad8 9416                      	lsr r1
001ad9 9407                      	ror r0
001ada 9416                      	lsr r1
001adb 9407                      	ror r0
                                 
001adc 9200 28ab                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001ade 9210 28ac                 	sts pulse2_fx_Qxy_speed+1, r1
001ae0 9220 28ad                 	sts pulse2_fx_Qxy_total_offset, zero
001ae2 9220 28ae                 	sts pulse2_fx_Qxy_total_offset+1, zero
001ae4 ceef                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001ae5 91e0 2875                 	lds ZL, pulse2_arpeggio_macro
001ae7 91f0 2876                 	lds ZH, pulse2_arpeggio_macro+1
001ae9 9630                      	adiw Z, 0
001aea f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001aeb cee8                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001aec 91e0 287c                 	lds ZL, pulse2_pitch_macro
001aee 91f0 287d                 	lds ZH, pulse2_pitch_macro+1
001af0 9630                      	adiw Z, 0
001af1 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001af2 cee1                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001af3 91e0 2882                 	lds ZL, pulse2_hi_pitch_macro
001af5 91f0 2883                 	lds ZH, pulse2_hi_pitch_macro+1
001af7 9630                      	adiw Z, 0
001af8 f009                      	breq sound_driver_channel1_fx_Rxy_process
001af9 ceda                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001afa 2fba                      	mov r27, r26 //copy fx parameters into r27
001afb 70bf                      	andi r27, 0x0F //mask note index offset
001afc 91c0 280f                 	lds r28, pulse2_note //load current note index
001afe 1bcb                      	sub r28, r27
001aff f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001b00 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001b01 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001b02 e0f0                      	ldi ZH, HIGH(note_table << 1)
001b03 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001b04 0fec                      	add ZL, r28 //add offset
001b05 1df2                      	adc ZH, zero
001b06 91c5                      	lpm r28, Z+ //load bytes
001b07 91d4                      	lpm r29, Z
001b08 93c0 28af                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001b0a 93d0 28b0                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001b0c 95a2                      	swap r26
001b0d 70af                      	andi r26, 0x0F //mask effect speed
001b0e 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b0f 95a3                      	inc r26 //increment the speed by 1
                                 
001b10 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b11 937f                      	push r23
001b12 2f6a                      	mov r22, r26 //store the speed data into r27
001b13 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b14 9f67                      	mul r22, r23
001b15 917f                      	pop r23
001b16 916f                      	pop r22
                                 
001b17 9416                      	lsr r1 //shift out the fractional bits
001b18 9407                      	ror r0
001b19 9416                      	lsr r1
001b1a 9407                      	ror r0
001b1b 9416                      	lsr r1
001b1c 9407                      	ror r0
001b1d 9416                      	lsr r1
001b1e 9407                      	ror r0
                                 
001b1f 9200 28b1                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001b21 9210 28b2                 	sts pulse2_fx_Rxy_speed+1, r1
001b23 9220 28b3                 	sts pulse2_fx_Rxy_total_offset, zero
001b25 9220 28b4                 	sts pulse2_fx_Rxy_total_offset+1, zero
001b27 ceac                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001b28 15a2                      	cp r26, zero
001b29 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001b2a 91b0 2819                 	lds r27, song_speed
001b2c 17ab                      	cp r26, r27
001b2d f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001b2e 93a0 28b5                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001b30 e0b1                      	ldi r27, 0x01
001b31 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
001b33 c161                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001b34 ce9f                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001b35 e5e8                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001b36 e5f3                      	ldi ZH, HIGH(sequences << 1)
001b37 0fea                      	add ZL, r26 //offset the pointer
001b38 1df2                      	adc ZH, zero
                                 
001b39 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001b3a 95a7                      	ror r26
001b3b 95a7                      	ror r26
001b3c 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001b3e 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001b3f 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001b40 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001b41 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001b42 ce91                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001b43 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001b44 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001b45 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001b46 93c0 2808                 	sts pulse2_param, r28
001b48 ce8b                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001b49 ce8a                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001b4a ce89                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001b4b ce88                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001b4c ce87                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001b4d 93b0 280f                 	sts pulse2_note, r27 //store the note index
001b4f e0a3                      	ldi r26, 0x03
001b50 e0b2                      	ldi r27, 0x02
001b51 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001b53 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
001b55 93b0 287e                 	sts pulse2_pitch_macro_offset, r27
001b57 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27
001b59 93b0 2889                 	sts pulse2_duty_macro_offset, r27
001b5b 9220 287b                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001b5d 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero
001b5f 9220 2890                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001b61 9220 2891                 	sts pulse2_fx_1xx_total+1, zero
001b63 9220 2894                 	sts pulse2_fx_2xx_total, zero
001b65 9220 2895                 	sts pulse2_fx_2xx_total+1, zero
001b67 9220 289c                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001b69 9220 289d                 	sts pulse2_fx_3xx_total_offset+1, zero
001b6b 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001b6d 91b0 0a9d                 	lds r27, TCB1_CCMPH
001b6f 93a0 2896                 	sts pulse2_fx_3xx_start, r26
001b71 93b0 2897                 	sts pulse2_fx_3xx_start+1, r27
001b73 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001b75 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001b76 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001b78 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001b7a 9220 28ad                 	sts pulse2_fx_Qxy_total_offset, zero
001b7c 9220 28ae                 	sts pulse2_fx_Qxy_total_offset+1, zero
001b7e 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001b80 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001b82 9220 28b3                 	sts pulse2_fx_Rxy_total_offset, zero
001b84 9220 28b4                 	sts pulse2_fx_Rxy_total_offset+1, zero
001b86 d0f7                      	rcall sound_driver_channel1_increment_offset
001b87 ce4c                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001b88 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001b89 91a0 2808                 	lds r26, pulse2_param
001b8b 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001b8c 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001b8d 93a0 2808                 	sts pulse2_param, r26
001b8f 6092                      	sbr pulse_channel_flags, 2
001b90 d0ed                      	rcall sound_driver_channel1_increment_offset
001b91 ce42                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001b92 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001b93 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
001b95 d0e8                      	rcall sound_driver_channel1_increment_offset
001b96 c0fe                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001b97 9220 2870                 	sts pulse2_volume_macro, zero //reset all macro addresses
001b99 9220 2871                 	sts pulse2_volume_macro+1, zero
001b9b 9220 2875                 	sts pulse2_arpeggio_macro, zero
001b9d 9220 2876                 	sts pulse2_arpeggio_macro+1, zero
001b9f 9220 287c                 	sts pulse2_pitch_macro, zero
001ba1 9220 287d                 	sts pulse2_pitch_macro+1, zero
001ba3 9220 2882                 	sts pulse2_hi_pitch_macro, zero
001ba5 9220 2883                 	sts pulse2_hi_pitch_macro+1, zero
001ba7 9220 2887                 	sts pulse2_duty_macro, zero
001ba9 9220 2888                 	sts pulse2_duty_macro+1, zero
001bab 9220 287b                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001bad 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001baf 9631                      	adiw Z, 1 //point to the byte next to the flag
001bb0 91b4                      	lpm r27, Z //store the instrument offset into r27
001bb1 e6ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001bb2 e1f0                      	ldi ZH, HIGH(instruments)
001bb3 0feb                      	add ZL, r27 //point Z to offsetted instrument
001bb4 1df2                      	adc ZH, zero
001bb5 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001bb6 1fff                      	rol ZH
001bb7 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001bb8 91b4                      	lpm r27, Z
                                 
001bb9 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001bba 1fbb                      	rol r27
001bbb 2fea                      	mov ZL, r26
001bbc 2ffb                      	mov ZH, r27
001bbd 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001bbe 9632                      	adiw Z, 2 //point Z to the address of the macro
001bbf e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001bc0 95aa                      	dec r26
001bc1 f019                      	breq sound_driver_channel1_instrument_change_exit
001bc2 95b6                      	lsr r27
001bc3 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001bc4 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001bc5 e0a3                      	ldi r26, 0x03
001bc6 e0b2                      	ldi r27, 0x02
001bc7 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001bc9 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
001bcb 93b0 287e                 	sts pulse2_pitch_macro_offset, r27
001bcd 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27
001bcf 93b0 2889                 	sts pulse2_duty_macro_offset, r27
001bd1 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001bd2 ce01                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001bd3 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001bd4 91d5                      	lpm r29, Z+
                                 
001bd5 30a5                      	cpi r26, 5
001bd6 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001bd7 30a4                      	cpi r26, 4
001bd8 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001bd9 30a3                      	cpi r26, 3
001bda f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001bdb 30a2                      	cpi r26, 2
001bdc f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001bdd c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001bde 93c0 2870                 	sts pulse2_volume_macro, r28
001be0 93d0 2871                 	sts pulse2_volume_macro+1, r29
001be2 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001be3 93c0 2874                 	sts pulse2_volume_macro_release, r28
001be5 93d0 2873                 	sts pulse2_volume_macro_loop, r29
001be7 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001be8 93c0 2875                 	sts pulse2_arpeggio_macro, r28
001bea 93d0 2876                 	sts pulse2_arpeggio_macro+1, r29
001bec 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001bee 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001bf0 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001bf2 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001bf4 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001bf5 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001bf6 93c0 287c                 	sts pulse2_pitch_macro, r28
001bf8 93d0 287d                 	sts pulse2_pitch_macro+1, r29
001bfa 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001bfc 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001bfe 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001c00 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001c02 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001c03 93c0 2880                 	sts pulse2_pitch_macro_release, r28
001c05 93d0 287f                 	sts pulse2_pitch_macro_loop, r29
001c07 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001c08 93c0 2882                 	sts pulse2_hi_pitch_macro, r28
001c0a 93d0 2883                 	sts pulse2_hi_pitch_macro+1, r29
001c0c 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c0e 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001c10 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001c12 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001c14 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001c15 93c0 2886                 	sts pulse2_hi_pitch_macro_release, r28
001c17 93d0 2885                 	sts pulse2_hi_pitch_macro_loop, r29
001c19 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001c1a 93c0 2887                 	sts pulse2_duty_macro, r28
001c1c 93d0 2888                 	sts pulse2_duty_macro+1, r29
001c1e d005                      	rcall sound_driver_channel1_instrument_change_read_header
001c1f 93c0 288b                 	sts pulse2_duty_macro_release, r28
001c21 93d0 288a                 	sts pulse2_duty_macro_loop, r29
001c23 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001c24 93ef                      	push ZL
001c25 93ff                      	push ZH
001c26 2fec                      	mov ZL, r28
001c27 2ffd                      	mov ZH, r29
001c28 0fee                      	lsl ZL
001c29 1fff                      	rol ZH
001c2a 91c5                      	lpm r28, Z+
001c2b 91d4                      	lpm r29, Z
001c2c 91ff                      	pop ZH
001c2d 91ef                      	pop ZL
001c2e 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001c2f 93ef                      	push ZL
001c30 93ff                      	push ZH
001c31 2fec                      	mov ZL, r28
001c32 2ffd                      	mov ZH, r29
001c33 0fee                      	lsl ZL
001c34 1fff                      	rol ZH
001c35 91c5                      	lpm r28, Z+
001c36 91d5                      	lpm r29, Z+
001c37 93c0 2879                 	sts pulse2_arpeggio_macro_release, r28
001c39 93d0 2878                 	sts pulse2_arpeggio_macro_loop, r29
001c3b 91c4                      	lpm r28, Z
001c3c 93c0 287a                 	sts pulse2_arpeggio_macro_mode, r28
001c3e 91ff                      	pop ZH
001c3f 91ef                      	pop ZL
001c40 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001c41 91b0 2874                 	lds r27, pulse2_volume_macro_release
001c43 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001c44 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001c45 95b3                      	inc r27
001c46 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001c48 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
001c4a 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001c4b f019                      	breq sound_driver_channel1_release_pitch
001c4c 95b3                      	inc r27
001c4d 93b0 2877                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001c4f 91b0 2880                 	lds r27, pulse2_pitch_macro_release
001c51 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001c52 f019                      	breq sound_driver_channel1_release_hi_pitch
001c53 95b3                      	inc r27
001c54 93b0 287e                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001c56 91b0 2886                 	lds r27, pulse2_hi_pitch_macro_release
001c58 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001c59 f019                      	breq sound_driver_channel1_release_duty
001c5a 95b3                      	inc r27
001c5b 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001c5d 91b0 288b                 	lds r27, pulse2_duty_macro_release
001c5f 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001c60 f019                      	breq sound_driver_channel1_release_exit
001c61 95b3                      	inc r27
001c62 93b0 2889                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001c64 d019                      	rcall sound_driver_channel1_increment_offset
001c65 cd6e                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001c66 91e0 2813                 	lds ZL, song_frames
001c68 91f0 2814                 	lds ZH, song_frames+1
001c6a 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001c6c 91b0 2816                 	lds r27, song_frame_offset+1
001c6e 9612                      	adiw r27:r26, 2 //offset for channel 1
001c6f 0fea                      	add ZL, r26
001c70 1ffb                      	adc ZH, r27
                                 
001c71 91a5                      	lpm r26, Z+ //load the address of the next pattern
001c72 91b4                      	lpm r27, Z
001c73 0faa                      	lsl r26
001c74 1fbb                      	rol r27
001c75 93a0 286a                 	sts pulse2_pattern, r26
001c77 93b0 286b                 	sts pulse2_pattern+1, r27
                                 
001c79 9220 286e                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001c7b 9220 286f                 	sts pulse2_pattern_offset+1, zero
001c7d cd56                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001c7e 91e0 286e                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001c80 91f0 286f                 	lds ZH, pulse2_pattern_offset+1
001c82 9631                      	adiw Z, 1
001c83 93e0 286e                 	sts pulse2_pattern_offset, ZL
001c85 93f0 286f                 	sts pulse2_pattern_offset+1, ZH
001c87 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001c88 91e0 286e                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001c8a 91f0 286f                 	lds ZH, pulse2_pattern_offset+1
001c8c 9632                      	adiw Z, 2 //increment the pointer twice
001c8d 93e0 286e                 	sts pulse2_pattern_offset, ZL
001c8f 93f0 286f                 	sts pulse2_pattern_offset+1, ZH
001c91 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001c92 95ba                      	dec r27
001c93 93b0 286d                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001c95 91a0 28b9                 	lds r26, triangle_pattern_delay_rows
001c97 91b0 28ba                 	lds r27, triangle_pattern_delay_frames
001c99 9610                      	adiw r27:r26, 0
001c9a f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001c9b c2a3                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001c9c 91e0 28b7                 	lds ZL, triangle_pattern //current pattern for triangle
001c9e 91f0 28b8                 	lds ZH, triangle_pattern+1
001ca0 91a0 28bb                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001ca2 91b0 28bc                 	lds r27, triangle_pattern_offset+1
001ca4 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001ca5 1ffb                      	adc ZH, r27
001ca6 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001ca7 35b7                      	cpi r27, 0x57
001ca8 f408                      	brsh sound_driver_channel2_check_if_volume
001ca9 c14f                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001caa 36b7                      	cpi r27, 0x67
001cab f408                      	brsh sound_driver_channel2_check_if_delay
001cac c184                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001cad 3eb3                      	cpi r27, 0xE3
001cae f408                      	brsh sound_driver_channel2_check_if_instrument
001caf c18f                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001cb0 f409                      	brne sound_driver_channel2_check_if_release
001cb1 c192                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001cb2 3eb4                      	cpi r27, 0xE4
001cb3 f409                      	brne sound_driver_channel2_check_if_end
001cb4 c239                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001cb5 3fbf                      	cpi r27, 0xFF
001cb6 f409                      	brne sound_driver_channel2_check_if_fx
001cb7 c25b                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001cb8 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001cb9 91a4                      	lpm r26, Z //load the fx data into r26
001cba d27a                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001cbb 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001cbc ece4                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001cbd e5f3                      	ldi ZH, HIGH(channel2_fx << 1)
001cbe 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001cbf 0feb                      	add ZL, r27 //add offset
001cc0 1df2                      	adc ZH, zero
001cc1 91c5                      	lpm r28, Z+ //load address bytes
001cc2 91d4                      	lpm r29, Z
001cc3 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001cc4 2ffd                      	mov ZH, r29
001cc5 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001cc6 93a0 28d9                 	sts triangle_fx_0xy_sequence, r26
001cc8 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
001cca cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001ccb 9220 28df                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001ccd 9220 28e0                 	sts triangle_fx_2xx+1, zero
001ccf 9220 28d9                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001cd1 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
001cd3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001cd4 937f                      	push r23
001cd5 2f6a                      	mov r22, r26 //store the rate into r22
001cd6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001cd7 9f67                      	mul r22, r23
001cd8 917f                      	pop r23
001cd9 916f                      	pop r22
                                 
001cda 9416                      	lsr r1 //shift out the fractional bits
001cdb 9407                      	ror r0
001cdc 9416                      	lsr r1
001cdd 9407                      	ror r0
001cde 9416                      	lsr r1
001cdf 9407                      	ror r0
001ce0 9416                      	lsr r1
001ce1 9407                      	ror r0
001ce2 9200 28db                 	sts triangle_fx_1xx, r0
001ce4 9210 28dc                 	sts triangle_fx_1xx+1, r1
001ce6 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001ce7 9220 28db                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001ce9 9220 28dc                 	sts triangle_fx_1xx+1, zero
001ceb 9220 28d9                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001ced 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
001cef 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001cf0 937f                      	push r23
001cf1 2f6a                      	mov r22, r26 //store the rate into r22
001cf2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001cf3 9f67                      	mul r22, r23
001cf4 917f                      	pop r23
001cf5 916f                      	pop r22
                                 
001cf6 9416                      	lsr r1 //shift out the fractional bits
001cf7 9407                      	ror r0
001cf8 9416                      	lsr r1
001cf9 9407                      	ror r0
001cfa 9416                      	lsr r1
001cfb 9407                      	ror r0
001cfc 9416                      	lsr r1
001cfd 9407                      	ror r0
001cfe 9200 28df                 	sts triangle_fx_2xx, r0
001d00 9210 28e0                 	sts triangle_fx_2xx+1, r1
001d02 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001d03 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d04 937f                      	push r23
001d05 2f6a                      	mov r22, r26 //store the rate into r22
001d06 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d07 9f67                      	mul r22, r23
001d08 917f                      	pop r23
001d09 916f                      	pop r22
                                 
001d0a 9416                      	lsr r1 //shift out the fractional bits
001d0b 9407                      	ror r0
001d0c 9416                      	lsr r1
001d0d 9407                      	ror r0
001d0e 9416                      	lsr r1
001d0f 9407                      	ror r0
001d10 9416                      	lsr r1
001d11 9407                      	ror r0
001d12 9200 28e7                 	sts triangle_fx_3xx_speed, r0
001d14 9210 28e8                 	sts triangle_fx_3xx_speed+1, r1
                                 
001d16 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001d17 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001d18 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001d19 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001d1b 91b0 0aad                 	lds r27, TCB2_CCMPH
001d1d 93a0 28e3                 	sts triangle_fx_3xx_start, r26
001d1f 93b0 28e4                 	sts triangle_fx_3xx_start+1, r27
                                 
001d21 9220 28e9                 	sts triangle_fx_3xx_total_offset, zero
001d23 9220 28ea                 	sts triangle_fx_3xx_total_offset+1, zero
001d25 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001d26 2fba                      	mov r27, r26
001d27 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001d28 95a2                      	swap r26
001d29 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001d2a 93a0 28eb                 	sts triangle_fx_4xy_speed, r26
001d2c 93b0 28ec                 	sts triangle_fx_4xy_depth, r27
001d2e 9220 28ed                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001d30 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001d31 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001d32 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001d33 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001d35 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001d36 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001d38 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001d39 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001d3b cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001d3c 15a2                      	cp r26, zero
001d3d f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001d3e e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001d3f 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001d41 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001d42 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001d44 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001d46 9220 0aad                 	sts TCB2_CCMPH, zero
001d48 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001d49 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001d4b cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001d4c 15a2                      	cp r26, zero
001d4d f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001d4e 91b0 2819                 	lds r27, song_speed
001d50 17ab                      	cp r26, r27
001d51 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001d52 93a0 28ee                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001d54 e0b1                      	ldi r27, 0x01
001d55 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
001d57 c1ea                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel2_fx_Gxx_invalid:
001d58 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001d59 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001d5a cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001d5b cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001d5c cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001d5d 93a0 28f0                 	sts triangle_fx_Pxx, r26
001d5f cf3c                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001d60 91e0 28c2                 	lds ZL, triangle_arpeggio_macro
001d62 91f0 28c3                 	lds ZH, triangle_arpeggio_macro+1
001d64 9630                      	adiw Z, 0
001d65 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001d66 cf35                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001d67 91e0 28c9                 	lds ZL, triangle_pitch_macro
001d69 91f0 28ca                 	lds ZH, triangle_pitch_macro+1
001d6b 9630                      	adiw Z, 0
001d6c f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001d6d cf2e                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001d6e 91e0 28cf                 	lds ZL, triangle_hi_pitch_macro
001d70 91f0 28d0                 	lds ZH, triangle_hi_pitch_macro+1
001d72 9630                      	adiw Z, 0
001d73 f009                      	breq sound_driver_channel2_fx_Qxy_process
001d74 cf27                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001d75 2fba                      	mov r27, r26 //copy fx parameters into r27
001d76 70bf                      	andi r27, 0x0F //mask note index offset
001d77 91c0 2812                 	lds r28, triangle_note //load current note index
001d79 0fbc                      	add r27, r28
001d7a 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001d7b f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001d7c e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001d7d e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001d7e e0f0                      	ldi ZH, HIGH(note_table << 1)
001d7f 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001d80 0feb                      	add ZL, r27 //add offset
001d81 1df2                      	adc ZH, zero
001d82 91c5                      	lpm r28, Z+ //load bytes
001d83 91d4                      	lpm r29, Z
001d84 93c0 28f1                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001d86 93d0 28f2                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001d88 95a2                      	swap r26
001d89 70af                      	andi r26, 0x0F //mask effect speed
001d8a 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001d8b 95a3                      	inc r26 //increment the speed by 1
                                 
001d8c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d8d 937f                      	push r23
001d8e 2f6a                      	mov r22, r26 //store the speed data into r27
001d8f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d90 9f67                      	mul r22, r23
001d91 917f                      	pop r23
001d92 916f                      	pop r22
                                 
001d93 9416                      	lsr r1 //shift out the fractional bits
001d94 9407                      	ror r0
001d95 9416                      	lsr r1
001d96 9407                      	ror r0
001d97 9416                      	lsr r1
001d98 9407                      	ror r0
001d99 9416                      	lsr r1
001d9a 9407                      	ror r0
                                 
001d9b 9200 28f3                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001d9d 9210 28f4                 	sts triangle_fx_Qxy_speed+1, r1
001d9f 9220 28f5                 	sts triangle_fx_Qxy_total_offset, zero
001da1 9220 28f6                 	sts triangle_fx_Qxy_total_offset+1, zero
001da3 cef8                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001da4 91e0 28c2                 	lds ZL, triangle_arpeggio_macro
001da6 91f0 28c3                 	lds ZH, triangle_arpeggio_macro+1
001da8 9630                      	adiw Z, 0
001da9 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001daa cef1                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001dab 91e0 28c9                 	lds ZL, triangle_pitch_macro
001dad 91f0 28ca                 	lds ZH, triangle_pitch_macro+1
001daf 9630                      	adiw Z, 0
001db0 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001db1 ceea                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001db2 91e0 28cf                 	lds ZL, triangle_hi_pitch_macro
001db4 91f0 28d0                 	lds ZH, triangle_hi_pitch_macro+1
001db6 9630                      	adiw Z, 0
001db7 f009                      	breq sound_driver_channel2_fx_Rxy_process
001db8 cee3                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001db9 2fba                      	mov r27, r26 //copy fx parameters into r27
001dba 70bf                      	andi r27, 0x0F //mask note index offset
001dbb 91c0 2812                 	lds r28, triangle_note //load current note index
001dbd 1bcb                      	sub r28, r27
001dbe f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001dbf e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001dc0 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001dc1 e0f0                      	ldi ZH, HIGH(note_table << 1)
001dc2 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001dc3 0fec                      	add ZL, r28 //add offset
001dc4 1df2                      	adc ZH, zero
001dc5 91c5                      	lpm r28, Z+ //load bytes
001dc6 91d4                      	lpm r29, Z
001dc7 93c0 28f7                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001dc9 93d0 28f8                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001dcb 95a2                      	swap r26
001dcc 70af                      	andi r26, 0x0F //mask effect speed
001dcd 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001dce 95a3                      	inc r26 //increment the speed by 1
                                 
001dcf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001dd0 937f                      	push r23
001dd1 2f6a                      	mov r22, r26 //store the speed data into r27
001dd2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001dd3 9f67                      	mul r22, r23
001dd4 917f                      	pop r23
001dd5 916f                      	pop r22
                                 
001dd6 9416                      	lsr r1 //shift out the fractional bits
001dd7 9407                      	ror r0
001dd8 9416                      	lsr r1
001dd9 9407                      	ror r0
001dda 9416                      	lsr r1
001ddb 9407                      	ror r0
001ddc 9416                      	lsr r1
001ddd 9407                      	ror r0
                                 
001dde 9200 28f9                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001de0 9210 28fa                 	sts triangle_fx_Rxy_speed+1, r1
001de2 9220 28fb                 	sts triangle_fx_Rxy_total_offset, zero
001de4 9220 28fc                 	sts triangle_fx_Rxy_total_offset+1, zero
001de6 ceb5                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001de7 15a2                      	cp r26, zero
001de8 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001de9 91b0 2819                 	lds r27, song_speed
001deb 17ab                      	cp r26, r27
001dec f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001ded 93a0 28fd                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001def e0b1                      	ldi r27, 0x01
001df0 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
001df2 c14f                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel2_fx_Sxx_invalid:
001df3 cea8                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001df4 cea7                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001df5 cea6                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001df6 cea5                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001df7 cea4                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001df8 cea3                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001df9 93b0 2812                 	sts triangle_note, r27 //store the note index
001dfb e0a3                      	ldi r26, 0x03
001dfc e0b2                      	ldi r27, 0x02
001dfd 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001dff 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
001e01 93b0 28cb                 	sts triangle_pitch_macro_offset, r27
001e03 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27
001e05 93b0 28d6                 	sts triangle_duty_macro_offset, r27
001e07 9220 28c8                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001e09 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero
001e0b 9220 28dd                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001e0d 9220 28de                 	sts triangle_fx_1xx_total+1, zero
001e0f 9220 28e1                 	sts triangle_fx_2xx_total, zero
001e11 9220 28e2                 	sts triangle_fx_2xx_total+1, zero
001e13 9220 28e9                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001e15 9220 28ea                 	sts triangle_fx_3xx_total_offset+1, zero
001e17 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001e19 91b0 0aad                 	lds r27, TCB2_CCMPH
001e1b 93a0 28e3                 	sts triangle_fx_3xx_start, r26
001e1d 93b0 28e4                 	sts triangle_fx_3xx_start+1, r27
001e1f 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e21 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001e23 9220 28f5                 	sts triangle_fx_Qxy_total_offset, zero
001e25 9220 28f6                 	sts triangle_fx_Qxy_total_offset+1, zero
001e27 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001e29 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001e2b 9220 28fb                 	sts triangle_fx_Rxy_total_offset, zero
001e2d 9220 28fc                 	sts triangle_fx_Rxy_total_offset+1, zero
001e2f d0fb                      	rcall sound_driver_channel2_increment_offset
001e30 ce6b                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001e31 d0f9                      	rcall sound_driver_channel2_increment_offset
001e32 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001e33 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001e34 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001e35 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001e37 ce64                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001e38 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001e3a 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001e3c 9220 0aad                 	sts TCB2_CCMPH, zero
001e3e ce5d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001e3f 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001e40 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
001e42 d0e8                      	rcall sound_driver_channel2_increment_offset
001e43 c0fe                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001e44 9220 28bd                 	sts triangle_volume_macro, zero //reset all macro addresses
001e46 9220 28be                 	sts triangle_volume_macro+1, zero
001e48 9220 28c2                 	sts triangle_arpeggio_macro, zero
001e4a 9220 28c3                 	sts triangle_arpeggio_macro+1, zero
001e4c 9220 28c9                 	sts triangle_pitch_macro, zero
001e4e 9220 28ca                 	sts triangle_pitch_macro+1, zero
001e50 9220 28cf                 	sts triangle_hi_pitch_macro, zero
001e52 9220 28d0                 	sts triangle_hi_pitch_macro+1, zero
001e54 9220 28d4                 	sts triangle_duty_macro, zero
001e56 9220 28d5                 	sts triangle_duty_macro+1, zero
001e58 9220 28c8                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001e5a 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001e5c 9631                      	adiw Z, 1 //point to the byte next to the flag
001e5d 91b4                      	lpm r27, Z //store the instrument offset into r27
001e5e e6ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001e5f e1f0                      	ldi ZH, HIGH(instruments)
001e60 0feb                      	add ZL, r27 //point Z to offsetted instrument
001e61 1df2                      	adc ZH, zero
001e62 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001e63 1fff                      	rol ZH
001e64 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001e65 91b4                      	lpm r27, Z
                                 
001e66 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001e67 1fbb                      	rol r27
001e68 2fea                      	mov ZL, r26
001e69 2ffb                      	mov ZH, r27
001e6a 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001e6b 9632                      	adiw Z, 2 //point Z to the address of the macro
001e6c e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001e6d 95aa                      	dec r26
001e6e f019                      	breq sound_driver_channel2_instrument_change_exit
001e6f 95b6                      	lsr r27
001e70 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001e71 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001e72 e0a3                      	ldi r26, 0x03
001e73 e0b2                      	ldi r27, 0x02
001e74 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001e76 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
001e78 93b0 28cb                 	sts triangle_pitch_macro_offset, r27
001e7a 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27
001e7c 93b0 28d6                 	sts triangle_duty_macro_offset, r27
001e7e d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001e7f ce1c                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001e80 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001e81 91d5                      	lpm r29, Z+
                                 
001e82 30a5                      	cpi r26, 5
001e83 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
001e84 30a4                      	cpi r26, 4
001e85 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
001e86 30a3                      	cpi r26, 3
001e87 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
001e88 30a2                      	cpi r26, 2
001e89 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
001e8a c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
001e8b 93c0 28bd                 	sts triangle_volume_macro, r28
001e8d 93d0 28be                 	sts triangle_volume_macro+1, r29
001e8f d041                      	rcall sound_driver_channel2_instrument_change_read_header
001e90 93c0 28c1                 	sts triangle_volume_macro_release, r28
001e92 93d0 28c0                 	sts triangle_volume_macro_loop, r29
001e94 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
001e95 93c0 28c2                 	sts triangle_arpeggio_macro, r28
001e97 93d0 28c3                 	sts triangle_arpeggio_macro+1, r29
001e99 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e9b 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001e9d 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001e9f 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001ea1 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
001ea2 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
001ea3 93c0 28c9                 	sts triangle_pitch_macro, r28
001ea5 93d0 28ca                 	sts triangle_pitch_macro+1, r29
001ea7 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ea9 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001eab 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001ead 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001eaf d021                      	rcall sound_driver_channel2_instrument_change_read_header
001eb0 93c0 28cd                 	sts triangle_pitch_macro_release, r28
001eb2 93d0 28cc                 	sts triangle_pitch_macro_loop, r29
001eb4 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001eb5 93c0 28cf                 	sts triangle_hi_pitch_macro, r28
001eb7 93d0 28d0                 	sts triangle_hi_pitch_macro+1, r29
001eb9 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ebb 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001ebd 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001ebf 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001ec1 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001ec2 93c0 28d3                 	sts triangle_hi_pitch_macro_release, r28
001ec4 93d0 28d2                 	sts triangle_hi_pitch_macro_loop, r29
001ec6 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
001ec7 93c0 28d4                 	sts triangle_duty_macro, r28
001ec9 93d0 28d5                 	sts triangle_duty_macro+1, r29
001ecb d005                      	rcall sound_driver_channel2_instrument_change_read_header
001ecc 93c0 28d8                 	sts triangle_duty_macro_release, r28
001ece 93d0 28d7                 	sts triangle_duty_macro_loop, r29
001ed0 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001ed1 93ef                      	push ZL
001ed2 93ff                      	push ZH
001ed3 2fec                      	mov ZL, r28
001ed4 2ffd                      	mov ZH, r29
001ed5 0fee                      	lsl ZL
001ed6 1fff                      	rol ZH
001ed7 91c5                      	lpm r28, Z+
001ed8 91d4                      	lpm r29, Z
001ed9 91ff                      	pop ZH
001eda 91ef                      	pop ZL
001edb 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
001edc 93ef                      	push ZL
001edd 93ff                      	push ZH
001ede 2fec                      	mov ZL, r28
001edf 2ffd                      	mov ZH, r29
001ee0 0fee                      	lsl ZL
001ee1 1fff                      	rol ZH
001ee2 91c5                      	lpm r28, Z+
001ee3 91d5                      	lpm r29, Z+
001ee4 93c0 28c6                 	sts triangle_arpeggio_macro_release, r28
001ee6 93d0 28c5                 	sts triangle_arpeggio_macro_loop, r29
001ee8 91c4                      	lpm r28, Z
001ee9 93c0 28c7                 	sts triangle_arpeggio_macro_mode, r28
001eeb 91ff                      	pop ZH
001eec 91ef                      	pop ZL
001eed 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001eee 91b0 28c1                 	lds r27, triangle_volume_macro_release
001ef0 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001ef1 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001ef2 95b3                      	inc r27
001ef3 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001ef5 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
001ef7 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001ef8 f019                      	breq sound_driver_channel2_release_pitch
001ef9 95b3                      	inc r27
001efa 93b0 28c4                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
001efc 91b0 28cd                 	lds r27, triangle_pitch_macro_release
001efe 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001eff f019                      	breq sound_driver_channel2_release_hi_pitch
001f00 95b3                      	inc r27
001f01 93b0 28cb                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001f03 91b0 28d3                 	lds r27, triangle_hi_pitch_macro_release
001f05 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001f06 f019                      	breq sound_driver_channel2_release_duty
001f07 95b3                      	inc r27
001f08 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
001f0a 91b0 28d8                 	lds r27, triangle_duty_macro_release
001f0c 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001f0d f019                      	breq sound_driver_channel2_release_exit
001f0e 95b3                      	inc r27
001f0f 93b0 28d6                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001f11 d019                      	rcall sound_driver_channel2_increment_offset
001f12 cd89                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001f13 91e0 2813                 	lds ZL, song_frames
001f15 91f0 2814                 	lds ZH, song_frames+1
001f17 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001f19 91b0 2816                 	lds r27, song_frame_offset+1
001f1b 9614                      	adiw r27:r26, 4 //offset for channel 2
001f1c 0fea                      	add ZL, r26
001f1d 1ffb                      	adc ZH, r27
                                 
001f1e 91a5                      	lpm r26, Z+ //load the address of the next pattern
001f1f 91b4                      	lpm r27, Z
001f20 0faa                      	lsl r26
001f21 1fbb                      	rol r27
001f22 93a0 28b7                 	sts triangle_pattern, r26
001f24 93b0 28b8                 	sts triangle_pattern+1, r27
                                 
001f26 9220 28bb                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001f28 9220 28bc                 	sts triangle_pattern_offset+1, zero
001f2a cd71                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
001f2b 91e0 28bb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001f2d 91f0 28bc                 	lds ZH, triangle_pattern_offset+1
001f2f 9631                      	adiw Z, 1
001f30 93e0 28bb                 	sts triangle_pattern_offset, ZL
001f32 93f0 28bc                 	sts triangle_pattern_offset+1, ZH
001f34 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001f35 91e0 28bb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001f37 91f0 28bc                 	lds ZH, triangle_pattern_offset+1
001f39 9632                      	adiw Z, 2 //increment the pointer twice
001f3a 93e0 28bb                 	sts triangle_pattern_offset, ZL
001f3c 93f0 28bc                 	sts triangle_pattern_offset+1, ZH
001f3e 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001f3f 95ba                      	dec r27
001f40 93b0 28ba                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
001f42 91f0 2819                 	lds r31, song_speed
001f44 2fef                      	mov r30, r31
001f45 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
001f46 91a0 2820                 	lds r26, pulse1_pattern_delay_frames
001f48 11a2                      	cpse r26, zero
001f49 c042                      	rjmp sound_driver_calculate_delays_pulse2
001f4a c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
001f4b 2faf                      	mov r26, r31 //move the speed to r26
001f4c 91b0 281f                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
001f4e 15b2                      	cp r27, zero
001f4f f409                      	brne PC+2
001f50 c03b                      	rjmp sound_driver_calculate_delays_pulse2
001f51 95ba                      	dec r27
001f52 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
001f54 11b2                      	cpse r27, zero
001f55 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
001f56 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
001f57 efbf                      	ldi r27, 0xFF
001f58 91c0 2868                 	lds r28, pulse1_fx_Sxx_pre
001f5a 91d0 2869                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
001f5c 17cb                      	cp r28, r27
001f5d f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
001f5e c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
001f5f 17db                      	cp r29, r27
001f60 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
001f61 c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
001f62 91c0 2859                 	lds r28, pulse1_fx_Gxx_pre
001f64 91d0 285a                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
001f66 17cb                      	cp r28, r27
001f67 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
001f68 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
001f69 17db                      	cp r29, r27
001f6a f0f9                      	breq sound_driver_calculate_delays_pulse1_store
001f6b c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
001f6c 93b0 2868                 	sts pulse1_fx_Sxx_pre, r27
001f6e 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001f6f 93e0 2869                 	sts pulse1_fx_Sxx_post, r30
001f71 95ca                      	dec r28
001f72 93c0 2820                 	sts pulse1_pattern_delay_frames, r28
001f74 2fef                      	mov r30, r31
001f75 50e1                      	subi r30, 1
001f76 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
001f77 93b0 2869                 	sts pulse1_fx_Sxx_post, r27
001f79 2fad                      	mov r26, r29
001f7a c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
001f7b 93b0 2859                 	sts pulse1_fx_Gxx_pre, r27
001f7d 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001f7e 93e0 285a                 	sts pulse1_fx_Gxx_post, r30
001f80 95ca                      	dec r28
001f81 93c0 2820                 	sts pulse1_pattern_delay_frames, r28
001f83 2fef                      	mov r30, r31
001f84 50e1                      	subi r30, 1
001f85 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
001f86 93b0 285a                 	sts pulse1_fx_Gxx_post, r27
001f88 2fad                      	mov r26, r29
001f89 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
001f8a 93a0 2820                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
001f8c 91a0 286d                 	lds r26, pulse2_pattern_delay_frames
001f8e 11a2                      	cpse r26, zero
001f8f c042                      	rjmp sound_driver_calculate_delays_triangle
001f90 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
001f91 2faf                      	mov r26, r31 //move the speed to r26
001f92 91b0 286c                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
001f94 15b2                      	cp r27, zero
001f95 f409                      	brne PC+2
001f96 c03b                      	rjmp sound_driver_calculate_delays_triangle
001f97 95ba                      	dec r27
001f98 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
001f9a 11b2                      	cpse r27, zero
001f9b c034                      	rjmp sound_driver_calculate_delays_pulse2_store
001f9c 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
001f9d efbf                      	ldi r27, 0xFF
001f9e 91c0 28b5                 	lds r28, pulse2_fx_Sxx_pre
001fa0 91d0 28b6                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
001fa2 17cb                      	cp r28, r27
001fa3 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
001fa4 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
001fa5 17db                      	cp r29, r27
001fa6 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
001fa7 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
001fa8 91c0 28a6                 	lds r28, pulse2_fx_Gxx_pre
001faa 91d0 28a7                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
001fac 17cb                      	cp r28, r27
001fad f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
001fae c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
001faf 17db                      	cp r29, r27
001fb0 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
001fb1 c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
001fb2 93b0 28b5                 	sts pulse2_fx_Sxx_pre, r27
001fb4 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001fb5 93e0 28b6                 	sts pulse2_fx_Sxx_post, r30
001fb7 95ca                      	dec r28
001fb8 93c0 286d                 	sts pulse2_pattern_delay_frames, r28
001fba 2fef                      	mov r30, r31
001fbb 50e1                      	subi r30, 1
001fbc cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
001fbd 93b0 28b6                 	sts pulse2_fx_Sxx_post, r27
001fbf 2fad                      	mov r26, r29
001fc0 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
001fc1 93b0 28a6                 	sts pulse2_fx_Gxx_pre, r27
001fc3 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001fc4 93e0 28a7                 	sts pulse2_fx_Gxx_post, r30
001fc6 95ca                      	dec r28
001fc7 93c0 286d                 	sts pulse2_pattern_delay_frames, r28
001fc9 2fef                      	mov r30, r31
001fca 50e1                      	subi r30, 1
001fcb cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
001fcc 93b0 28a7                 	sts pulse2_fx_Gxx_post, r27
001fce 2fad                      	mov r26, r29
001fcf c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
001fd0 93a0 286d                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
001fd2 91a0 28ba                 	lds r26, triangle_pattern_delay_frames
001fd4 11a2                      	cpse r26, zero
001fd5 c042                      	rjmp sound_driver_calculate_delays_noise
001fd6 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
001fd7 2faf                      	mov r26, r31 //move the speed to r26
001fd8 91b0 28b9                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
001fda 15b2                      	cp r27, zero
001fdb f409                      	brne PC+2
001fdc c03b                      	rjmp sound_driver_calculate_delays_noise
001fdd 95ba                      	dec r27
001fde 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
001fe0 11b2                      	cpse r27, zero
001fe1 c034                      	rjmp sound_driver_calculate_delays_triangle_store
001fe2 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
001fe3 efbf                      	ldi r27, 0xFF
001fe4 91c0 28fd                 	lds r28, triangle_fx_Sxx_pre
001fe6 91d0 28fe                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
001fe8 17cb                      	cp r28, r27
001fe9 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
001fea c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
001feb 17db                      	cp r29, r27
001fec f009                      	breq sound_driver_calculate_delays_triangle_Gxx
001fed c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
001fee 91c0 28ee                 	lds r28, triangle_fx_Gxx_pre
001ff0 91d0 28ef                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
001ff2 17cb                      	cp r28, r27
001ff3 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
001ff4 c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
001ff5 17db                      	cp r29, r27
001ff6 f0f9                      	breq sound_driver_calculate_delays_triangle_store
001ff7 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
001ff8 93b0 28fd                 	sts triangle_fx_Sxx_pre, r27
001ffa 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001ffb 93e0 28fe                 	sts triangle_fx_Sxx_post, r30
001ffd 95ca                      	dec r28
001ffe 93c0 28ba                 	sts triangle_pattern_delay_frames, r28
002000 2fef                      	mov r30, r31
002001 50e1                      	subi r30, 1
002002 c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
002003 93b0 28fe                 	sts triangle_fx_Sxx_post, r27
002005 2fad                      	mov r26, r29
002006 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002007 93b0 28ee                 	sts triangle_fx_Gxx_pre, r27
002009 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00200a 93e0 28ef                 	sts triangle_fx_Gxx_post, r30
00200c 95ca                      	dec r28
00200d 93c0 28ba                 	sts triangle_pattern_delay_frames, r28
00200f 2fef                      	mov r30, r31
002010 50e1                      	subi r30, 1
002011 c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
002012 93b0 28ef                 	sts triangle_fx_Gxx_post, r27
002014 2fad                      	mov r26, r29
002015 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
002016 93a0 28ba                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002018 91e0 2823                 	lds ZL, pulse1_volume_macro
00201a 91f0 2824                 	lds ZH, pulse1_volume_macro+1
00201c 9630                      	adiw Z, 0
00201d f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
00201e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00201f 1fff                      	rol ZH
002020 91a0 2825                 	lds r26, pulse1_volume_macro_offset
002022 0fea                      	add ZL, r26
002023 1df2                      	adc ZH, zero
                                 
002024 91b0 2827                 	lds r27, pulse1_volume_macro_release
002026 17ba                      	cp r27, r26
002027 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
002028 91a0 2826                 	lds r26, pulse1_volume_macro_loop
00202a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00202b f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00202c c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
00202d 95a3                      	inc r26 //increment the macro offset
00202e 93a0 2825                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
002030 91b4                      	lpm r27, Z //load volume data into r27
002031 3fbf                      	cpi r27, 0xFF //check for macro end flag
002032 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
002033 91b0 2827                 	lds r27, pulse1_volume_macro_release
002035 3fbf                      	cpi r27, 0xFF
002036 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
002037 91b0 2826                 	lds r27, pulse1_volume_macro_loop //load the loop index
002039 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00203b cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
00203c 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00203d 93a0 2825                 	sts pulse1_volume_macro_offset, r26
00203f cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
002040 efe8                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002041 e5f3                      	ldi ZH, HIGH(volumes << 1)
002042 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002043 0feb                      	add ZL, r27 //add offset to the table
002044 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
002045 91b0 2800                 	lds r27, pulse1_param //load main volume
002047 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002048 91a0 2857                 	lds r26, pulse1_fx_7xy_value
00204a 30a0                      	cpi r26, 0x00
00204b f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
00204c 0feb                      	add ZL, r27 //offset the volume table by the main volume
00204d 1df2                      	adc ZH, zero
00204e 91b4                      	lpm r27, Z
00204f 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002051 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002052 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002054 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002055 91a0 2857                 	lds r26, pulse1_fx_7xy_value
002057 30a0                      	cpi r26, 0x00
002058 f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
002059 93b0 2806                 	sts pulse1_output_volume, r27
00205b c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
00205c 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00205d f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00205e f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00205f e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002060 0feb                      	add ZL, r27 //offset the volume table by the main volume
002061 1df2                      	adc ZH, zero
002062 91b4                      	lpm r27, Z
002063 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002065 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002066 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002067 0feb                      	add ZL, r27 //offset the volume table by the main volume
002068 1df2                      	adc ZH, zero
002069 91b4                      	lpm r27, Z
00206a 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00206c c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
00206d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00206e f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
00206f f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002070 93b0 2806                 	sts pulse1_output_volume, r27
002072 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002073 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002074 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002076 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
002078 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
00207a 9630                      	adiw Z, 0
00207b f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00207c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00207d 1fff                      	rol ZH
00207e 91a0 282a                 	lds r26, pulse1_arpeggio_macro_offset
002080 0fea                      	add ZL, r26
002081 1df2                      	adc ZH, zero
                                 
002082 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
002084 17ba                      	cp r27, r26
002085 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002086 91a0 282b                 	lds r26, pulse1_arpeggio_macro_loop
002088 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002089 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00208a c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00208b 95a3                      	inc r26 //increment the macro offset
00208c 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00208e 91b4                      	lpm r27, Z //load arpeggio data into r27
00208f 38b0                      	cpi r27, 0x80 //check for macro end flag
002090 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002091 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002092 50a1                      	subi r26, 1 //keep the offset at the end flag
002093 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
002095 91b0 282d                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002097 30b1                      	cpi r27, 0x01
002098 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
002099 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
00209b 3fbf                      	cpi r27, 0xFF
00209c f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
00209d 91b0 282b                 	lds r27, pulse1_arpeggio_macro_loop
00209f 3fbf                      	cpi r27, 0xFF
0020a0 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0020a1 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0020a2 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
0020a4 3fbf                      	cpi r27, 0xFF
0020a5 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0020a6 91b0 282b                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0020a8 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0020a9 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0020aa 91c0 283f                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0020ac 91d0 2840                 	lds r29, pulse1_fx_0xy_sequence+1
0020ae 9620                      	adiw r29:r28, 0
0020af f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0020b0 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0020b1 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0020b3 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0020b4 93b0 282a                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0020b6 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0020b7 91c0 283f                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0020b9 91d0 2840                 	lds r29, pulse1_fx_0xy_sequence+1
0020bb 9620                      	adiw r29:r28, 0 //check for 0xy effect
0020bc f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
0020bd 95d6                      	lsr r29
0020be 95c7                      	ror r28
0020bf 95d7                      	ror r29
0020c0 95c7                      	ror r28
0020c1 95d7                      	ror r29
0020c2 95c7                      	ror r28
0020c3 95d7                      	ror r29
0020c4 95c7                      	ror r28
0020c5 95d7                      	ror r29
0020c6 95d2                      	swap r29
                                 
0020c7 93c0 283f                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0020c9 93d0 2840                 	sts pulse1_fx_0xy_sequence+1, r29
0020cb 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0020cc 91a0 2807                 	lds r26, pulse1_note //load the current note index
0020ce 0fac                      	add r26, r28 //add the note offset
0020cf c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0020d0 91a0 2807                 	lds r26, pulse1_note //load the current note index
0020d2 c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0020d3 9220 282e                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0020d5 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero
0020d7 91a0 282d                 	lds r26, pulse1_arpeggio_macro_mode
0020d9 30a1                      	cpi r26, 0x01 //absolute mode
0020da f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0020db f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0020dc c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0020dd 91a0 2807                 	lds r26, pulse1_note //load the current note index
0020df 0fab                      	add r26, r27 //offset the note with the arpeggio data
0020e0 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0020e1 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0020e2 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0020e3 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0020e4 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0020e5 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0020e6 fda7                      	sbrc r26, 7 //check if result is negative
0020e7 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0020e8 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0020e9 2fab                      	mov r26, r27 //move the arpeggio data into r26
0020ea c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0020eb 91a0 2807                 	lds r26, pulse1_note //load the current note index
0020ed 0fab                      	add r26, r27 //offset the note with the arpeggio data
0020ee fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0020ef c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0020f0 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0020f2 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0020f3 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0020f4 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0020f5 93a0 2807                 	sts pulse1_note, r26
0020f7 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
0020f8 fda7                      	sbrc r26, 7 //check if result is negative
0020f9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0020fa 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
0020fc e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
0020fd e0f0                      	ldi ZH, HIGH(note_table << 1)
0020fe 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0020ff 0fea                      	add ZL, r26 //add offset
002100 1df2                      	adc ZH, zero
002101 91a5                      	lpm r26, Z+ //load bytes
002102 91b4                      	lpm r27, Z
002103 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002105 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002107 93a0 284b                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002109 93b0 284c                 	sts pulse1_fx_3xx_target+1, r27
00210b c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
00210c 91e0 282f                 	lds ZL, pulse1_pitch_macro
00210e 91f0 2830                 	lds ZH, pulse1_pitch_macro+1
002110 9630                      	adiw Z, 0
002111 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002112 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002113 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002114 1fff                      	rol ZH
002115 91a0 2831                 	lds r26, pulse1_pitch_macro_offset
002117 0fea                      	add ZL, r26
002118 1df2                      	adc ZH, zero
                                 
002119 91b0 2833                 	lds r27, pulse1_pitch_macro_release
00211b 17ba                      	cp r27, r26
00211c f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
00211d 91a0 2832                 	lds r26, pulse1_pitch_macro_loop
00211f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002120 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002121 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
002122 95a3                      	inc r26 //increment the macro offset
002123 93a0 2831                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
002125 91b4                      	lpm r27, Z //load pitch data into r27
002126 38b0                      	cpi r27, 0x80 //check for macro end flag
002127 f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
002128 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002129 93a0 2831                 	sts pulse1_pitch_macro_offset, r26
00212b 91b0 2833                 	lds r27, pulse1_pitch_macro_release
00212d 3fbf                      	cpi r27, 0xFF
00212e f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
00212f 91b0 2832                 	lds r27, pulse1_pitch_macro_loop //load the loop index
002131 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002132 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002133 93b0 2831                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
002135 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002136 91b0 282e                 	lds r27, pulse1_total_pitch_offset
002138 c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002139 91a0 282e                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
00213b 0fba                      	add r27, r26
00213c 93b0 282e                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
00213e 91a0 285b                 	lds r26, pulse1_fx_Pxx
002140 0fba                      	add r27, r26
                                 
002141 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002142 937f                      	push r23
002143 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002144 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002145 0367                      	mulsu r22, r23
002146 917f                      	pop r23
002147 916f                      	pop r22
                                 
002148 9416                      	lsr r1 //shift out the fractional bits
002149 9407                      	ror r0
00214a 9416                      	lsr r1
00214b 9407                      	ror r0
00214c 9416                      	lsr r1
00214d 9407                      	ror r0
00214e 9416                      	lsr r1
00214f 9407                      	ror r0
002150 fe13                      	sbrs r1, 3 //check if result was a negative number
002151 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
002152 efb0                      	ldi r27, 0xF0
002153 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002154 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002156 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002158 0da0                      	add r26, r0 //offset the timer values
002159 1db1                      	adc r27, r1
                                 	
00215a 91c0 2843                 	lds r28, pulse1_fx_1xx_total
00215c 91d0 2844                 	lds r29, pulse1_fx_1xx_total+1
00215e 1bac                      	sub r26, r28
00215f 0bbd                      	sbc r27, r29
002160 91c0 2847                 	lds r28, pulse1_fx_2xx_total
002162 91d0 2848                 	lds r29, pulse1_fx_2xx_total+1
002164 0fac                      	add r26, r28
002165 1fbd                      	adc r27, r29
002166 91c0 2860                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002168 91d0 2861                 	lds r29, pulse1_fx_Qxy_total_offset+1
00216a 1bac                      	sub r26, r28
00216b 0bbd                      	sbc r27, r29
00216c 91c0 2866                 	lds r28, pulse1_fx_Rxy_total_offset
00216e 91d0 2867                 	lds r29, pulse1_fx_Rxy_total_offset+1
002170 0fac                      	add r26, r28
002171 1fbd                      	adc r27, r29
                                 
002172 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002174 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
002176 91e0 2835                 	lds ZL, pulse1_hi_pitch_macro
002178 91f0 2836                 	lds ZH, pulse1_hi_pitch_macro+1
00217a 9630                      	adiw Z, 0
00217b f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
00217c c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
00217d 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00217e 1fff                      	rol ZH
00217f 91a0 2837                 	lds r26, pulse1_hi_pitch_macro_offset
002181 0fea                      	add ZL, r26
002182 1df2                      	adc ZH, zero
                                 
002183 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_release
002185 17ba                      	cp r27, r26
002186 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002187 91a0 2838                 	lds r26, pulse1_hi_pitch_macro_loop
002189 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00218a f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00218b c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
00218c 95a3                      	inc r26 //increment the macro offset
00218d 93a0 2837                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
00218f 91b4                      	lpm r27, Z //load hi pitch data into r27
002190 38b0                      	cpi r27, 0x80 //check for macro end flag
002191 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
002192 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002193 93a0 2837                 	sts pulse1_hi_pitch_macro_offset, r26
002195 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_release
002197 3fbf                      	cpi r27, 0xFF
002198 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
002199 91b0 2838                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
00219b 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00219c f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00219d 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
00219f cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0021a0 91b0 2834                 	lds r27, pulse1_total_hi_pitch_offset
0021a2 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0021a3 91a0 2834                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0021a5 0fba                      	add r27, r26
0021a6 93b0 2834                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0021a8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0021a9 937f                      	push r23
0021aa 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0021ab eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0021ac 0367                      	mulsu r22, r23
0021ad 917f                      	pop r23
0021ae 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0021af 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0021b1 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0021b3 0da0                      	add r26, r0 //offset the timer values
0021b4 1db1                      	adc r27, r1
0021b5 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0021b7 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0021b9 91e0 283a                 	lds ZL, pulse1_duty_macro
0021bb 91f0 283b                 	lds ZH, pulse1_duty_macro+1
0021bd 9630                      	adiw Z, 0
0021be f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0021bf 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0021c0 1fff                      	rol ZH
0021c1 91a0 283c                 	lds r26, pulse1_duty_macro_offset
0021c3 0fea                      	add ZL, r26
0021c4 1df2                      	adc ZH, zero
                                 
0021c5 91b0 283e                 	lds r27, pulse1_duty_macro_release
0021c7 17ba                      	cp r27, r26
0021c8 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0021c9 91a0 283d                 	lds r26, pulse1_duty_macro_loop
0021cb 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0021cc f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0021cd c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0021ce 95a3                      	inc r26 //increment the macro offset
0021cf 93a0 283c                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0021d1 91b4                      	lpm r27, Z //load pitch data into r27
0021d2 3fbf                      	cpi r27, 0xFF //check for macro end flag
0021d3 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0021d4 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0021d5 93a0 283c                 	sts pulse1_duty_macro_offset, r26
0021d7 91b0 283e                 	lds r27, pulse1_duty_macro_release
0021d9 3fbf                      	cpi r27, 0xFF
0021da f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0021db 91b0 283d                 	lds r27, pulse1_duty_macro_loop //load the loop index
0021dd 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0021de f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0021df 93b0 283c                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0021e1 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0021e2 e5e8                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0021e3 e5f3                      	ldi ZH, HIGH(sequences << 1)
0021e4 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0021e5 1df2                      	adc ZH, zero
                                 
0021e6 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0021e7 95b7                      	ror r27
0021e8 95b7                      	ror r27
0021e9 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0021eb 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0021ec 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0021ed 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0021ee c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0021ef c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0021f0 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0021f1 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0021f2 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0021f3 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0021f5 91e0 2841                 	lds ZL, pulse1_fx_1xx
0021f7 91f0 2842                 	lds ZH, pulse1_fx_1xx+1
0021f9 9630                      	adiw Z, 0
0021fa f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0021fb 91a0 2843                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0021fd 91b0 2844                 	lds r27, pulse1_fx_1xx_total+1
0021ff 0fae                      	add r26, ZL //increase the total offset by the rate
002200 1fbf                      	adc r27, ZH
002201 93a0 2843                 	sts pulse1_fx_1xx_total, r26
002203 93b0 2844                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
002205 91e0 2845                 	lds ZL, pulse1_fx_2xx
002207 91f0 2846                 	lds ZH, pulse1_fx_2xx+1
002209 9630                      	adiw Z, 0
00220a f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
00220b 91a0 2847                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
00220d 91b0 2848                 	lds r27, pulse1_fx_2xx_total+1
00220f 0fae                      	add r26, ZL //increase the total offset by the rate
002210 1fbf                      	adc r27, ZH
002211 93a0 2847                 	sts pulse1_fx_2xx_total, r26
002213 93b0 2848                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
002215 91e0 284d                 	lds ZL, pulse1_fx_3xx_speed
002217 91f0 284e                 	lds ZH, pulse1_fx_3xx_speed+1
002219 9630                      	adiw Z, 0
00221a f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
00221b c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
00221c 91a0 2849                 	lds r26, pulse1_fx_3xx_start
00221e 91b0 284a                 	lds r27, pulse1_fx_3xx_start+1
002220 9610                      	adiw r26:r27, 0
002221 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
002222 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
002223 91c0 284b                 	lds r28, pulse1_fx_3xx_target
002225 91d0 284c                 	lds r29, pulse1_fx_3xx_target+1
                                 
002227 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002228 07bd                      	cpc r27, r29
002229 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
00222a f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00222b c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
00222c 9220 2849                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00222e 9220 284a                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002230 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
002231 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002232 0bdb                      	sbc r29, r27
002233 91a0 284f                 	lds r26, pulse1_fx_3xx_total_offset
002235 91b0 2850                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
002237 0fae                      	add r26, ZL //add the speed to the total offset
002238 1fbf                      	adc r27, ZH
002239 1bca                      	sub r28, r26 //invert the total difference with the total offset
00223a 0bdb                      	sbc r29, r27
00223b f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00223c 93a0 284f                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
00223e 93b0 2850                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
002240 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
002242 91b0 0a8d                 	lds r27, TCB0_CCMPH
002244 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002245 0bbd                      	sbc r27, r29
002246 93a0 0a8c                 	sts TCB0_CCMPL, r26
002248 93b0 0a8d                 	sts TCB0_CCMPH, r27
00224a c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
00224b 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00224c 0bbd                      	sbc r27, r29
00224d 91c0 284f                 	lds r28, pulse1_fx_3xx_total_offset
00224f 91d0 2850                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
002251 0fce                      	add r28, ZL //add the speed to the total offset
002252 1fdf                      	adc r29, ZH
002253 1bac                      	sub r26, r28 //invert the total difference with the total offset
002254 0bbd                      	sbc r27, r29
002255 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002256 93c0 284f                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
002258 93d0 2850                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
00225a 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
00225c 91d0 0a8d                 	lds r29, TCB0_CCMPH
00225e 0fca                      	add r28, r26 //offset the current timer period with the total offset
00225f 1fdb                      	adc r29, r27
002260 93c0 0a8c                 	sts TCB0_CCMPL, r28
002262 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002264 91a0 2851                 	lds r26, pulse1_fx_4xy_speed
002266 15a2                      	cp r26, zero
002267 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
002268 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
002269 91b0 2852                 	lds r27, pulse1_fx_4xy_depth
00226b 91c0 2853                 	lds r28, pulse1_fx_4xy_phase
00226d 0fca                      	add r28, r26 //increase the phase by the speed
00226e 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
00226f f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002270 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
002271 93c0 2853                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002273 31c0                      	cpi r28, 16
002274 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
002275 32c0                      	cpi r28, 32
002276 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
002277 33c0                      	cpi r28, 48
002278 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
002279 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
00227a 70cf                      	andi r28, 0x0F //mask for values 0-15
00227b c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
00227c 6fc0                      	ori r28, 0xF0
00227d 95c0                      	com r28 //invert values 0-15
00227e c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
00227f 70cf                      	andi r28, 0x0F //mask for values 0-15
002280 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
002281 6fc0                      	ori r28, 0xF0
002282 95c0                      	com r28 //invert values 0-15
002283 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
002284 95b2                      	swap r27 //multiply depth by 16
002285 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002286 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002287 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002288 0fec                      	add ZL, r28 //offset the table by the depth+phase
002289 1df2                      	adc ZH, zero
00228a 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00228b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00228c 937f                      	push r23
00228d 2f6c                      	mov r22, r28 //store the vibrato value into r22
00228e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00228f 9f67                      	mul r22, r23
002290 917f                      	pop r23
002291 916f                      	pop r22
                                 
002292 9416                      	lsr r1 //shift out the fractional bits
002293 9407                      	ror r0
002294 9416                      	lsr r1
002295 9407                      	ror r0
002296 9416                      	lsr r1
002297 9407                      	ror r0
002298 9416                      	lsr r1
002299 9407                      	ror r0
                                 	
00229a 91a0 0a8c                 	lds r26, TCB0_CCMPL
00229c 91b0 0a8d                 	lds r27, TCB0_CCMPH
00229e 0da0                      	add r26, r0
00229f 1db1                      	adc r27, r1
0022a0 93a0 0a8c                 	sts TCB0_CCMPL, r26
0022a2 93b0 0a8d                 	sts TCB0_CCMPH, r27
0022a4 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
0022a5 95b2                      	swap r27 //multiply depth by 16
0022a6 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0022a7 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0022a8 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0022a9 0fec                      	add ZL, r28 //offset the table by the depth+phase
0022aa 1df2                      	adc ZH, zero
0022ab 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0022ac 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022ad 937f                      	push r23
0022ae 2f6c                      	mov r22, r28 //store the vibrato value into r22
0022af eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022b0 9f67                      	mul r22, r23
0022b1 917f                      	pop r23
0022b2 916f                      	pop r22
                                 
0022b3 9416                      	lsr r1 //shift out the fractional bits
0022b4 9407                      	ror r0
0022b5 9416                      	lsr r1
0022b6 9407                      	ror r0
0022b7 9416                      	lsr r1
0022b8 9407                      	ror r0
0022b9 9416                      	lsr r1
0022ba 9407                      	ror r0
                                 
0022bb 91a0 0a8c                 	lds r26, TCB0_CCMPL
0022bd 91b0 0a8d                 	lds r27, TCB0_CCMPH
0022bf 19a0                      	sub r26, r0
0022c0 09b1                      	sbc r27, r1
0022c1 93a0 0a8c                 	sts TCB0_CCMPL, r26
0022c3 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0022c5 91a0 2854                 	lds r26, pulse1_fx_7xy_speed
0022c7 15a2                      	cp r26, zero
0022c8 f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0022c9 91b0 2855                 	lds r27, pulse1_fx_7xy_depth
0022cb 91c0 2856                 	lds r28, pulse1_fx_7xy_phase
0022cd 0fca                      	add r28, r26 //increase the phase by the speed
0022ce 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0022cf f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0022d0 e0c0                      	ldi r28, 0x00
0022d1 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0022d2 93c0 2856                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
0022d4 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0022d5 ffc4                      	sbrs r28, 4
0022d6 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
0022d7 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
0022d8 70cf                      	andi r28, 0x0F //mask for values 0-15
0022d9 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
0022da 6fc0                      	ori r28, 0xF0
0022db 95c0                      	com r28 //invert values 0-15
0022dc c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
0022dd 95b2                      	swap r27 //multiply depth by 16
0022de 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0022df e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0022e0 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0022e1 0fec                      	add ZL, r28 //offset the table by the depth+phase
0022e2 1df2                      	adc ZH, zero
0022e3 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0022e4 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0022e5 93c0 2857                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
0022e7 91b0 2858                 	lds r27, pulse1_fx_Axy
0022e9 15b2                      	cp r27, zero
0022ea f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0022eb 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0022ed 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0022ef 2fda                      	mov r29, r26 //copy fractional volume into r29
0022f0 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0022f1 95e2                      	swap r30
0022f2 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0022f3 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0022f4 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0022f5 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0022f6 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0022f7 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0022f8 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0022f9 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0022fa f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0022fb efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0022fc c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0022fd 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0022fe f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0022ff e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
002300 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
002302 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002303 95a2                      	swap r26
002304 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002305 2bca                      	or r28, r26 //store the new volume back into pulse1_param
002306 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
002308 91e0 285c                 	lds ZL, pulse1_fx_Qxy_target
00230a 91f0 285d                 	lds ZH, pulse1_fx_Qxy_target+1
00230c 9630                      	adiw Z, 0
00230d f199                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00230e 91a0 2860                 	lds r26, pulse1_fx_Qxy_total_offset
002310 91b0 2861                 	lds r27, pulse1_fx_Qxy_total_offset+1
002312 91c0 0a8c                 	lds r28, TCB0_CCMPL
002314 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002316 1bec                      	sub ZL, r28 //calculate the difference to the target
002317 0bfd                      	sbc ZH, r29
002318 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
002319 f0e8                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
00231a 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
00231b 0bbf                      	sbc r27, ZH
                                 
00231c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00231d 937f                      	push r23
00231e 9160 285b                 	lds r22, pulse1_fx_Pxx
002320 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002321 9f67                      	mul r22, r23
002322 917f                      	pop r23
002323 916f                      	pop r22
002324 9416                      	lsr r1 //shift out the fractional bits
002325 9407                      	ror r0
002326 9416                      	lsr r1
002327 9407                      	ror r0
002328 9416                      	lsr r1
002329 9407                      	ror r0
00232a 9416                      	lsr r1
00232b 9407                      	ror r0
                                 
00232c 0da0                      	add r26, r0
00232d 1db2                      	adc r27, zero
                                 
00232e 93a0 2860                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
002330 93b0 2861                 	sts pulse1_fx_Qxy_total_offset+1, r27
002332 9220 285c                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002334 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
002336 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
002337 91c0 285e                 	lds r28, pulse1_fx_Qxy_speed
002339 91d0 285f                 	lds r29, pulse1_fx_Qxy_speed+1
00233b 0fac                      	add r26, r28 //increase the total offset by the speed
00233c 1fbd                      	adc r27, r29
00233d 93a0 2860                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
00233f 93b0 2861                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
002341 91e0 2862                 	lds ZL, pulse1_fx_Rxy_target
002343 91f0 2863                 	lds ZH, pulse1_fx_Rxy_target+1
002345 9630                      	adiw Z, 0
002346 f199                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
002347 91a0 2866                 	lds r26, pulse1_fx_Rxy_total_offset
002349 91b0 2867                 	lds r27, pulse1_fx_Rxy_total_offset+1
00234b 91c0 0a8c                 	lds r28, TCB0_CCMPL
00234d 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
00234f 1bce                      	sub r28, ZL //calculate the difference to the target
002350 0bdf                      	sbc r29, ZH
002351 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
002352 f0e8                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
002353 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002354 0bbd                      	sbc r27, r29
                                 
002355 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002356 937f                      	push r23
002357 9160 285b                 	lds r22, pulse1_fx_Pxx
002359 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00235a 9f67                      	mul r22, r23
00235b 917f                      	pop r23
00235c 916f                      	pop r22
00235d 9416                      	lsr r1 //shift out the fractional bits
00235e 9407                      	ror r0
00235f 9416                      	lsr r1
002360 9407                      	ror r0
002361 9416                      	lsr r1
002362 9407                      	ror r0
002363 9416                      	lsr r1
002364 9407                      	ror r0
                                 
002365 0da0                      	add r26, r0
002366 1db2                      	adc r27, zero
                                 
002367 93a0 2866                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002369 93b0 2867                 	sts pulse1_fx_Rxy_total_offset+1, r27
00236b 9220 2862                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
00236d 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
00236f c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
002370 91c0 2864                 	lds r28, pulse1_fx_Rxy_speed
002372 91d0 2865                 	lds r29, pulse1_fx_Rxy_speed+1
002374 0fac                      	add r26, r28 //increase the total offset by the speed
002375 1fbd                      	adc r27, r29
002376 93a0 2866                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002378 93b0 2867                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
00237a 91e0 2870                 	lds ZL, pulse2_volume_macro
00237c 91f0 2871                 	lds ZH, pulse2_volume_macro+1
00237e 9630                      	adiw Z, 0
00237f f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
002380 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002381 1fff                      	rol ZH
002382 91a0 2872                 	lds r26, pulse2_volume_macro_offset
002384 0fea                      	add ZL, r26
002385 1df2                      	adc ZH, zero
                                 
002386 91b0 2874                 	lds r27, pulse2_volume_macro_release
002388 17ba                      	cp r27, r26
002389 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
00238a 91a0 2873                 	lds r26, pulse2_volume_macro_loop
00238c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00238d f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00238e c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
00238f 95a3                      	inc r26 //increment the macro offset
002390 93a0 2872                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002392 91b4                      	lpm r27, Z //load volume data into r27
002393 3fbf                      	cpi r27, 0xFF //check for macro end flag
002394 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002395 91b0 2874                 	lds r27, pulse2_volume_macro_release
002397 3fbf                      	cpi r27, 0xFF
002398 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
002399 91b0 2873                 	lds r27, pulse2_volume_macro_loop //load the loop index
00239b 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
00239d cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
00239e 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00239f 93a0 2872                 	sts pulse2_volume_macro_offset, r26
0023a1 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
0023a2 efe8                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0023a3 e5f3                      	ldi ZH, HIGH(volumes << 1)
0023a4 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0023a5 0feb                      	add ZL, r27 //add offset to the table
0023a6 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
0023a7 91b0 2808                 	lds r27, pulse2_param //load main volume
0023a9 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0023aa 91a0 28a4                 	lds r26, pulse2_fx_7xy_value
0023ac 30a0                      	cpi r26, 0x00
0023ad f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
0023ae 0feb                      	add ZL, r27 //offset the volume table by the main volume
0023af 1df2                      	adc ZH, zero
0023b0 91b4                      	lpm r27, Z
0023b1 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0023b3 c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
0023b4 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0023b6 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0023b7 91a0 28a4                 	lds r26, pulse2_fx_7xy_value
0023b9 30a0                      	cpi r26, 0x00
0023ba f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
0023bb 93b0 280e                 	sts pulse2_output_volume, r27
0023bd c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
0023be 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0023bf f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
0023c0 f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
0023c1 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
0023c2 0feb                      	add ZL, r27 //offset the volume table by the main volume
0023c3 1df2                      	adc ZH, zero
0023c4 91b4                      	lpm r27, Z
0023c5 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0023c7 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
0023c8 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0023c9 0feb                      	add ZL, r27 //offset the volume table by the main volume
0023ca 1df2                      	adc ZH, zero
0023cb 91b4                      	lpm r27, Z
0023cc 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0023ce c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
0023cf 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0023d0 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0023d1 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0023d2 93b0 280e                 	sts pulse2_output_volume, r27
0023d4 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
0023d5 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0023d6 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0023d8 91e0 2875                 	lds ZL, pulse2_arpeggio_macro
0023da 91f0 2876                 	lds ZH, pulse2_arpeggio_macro+1
0023dc 9630                      	adiw Z, 0
0023dd f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0023de 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0023df 1fff                      	rol ZH
0023e0 91a0 2877                 	lds r26, pulse2_arpeggio_macro_offset
0023e2 0fea                      	add ZL, r26
0023e3 1df2                      	adc ZH, zero
                                 
0023e4 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
0023e6 17ba                      	cp r27, r26
0023e7 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0023e8 91a0 2878                 	lds r26, pulse2_arpeggio_macro_loop
0023ea 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0023eb f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0023ec c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
0023ed 95a3                      	inc r26 //increment the macro offset
0023ee 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
0023f0 91b4                      	lpm r27, Z //load arpeggio data into r27
0023f1 38b0                      	cpi r27, 0x80 //check for macro end flag
0023f2 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
0023f3 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
0023f4 50a1                      	subi r26, 1 //keep the offset at the end flag
0023f5 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
0023f7 91b0 287a                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0023f9 30b1                      	cpi r27, 0x01
0023fa f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
0023fb 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
0023fd 3fbf                      	cpi r27, 0xFF
0023fe f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
0023ff 91b0 2878                 	lds r27, pulse2_arpeggio_macro_loop
002401 3fbf                      	cpi r27, 0xFF
002402 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002403 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002404 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
002406 3fbf                      	cpi r27, 0xFF
002407 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
002408 91b0 2878                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
00240a 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00240b f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
00240c 91c0 288c                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
00240e 91d0 288d                 	lds r29, pulse2_fx_0xy_sequence+1
002410 9620                      	adiw r29:r28, 0
002411 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002412 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002413 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002415 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002416 93b0 2877                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
002418 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
002419 91c0 288c                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
00241b 91d0 288d                 	lds r29, pulse2_fx_0xy_sequence+1
00241d 9620                      	adiw r29:r28, 0 //check for 0xy effect
00241e f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
00241f 95d6                      	lsr r29
002420 95c7                      	ror r28
002421 95d7                      	ror r29
002422 95c7                      	ror r28
002423 95d7                      	ror r29
002424 95c7                      	ror r28
002425 95d7                      	ror r29
002426 95c7                      	ror r28
002427 95d7                      	ror r29
002428 95d2                      	swap r29
                                 
002429 93c0 288c                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
00242b 93d0 288d                 	sts pulse2_fx_0xy_sequence+1, r29
00242d 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00242e 91a0 280f                 	lds r26, pulse2_note //load the current note index
002430 0fac                      	add r26, r28 //add the note offset
002431 c02c                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002432 91a0 280f                 	lds r26, pulse2_note //load the current note index
002434 c029                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
002435 9220 287b                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002437 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero
002439 91a0 287a                 	lds r26, pulse2_arpeggio_macro_mode
00243b 30a1                      	cpi r26, 0x01 //absolute mode
00243c f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
00243d f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
00243e c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
00243f 91a0 280f                 	lds r26, pulse2_note //load the current note index
002441 0fab                      	add r26, r27 //offset the note with the arpeggio data
002442 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002443 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
002444 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002445 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002446 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002447 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
002448 fda7                      	sbrc r26, 7 //check if result is negative
002449 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00244a c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
00244b 2fab                      	mov r26, r27 //move the arpeggio data into r26
00244c c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
00244d 91a0 280f                 	lds r26, pulse2_note //load the current note index
00244f 0fab                      	add r26, r27 //offset the note with the arpeggio data
002450 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002451 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
002452 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
002454 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002455 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002456 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002457 93a0 280f                 	sts pulse2_note, r26
002459 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
00245a fda7                      	sbrc r26, 7 //check if result is negative
00245b e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00245c 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
00245e e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
00245f e0f0                      	ldi ZH, HIGH(note_table << 1)
002460 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002461 0fea                      	add ZL, r26 //add offset
002462 1df2                      	adc ZH, zero
002463 91a5                      	lpm r26, Z+ //load bytes
002464 91b4                      	lpm r27, Z
002465 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
002467 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
002469 93a0 2898                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00246b 93b0 2899                 	sts pulse2_fx_3xx_target+1, r27
00246d c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel1_pitch:
00246e 91e0 287c                 	lds ZL, pulse2_pitch_macro
002470 91f0 287d                 	lds ZH, pulse2_pitch_macro+1
002472 9630                      	adiw Z, 0
002473 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002474 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002475 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002476 1fff                      	rol ZH
002477 91a0 287e                 	lds r26, pulse2_pitch_macro_offset
002479 0fea                      	add ZL, r26
00247a 1df2                      	adc ZH, zero
                                 
00247b 91b0 2880                 	lds r27, pulse2_pitch_macro_release
00247d 17ba                      	cp r27, r26
00247e f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
00247f 91a0 287f                 	lds r26, pulse2_pitch_macro_loop
002481 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002482 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002483 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002484 95a3                      	inc r26 //increment the macro offset
002485 93a0 287e                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002487 91b4                      	lpm r27, Z //load pitch data into r27
002488 38b0                      	cpi r27, 0x80 //check for macro end flag
002489 f489                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
00248a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00248b 93a0 287e                 	sts pulse2_pitch_macro_offset, r26
00248d 91b0 2880                 	lds r27, pulse2_pitch_macro_release
00248f 3fbf                      	cpi r27, 0xFF
002490 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002491 91b0 287f                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002493 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002494 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002495 93b0 287e                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002497 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002498 91b0 287b                 	lds r27, pulse2_total_pitch_offset
00249a c005                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
00249b 91a0 287b                 	lds r26, pulse2_total_pitch_offset //load the total pitch offset to change
00249d 0fba                      	add r27, r26
00249e 93b0 287b                 	sts pulse2_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
0024a0 91a0 28a8                 	lds r26, pulse2_fx_Pxx
0024a2 0fba                      	add r27, r26
                                 
0024a3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0024a4 937f                      	push r23
0024a5 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0024a6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0024a7 0367                      	mulsu r22, r23
0024a8 917f                      	pop r23
0024a9 916f                      	pop r22
                                 
0024aa 9416                      	lsr r1 //shift out the fractional bits
0024ab 9407                      	ror r0
0024ac 9416                      	lsr r1
0024ad 9407                      	ror r0
0024ae 9416                      	lsr r1
0024af 9407                      	ror r0
0024b0 9416                      	lsr r1
0024b1 9407                      	ror r0
0024b2 fe13                      	sbrs r1, 3 //check if result was a negative number
0024b3 c002                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
0024b4 efb0                      	ldi r27, 0xF0
0024b5 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
0024b6 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0024b8 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0024ba 0da0                      	add r26, r0 //offset the timer values
0024bb 1db1                      	adc r27, r1
                                 	
0024bc 91c0 2890                 	lds r28, pulse2_fx_1xx_total
0024be 91d0 2891                 	lds r29, pulse2_fx_1xx_total+1
0024c0 1bac                      	sub r26, r28
0024c1 0bbd                      	sbc r27, r29
0024c2 91c0 2894                 	lds r28, pulse2_fx_2xx_total
0024c4 91d0 2895                 	lds r29, pulse2_fx_2xx_total+1
0024c6 0fac                      	add r26, r28
0024c7 1fbd                      	adc r27, r29
0024c8 91c0 28ad                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0024ca 91d0 28ae                 	lds r29, pulse2_fx_Qxy_total_offset+1
0024cc 1bac                      	sub r26, r28
0024cd 0bbd                      	sbc r27, r29
0024ce 91c0 28b3                 	lds r28, pulse2_fx_Rxy_total_offset
0024d0 91d0 28b4                 	lds r29, pulse2_fx_Rxy_total_offset+1
0024d2 0fac                      	add r26, r28
0024d3 1fbd                      	adc r27, r29
                                 
0024d4 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0024d6 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
0024d8 91e0 2882                 	lds ZL, pulse2_hi_pitch_macro
0024da 91f0 2883                 	lds ZH, pulse2_hi_pitch_macro+1
0024dc 9630                      	adiw Z, 0
0024dd f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
0024de c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
0024df 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0024e0 1fff                      	rol ZH
0024e1 91a0 2884                 	lds r26, pulse2_hi_pitch_macro_offset
0024e3 0fea                      	add ZL, r26
0024e4 1df2                      	adc ZH, zero
                                 
0024e5 91b0 2886                 	lds r27, pulse2_hi_pitch_macro_release
0024e7 17ba                      	cp r27, r26
0024e8 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0024e9 91a0 2885                 	lds r26, pulse2_hi_pitch_macro_loop
0024eb 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0024ec f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0024ed c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
0024ee 95a3                      	inc r26 //increment the macro offset
0024ef 93a0 2884                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
0024f1 91b4                      	lpm r27, Z //load hi pitch data into r27
0024f2 38b0                      	cpi r27, 0x80 //check for macro end flag
0024f3 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
0024f4 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0024f5 93a0 2884                 	sts pulse2_hi_pitch_macro_offset, r26
0024f7 91b0 2886                 	lds r27, pulse2_hi_pitch_macro_release
0024f9 3fbf                      	cpi r27, 0xFF
0024fa f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
0024fb 91b0 2885                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
0024fd 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0024fe f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0024ff 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002501 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002502 91b0 2881                 	lds r27, pulse2_total_hi_pitch_offset
002504 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002505 91a0 2881                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002507 0fba                      	add r27, r26
002508 93b0 2881                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
00250a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00250b 937f                      	push r23
00250c 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00250d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00250e 0367                      	mulsu r22, r23
00250f 917f                      	pop r23
002510 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002511 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002513 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002515 0da0                      	add r26, r0 //offset the timer values
002516 1db1                      	adc r27, r1
002517 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002519 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
00251b 91e0 2887                 	lds ZL, pulse2_duty_macro
00251d 91f0 2888                 	lds ZH, pulse2_duty_macro+1
00251f 9630                      	adiw Z, 0
002520 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002521 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002522 1fff                      	rol ZH
002523 91a0 2889                 	lds r26, pulse2_duty_macro_offset
002525 0fea                      	add ZL, r26
002526 1df2                      	adc ZH, zero
                                 
002527 91b0 288b                 	lds r27, pulse2_duty_macro_release
002529 17ba                      	cp r27, r26
00252a f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
00252b 91a0 288a                 	lds r26, pulse2_duty_macro_loop
00252d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00252e f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00252f c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002530 95a3                      	inc r26 //increment the macro offset
002531 93a0 2889                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002533 91b4                      	lpm r27, Z //load pitch data into r27
002534 3fbf                      	cpi r27, 0xFF //check for macro end flag
002535 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002536 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002537 93a0 2889                 	sts pulse2_duty_macro_offset, r26
002539 91b0 288b                 	lds r27, pulse2_duty_macro_release
00253b 3fbf                      	cpi r27, 0xFF
00253c f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
00253d 91b0 288a                 	lds r27, pulse2_duty_macro_loop //load the loop index
00253f 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002540 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002541 93b0 2889                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002543 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002544 e5e8                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002545 e5f3                      	ldi ZH, HIGH(sequences << 1)
002546 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002547 1df2                      	adc ZH, zero
                                 
002548 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002549 95b7                      	ror r27
00254a 95b7                      	ror r27
00254b 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
00254d 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
00254e 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00254f 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002550 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002551 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002552 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002553 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002554 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002555 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002557 91e0 288e                 	lds ZL, pulse2_fx_1xx
002559 91f0 288f                 	lds ZH, pulse2_fx_1xx+1
00255b 9630                      	adiw Z, 0
00255c f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
00255d 91a0 2890                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
00255f 91b0 2891                 	lds r27, pulse2_fx_1xx_total+1
002561 0fae                      	add r26, ZL //increase the total offset by the rate
002562 1fbf                      	adc r27, ZH
002563 93a0 2890                 	sts pulse2_fx_1xx_total, r26
002565 93b0 2891                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002567 91e0 2892                 	lds ZL, pulse2_fx_2xx
002569 91f0 2893                 	lds ZH, pulse2_fx_2xx+1
00256b 9630                      	adiw Z, 0
00256c f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
00256d 91a0 2894                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
00256f 91b0 2895                 	lds r27, pulse2_fx_2xx_total+1
002571 0fae                      	add r26, ZL //increase the total offset by the rate
002572 1fbf                      	adc r27, ZH
002573 93a0 2894                 	sts pulse2_fx_2xx_total, r26
002575 93b0 2895                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002577 91e0 289a                 	lds ZL, pulse2_fx_3xx_speed
002579 91f0 289b                 	lds ZH, pulse2_fx_3xx_speed+1
00257b 9630                      	adiw Z, 0
00257c f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
00257d c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
00257e 91a0 2896                 	lds r26, pulse2_fx_3xx_start
002580 91b0 2897                 	lds r27, pulse2_fx_3xx_start+1
002582 9610                      	adiw r26:r27, 0
002583 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002584 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002585 91c0 2898                 	lds r28, pulse2_fx_3xx_target
002587 91d0 2899                 	lds r29, pulse2_fx_3xx_target+1
                                 
002589 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00258a 07bd                      	cpc r27, r29
00258b f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
00258c f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00258d c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
00258e 9220 2896                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002590 9220 2897                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002592 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002593 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002594 0bdb                      	sbc r29, r27
002595 91a0 289c                 	lds r26, pulse2_fx_3xx_total_offset
002597 91b0 289d                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002599 0fae                      	add r26, ZL //add the speed to the total offset
00259a 1fbf                      	adc r27, ZH
00259b 1bca                      	sub r28, r26 //invert the total difference with the total offset
00259c 0bdb                      	sbc r29, r27
00259d f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00259e 93a0 289c                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
0025a0 93b0 289d                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
0025a2 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
0025a4 91b0 0a9d                 	lds r27, TCB1_CCMPH
0025a6 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0025a7 0bbd                      	sbc r27, r29
0025a8 93a0 0a9c                 	sts TCB1_CCMPL, r26
0025aa 93b0 0a9d                 	sts TCB1_CCMPH, r27
0025ac c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
0025ad 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0025ae 0bbd                      	sbc r27, r29
0025af 91c0 289c                 	lds r28, pulse2_fx_3xx_total_offset
0025b1 91d0 289d                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
0025b3 0fce                      	add r28, ZL //add the speed to the total offset
0025b4 1fdf                      	adc r29, ZH
0025b5 1bac                      	sub r26, r28 //invert the total difference with the total offset
0025b6 0bbd                      	sbc r27, r29
0025b7 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0025b8 93c0 289c                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
0025ba 93d0 289d                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
0025bc 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
0025be 91d0 0a9d                 	lds r29, TCB1_CCMPH
0025c0 0fca                      	add r28, r26 //offset the current timer period with the total offset
0025c1 1fdb                      	adc r29, r27
0025c2 93c0 0a9c                 	sts TCB1_CCMPL, r28
0025c4 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
0025c6 91a0 289e                 	lds r26, pulse2_fx_4xy_speed
0025c8 15a2                      	cp r26, zero
0025c9 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
0025ca c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
0025cb 91b0 289f                 	lds r27, pulse2_fx_4xy_depth
0025cd 91c0 28a0                 	lds r28, pulse2_fx_4xy_phase
0025cf 0fca                      	add r28, r26 //increase the phase by the speed
0025d0 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0025d1 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0025d2 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
0025d3 93c0 28a0                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
0025d5 31c0                      	cpi r28, 16
0025d6 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
0025d7 32c0                      	cpi r28, 32
0025d8 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
0025d9 33c0                      	cpi r28, 48
0025da f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
0025db c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
0025dc 70cf                      	andi r28, 0x0F //mask for values 0-15
0025dd c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
0025de 6fc0                      	ori r28, 0xF0
0025df 95c0                      	com r28 //invert values 0-15
0025e0 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
0025e1 70cf                      	andi r28, 0x0F //mask for values 0-15
0025e2 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
0025e3 6fc0                      	ori r28, 0xF0
0025e4 95c0                      	com r28 //invert values 0-15
0025e5 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
0025e6 95b2                      	swap r27 //multiply depth by 16
0025e7 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0025e8 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0025e9 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0025ea 0fec                      	add ZL, r28 //offset the table by the depth+phase
0025eb 1df2                      	adc ZH, zero
0025ec 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0025ed 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025ee 937f                      	push r23
0025ef 2f6c                      	mov r22, r28 //store the vibrato value into r22
0025f0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025f1 9f67                      	mul r22, r23
0025f2 917f                      	pop r23
0025f3 916f                      	pop r22
                                 
0025f4 9416                      	lsr r1 //shift out the fractional bits
0025f5 9407                      	ror r0
0025f6 9416                      	lsr r1
0025f7 9407                      	ror r0
0025f8 9416                      	lsr r1
0025f9 9407                      	ror r0
0025fa 9416                      	lsr r1
0025fb 9407                      	ror r0
                                 	
0025fc 91a0 0a9c                 	lds r26, TCB1_CCMPL
0025fe 91b0 0a9d                 	lds r27, TCB1_CCMPH
002600 0da0                      	add r26, r0
002601 1db1                      	adc r27, r1
002602 93a0 0a9c                 	sts TCB1_CCMPL, r26
002604 93b0 0a9d                 	sts TCB1_CCMPH, r27
002606 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002607 95b2                      	swap r27 //multiply depth by 16
002608 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002609 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00260a e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00260b 0fec                      	add ZL, r28 //offset the table by the depth+phase
00260c 1df2                      	adc ZH, zero
00260d 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00260e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00260f 937f                      	push r23
002610 2f6c                      	mov r22, r28 //store the vibrato value into r22
002611 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002612 9f67                      	mul r22, r23
002613 917f                      	pop r23
002614 916f                      	pop r22
                                 
002615 9416                      	lsr r1 //shift out the fractional bits
002616 9407                      	ror r0
002617 9416                      	lsr r1
002618 9407                      	ror r0
002619 9416                      	lsr r1
00261a 9407                      	ror r0
00261b 9416                      	lsr r1
00261c 9407                      	ror r0
                                 
00261d 91a0 0a9c                 	lds r26, TCB1_CCMPL
00261f 91b0 0a9d                 	lds r27, TCB1_CCMPH
002621 19a0                      	sub r26, r0
002622 09b1                      	sbc r27, r1
002623 93a0 0a9c                 	sts TCB1_CCMPL, r26
002625 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002627 91a0 28a1                 	lds r26, pulse2_fx_7xy_speed
002629 15a2                      	cp r26, zero
00262a f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00262b 91b0 28a2                 	lds r27, pulse2_fx_7xy_depth
00262d 91c0 28a3                 	lds r28, pulse2_fx_7xy_phase
00262f 0fca                      	add r28, r26 //increase the phase by the speed
002630 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002631 f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002632 e0c0                      	ldi r28, 0x00
002633 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002634 93c0 28a3                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002636 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002637 ffc4                      	sbrs r28, 4
002638 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002639 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
00263a 70cf                      	andi r28, 0x0F //mask for values 0-15
00263b c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
00263c 6fc0                      	ori r28, 0xF0
00263d 95c0                      	com r28 //invert values 0-15
00263e c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
00263f 95b2                      	swap r27 //multiply depth by 16
002640 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002641 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002642 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002643 0fec                      	add ZL, r28 //offset the table by the depth+phase
002644 1df2                      	adc ZH, zero
002645 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002646 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002647 93c0 28a4                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002649 91b0 28a5                 	lds r27, pulse2_fx_Axy
00264b 15b2                      	cp r27, zero
00264c f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00264d 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
00264f 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002651 2fda                      	mov r29, r26 //copy fractional volume into r29
002652 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002653 95e2                      	swap r30
002654 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002655 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002656 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002657 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002658 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002659 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
00265a c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
00265b 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00265c f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00265d efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
00265e c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
00265f 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002660 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002661 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002662 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002664 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002665 95a2                      	swap r26
002666 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002667 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002668 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
00266a 91e0 28a9                 	lds ZL, pulse2_fx_Qxy_target
00266c 91f0 28aa                 	lds ZH, pulse2_fx_Qxy_target+1
00266e 9630                      	adiw Z, 0
00266f f199                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002670 91a0 28ad                 	lds r26, pulse2_fx_Qxy_total_offset
002672 91b0 28ae                 	lds r27, pulse2_fx_Qxy_total_offset+1
002674 91c0 0a9c                 	lds r28, TCB1_CCMPL
002676 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002678 1bec                      	sub ZL, r28 //calculate the difference to the target
002679 0bfd                      	sbc ZH, r29
00267a f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
00267b f0e8                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
00267c 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
00267d 0bbf                      	sbc r27, ZH
                                 
00267e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00267f 937f                      	push r23
002680 9160 28a8                 	lds r22, pulse2_fx_Pxx
002682 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002683 9f67                      	mul r22, r23
002684 917f                      	pop r23
002685 916f                      	pop r22
002686 9416                      	lsr r1 //shift out the fractional bits
002687 9407                      	ror r0
002688 9416                      	lsr r1
002689 9407                      	ror r0
00268a 9416                      	lsr r1
00268b 9407                      	ror r0
00268c 9416                      	lsr r1
00268d 9407                      	ror r0
                                 
00268e 0da0                      	add r26, r0
00268f 1db2                      	adc r27, zero
                                 
002690 93a0 28ad                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002692 93b0 28ae                 	sts pulse2_fx_Qxy_total_offset+1, r27
002694 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002696 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
002698 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002699 91c0 28ab                 	lds r28, pulse2_fx_Qxy_speed
00269b 91d0 28ac                 	lds r29, pulse2_fx_Qxy_speed+1
00269d 0fac                      	add r26, r28 //increase the total offset by the speed
00269e 1fbd                      	adc r27, r29
00269f 93a0 28ad                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
0026a1 93b0 28ae                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
0026a3 91e0 28af                 	lds ZL, pulse2_fx_Rxy_target
0026a5 91f0 28b0                 	lds ZH, pulse2_fx_Rxy_target+1
0026a7 9630                      	adiw Z, 0
0026a8 f199                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
0026a9 91a0 28b3                 	lds r26, pulse2_fx_Rxy_total_offset
0026ab 91b0 28b4                 	lds r27, pulse2_fx_Rxy_total_offset+1
0026ad 91c0 0a9c                 	lds r28, TCB1_CCMPL
0026af 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
0026b1 1bce                      	sub r28, ZL //calculate the difference to the target
0026b2 0bdf                      	sbc r29, ZH
0026b3 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
0026b4 f0e8                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
0026b5 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0026b6 0bbd                      	sbc r27, r29
                                 
0026b7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026b8 937f                      	push r23
0026b9 9160 28a8                 	lds r22, pulse2_fx_Pxx
0026bb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026bc 9f67                      	mul r22, r23
0026bd 917f                      	pop r23
0026be 916f                      	pop r22
0026bf 9416                      	lsr r1 //shift out the fractional bits
0026c0 9407                      	ror r0
0026c1 9416                      	lsr r1
0026c2 9407                      	ror r0
0026c3 9416                      	lsr r1
0026c4 9407                      	ror r0
0026c5 9416                      	lsr r1
0026c6 9407                      	ror r0
                                 
0026c7 0da0                      	add r26, r0
0026c8 1db2                      	adc r27, zero
                                 
0026c9 93a0 28b3                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
0026cb 93b0 28b4                 	sts pulse2_fx_Rxy_total_offset+1, r27
0026cd 9220 28af                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
0026cf 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
0026d1 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
0026d2 91c0 28b1                 	lds r28, pulse2_fx_Rxy_speed
0026d4 91d0 28b2                 	lds r29, pulse2_fx_Rxy_speed+1
0026d6 0fac                      	add r26, r28 //increase the total offset by the speed
0026d7 1fbd                      	adc r27, r29
0026d8 93a0 28b3                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
0026da 93b0 28b4                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
0026dc 91e0 28bd                 	lds ZL, triangle_volume_macro
0026de 91f0 28be                 	lds ZH, triangle_volume_macro+1
0026e0 9630                      	adiw Z, 0
0026e1 f179                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
0026e2 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0026e3 1fff                      	rol ZH
0026e4 91a0 28bf                 	lds r26, triangle_volume_macro_offset
0026e6 0fea                      	add ZL, r26
0026e7 1df2                      	adc ZH, zero
                                 
0026e8 91b0 28c1                 	lds r27, triangle_volume_macro_release
0026ea 17ba                      	cp r27, r26
0026eb f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
0026ec 91a0 28c0                 	lds r26, triangle_volume_macro_loop
0026ee 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026ef f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026f0 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
0026f1 95a3                      	inc r26 //increment the macro offset
0026f2 93a0 28bf                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
0026f4 91b4                      	lpm r27, Z //load volume data into r27
0026f5 3fbf                      	cpi r27, 0xFF //check for macro end flag
0026f6 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
0026f7 91b0 28c1                 	lds r27, triangle_volume_macro_release
0026f9 3fbf                      	cpi r27, 0xFF
0026fa f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
0026fb 91b0 28c0                 	lds r27, triangle_volume_macro_loop //load the loop index
0026fd 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
0026ff cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002700 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002701 93a0 28bf                 	sts triangle_volume_macro_offset, r26
002703 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002704 15b2                      	cp r27, zero
002705 f021                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002706 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002707 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002709 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
00270a 9220 0aa5                 	sts TCB2_INTCTRL, zero
00270c 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
00270e 9220 0aad                 	sts TCB2_CCMPH, zero
002710 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002711 91e0 28c2                 	lds ZL, triangle_arpeggio_macro
002713 91f0 28c3                 	lds ZH, triangle_arpeggio_macro+1
002715 9630                      	adiw Z, 0
002716 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002717 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002718 1fff                      	rol ZH
002719 91a0 28c4                 	lds r26, triangle_arpeggio_macro_offset
00271b 0fea                      	add ZL, r26
00271c 1df2                      	adc ZH, zero
                                 
00271d 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
00271f 17ba                      	cp r27, r26
002720 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002721 91a0 28c5                 	lds r26, triangle_arpeggio_macro_loop
002723 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002724 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002725 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002726 95a3                      	inc r26 //increment the macro offset
002727 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002729 91b4                      	lpm r27, Z //load arpeggio data into r27
00272a 38b0                      	cpi r27, 0x80 //check for macro end flag
00272b f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
00272c c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
00272d 50a1                      	subi r26, 1 //keep the offset at the end flag
00272e 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
002730 91b0 28c7                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002732 30b1                      	cpi r27, 0x01
002733 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002734 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
002736 3fbf                      	cpi r27, 0xFF
002737 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002738 91b0 28c5                 	lds r27, triangle_arpeggio_macro_loop
00273a 3fbf                      	cpi r27, 0xFF
00273b f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00273c c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
00273d 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
00273f 3fbf                      	cpi r27, 0xFF
002740 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002741 91b0 28c5                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002743 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002744 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002745 91c0 28d9                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002747 91d0 28da                 	lds r29, triangle_fx_0xy_sequence+1
002749 9620                      	adiw r29:r28, 0
00274a f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00274b 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00274c 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
00274e cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
00274f 93b0 28c4                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002751 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002752 91c0 28d9                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002754 91d0 28da                 	lds r29, triangle_fx_0xy_sequence+1
002756 9620                      	adiw r29:r28, 0 //check for 0xy effect
002757 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
002758 95d6                      	lsr r29
002759 95c7                      	ror r28
00275a 95d7                      	ror r29
00275b 95c7                      	ror r28
00275c 95d7                      	ror r29
00275d 95c7                      	ror r28
00275e 95d7                      	ror r29
00275f 95c7                      	ror r28
002760 95d7                      	ror r29
002761 95d2                      	swap r29
                                 
002762 93c0 28d9                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002764 93d0 28da                 	sts triangle_fx_0xy_sequence+1, r29
002766 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002767 91a0 2812                 	lds r26, triangle_note //load the current note index
002769 0fac                      	add r26, r28 //add the note offset
00276a c02c                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00276b 91a0 2812                 	lds r26, triangle_note //load the current note index
00276d c029                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
00276e 9220 28c8                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002770 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero
002772 91a0 28c7                 	lds r26, triangle_arpeggio_macro_mode
002774 30a1                      	cpi r26, 0x01 //absolute mode
002775 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002776 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002777 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002778 91a0 2812                 	lds r26, triangle_note //load the current note index
00277a 0fab                      	add r26, r27 //offset the note with the arpeggio data
00277b fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00277c c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
00277d 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00277e f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
00277f e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002780 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002781 fda7                      	sbrc r26, 7 //check if result is negative
002782 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002783 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002784 2fab                      	mov r26, r27 //move the arpeggio data into r26
002785 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002786 91a0 2812                 	lds r26, triangle_note //load the current note index
002788 0fab                      	add r26, r27 //offset the note with the arpeggio data
002789 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00278a c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
00278b 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
00278d 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00278e f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
00278f e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002790 93a0 2812                 	sts triangle_note, r26
002792 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002793 fda7                      	sbrc r26, 7 //check if result is negative
002794 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002795 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002797 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
002798 e0f0                      	ldi ZH, HIGH(note_table << 1)
002799 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00279a 0fea                      	add ZL, r26 //add offset
00279b 1df2                      	adc ZH, zero
00279c 91a5                      	lpm r26, Z+ //load bytes
00279d 91b4                      	lpm r27, Z
00279e 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
0027a0 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
0027a2 93a0 28e5                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0027a4 93b0 28e6                 	sts triangle_fx_3xx_target+1, r27
0027a6 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel2_pitch:
0027a7 91e0 28c9                 	lds ZL, triangle_pitch_macro
0027a9 91f0 28ca                 	lds ZH, triangle_pitch_macro+1
0027ab 9630                      	adiw Z, 0
0027ac f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
0027ad c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
0027ae 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0027af 1fff                      	rol ZH
0027b0 91a0 28cb                 	lds r26, triangle_pitch_macro_offset
0027b2 0fea                      	add ZL, r26
0027b3 1df2                      	adc ZH, zero
                                 
0027b4 91b0 28cd                 	lds r27, triangle_pitch_macro_release
0027b6 17ba                      	cp r27, r26
0027b7 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
0027b8 91a0 28cc                 	lds r26, triangle_pitch_macro_loop
0027ba 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0027bb f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0027bc c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
0027bd 95a3                      	inc r26 //increment the macro offset
0027be 93a0 28cb                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
0027c0 91b4                      	lpm r27, Z //load pitch data into r27
0027c1 38b0                      	cpi r27, 0x80 //check for macro end flag
0027c2 f489                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
0027c3 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0027c4 93a0 28cb                 	sts triangle_pitch_macro_offset, r26
0027c6 91b0 28cd                 	lds r27, triangle_pitch_macro_release
0027c8 3fbf                      	cpi r27, 0xFF
0027c9 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
0027ca 91b0 28cc                 	lds r27, triangle_pitch_macro_loop //load the loop index
0027cc 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0027cd f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0027ce 93b0 28cb                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
0027d0 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
0027d1 91b0 28c8                 	lds r27, triangle_total_pitch_offset
0027d3 c005                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
0027d4 91a0 28c8                 	lds r26, triangle_total_pitch_offset //load the total pitch offset to change
0027d6 0fba                      	add r27, r26
0027d7 93b0 28c8                 	sts triangle_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
0027d9 91a0 28f0                 	lds r26, triangle_fx_Pxx
0027db 0fba                      	add r27, r26
                                 
0027dc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0027dd 937f                      	push r23
0027de 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0027df eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0027e0 0367                      	mulsu r22, r23
0027e1 917f                      	pop r23
0027e2 916f                      	pop r22
                                 
0027e3 9416                      	lsr r1 //shift out the fractional bits
0027e4 9407                      	ror r0
0027e5 9416                      	lsr r1
0027e6 9407                      	ror r0
0027e7 9416                      	lsr r1
0027e8 9407                      	ror r0
0027e9 9416                      	lsr r1
0027ea 9407                      	ror r0
0027eb fe13                      	sbrs r1, 3 //check if result was a negative number
0027ec c002                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
0027ed efb0                      	ldi r27, 0xF0
0027ee 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
0027ef 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
0027f1 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
0027f3 0da0                      	add r26, r0 //offset the timer values
0027f4 1db1                      	adc r27, r1
                                 	
0027f5 91c0 28dd                 	lds r28, triangle_fx_1xx_total
0027f7 91d0 28de                 	lds r29, triangle_fx_1xx_total+1
0027f9 1bac                      	sub r26, r28
0027fa 0bbd                      	sbc r27, r29
0027fb 91c0 28e1                 	lds r28, triangle_fx_2xx_total
0027fd 91d0 28e2                 	lds r29, triangle_fx_2xx_total+1
0027ff 0fac                      	add r26, r28
002800 1fbd                      	adc r27, r29
002801 91c0 28f5                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002803 91d0 28f6                 	lds r29, triangle_fx_Qxy_total_offset+1
002805 1bac                      	sub r26, r28
002806 0bbd                      	sbc r27, r29
002807 91c0 28fb                 	lds r28, triangle_fx_Rxy_total_offset
002809 91d0 28fc                 	lds r29, triangle_fx_Rxy_total_offset+1
00280b 0fac                      	add r26, r28
00280c 1fbd                      	adc r27, r29
                                 
00280d 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
00280f 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002811 91e0 28cf                 	lds ZL, triangle_hi_pitch_macro
002813 91f0 28d0                 	lds ZH, triangle_hi_pitch_macro+1
002815 9630                      	adiw Z, 0
002816 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002817 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002818 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002819 1fff                      	rol ZH
00281a 91a0 28d1                 	lds r26, triangle_hi_pitch_macro_offset
00281c 0fea                      	add ZL, r26
00281d 1df2                      	adc ZH, zero
                                 
00281e 91b0 28d3                 	lds r27, triangle_hi_pitch_macro_release
002820 17ba                      	cp r27, r26
002821 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002822 91a0 28d2                 	lds r26, triangle_hi_pitch_macro_loop
002824 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002825 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002826 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002827 95a3                      	inc r26 //increment the macro offset
002828 93a0 28d1                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
00282a 91b4                      	lpm r27, Z //load hi pitch data into r27
00282b 38b0                      	cpi r27, 0x80 //check for macro end flag
00282c f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
00282d 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00282e 93a0 28d1                 	sts triangle_hi_pitch_macro_offset, r26
002830 91b0 28d3                 	lds r27, triangle_hi_pitch_macro_release
002832 3fbf                      	cpi r27, 0xFF
002833 f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002834 91b0 28d2                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002836 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002837 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002838 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
00283a cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
00283b 91b0 28ce                 	lds r27, triangle_total_hi_pitch_offset
00283d c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
00283e 91a0 28ce                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002840 0fba                      	add r27, r26
002841 93b0 28ce                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002843 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002844 937f                      	push r23
002845 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002846 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002847 0367                      	mulsu r22, r23
002848 917f                      	pop r23
002849 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
00284a 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
00284c 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
00284e 0da0                      	add r26, r0 //offset the timer values
00284f 1db1                      	adc r27, r1
002850 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002852 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002854 91e0 28db                 	lds ZL, triangle_fx_1xx
002856 91f0 28dc                 	lds ZH, triangle_fx_1xx+1
002858 9630                      	adiw Z, 0
002859 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
00285a 91a0 28dd                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
00285c 91b0 28de                 	lds r27, triangle_fx_1xx_total+1
00285e 0fae                      	add r26, ZL //increase the total offset by the rate
00285f 1fbf                      	adc r27, ZH
002860 93a0 28dd                 	sts triangle_fx_1xx_total, r26
002862 93b0 28de                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002864 91e0 28df                 	lds ZL, triangle_fx_2xx
002866 91f0 28e0                 	lds ZH, triangle_fx_2xx+1
002868 9630                      	adiw Z, 0
002869 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
00286a 91a0 28e1                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
00286c 91b0 28e2                 	lds r27, triangle_fx_2xx_total+1
00286e 0fae                      	add r26, ZL //increase the total offset by the rate
00286f 1fbf                      	adc r27, ZH
002870 93a0 28e1                 	sts triangle_fx_2xx_total, r26
002872 93b0 28e2                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002874 91e0 28e7                 	lds ZL, triangle_fx_3xx_speed
002876 91f0 28e8                 	lds ZH, triangle_fx_3xx_speed+1
002878 9630                      	adiw Z, 0
002879 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
00287a c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
00287b 91a0 28e3                 	lds r26, triangle_fx_3xx_start
00287d 91b0 28e4                 	lds r27, triangle_fx_3xx_start+1
00287f 9610                      	adiw r26:r27, 0
002880 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002881 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002882 91c0 28e5                 	lds r28, triangle_fx_3xx_target
002884 91d0 28e6                 	lds r29, triangle_fx_3xx_target+1
                                 
002886 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002887 07bd                      	cpc r27, r29
002888 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002889 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00288a c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
00288b 9220 28e3                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00288d 9220 28e4                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
00288f c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002890 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002891 0bdb                      	sbc r29, r27
002892 91a0 28e9                 	lds r26, triangle_fx_3xx_total_offset
002894 91b0 28ea                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002896 0fae                      	add r26, ZL //add the speed to the total offset
002897 1fbf                      	adc r27, ZH
002898 1bca                      	sub r28, r26 //invert the total difference with the total offset
002899 0bdb                      	sbc r29, r27
00289a f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00289b 93a0 28e9                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
00289d 93b0 28ea                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
00289f 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
0028a1 91b0 0aad                 	lds r27, TCB2_CCMPH
0028a3 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0028a4 0bbd                      	sbc r27, r29
0028a5 93a0 0aac                 	sts TCB2_CCMPL, r26
0028a7 93b0 0aad                 	sts TCB2_CCMPH, r27
0028a9 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
0028aa 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0028ab 0bbd                      	sbc r27, r29
0028ac 91c0 28e9                 	lds r28, triangle_fx_3xx_total_offset
0028ae 91d0 28ea                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
0028b0 0fce                      	add r28, ZL //add the speed to the total offset
0028b1 1fdf                      	adc r29, ZH
0028b2 1bac                      	sub r26, r28 //invert the total difference with the total offset
0028b3 0bbd                      	sbc r27, r29
0028b4 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0028b5 93c0 28e9                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
0028b7 93d0 28ea                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
0028b9 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
0028bb 91d0 0aad                 	lds r29, TCB2_CCMPH
0028bd 0fca                      	add r28, r26 //offset the current timer period with the total offset
0028be 1fdb                      	adc r29, r27
0028bf 93c0 0aac                 	sts TCB2_CCMPL, r28
0028c1 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
0028c3 91a0 28eb                 	lds r26, triangle_fx_4xy_speed
0028c5 15a2                      	cp r26, zero
0028c6 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
0028c7 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
0028c8 91b0 28ec                 	lds r27, triangle_fx_4xy_depth
0028ca 91c0 28ed                 	lds r28, triangle_fx_4xy_phase
0028cc 0fca                      	add r28, r26 //increase the phase by the speed
0028cd 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0028ce f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0028cf 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
0028d0 93c0 28ed                 	sts triangle_fx_4xy_phase, r28 //store the new phase
0028d2 31c0                      	cpi r28, 16
0028d3 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
0028d4 32c0                      	cpi r28, 32
0028d5 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
0028d6 33c0                      	cpi r28, 48
0028d7 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
0028d8 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
0028d9 70cf                      	andi r28, 0x0F //mask for values 0-15
0028da c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
0028db 6fc0                      	ori r28, 0xF0
0028dc 95c0                      	com r28 //invert values 0-15
0028dd c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
0028de 70cf                      	andi r28, 0x0F //mask for values 0-15
0028df c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
0028e0 6fc0                      	ori r28, 0xF0
0028e1 95c0                      	com r28 //invert values 0-15
0028e2 c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
0028e3 95b2                      	swap r27 //multiply depth by 16
0028e4 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0028e5 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0028e6 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0028e7 0fec                      	add ZL, r28 //offset the table by the depth+phase
0028e8 1df2                      	adc ZH, zero
0028e9 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0028ea 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028eb 937f                      	push r23
0028ec 2f6c                      	mov r22, r28 //store the vibrato value into r22
0028ed eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028ee 9f67                      	mul r22, r23
0028ef 917f                      	pop r23
0028f0 916f                      	pop r22
                                 
0028f1 9416                      	lsr r1 //shift out the fractional bits
0028f2 9407                      	ror r0
0028f3 9416                      	lsr r1
0028f4 9407                      	ror r0
0028f5 9416                      	lsr r1
0028f6 9407                      	ror r0
0028f7 9416                      	lsr r1
0028f8 9407                      	ror r0
                                 	
0028f9 91a0 0aac                 	lds r26, TCB2_CCMPL
0028fb 91b0 0aad                 	lds r27, TCB2_CCMPH
0028fd 0da0                      	add r26, r0
0028fe 1db1                      	adc r27, r1
0028ff 93a0 0aac                 	sts TCB2_CCMPL, r26
002901 93b0 0aad                 	sts TCB2_CCMPH, r27
002903 c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002904 95b2                      	swap r27 //multiply depth by 16
002905 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002906 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002907 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002908 0fec                      	add ZL, r28 //offset the table by the depth+phase
002909 1df2                      	adc ZH, zero
00290a 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00290b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00290c 937f                      	push r23
00290d 2f6c                      	mov r22, r28 //store the vibrato value into r22
00290e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00290f 9f67                      	mul r22, r23
002910 917f                      	pop r23
002911 916f                      	pop r22
                                 
002912 9416                      	lsr r1 //shift out the fractional bits
002913 9407                      	ror r0
002914 9416                      	lsr r1
002915 9407                      	ror r0
002916 9416                      	lsr r1
002917 9407                      	ror r0
002918 9416                      	lsr r1
002919 9407                      	ror r0
                                 
00291a 91a0 0aac                 	lds r26, TCB2_CCMPL
00291c 91b0 0aad                 	lds r27, TCB2_CCMPH
00291e 19a0                      	sub r26, r0
00291f 09b1                      	sbc r27, r1
002920 93a0 0aac                 	sts TCB2_CCMPL, r26
002922 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002924 91e0 28f1                 	lds ZL, triangle_fx_Qxy_target
002926 91f0 28f2                 	lds ZH, triangle_fx_Qxy_target+1
002928 9630                      	adiw Z, 0
002929 f199                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00292a 91a0 28f5                 	lds r26, triangle_fx_Qxy_total_offset
00292c 91b0 28f6                 	lds r27, triangle_fx_Qxy_total_offset+1
00292e 91c0 0aac                 	lds r28, TCB2_CCMPL
002930 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002932 1bec                      	sub ZL, r28 //calculate the difference to the target
002933 0bfd                      	sbc ZH, r29
002934 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002935 f0e8                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002936 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002937 0bbf                      	sbc r27, ZH
                                 
002938 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002939 937f                      	push r23
00293a 9160 28f0                 	lds r22, triangle_fx_Pxx
00293c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00293d 9f67                      	mul r22, r23
00293e 917f                      	pop r23
00293f 916f                      	pop r22
002940 9416                      	lsr r1 //shift out the fractional bits
002941 9407                      	ror r0
002942 9416                      	lsr r1
002943 9407                      	ror r0
002944 9416                      	lsr r1
002945 9407                      	ror r0
002946 9416                      	lsr r1
002947 9407                      	ror r0
                                 
002948 0da0                      	add r26, r0
002949 1db2                      	adc r27, zero
                                 
00294a 93a0 28f5                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
00294c 93b0 28f6                 	sts triangle_fx_Qxy_total_offset+1, r27
00294e 9220 28f1                 	sts triangle_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002950 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
002952 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002953 91c0 28f3                 	lds r28, triangle_fx_Qxy_speed
002955 91d0 28f4                 	lds r29, triangle_fx_Qxy_speed+1
002957 0fac                      	add r26, r28 //increase the total offset by the speed
002958 1fbd                      	adc r27, r29
002959 93a0 28f5                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
00295b 93b0 28f6                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
00295d 91e0 28f7                 	lds ZL, triangle_fx_Rxy_target
00295f 91f0 28f8                 	lds ZH, triangle_fx_Rxy_target+1
002961 9630                      	adiw Z, 0
002962 f199                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002963 91a0 28fb                 	lds r26, triangle_fx_Rxy_total_offset
002965 91b0 28fc                 	lds r27, triangle_fx_Rxy_total_offset+1
002967 91c0 0aac                 	lds r28, TCB2_CCMPL
002969 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
00296b 1bce                      	sub r28, ZL //calculate the difference to the target
00296c 0bdf                      	sbc r29, ZH
00296d f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
00296e f0e8                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
00296f 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002970 0bbd                      	sbc r27, r29
                                 
002971 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002972 937f                      	push r23
002973 9160 28f0                 	lds r22, triangle_fx_Pxx
002975 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002976 9f67                      	mul r22, r23
002977 917f                      	pop r23
002978 916f                      	pop r22
002979 9416                      	lsr r1 //shift out the fractional bits
00297a 9407                      	ror r0
00297b 9416                      	lsr r1
00297c 9407                      	ror r0
00297d 9416                      	lsr r1
00297e 9407                      	ror r0
00297f 9416                      	lsr r1
002980 9407                      	ror r0
                                 
002981 0da0                      	add r26, r0
002982 1db2                      	adc r27, zero
                                 
002983 93a0 28fb                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002985 93b0 28fc                 	sts triangle_fx_Rxy_total_offset+1, r27
002987 9220 28f7                 	sts triangle_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002989 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
00298b c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
00298c 91c0 28f9                 	lds r28, triangle_fx_Rxy_speed
00298e 91d0 28fa                 	lds r29, triangle_fx_Rxy_speed+1
002990 0fac                      	add r26, r28 //increase the total offset by the speed
002991 1fbd                      	adc r27, r29
002992 93a0 28fb                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002994 93b0 28fc                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
                                 
                                 sound_driver_exit:
002996 91ff                      	pop r31
002997 91ef                      	pop r30
002998 91df                      	pop r29
002999 91cf                      	pop r28
00299a 940c 157a                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
00299c 7f05
00299d 010a
00299e 0214
00299f 0328
0029a0 0450
0029a1 051e
0029a2 0607
0029a3 070d
0029a4 0806
0029a5 090c
0029a6 0a18
0029a7 0b30
0029a8 0c60
0029a9 0d24
0029aa 0e08
0029ab 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
0029ac 0301
0029ad fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
0029ae 1732
0029af 1737
0029b0 1753
0029b1 176f
0029b2 1792                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
0029b3 179d
0029b4 17aa
0029b5 17ad
0029b6 17b0
0029b7 17b3                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
0029b8 17b6
0029b9 17be
0029ba 17c1
0029bb 17ce
0029bc 17cf                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
0029bd 17d0
0029be 17d1
0029bf 17d2
0029c0 17d5
0029c1 1819                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
0029c2 185c
0029c3 1869
0029c4 187d
0029c5 187e
0029c6 187f                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
0029c7 1880                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
0029c8 19fe
0029c9 1a03
0029ca 1a1f
0029cb 1a3b
0029cc 1a5e                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
0029cd 1a69
0029ce 1a76
0029cf 1a79
0029d0 1a7c
0029d1 1a7f                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
0029d2 1a82
0029d3 1a8a
0029d4 1a8d
0029d5 1a9a
0029d6 1a9b                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
0029d7 1a9c
0029d8 1a9d
0029d9 1a9e
0029da 1aa1
0029db 1ae5                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
0029dc 1b28
0029dd 1b35
0029de 1b49
0029df 1b4a
0029e0 1b4b                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
0029e1 1b4c                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
0029e2 1cc6
0029e3 1ccb
0029e4 1ce7
0029e5 1d03
0029e6 1d26                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
0029e7 1d31
0029e8 1d32
0029e9 1d33
0029ea 1d36
0029eb 1d39                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
0029ec 1d3c
0029ed 1d49
0029ee 1d4c
0029ef 1d59
0029f0 1d5a                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
0029f1 1d5b
0029f2 1d5c
0029f3 1d5d
0029f4 1d60
0029f5 1da4                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
0029f6 1de7
0029f7 1df4
0029f8 1df5
0029f9 1df6
0029fa 1df7                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
0029fb 1df8                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0029fc 0000
0029fd 0000
0029fe 0000
0029ff 0000
002a00 0000
002a01 0000
002a02 0000
002a03 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
002a04 0100
002a05 0101
002a06 0101
002a07 0101
002a08 0101
002a09 0101
002a0a 0101
002a0b 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
002a0c 0100
002a0d 0101
002a0e 0101
002a0f 0101
002a10 0101
002a11 0101
002a12 0101
002a13 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
002a14 0100
002a15 0101
002a16 0101
002a17 0101
002a18 0101
002a19 0202
002a1a 0202
002a1b 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
002a1c 0100
002a1d 0101
002a1e 0101
002a1f 0101
002a20 0202
002a21 0202
002a22 0303
002a23 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
002a24 0100
002a25 0101
002a26 0101
002a27 0202
002a28 0302
002a29 0303
002a2a 0404
002a2b 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
002a2c 0100
002a2d 0101
002a2e 0201
002a2f 0202
002a30 0303
002a31 0404
002a32 0504
002a33 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
002a34 0100
002a35 0101
002a36 0201
002a37 0302
002a38 0403
002a39 0504
002a3a 0605
002a3b 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
002a3c 0100
002a3d 0101
002a3e 0202
002a3f 0303
002a40 0404
002a41 0505
002a42 0606
002a43 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
002a44 0100
002a45 0101
002a46 0302
002a47 0403
002a48 0504
002a49 0606
002a4a 0707
002a4b 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
002a4c 0100
002a4d 0201
002a4e 0302
002a4f 0404
002a50 0605
002a51 0706
002a52 0808
002a53 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
002a54 0100
002a55 0201
002a56 0302
002a57 0504
002a58 0605
002a59 0807
002a5a 0908
002a5b 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
002a5c 0100
002a5d 0201
002a5e 0403
002a5f 0504
002a60 0706
002a61 0808
002a62 0a09
002a63 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
002a64 0100
002a65 0201
002a66 0403
002a67 0605
002a68 0706
002a69 0908
002a6a 0b0a
002a6b 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
002a6c 0100
002a6d 0201
002a6e 0403
002a6f 0605
002a70 0807
002a71 0a09
002a72 0c0b
002a73 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
002a74 0100
002a75 0302
002a76 0504
002a77 0706
002a78 0908
002a79 0b0a
002a7a 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 187 r0 : 153 r1 : 153 r2 : 520 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   0 r22: 132 r23: 132 r24:   0 r25:  24 r26: 705 r27: 880 r28: 517 
r29: 272 r30: 286 r31: 261 
Registers used: 24 out of 35 (68.6%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 107 add   : 145 adiw  :  80 and   :   0 
andi  :  71 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   5 brcs  :   9 break :   0 breq  : 127 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  60 brlt  :   0 brmi  :   0 
brne  :  91 brpl  :   0 brsh  :  24 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   4 
clc   :   0 clh   :   0 cli   :   7 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  13 cp    :  76 cpc   :   8 
cpi   : 125 cpse  :  17 dec   :  29 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   3 in    :   6 inc   :  36 
jmp   :   9 ld    :   0 ldd   :   0 ldi   : 225 lds   : 539 lpm   : 197 
lsl   :  58 lsr   : 136 mov   : 101 movw  :   0 mul   :  27 muls  :   0 
mulsu :   6 neg   :   0 nop   :   0 or    :  14 ori   :   8 out   :   8 
pop   :  96 push  :  90 rcall :  39 ret   :  28 reti  :   6 rjmp  : 388 
rol   :  38 ror   : 154 sbc   :  36 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  10 sbrc  :  21 sbrs  :  13 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1011 sub   :  49 subi  :  39 swap  :  35 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0054f8  11834   9846  21680   49152  44.1%
[.dseg] 0x002800 0x002901      0    257    257    6144   4.2%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 107 warnings
