
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Mon May 24 22:04:29 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of noise
002817                           noise_note: .byte 1 //the current note index in the period table
002818                           noise_adjusted_note: .byte 1 //the resultant note index after the arpeggio macro
                                 
002819                           song_frames: .byte 2
00281b                           song_frame_offset: .byte 2
00281d                           song_size: .byte 2
00281f                           song_tempo: .byte 2
002821                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002822                           song_fx_Bxx: .byte 1
002823                           song_fx_Cxx: .byte 1
002824                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002825                           pulse1_pattern: .byte 2
002827                           pulse1_pattern_delay_rows: .byte 1
002828                           pulse1_pattern_delay_frames: .byte 1
002829                           pulse1_pattern_offset: .byte 2
                                 
00282b                           pulse1_volume_macro: .byte 2
00282d                           pulse1_volume_macro_offset: .byte 1
00282e                           pulse1_volume_macro_loop: .byte 1
00282f                           pulse1_volume_macro_release: .byte 1
                                 
002830                           pulse1_arpeggio_macro: .byte 2
002832                           pulse1_arpeggio_macro_offset: .byte 1
002833                           pulse1_arpeggio_macro_loop: .byte 1
002834                           pulse1_arpeggio_macro_release: .byte 1
002835                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002836                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002838                           pulse1_pitch_macro: .byte 2
00283a                           pulse1_pitch_macro_offset: .byte 1
00283b                           pulse1_pitch_macro_loop: .byte 1
00283c                           pulse1_pitch_macro_release: .byte 1
                                 
00283d                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283e                           pulse1_hi_pitch_macro: .byte 2
002840                           pulse1_hi_pitch_macro_offset: .byte 1
002841                           pulse1_hi_pitch_macro_loop: .byte 1
002842                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002843                           pulse1_duty_macro: .byte 2
002845                           pulse1_duty_macro_offset: .byte 1
002846                           pulse1_duty_macro_loop: .byte 1
002847                           pulse1_duty_macro_release: .byte 1
                                 
002848                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00284a                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00284c                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284e                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002850                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002852                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002854                           pulse1_fx_3xx_target: .byte 2 //target note period
002856                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002858                           pulse1_fx_3xx_total_offset: .byte 2
00285a                           pulse1_fx_4xy_speed: .byte 1
00285b                           pulse1_fx_4xy_depth: .byte 1
00285c                           pulse1_fx_4xy_phase: .byte 1
00285d                           pulse1_fx_7xy_speed: .byte 1
00285e                           pulse1_fx_7xy_depth: .byte 1
00285f                           pulse1_fx_7xy_phase: .byte 1
002860                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002861                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002862                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002863                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002864                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002866                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002867                           pulse1_fx_Qxy_target: .byte 2 //target note period
002869                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00286b                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286d                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286e                           pulse1_fx_Rxy_target: .byte 2 //target note period
002870                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002872                           pulse1_fx_Rxy_total_offset: .byte 2
002874                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002875                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002876                           pulse2_pattern: .byte 2
002878                           pulse2_pattern_delay_rows: .byte 1
002879                           pulse2_pattern_delay_frames: .byte 1
00287a                           pulse2_pattern_offset: .byte 2
                                 
00287c                           pulse2_volume_macro: .byte 2
00287e                           pulse2_volume_macro_offset: .byte 1
00287f                           pulse2_volume_macro_loop: .byte 1
002880                           pulse2_volume_macro_release: .byte 1
                                 
002881                           pulse2_arpeggio_macro: .byte 2
002883                           pulse2_arpeggio_macro_offset: .byte 1
002884                           pulse2_arpeggio_macro_loop: .byte 1
002885                           pulse2_arpeggio_macro_release: .byte 1
002886                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002887                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002889                           pulse2_pitch_macro: .byte 2
00288b                           pulse2_pitch_macro_offset: .byte 1
00288c                           pulse2_pitch_macro_loop: .byte 1
00288d                           pulse2_pitch_macro_release: .byte 1
                                 
00288e                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288f                           pulse2_hi_pitch_macro: .byte 2
002891                           pulse2_hi_pitch_macro_offset: .byte 1
002892                           pulse2_hi_pitch_macro_loop: .byte 1
002893                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002894                           pulse2_duty_macro: .byte 2
002896                           pulse2_duty_macro_offset: .byte 1
002897                           pulse2_duty_macro_loop: .byte 1
002898                           pulse2_duty_macro_release: .byte 1
                                 
002899                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00289b                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289d                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289f                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028a1                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a3                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a5                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a7                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a9                           pulse2_fx_3xx_total_offset: .byte 2
0028ab                           pulse2_fx_4xy_speed: .byte 1
0028ac                           pulse2_fx_4xy_depth: .byte 1
0028ad                           pulse2_fx_4xy_phase: .byte 1
0028ae                           pulse2_fx_7xy_speed: .byte 1
0028af                           pulse2_fx_7xy_depth: .byte 1
0028b0                           pulse2_fx_7xy_phase: .byte 1
0028b1                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028b2                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b3                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b4                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b5                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b7                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b8                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028ba                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028bc                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028be                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bf                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028c1                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c3                           pulse2_fx_Rxy_total_offset: .byte 2
0028c5                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c6                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c7                           triangle_pattern: .byte 2
0028c9                           triangle_pattern_delay_rows: .byte 1
0028ca                           triangle_pattern_delay_frames: .byte 1
0028cb                           triangle_pattern_offset: .byte 2
                                 
0028cd                           triangle_volume_macro: .byte 2
0028cf                           triangle_volume_macro_offset: .byte 1
0028d0                           triangle_volume_macro_loop: .byte 1
0028d1                           triangle_volume_macro_release: .byte 1
                                 
0028d2                           triangle_arpeggio_macro: .byte 2
0028d4                           triangle_arpeggio_macro_offset: .byte 1
0028d5                           triangle_arpeggio_macro_loop: .byte 1
0028d6                           triangle_arpeggio_macro_release: .byte 1
0028d7                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d8                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028da                           triangle_pitch_macro: .byte 2
0028dc                           triangle_pitch_macro_offset: .byte 1
0028dd                           triangle_pitch_macro_loop: .byte 1
0028de                           triangle_pitch_macro_release: .byte 1
                                 
0028df                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028e0                           triangle_hi_pitch_macro: .byte 2
0028e2                           triangle_hi_pitch_macro_offset: .byte 1
0028e3                           triangle_hi_pitch_macro_loop: .byte 1
0028e4                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e5                           triangle_duty_macro: .byte 2
0028e7                           triangle_duty_macro_offset: .byte 1
0028e8                           triangle_duty_macro_loop: .byte 1
0028e9                           triangle_duty_macro_release: .byte 1
                                 
0028ea                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028ec                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028ee                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028f0                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028f2                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f4                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f6                           triangle_fx_3xx_target: .byte 2 //target note period
0028f8                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028fa                           triangle_fx_3xx_total_offset: .byte 2
0028fc                           triangle_fx_4xy_speed: .byte 1
0028fd                           triangle_fx_4xy_depth: .byte 1
0028fe                           triangle_fx_4xy_phase: .byte 1
0028ff                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002900                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002901                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002903                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002904                           triangle_fx_Qxy_target: .byte 2 //target note period
002906                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002908                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00290a                           triangle_fx_Rxy_target_note: .byte 1 //target note index
00290b                           triangle_fx_Rxy_target: .byte 2 //target note period
00290d                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290f                           triangle_fx_Rxy_total_offset: .byte 2
002911                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002912                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002913                           noise_pattern: .byte 2
002915                           noise_pattern_delay_rows: .byte 1
002916                           noise_pattern_delay_frames: .byte 1
002917                           noise_pattern_offset: .byte 2
                                 
002919                           noise_volume_macro: .byte 2
00291b                           noise_volume_macro_offset: .byte 1
00291c                           noise_volume_macro_loop: .byte 1
00291d                           noise_volume_macro_release: .byte 1
                                 
00291e                           noise_arpeggio_macro: .byte 2
002920                           noise_arpeggio_macro_offset: .byte 1
002921                           noise_arpeggio_macro_loop: .byte 1
002922                           noise_arpeggio_macro_release: .byte 1
002923                           noise_arpeggio_macro_mode: .byte 1
                                 
002924                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002926                           noise_pitch_macro: .byte 2
002928                           noise_pitch_macro_offset: .byte 1
002929                           noise_pitch_macro_loop: .byte 1
00292a                           noise_pitch_macro_release: .byte 1
                                 
00292b                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00292c                           noise_hi_pitch_macro: .byte 2
00292e                           noise_hi_pitch_macro_offset: .byte 1
00292f                           noise_hi_pitch_macro_loop: .byte 1
002930                           noise_hi_pitch_macro_release: .byte 1
                                 
002931                           noise_duty_macro: .byte 2
002933                           noise_duty_macro_offset: .byte 1
002934                           noise_duty_macro_loop: .byte 1
002935                           noise_duty_macro_release: .byte 1
                                 
002936                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002938                           noise_fx_1xx: .byte 1 //refers to the rate in which to subtract the pitch from by the 1xx
002939                           noise_fx_1xx_total: .byte 1 //the total pitch offset for 1xx
00293a                           noise_fx_2xx: .byte 1 //refers to the rate in which to add to the pitch by the 2xx
00293b                           noise_fx_2xx_total: .byte 1 //the total pitch offset for 2xx
00293c                           noise_fx_4xy_speed: .byte 1
00293d                           noise_fx_4xy_depth: .byte 1
00293e                           noise_fx_4xy_phase: .byte 1
00293f                           noise_fx_4xy_offset: .byte 1
002940                           noise_fx_7xy_speed: .byte 1
002941                           noise_fx_7xy_depth: .byte 1
002942                           noise_fx_7xy_phase: .byte 1
002943                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002944                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002945                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002946                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002947                           noise_fx_Pxx_total: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002948                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002949                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
00294a                           dpcm_pattern: .byte 2
00294c                           dpcm_pattern_delay_rows: .byte 1
00294d                           dpcm_pattern_delay_frames: .byte 1
00294e                           dpcm_pattern_offset: .byte 2
                                 
002950                           dpcm_sample: .byte 2
002952                           dpcm_sample_offset: .byte 2
                                 
002954                           dpcm_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002955                           dpcm_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002956                           dpcm_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002957                           dpcm_fx_Sxx_post: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 //NOTE: same idea with one
                                 .def zero = r2
                                 .def one = r3
                                 .def frame_sequence = r4
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r7
                                 .def pulse1_length_counter = r8
                                 .def pulse1_sweep = r9 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r10
                                 .def pulse2_length_counter = r11
                                 .def pulse2_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 .def dpcm_shift = r13
                                 .def dpcm_bit_counter = r14
                                 .def dpcm_period = r15
                                 .def dpcm_length_LOW = r23
                                 .def dpcm_length_HIGH = r24
                                 .def dpcm_output_volume = r5
                                 
                                 
                                 reset:
000000 940c 1b91                 	jmp init
                                 
                                 .org RTC_CNT_vect
000006 940c 1f48                 	jmp frame_counter_routine
                                 
                                 .org TCA0_OVF_vect
00000e 940c 203b                 	jmp dpcm_sequence_routine
                                 
                                 .org TCB0_INT_vect
000018 940c 1f70                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 1fbd                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 200a                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 2015                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(35): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(50): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(114): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(126): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(140): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(142): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(155): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(201): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(202): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(203): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(204): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(205): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(206): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(207): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(209): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(212): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
001b91 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
001b92 93c0 0034                 	sts CPU_CCP, r28
001b94 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
001b95 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001b97 2422                      	clr zero
                                 	//ONE
001b98 e0c1                      	ldi r28, 1
001b99 2e3c                      	mov one, r28
                                 	//FRAME SEQUENCE
001b9a 2c42                      	mov frame_sequence, zero
                                 
                                 	//MEMORY
001b9b e3c0                      	ldi r28, 0b00110000
001b9c 93c0 2800                 	sts pulse1_param, r28
001b9e e8c0                      	ldi r28, 0b10000000
001b9f 93c0 2801                 	sts pulse1_sweep_param, r28
001ba1 efcf                      	ldi r28, 0xFF
001ba2 93c0 2802                 	sts pulse1_timerL, r28
001ba4 93c0 2803                 	sts pulse1_timerH, r28
001ba6 93c0 2804                 	sts pulse1_length, r28
                                 
001ba8 e3c0                      	ldi r28, 0b00110000
001ba9 93c0 2808                 	sts pulse2_param, r28
001bab e8c0                      	ldi r28, 0b10000000
001bac 93c0 2809                 	sts pulse2_sweep_param, r28
001bae efcf                      	ldi r28, 0xFF
001baf 93c0 280a                 	sts pulse2_timerL, r28
001bb1 93c0 280b                 	sts pulse2_timerH, r28
001bb3 93c0 280c                 	sts pulse2_length, r28
                                 
001bb5 efcf                      	ldi r28, 0xFF
001bb6 93c0 2810                 	sts triangle_timerL, r28
001bb8 93c0 2811                 	sts triangle_timerH, r28
                                 
001bba e3c0                      	ldi r28, 0b00110000
001bbb 93c0 2813                 	sts noise_param, r28
001bbd e0cf                      	ldi r28, 0b00001111
001bbe 93c0 2814                 	sts noise_period, r28
                                 
001bc0 e0c4                      	ldi r28, 0x04
001bc1 93c0 281b                 	sts song_frame_offset, r28
001bc3 9220 281c                 	sts song_frame_offset+1, zero
001bc5 efcf                      	ldi r28, 0xFF
001bc6 93c0 2822                 	sts song_fx_Bxx, r28
001bc8 9220 2823                 	sts song_fx_Cxx, zero
001bca 9220 2824                 	sts song_fx_Dxx, zero
001bcc e6ee                      	ldi ZL, LOW(song0_frames << 1)
001bcd e0f3                      	ldi ZH, HIGH(song0_frames << 1)
001bce 93e0 2819                 	sts song_frames, ZL
001bd0 93f0 281a                 	sts song_frames+1, ZH
001bd2 91c5                      	lpm r28, Z+ //load the song size
001bd3 91d5                      	lpm r29, Z+
001bd4 93c0 281d                 	sts song_size, r28
001bd6 93d0 281e                 	sts song_size+1, r29
001bd8 91c5                      	lpm r28, Z+ //load the song tempo
001bd9 91d5                      	lpm r29, Z+
001bda 93c0 281f                 	sts song_tempo, r28
001bdc 93d0 2820                 	sts song_tempo+1, r29
001bde 9220 2821                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
001be0 91c5                      	lpm r28, Z+
001be1 91d5                      	lpm r29, Z+
001be2 0fcc                      	lsl r28
001be3 1fdd                      	rol r29
001be4 93c0 2825                 	sts pulse1_pattern, r28
001be6 93d0 2826                 	sts pulse1_pattern+1, r29
001be8 9220 2827                 	sts pulse1_pattern_delay_rows, zero
001bea 9230 2828                 	sts pulse1_pattern_delay_frames, one
001bec 9220 2829                 	sts pulse1_pattern_offset, zero
001bee 9220 282a                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
001bf0 91c5                      	lpm r28, Z+
001bf1 91d5                      	lpm r29, Z+
001bf2 0fcc                      	lsl r28
001bf3 1fdd                      	rol r29
001bf4 93c0 2876                 	sts pulse2_pattern, r28
001bf6 93d0 2877                 	sts pulse2_pattern+1, r29
001bf8 9220 2878                 	sts pulse2_pattern_delay_rows, zero
001bfa 9230 2879                 	sts pulse2_pattern_delay_frames, one
001bfc 9220 287a                 	sts pulse2_pattern_offset, zero
001bfe 9220 287b                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
001c00 91c5                      	lpm r28, Z+
001c01 91d5                      	lpm r29, Z+
001c02 0fcc                      	lsl r28
001c03 1fdd                      	rol r29
001c04 93c0 28c7                 	sts triangle_pattern, r28
001c06 93d0 28c8                 	sts triangle_pattern+1, r29
001c08 9220 28c9                 	sts triangle_pattern_delay_rows, zero
001c0a 9230 28ca                 	sts triangle_pattern_delay_frames, one
001c0c 9220 28cb                 	sts triangle_pattern_offset, zero
001c0e 9220 28cc                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
001c10 91c5                      	lpm r28, Z+
001c11 91d5                      	lpm r29, Z+
001c12 0fcc                      	lsl r28
001c13 1fdd                      	rol r29
001c14 93c0 2913                 	sts noise_pattern, r28
001c16 93d0 2914                 	sts noise_pattern+1, r29
001c18 9220 2915                 	sts noise_pattern_delay_rows, zero
001c1a 9230 2916                 	sts noise_pattern_delay_frames, one
001c1c 9220 2917                 	sts noise_pattern_offset, zero
001c1e 9220 2918                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 4
001c20 91c5                      	lpm r28, Z+
001c21 91d5                      	lpm r29, Z+
001c22 0fcc                      	lsl r28
001c23 1fdd                      	rol r29
001c24 93c0 294a                 	sts dpcm_pattern, r28
001c26 93d0 294b                 	sts dpcm_pattern+1, r29
001c28 9220 294c                 	sts dpcm_pattern_delay_rows, zero
001c2a 9230 294d                 	sts dpcm_pattern_delay_frames, one
001c2c 9220 294e                 	sts dpcm_pattern_offset, zero
001c2e 9220 294f                 	sts dpcm_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
001c30 efcf                      	ldi r28, 0xFF
001c31 9220 282d                 	sts pulse1_volume_macro_offset, zero
001c33 93c0 282e                 	sts pulse1_volume_macro_loop, r28
001c35 93c0 282f                 	sts pulse1_volume_macro_release, r28
001c37 9220 2832                 	sts pulse1_arpeggio_macro_offset, zero
001c39 93c0 2833                 	sts pulse1_arpeggio_macro_loop, r28
001c3b 93c0 2834                 	sts pulse1_arpeggio_macro_release, r28
001c3d 93c0 2835                 	sts pulse1_arpeggio_macro_mode, r28
001c3f 9220 283a                 	sts pulse1_pitch_macro_offset, zero
001c41 93c0 283b                 	sts pulse1_pitch_macro_loop, r28
001c43 93c0 283c                 	sts pulse1_pitch_macro_release, r28
001c45 9220 2840                 	sts pulse1_hi_pitch_macro_offset, zero
001c47 93c0 2841                 	sts pulse1_hi_pitch_macro_loop, r28
001c49 93c0 2842                 	sts pulse1_hi_pitch_macro_release, r28
001c4b 9220 2845                 	sts pulse1_duty_macro_offset, zero
001c4d 93c0 2846                 	sts pulse1_duty_macro_loop, r28
001c4f 93c0 2847                 	sts pulse1_duty_macro_release, r28
                                 
001c51 9220 282b                 	sts pulse1_volume_macro, zero
001c53 9220 282c                 	sts pulse1_volume_macro+1, zero
001c55 9220 2830                 	sts pulse1_arpeggio_macro, zero
001c57 9220 2831                 	sts pulse1_arpeggio_macro+1, zero
001c59 9220 2836                 	sts pulse1_total_pitch_offset, zero
001c5b 9220 2837                 	sts pulse1_total_pitch_offset+1, zero
001c5d 9220 2838                 	sts pulse1_pitch_macro, zero
001c5f 9220 2839                 	sts pulse1_pitch_macro+1, zero
001c61 9220 283d                 	sts pulse1_total_hi_pitch_offset, zero
001c63 9220 283e                 	sts pulse1_hi_pitch_macro, zero
001c65 9220 283f                 	sts pulse1_hi_pitch_macro+1, zero
001c67 9220 2843                 	sts pulse1_duty_macro, zero
001c69 9220 2844                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001c6b e00f                      	ldi pulse1_volume_divider, 0x0F
001c6c 9110 2800                 	lds pulse1_volume_decay, pulse1_param
001c6e 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001c6f 9190 2800                 	lds pulse_channel_flags, pulse1_param
001c71 7390                      	andi pulse_channel_flags, 0b00110000
001c72 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001c73 9220 2806                 	sts pulse1_output_volume, zero
001c75 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001c77 2e8c                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001c78 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001c79 2e7c                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001c7a 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param
001c7c 9492                      	swap pulse1_sweep //swap data from high byte and low byte
001c7d 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
001c7e efcf                      	ldi r28, 0xFF
001c7f 9220 2848                 	sts pulse1_fx_0xy_sequence, zero
001c81 9220 2849                 	sts pulse1_fx_0xy_sequence+1, zero
001c83 9220 284a                 	sts pulse1_fx_1xx, zero
001c85 9220 284b                 	sts pulse1_fx_1xx+1, zero
001c87 9220 284c                 	sts pulse1_fx_1xx_total, zero
001c89 9220 284d                 	sts pulse1_fx_1xx_total+1, zero
001c8b 9220 284e                 	sts pulse1_fx_2xx, zero
001c8d 9220 284f                 	sts pulse1_fx_2xx+1, zero
001c8f 9220 2850                 	sts pulse1_fx_2xx_total, zero
001c91 9220 2851                 	sts pulse1_fx_2xx_total+1, zero
001c93 9220 2852                 	sts pulse1_fx_3xx_start, zero
001c95 9220 2853                 	sts pulse1_fx_3xx_start+1, zero
001c97 9220 2854                 	sts pulse1_fx_3xx_target, zero
001c99 9220 2855                 	sts pulse1_fx_3xx_target+1, zero
001c9b 9220 2856                 	sts pulse1_fx_3xx_speed, zero
001c9d 9220 2857                 	sts pulse1_fx_3xx_speed+1, zero
001c9f 9220 2858                 	sts pulse1_fx_3xx_total_offset, zero
001ca1 9220 2859                 	sts pulse1_fx_3xx_total_offset+1, zero
001ca3 9220 285a                 	sts pulse1_fx_4xy_speed, zero
001ca5 9220 285b                 	sts pulse1_fx_4xy_depth, zero
001ca7 9220 285c                 	sts pulse1_fx_4xy_phase, zero
001ca9 9220 285d                 	sts pulse1_fx_7xy_speed, zero
001cab 9220 285e                 	sts pulse1_fx_7xy_depth, zero
001cad 9220 285f                 	sts pulse1_fx_7xy_phase, zero
001caf 9220 2860                 	sts pulse1_fx_7xy_value, zero
001cb1 9220 2861                 	sts pulse1_fx_Axy, zero
001cb3 93c0 2862                 	sts pulse1_fx_Gxx_pre, r28
001cb5 93c0 2863                 	sts pulse1_fx_Gxx_post, r28
001cb7 9220 2864                 	sts pulse1_fx_Pxx_total, zero
001cb9 9220 2865                 	sts pulse1_fx_Pxx_total+1, zero
001cbb 9220 2866                 	sts pulse1_fx_Qxy_target_note, zero
001cbd 9220 2867                 	sts pulse1_fx_Qxy_target, zero
001cbf 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
001cc1 9220 2869                 	sts pulse1_fx_Qxy_speed, zero
001cc3 9220 286a                 	sts pulse1_fx_Qxy_speed+1, zero
001cc5 9220 286b                 	sts pulse1_fx_Qxy_total_offset, zero
001cc7 9220 286c                 	sts pulse1_fx_Qxy_total_offset+1, zero
001cc9 9220 286d                 	sts pulse1_fx_Rxy_target_note, zero
001ccb 9220 286e                 	sts pulse1_fx_Rxy_target, zero
001ccd 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
001ccf 9220 2870                 	sts pulse1_fx_Rxy_speed, zero
001cd1 9220 2871                 	sts pulse1_fx_Rxy_speed+1, zero
001cd3 9220 2872                 	sts pulse1_fx_Rxy_total_offset, zero
001cd5 9220 2873                 	sts pulse1_fx_Rxy_total_offset+1, zero
001cd7 93c0 2874                 	sts pulse1_fx_Sxx_pre, r28
001cd9 93c0 2875                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
001cdb efcf                      	ldi r28, 0xFF
001cdc 9220 287e                 	sts pulse2_volume_macro_offset, zero
001cde 93c0 287f                 	sts pulse2_volume_macro_loop, r28
001ce0 93c0 2880                 	sts pulse2_volume_macro_release, r28
001ce2 9220 2883                 	sts pulse2_arpeggio_macro_offset, zero
001ce4 93c0 2884                 	sts pulse2_arpeggio_macro_loop, r28
001ce6 93c0 2885                 	sts pulse2_arpeggio_macro_release, r28
001ce8 93c0 2886                 	sts pulse2_arpeggio_macro_mode, r28
001cea 9220 288b                 	sts pulse2_pitch_macro_offset, zero
001cec 93c0 288c                 	sts pulse2_pitch_macro_loop, r28
001cee 93c0 288d                 	sts pulse2_pitch_macro_release, r28
001cf0 9220 2891                 	sts pulse2_hi_pitch_macro_offset, zero
001cf2 93c0 2892                 	sts pulse2_hi_pitch_macro_loop, r28
001cf4 93c0 2893                 	sts pulse2_hi_pitch_macro_release, r28
001cf6 9220 2896                 	sts pulse2_duty_macro_offset, zero
001cf8 93c0 2897                 	sts pulse2_duty_macro_loop, r28
001cfa 93c0 2898                 	sts pulse2_duty_macro_release, r28
                                 
001cfc 9220 287c                 	sts pulse2_volume_macro, zero
001cfe 9220 287d                 	sts pulse2_volume_macro+1, zero
001d00 9220 2881                 	sts pulse2_arpeggio_macro, zero
001d02 9220 2882                 	sts pulse2_arpeggio_macro+1, zero
001d04 9220 2887                 	sts pulse2_total_pitch_offset, zero
001d06 9220 2888                 	sts pulse2_total_pitch_offset+1, zero
001d08 9220 2889                 	sts pulse2_pitch_macro, zero
001d0a 9220 288a                 	sts pulse2_pitch_macro+1, zero
001d0c 9220 288e                 	sts pulse2_total_hi_pitch_offset, zero
001d0e 9220 288f                 	sts pulse2_hi_pitch_macro, zero
001d10 9220 2890                 	sts pulse2_hi_pitch_macro+1, zero
001d12 9220 2894                 	sts pulse2_duty_macro, zero
001d14 9220 2895                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
001d16 e02f                      	ldi pulse2_volume_divider, 0x0F
001d17 9130 2808                 	lds pulse2_volume_decay, pulse2_param
001d19 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
001d1a 91d0 2808                 	lds r29, pulse2_param
001d1c 73d0                      	andi r29, 0b00110000
001d1d 62d0                      	sbr r29, 0b0100000 //set start flag
001d1e 95d2                      	swap r29
001d1f 2b9d                      	or pulse_channel_flags, r29
001d20 9220 280e                 	sts pulse2_output_volume, zero
001d22 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
001d24 2ebc                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
001d25 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001d26 2eac                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
001d27 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param
001d29 94c2                      	swap pulse2_sweep //swap data from high byte and low byte
001d2a 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001d2b efcf                      	ldi r28, 0xFF
001d2c 9220 2899                 	sts pulse2_fx_0xy_sequence, zero
001d2e 9220 289a                 	sts pulse2_fx_0xy_sequence+1, zero
001d30 9220 289b                 	sts pulse2_fx_1xx, zero
001d32 9220 289c                 	sts pulse2_fx_1xx+1, zero
001d34 9220 289d                 	sts pulse2_fx_1xx_total, zero
001d36 9220 289e                 	sts pulse2_fx_1xx_total+1, zero
001d38 9220 289f                 	sts pulse2_fx_2xx, zero
001d3a 9220 28a0                 	sts pulse2_fx_2xx+1, zero
001d3c 9220 28a1                 	sts pulse2_fx_2xx_total, zero
001d3e 9220 28a2                 	sts pulse2_fx_2xx_total+1, zero
001d40 9220 28a3                 	sts pulse2_fx_3xx_start, zero
001d42 9220 28a4                 	sts pulse2_fx_3xx_start+1, zero
001d44 9220 28a5                 	sts pulse2_fx_3xx_target, zero
001d46 9220 28a6                 	sts pulse2_fx_3xx_target+1, zero
001d48 9220 28a7                 	sts pulse2_fx_3xx_speed, zero
001d4a 9220 28a8                 	sts pulse2_fx_3xx_speed+1, zero
001d4c 9220 28a9                 	sts pulse2_fx_3xx_total_offset, zero
001d4e 9220 28aa                 	sts pulse2_fx_3xx_total_offset+1, zero
001d50 9220 28ab                 	sts pulse2_fx_4xy_speed, zero
001d52 9220 28ac                 	sts pulse2_fx_4xy_depth, zero
001d54 9220 28ad                 	sts pulse2_fx_4xy_phase, zero
001d56 9220 28ae                 	sts pulse2_fx_7xy_speed, zero
001d58 9220 28af                 	sts pulse2_fx_7xy_depth, zero
001d5a 9220 28b0                 	sts pulse2_fx_7xy_phase, zero
001d5c 9220 28b1                 	sts pulse2_fx_7xy_value, zero
001d5e 9220 28b2                 	sts pulse2_fx_Axy, zero
001d60 93c0 28b3                 	sts pulse2_fx_Gxx_pre, r28
001d62 93c0 28b4                 	sts pulse2_fx_Gxx_post, r28
001d64 9220 28b5                 	sts pulse2_fx_Pxx_total, zero
001d66 9220 28b6                 	sts pulse2_fx_Pxx_total+1, zero
001d68 9220 28b7                 	sts pulse2_fx_Qxy_target_note, zero
001d6a 9220 28b8                 	sts pulse2_fx_Qxy_target, zero
001d6c 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
001d6e 9220 28ba                 	sts pulse2_fx_Qxy_speed, zero
001d70 9220 28bb                 	sts pulse2_fx_Qxy_speed+1, zero
001d72 9220 28bc                 	sts pulse2_fx_Qxy_total_offset, zero
001d74 9220 28bd                 	sts pulse2_fx_Qxy_total_offset+1, zero
001d76 9220 28be                 	sts pulse2_fx_Rxy_target_note, zero
001d78 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
001d7a 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
001d7c 9220 28c1                 	sts pulse2_fx_Rxy_speed, zero
001d7e 9220 28c2                 	sts pulse2_fx_Rxy_speed+1, zero
001d80 9220 28c3                 	sts pulse2_fx_Rxy_total_offset, zero
001d82 9220 28c4                 	sts pulse2_fx_Rxy_total_offset+1, zero
001d84 93c0 28c5                 	sts pulse2_fx_Sxx_pre, r28
001d86 93c0 28c6                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001d88 efcf                      	ldi r28, 0xFF
001d89 9220 28cf                 	sts triangle_volume_macro_offset, zero
001d8b 93c0 28d0                 	sts triangle_volume_macro_loop, r28
001d8d 93c0 28d1                 	sts triangle_volume_macro_release, r28
001d8f 9220 28d4                 	sts triangle_arpeggio_macro_offset, zero
001d91 93c0 28d5                 	sts triangle_arpeggio_macro_loop, r28
001d93 93c0 28d6                 	sts triangle_arpeggio_macro_release, r28
001d95 93c0 28d7                 	sts triangle_arpeggio_macro_mode, r28
001d97 9220 28dc                 	sts triangle_pitch_macro_offset, zero
001d99 93c0 28dd                 	sts triangle_pitch_macro_loop, r28
001d9b 93c0 28de                 	sts triangle_pitch_macro_release, r28
001d9d 9220 28e2                 	sts triangle_hi_pitch_macro_offset, zero
001d9f 93c0 28e3                 	sts triangle_hi_pitch_macro_loop, r28
001da1 93c0 28e4                 	sts triangle_hi_pitch_macro_release, r28
001da3 9220 28e7                 	sts triangle_duty_macro_offset, zero
001da5 93c0 28e8                 	sts triangle_duty_macro_loop, r28
001da7 93c0 28e9                 	sts triangle_duty_macro_release, r28
                                 
001da9 9220 28cd                 	sts triangle_volume_macro, zero
001dab 9220 28ce                 	sts triangle_volume_macro+1, zero
001dad 9220 28d2                 	sts triangle_arpeggio_macro, zero
001daf 9220 28d3                 	sts triangle_arpeggio_macro+1, zero
001db1 9220 28d8                 	sts triangle_total_pitch_offset, zero
001db3 9220 28d9                 	sts triangle_total_pitch_offset+1, zero
001db5 9220 28da                 	sts triangle_pitch_macro, zero
001db7 9220 28db                 	sts triangle_pitch_macro+1, zero
001db9 9220 28df                 	sts triangle_total_hi_pitch_offset, zero
001dbb 9220 28e0                 	sts triangle_hi_pitch_macro, zero
001dbd 9220 28e1                 	sts triangle_hi_pitch_macro+1, zero
001dbf 9220 28e5                 	sts triangle_duty_macro, zero
001dc1 9220 28e6                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
001dc3 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
001dc4 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
001dc5 efcf                      	ldi r28, 0xFF
001dc6 9220 28ea                 	sts triangle_fx_0xy_sequence, zero
001dc8 9220 28eb                 	sts triangle_fx_0xy_sequence+1, zero
001dca 9220 28ec                 	sts triangle_fx_1xx, zero
001dcc 9220 28ed                 	sts triangle_fx_1xx+1, zero
001dce 9220 28ee                 	sts triangle_fx_1xx_total, zero
001dd0 9220 28ef                 	sts triangle_fx_1xx_total+1, zero
001dd2 9220 28f0                 	sts triangle_fx_2xx, zero
001dd4 9220 28f1                 	sts triangle_fx_2xx+1, zero
001dd6 9220 28f2                 	sts triangle_fx_2xx_total, zero
001dd8 9220 28f3                 	sts triangle_fx_2xx_total+1, zero
001dda 9220 28f4                 	sts triangle_fx_3xx_start, zero
001ddc 9220 28f5                 	sts triangle_fx_3xx_start+1, zero
001dde 9220 28f6                 	sts triangle_fx_3xx_target, zero
001de0 9220 28f7                 	sts triangle_fx_3xx_target+1, zero
001de2 9220 28f8                 	sts triangle_fx_3xx_speed, zero
001de4 9220 28f9                 	sts triangle_fx_3xx_speed+1, zero
001de6 9220 28fa                 	sts triangle_fx_3xx_total_offset, zero
001de8 9220 28fb                 	sts triangle_fx_3xx_total_offset+1, zero
001dea 9220 28fc                 	sts triangle_fx_4xy_speed, zero
001dec 9220 28fd                 	sts triangle_fx_4xy_depth, zero
001dee 9220 28fe                 	sts triangle_fx_4xy_phase, zero
001df0 93c0 28ff                 	sts triangle_fx_Gxx_pre, r28
001df2 93c0 2900                 	sts triangle_fx_Gxx_post, r28
001df4 9220 2901                 	sts triangle_fx_Pxx_total, zero
001df6 9220 2902                 	sts triangle_fx_Pxx_total+1, zero
001df8 9220 2903                 	sts triangle_fx_Qxy_target_note, zero
001dfa 9220 2904                 	sts triangle_fx_Qxy_target, zero
001dfc 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
001dfe 9220 2906                 	sts triangle_fx_Qxy_speed, zero
001e00 9220 2907                 	sts triangle_fx_Qxy_speed+1, zero
001e02 9220 2908                 	sts triangle_fx_Qxy_total_offset, zero
001e04 9220 2909                 	sts triangle_fx_Qxy_total_offset+1, zero
001e06 9220 290a                 	sts triangle_fx_Rxy_target_note, zero
001e08 9220 290b                 	sts triangle_fx_Rxy_target, zero
001e0a 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
001e0c 9220 290d                 	sts triangle_fx_Rxy_speed, zero
001e0e 9220 290e                 	sts triangle_fx_Rxy_speed+1, zero
001e10 9220 290f                 	sts triangle_fx_Rxy_total_offset, zero
001e12 9220 2910                 	sts triangle_fx_Rxy_total_offset+1, zero
001e14 93c0 2911                 	sts triangle_fx_Sxx_pre, r28
001e16 93c0 2912                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
001e18 efcf                      	ldi r28, 0xFF
001e19 9220 291b                 	sts noise_volume_macro_offset, zero
001e1b 93c0 291c                 	sts noise_volume_macro_loop, r28
001e1d 93c0 291d                 	sts noise_volume_macro_release, r28
001e1f 9220 2920                 	sts noise_arpeggio_macro_offset, zero
001e21 93c0 2921                 	sts noise_arpeggio_macro_loop, r28
001e23 93c0 2922                 	sts noise_arpeggio_macro_release, r28
001e25 93c0 2923                 	sts noise_arpeggio_macro_mode, r28
001e27 9220 2928                 	sts noise_pitch_macro_offset, zero
001e29 93c0 2929                 	sts noise_pitch_macro_loop, r28
001e2b 93c0 292a                 	sts noise_pitch_macro_release, r28
001e2d 9220 292e                 	sts noise_hi_pitch_macro_offset, zero
001e2f 93c0 292f                 	sts noise_hi_pitch_macro_loop, r28
001e31 93c0 2930                 	sts noise_hi_pitch_macro_release, r28
001e33 9220 2933                 	sts noise_duty_macro_offset, zero
001e35 93c0 2934                 	sts noise_duty_macro_loop, r28
001e37 93c0 2935                 	sts noise_duty_macro_release, r28
                                 
001e39 9220 2919                 	sts noise_volume_macro, zero
001e3b 9220 291a                 	sts noise_volume_macro+1, zero
001e3d 9220 291e                 	sts noise_arpeggio_macro, zero
001e3f 9220 291f                 	sts noise_arpeggio_macro+1, zero
001e41 9220 2924                 	sts noise_total_pitch_offset, zero
001e43 9220 2925                 	sts noise_total_pitch_offset+1, zero
001e45 9220 2926                 	sts noise_pitch_macro, zero
001e47 9220 2927                 	sts noise_pitch_macro+1, zero
001e49 9220 292b                 	sts noise_total_hi_pitch_offset, zero
001e4b 9220 292c                 	sts noise_hi_pitch_macro, zero
001e4d 9220 292d                 	sts noise_hi_pitch_macro+1, zero
001e4f 9220 2931                 	sts noise_duty_macro, zero
001e51 9220 2932                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
001e53 9220 2816                 	sts noise_output_volume, zero
001e55 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001e57 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001e58 2f5c                      	mov noise_sequence_LOW, r28
001e59 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
001e5a efcf                      	ldi r28, 0xFF
001e5b 9220 2936                 	sts noise_fx_0xy_sequence, zero
001e5d 9220 2937                 	sts noise_fx_0xy_sequence+1, zero
001e5f 9220 2938                 	sts noise_fx_1xx, zero
001e61 9220 2939                 	sts noise_fx_1xx_total, zero
001e63 9220 293a                 	sts noise_fx_2xx, zero
001e65 9220 293b                 	sts noise_fx_2xx_total, zero
001e67 9220 293c                 	sts noise_fx_4xy_speed, zero
001e69 9220 293d                 	sts noise_fx_4xy_depth, zero
001e6b 9220 293e                 	sts noise_fx_4xy_phase, zero
001e6d 9220 293f                 	sts noise_fx_4xy_offset, zero
001e6f 9220 2940                 	sts noise_fx_7xy_speed, zero
001e71 9220 2941                 	sts noise_fx_7xy_depth, zero
001e73 9220 2942                 	sts noise_fx_7xy_phase, zero
001e75 9220 2943                 	sts noise_fx_7xy_value, zero
001e77 9220 2944                 	sts noise_fx_Axy, zero
001e79 93c0 2945                 	sts noise_fx_Gxx_pre, r28
001e7b 93c0 2946                 	sts noise_fx_Gxx_post, r28
001e7d 9220 2947                 	sts noise_fx_Pxx_total, zero
001e7f 93c0 2948                 	sts noise_fx_Sxx_pre, r28
001e81 93c0 2949                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 4 VOLUME
001e83 2c52                      	mov dpcm_output_volume, zero
                                 
                                 	//CHANNEL 4 SAMPLE
001e84 9220 2950                 	sts dpcm_sample, zero
001e86 9220 2951                 	sts dpcm_sample+1, zero
001e88 9220 2952                 	sts dpcm_sample_offset, zero
001e8a 9220 2953                 	sts dpcm_sample_offset+1, zero
001e8c 2cd2                      	mov dpcm_shift, zero
001e8d 2ce2                      	mov dpcm_bit_counter, zero
001e8e 2cf2                      	mov dpcm_period, zero
001e8f 2d72                      	mov dpcm_length_LOW, zero
001e90 2d82                      	mov dpcm_length_HIGH, zero
                                 
                                 	//CHANNEL 4 FX
001e91 93c0 2945                 	sts noise_fx_Gxx_pre, r28
001e93 93c0 2946                 	sts noise_fx_Gxx_post, r28
001e95 93c0 2948                 	sts noise_fx_Sxx_pre, r28
001e97 93c0 2949                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
001e99 efcf                      	ldi r28, 0xFF
001e9a b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
001e9b e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
001e9c 93c0 0a81                 	sts TCB0_CTRLB, r28
001e9e e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
001e9f 93c0 0a85                 	sts TCB0_INTCTRL, r28
001ea1 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001ea3 93c0 0a8c                 	sts TCB0_CCMPL, r28
001ea5 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001ea7 93c0 0a8d                 	sts TCB0_CCMPH, r28
001ea9 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001eaa 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001eac e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001ead 93b0 0a91                 	sts TCB1_CTRLB, r27
001eaf e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001eb0 93b0 0a95                 	sts TCB1_INTCTRL, r27
001eb2 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001eb4 93b0 0a9c                 	sts TCB1_CCMPL, r27
001eb6 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001eb8 93b0 0a9d                 	sts TCB1_CCMPH, r27
001eba e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001ebb 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001ebd e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001ebe 93b0 0aa1                 	sts TCB2_CTRLB, r27
001ec0 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
001ec1 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
001ec3 93b0 0aac                 	sts TCB2_CCMPL, r27
001ec5 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
001ec7 93b0 0aad                 	sts TCB2_CCMPH, r27
001ec9 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001eca 93b0 0aa0                 	sts TCB2_CTRLA, r27
001ecc 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
001ecd e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001ece 93b0 0ab1                 	sts TCB3_CTRLB, r27
001ed0 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ed1 93b0 0ab5                 	sts TCB3_INTCTRL, r27
001ed3 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001ed5 93b0 0abc                 	sts TCB3_CCMPL, r27
001ed7 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001ed9 93b0 0abd                 	sts TCB3_CCMPH, r27
001edb e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001edc 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 	//DPCM
001ede e0c0                      	ldi r28, TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
001edf 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
001ee1 e0c1                      	ldi r28, TCA_SINGLE_OVF_bm //enable overflow interrupts
001ee2 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001ee4 e0c2                      	ldi r28, TCA_SINGLE_CLKSEL_DIV2_gc //use prescaler divider of 2
001ee5 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//RTC
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Interrupts will be setup to interrupt every 240 Hz clock
                                 	//The 4th consecutive interrupt will clock the sound driver every 60 Hz, in which new audio data is read and written to the registers
                                 	//1st and 2nd interrupt will execute sequence 0 and 2. 3rd and 4th interrupt will execute sequence 1 and 3.
                                 	//Timer period Calculation: ((1/(tempo*4)) * 32768/2)
                                 	//The RTC timer is clocked at 32768 Hz
                                 	//The /2 comes from the prescaler divider used
                                 	//NOTE: The frame counter clock will not always be 60 Hz, and will depend on the song_tempo.
001ee7 e0b0                      	ldi r27, RTC_CLKSEL_INT32K_gc //internal 32kHz oscillator
001ee8 93b0 0147                 	sts RTC_CLKSEL, r27
001eea 91b0 281f                 	lds r27, song_tempo
001eec 91c0 2820                 	lds r28, song_tempo+1
001eee 93b0 014a                 	sts RTC_PER, r27
001ef0 93c0 014b                 	sts RTC_PER + 1, r28
001ef2 e0b1                      	ldi r27, RTC_OVF_bm //overflow interrupts
001ef3 93b0 0142                 	sts RTC_INTCTRL, r27
001ef5 e0b9                      	ldi r27, RTC_PRESCALER_DIV2_gc | RTC_PITEN_bm //use prescaler divider of 16 and enable RTC
001ef6 93b0 0140                 	sts RTC_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
001ef8 91c0 2806                 	lds r28, pulse1_output_volume
001efa 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
001efc fe70                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
001efd c015                      	rjmp volume_mixer_pulse1_off
                                 
001efe 1482                      	cp pulse1_length_counter, zero //if length is zero, return
001eff f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
001f00 91e0 0a8c                 	lds r30, TCB0_CCMPL
001f02 e5f9                      	ldi r31, 0x59
001f03 17ef                      	cp r30, r31
001f04 91e0 0a8d                 	lds r30, TCB0_CCMPH
001f06 e0f0                      	ldi r31, 0x00
001f07 07ef                      	cpc r30, r31
001f08 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $595A
001f09 91e0 0a8c                 	lds r30, TCB0_CCMPL
001f0b e5fa                      	ldi r31, 0x5A
001f0c 17ef                      	cp r30, r31
001f0d 91e0 0a8d                 	lds r30, TCB0_CCMPH
001f0f e5f9                      	ldi r31, 0x59
001f10 07ef                      	cpc r30, r31
001f11 f408                      	brsh volume_mixer_pulse1_off
001f12 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
001f13 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
001f14 fea0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
001f15 c015                      	rjmp volume_mixer_pulse2_off
                                 
001f16 14b2                      	cp pulse2_length_counter, zero //if length is zero, return
001f17 f099                      	breq volume_mixer_pulse2_off
                                 
001f18 91e0 0a9c                 	lds r30, TCB1_CCMPL
001f1a e5f9                      	ldi r31, 0x59
001f1b 17ef                      	cp r30, r31
001f1c 91e0 0a9d                 	lds r30, TCB1_CCMPH
001f1e e0f0                      	ldi r31, 0x00
001f1f 07ef                      	cpc r30, r31
001f20 f050                      	brlo volume_mixer_pulse2_off
                                 
001f21 91e0 0a9c                 	lds r30, TCB1_CCMPL
001f23 e5fa                      	ldi r31, 0x5A
001f24 17ef                      	cp r30, r31
001f25 91e0 0a9d                 	lds r30, TCB1_CCMPH
001f27 e5f9                      	ldi r31, 0x59
001f28 07ef                      	cpc r30, r31
001f29 f408                      	brsh volume_mixer_pulse2_off
001f2a c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001f2b 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
001f2c 0fcd                      	add r28, r29
001f2d e8e2                      	ldi ZL, LOW(pulse_volume_table << 1)
001f2e e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
001f2f 0fec                      	add ZL, r28
001f30 1df2                      	adc ZH, zero
001f31 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001f32 2fd4                      	mov r29, triangle_sequence
001f33 fdd4                      	sbrc r29, 4 //check 5th bit
001f34 95d0                      	com r29
001f35 70df                      	andi r29, 0x0F
001f36 2fed                      	mov r30, r29
001f37 0fde                      	add r29, r30 //multiply the triangle volume by 3
001f38 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_dpcm:
001f39 0dd5                      	add r29, dpcm_output_volume
                                 
                                 volume_mixer_tnd_noise:
001f3a ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
001f3b c004                      	rjmp volume_mixer_tnd_out
001f3c 91e0 2816                 	lds r30, noise_output_volume
001f3e 0fee                      	lsl r30 //multiply noise volume by 2
001f3f 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
001f40 eae2                      	ldi ZL, LOW(tnd_volume_table << 1)
001f41 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
001f42 0fed                      	add ZL, r29
001f43 1df2                      	adc ZH, zero
001f44 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001f45 0fcd                      	add r28, r29
001f46 b9c1                      	out VPORTA_OUT, r28
001f47 cfb0                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 frame_counter_routine:
001f48 b7bf                      	in r27, CPU_SREG
001f49 93bf                      	push r27
001f4a 94f8                      	cli
                                 
001f4b 2da4                      	mov r26, frame_sequence
001f4c 0c43                      	add frame_sequence, one
001f4d 30a0                      	cpi r26, 0x00
001f4e f029                      	breq sequence_0_2
001f4f 30a1                      	cpi r26, 0x01
001f50 f059                      	breq sequence_1_3
001f51 30a2                      	cpi r26, 0x02
001f52 f009                      	breq sequence_0_2
001f53 c12f                      	rjmp sound_driver
                                 
                                 sequence_0_2:
                                 	//ENVELOPE
001f54 d050                      	rcall pulse1_envelope_routine
001f55 d09c                      	rcall pulse2_envelope_routine
                                 
001f56 e0b3                      	ldi r27, RTC_CMP_bm | RTC_OVF_bm //clear OVF flag
001f57 93b0 0143                 	sts RTC_INTFLAGS, r27
001f59 91bf                      	pop r27
001f5a bfbf                      	out CPU_SREG, r27
001f5b 9518                      	reti
                                 
                                 sequence_1_3:
                                 	//ENVELOPE
001f5c d048                      	rcall pulse1_envelope_routine
001f5d d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001f5e fc93                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001f5f d01b                      	rcall pulse1_sweep_routine
001f60 fcc3                      	sbrc pulse2_sweep, 3
001f61 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001f62 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001f63 c002                      	rjmp sequence_1_3_pulse2_length
001f64 1082                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001f65 948a                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001f66 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001f67 c002                      	rjmp sequence_1_3_exit
001f68 10b2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001f69 94ba                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001f6a e0b1                      	ldi r27, RTC_OVF_bm //clear OVF flag
001f6b 93b0 0143                 	sts RTC_INTFLAGS, r27
001f6d 91bf                      	pop r27
001f6e bfbf                      	out CPU_SREG, r27
001f6f 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001f70 b7bf                      	in r27, CPU_SREG
001f71 93bf                      	push r27
001f72 94f8                      	cli
                                 
001f73 0c77                      	lsl pulse1_sequence //shifts sequence to the left
001f74 1c72                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001f75 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001f76 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001f78 91bf                      	pop r27
001f79 bfbf                      	out CPU_SREG, r27
001f7a 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001f7b 2db9                      	mov r27, pulse1_sweep
001f7c 70b7                      	andi r27, 0x07 //mask for period divider bits
001f7d f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001f7e 93df                      	push r29
001f7f 2dd9                      	mov r29, pulse1_sweep
001f80 95d2                      	swap r29
001f81 70d7                      	andi r29, 0x07 //mask for shift bits
001f82 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001f83 91df                      	pop r29
001f84 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001f85 91a0 0a8c                 	lds r26, TCB0_CCMPL
001f87 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001f89 95b6                      	lsr r27
001f8a 95a7                      	ror r26
001f8b 95da                      	dec r29
001f8c f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001f8d fe97                      	sbrs pulse1_sweep, 7 //check the negate flag
001f8e c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001f8f 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001f90 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001f91 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001f93 0fad                      	add r26, r29
001f94 91d0 0a8d                 	lds r29, TCB0_CCMPH
001f96 1fbd                      	adc r27, r29
                                 
001f97 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001f99 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001f9b 91df                      	pop r29
001f9c c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001f9d 949a                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001f9e ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
001f9f 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001fa0 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001fa2 9492                      	swap pulse1_sweep //bring data from high byte to low byte
001fa3 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
001fa4 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001fa5 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
001fa6 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001fa7 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001fa8 f011                      	breq PC+3 //if the divider == 0, check loop flag
001fa9 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001faa 9508                      	ret
                                 
001fab 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001fad 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001fae ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001faf c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001fb0 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001fb1 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001fb2 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001fb3 f409                      	brne PC+2 //if decay != 0, go decrement
001fb4 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001fb5 951a                      	dec pulse1_volume_decay
001fb6 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001fb7 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
001fb8 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001fba 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001fbb e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001fbc 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
001fbd b7bf                      	in r27, CPU_SREG
001fbe 93bf                      	push r27
001fbf 94f8                      	cli
                                 
001fc0 0caa                      	lsl pulse2_sequence //shifts sequence to the left
001fc1 1ca2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001fc2 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001fc3 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001fc5 91bf                      	pop r27
001fc6 bfbf                      	out CPU_SREG, r27
001fc7 9518                      	reti
                                 
                                 pulse2_sweep_routine:
001fc8 2dbc                      	mov r27, pulse2_sweep
001fc9 70b7                      	andi r27, 0x07 //mask for period divider bits
001fca f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001fcb 93df                      	push r29
001fcc 2ddc                      	mov r29, pulse2_sweep
001fcd 95d2                      	swap r29
001fce 70d7                      	andi r29, 0x07 //mask for shift bits
001fcf f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001fd0 91df                      	pop r29
001fd1 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001fd2 91a0 0a9c                 	lds r26, TCB1_CCMPL
001fd4 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
001fd6 95b6                      	lsr r27
001fd7 95a7                      	ror r26
001fd8 95da                      	dec r29
001fd9 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001fda fec7                      	sbrs pulse2_sweep, 7 //check the negate flag
001fdb c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001fdc 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001fdd 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001fde 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001fe0 0fad                      	add r26, r29
001fe1 91d0 0a9d                 	lds r29, TCB1_CCMPH
001fe3 1fbd                      	adc r27, r29
                                 
001fe4 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
001fe6 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001fe8 91df                      	pop r29
001fe9 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
001fea 94ca                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
001feb ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
001fec 9508                      	ret
                                 
                                 pulse2_sweep_reload:
001fed 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001fef 94c2                      	swap pulse2_sweep //bring data from high byte to low byte
001ff0 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
001ff1 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
001ff2 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
001ff3 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
001ff4 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
001ff5 f011                      	breq PC+3 //if the divider == 0, check loop flag
001ff6 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
001ff7 9508                      	ret
                                 
001ff8 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
001ffa 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001ffb ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
001ffc c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001ffd e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001ffe 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001fff 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
002000 f409                      	brne PC+2 //if decay != 0, go decrement
002001 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
002002 953a                      	dec pulse2_volume_decay
002003 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
002004 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
002005 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
002007 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
002008 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
002009 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
00200a b7bf                      	in r27, CPU_SREG
00200b 93bf                      	push r27
00200c 94f8                      	cli
                                 
00200d 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
00200e 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
00200f e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
002010 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
002012 91bf                      	pop r27
002013 bfbf                      	out CPU_SREG, r27
002014 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
002015 b7bf                      	in r27, CPU_SREG
002016 93bf                      	push r27
002017 94f8                      	cli
                                 
002018 2fa5                      	mov r26, noise_sequence_LOW
002019 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
00201a c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
00201b 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
00201c 27a5                      	eor r26, noise_sequence_LOW
00201d fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
00201e c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
00201f 9566                      	lsr noise_sequence_HIGH
002020 9557                      	ror noise_sequence_LOW
002021 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
002022 9566                      	lsr noise_sequence_HIGH
002023 9557                      	ror noise_sequence_LOW
002024 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
002025 c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
002026 0faa                      	lsl r26
002027 1faa                      	rol r26
002028 1faa                      	rol r26 //move the 6th bit to the 0th bit place
002029 27a5                      	eor r26, noise_sequence_LOW
00202a fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
00202b c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
00202c 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
00202d 9566                      	lsr noise_sequence_HIGH
00202e 9557                      	ror noise_sequence_LOW
00202f 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
002030 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
002031 9566                      	lsr noise_sequence_HIGH
002032 9557                      	ror noise_sequence_LOW
002033 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
002034 c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
002035 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
002036 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
002038 91bf                      	pop r27
002039 bfbf                      	out CPU_SREG, r27
00203a 9518                      	reti
                                 
                                 //DPCM ROUTINES
                                 dpcm_sequence_routine:
00203b b7bf                      	in r27, CPU_SREG
00203c 93bf                      	push r27
00203d 94f8                      	cli
                                 
00203e 91e0 2950                 	lds ZL, dpcm_sample
002040 91f0 2951                 	lds ZH, dpcm_sample+1
                                 
                                 dpcm_check_counter:
002042 14e2                      	cp dpcm_bit_counter, zero
002043 f009                      	breq dpcm_check_length
002044 c004                      	rjmp dpcm_shift_register
                                 dpcm_check_length:
002045 1572                      	cp dpcm_length_LOW, zero
002046 0582                      	cpc dpcm_length_HIGH, zero
002047 f129                      	breq dpcm_stop
002048 c004                      	rjmp dpcm_next_byte
                                 
                                 dpcm_shift_register:
002049 18e3                      	sub dpcm_bit_counter, one
00204a fcd0                      	sbrc dpcm_shift, 0
00204b c013                      	rjmp dpcm_volume_add
00204c c019                      	rjmp dpcm_volume_sub
                                 
                                 dpcm_next_byte:
00204d 91a0 2952                 	lds r26, dpcm_sample_offset
00204f 91b0 2953                 	lds r27, dpcm_sample_offset+1
002051 0da3                      	add r26, one //increment sample offset
002052 1db2                      	adc r27, zero
002053 1973                      	sub dpcm_length_LOW, one //decrement dpcm sample length
002054 0982                      	sbc dpcm_length_HIGH, zero
002055 93a0 2952                 	sts dpcm_sample_offset, r26
002057 93b0 2953                 	sts dpcm_sample_offset+1, r27
                                 
002059 0fea                      	add ZL, r26 //offset data in sample table
00205a 1ffb                      	adc ZH, r27
00205b 90d4                      	lpm dpcm_shift, Z //load data byte into dpcm shift register
00205c e0a8                      	ldi r26, 0x08
00205d 2eea                      	mov dpcm_bit_counter, r26 //reset bit counter to 8
00205e cfea                      	rjmp dpcm_shift_register
                                 
                                 dpcm_volume_add:
00205f 94d6                      	lsr dpcm_shift //right shift
002060 e7ae                      	ldi r26, 0x7E //0x7E + 0x02 is the highest volume DPCM can have
002061 165a                      	cp dpcm_output_volume, r26
002062 f470                      	brsh dpcm_sequence_exit //exit dpcm sequence if needed to prevent overflow
002063 0c53                      	add dpcm_output_volume, one //add 2
002064 0c53                      	add dpcm_output_volume, one
002065 c00b                      	rjmp dpcm_sequence_exit
                                 dpcm_volume_sub:
002066 94d6                      	lsr dpcm_shift //right shift
002067 e0a2                      	ldi r26, 0x02 // 0x02 - 0x02 is the lowest volume DPCM can have
002068 165a                      	cp dpcm_output_volume, r26
002069 f038                      	brlo dpcm_sequence_exit //exit dpcm sequence if needed to prevent overflow
00206a 1853                      	sub dpcm_output_volume, one //subtract 2
00206b 1853                      	sub dpcm_output_volume, one
00206c c004                      	rjmp dpcm_sequence_exit
                                 
                                 dpcm_stop:
00206d e0a2                      	ldi r26, TCA_SINGLE_CLKSEL_DIV2_gc //use prescale divider of 2 and disable timer
00206e 93a0 0a00                 	sts TCA0_SINGLE_CTRLA, r26
002070 c000                      	rjmp dpcm_sequence_exit
                                 
                                 dpcm_sequence_exit:
002071 e0b1                      	ldi r27, TCA_SINGLE_OVF_bm //clear OVF flag
002072 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
002074 91bf                      	pop r27
002075 bfbf                      	out CPU_SREG, r27
002076 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
002077 ebe0                      	ldi ZL, LOW(length << 1)
002078 e7f4                      	ldi ZH, HIGH(length << 1)
002079 0fed                      	add ZL, r29
00207a 1df2                      	adc ZH, zero
00207b 91d4                      	lpm r29, Z
00207c 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
00207d ede0                      	ldi ZL, LOW(sequences << 1)
00207e e7f4                      	ldi ZH, HIGH(sequences << 1)
00207f 0fed                      	add ZL, r29
002080 1df2                      	adc ZH, zero
002081 91d4                      	lpm r29, Z
002082 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
002083 2c42                      	mov frame_sequence, zero
002084 93cf                      	push r28
002085 93df                      	push r29
002086 93ef                      	push r30
002087 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
002088 91a0 2822                 	lds r26, song_fx_Bxx
00208a 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
00208b f4a9                      	brne sound_driver_fx_Bxx_routine
00208c 91a0 2823                 	lds r26, song_fx_Cxx
00208e 11a2                      	cpse r26, zero
00208f c0a3                      	rjmp sound_driver_fx_Cxx_routine
002090 91a0 2824                 	lds r26, song_fx_Dxx
002092 11a2                      	cpse r26, zero
002093 c0ae                      	rjmp sound_driver_fx_Dxx_routine
                                 
002094 91a0 281b                 	lds r26, song_frame_offset
002096 91b0 281c                 	lds r27, song_frame_offset+1
002098 91c0 281d                 	lds r28, song_size
00209a 91d0 281e                 	lds r29, song_size+1
00209c 17ac                      	cp r26, r28
00209d 07bd                      	cpc r27, r29
00209e f408                      	brsh sound_driver_fx_song_loop
00209f c131                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
0020a0 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
0020a1 91e0 2819                 	lds ZL, song_frames
0020a3 91f0 281a                 	lds ZH, song_frames+1
0020a5 27cc                      	clr r28 //initialize r29:r28 to 0
0020a6 27dd                      	clr r29
0020a7 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
0020a8 95aa                      	dec r26
0020a9 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
0020aa 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
0020ab cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
0020ac 9624                      	adiw r29:r28, 4 //add 4 to skip the first 4 bytes (first 4 bytes is the song size and tempo)
0020ad 93c0 281b                 	sts song_frame_offset, r28
0020af 93d0 281c                 	sts song_frame_offset+1, r29
0020b1 0fec                      	add ZL, r28
0020b2 1ffd                      	adc ZH, r29
                                 
0020b3 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
0020b4 91b5                      	lpm r27, Z+
0020b5 0faa                      	lsl r26
0020b6 1fbb                      	rol r27
0020b7 93a0 2825                 	sts pulse1_pattern, r26
0020b9 93b0 2826                 	sts pulse1_pattern+1, r27
0020bb 91a5                      	lpm r26, Z+
0020bc 91b5                      	lpm r27, Z+
0020bd 0faa                      	lsl r26
0020be 1fbb                      	rol r27
0020bf 93a0 2876                 	sts pulse2_pattern, r26
0020c1 93b0 2877                 	sts pulse2_pattern+1, r27
0020c3 91a5                      	lpm r26, Z+
0020c4 91b5                      	lpm r27, Z+
0020c5 0faa                      	lsl r26
0020c6 1fbb                      	rol r27
0020c7 93a0 28c7                 	sts triangle_pattern, r26
0020c9 93b0 28c8                 	sts triangle_pattern+1, r27
0020cb 91a5                      	lpm r26, Z+
0020cc 91b5                      	lpm r27, Z+
0020cd 0faa                      	lsl r26
0020ce 1fbb                      	rol r27
0020cf 93a0 2913                 	sts noise_pattern, r26
0020d1 93b0 2914                 	sts noise_pattern+1, r27
0020d3 91a5                      	lpm r26, Z+
0020d4 91b5                      	lpm r27, Z+
0020d5 0faa                      	lsl r26
0020d6 1fbb                      	rol r27
0020d7 93a0 294a                 	sts dpcm_pattern, r26
0020d9 93b0 294b                 	sts dpcm_pattern+1, r27
                                 
0020db 9220 2829                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0020dd 9220 282a                 	sts pulse1_pattern_offset+1, zero
0020df 9220 2827                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0020e1 9230 2828                 	sts pulse1_pattern_delay_frames, one
0020e3 9220 287a                 	sts pulse2_pattern_offset, zero
0020e5 9220 287b                 	sts pulse2_pattern_offset+1, zero
0020e7 9220 2878                 	sts pulse2_pattern_delay_rows, zero
0020e9 9230 2879                 	sts pulse2_pattern_delay_frames, one
0020eb 9220 28cb                 	sts triangle_pattern_offset, zero
0020ed 9220 28cc                 	sts triangle_pattern_offset+1, zero
0020ef 9220 28c9                 	sts triangle_pattern_delay_rows, zero
0020f1 9230 28ca                 	sts triangle_pattern_delay_frames, one
0020f3 9220 2917                 	sts noise_pattern_offset, zero
0020f5 9220 2918                 	sts noise_pattern_offset+1, zero
0020f7 9220 2915                 	sts noise_pattern_delay_rows, zero
0020f9 9230 2916                 	sts noise_pattern_delay_frames, one
0020fb 9220 294e                 	sts dpcm_pattern_offset, zero
0020fd 9220 294e                 	sts dpcm_pattern_offset, zero
0020ff 9220 294c                 	sts dpcm_pattern_delay_rows, zero
002101 9230 294d                 	sts dpcm_pattern_delay_frames, one
                                 
002103 efaf                      	ldi r26, 0xFF
002104 93a0 2862                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
002106 93a0 2863                 	sts pulse1_fx_Gxx_post, r26
002108 93a0 2874                 	sts pulse1_fx_Sxx_pre, r26
00210a 93a0 2875                 	sts pulse1_fx_Sxx_post, r26
00210c 93a0 28b3                 	sts pulse2_fx_Gxx_pre, r26
00210e 93a0 28b4                 	sts pulse2_fx_Gxx_post, r26
002110 93a0 28c5                 	sts pulse2_fx_Sxx_pre, r26
002112 93a0 28c6                 	sts pulse2_fx_Sxx_post, r26
002114 93a0 28ff                 	sts triangle_fx_Gxx_pre, r26
002116 93a0 2900                 	sts triangle_fx_Gxx_post, r26
002118 93a0 2911                 	sts triangle_fx_Sxx_pre, r26
00211a 93a0 2912                 	sts triangle_fx_Sxx_post, r26
00211c 93a0 2945                 	sts noise_fx_Gxx_pre, r26
00211e 93a0 2946                 	sts noise_fx_Gxx_post, r26
002120 93a0 2948                 	sts noise_fx_Sxx_pre, r26
002122 93a0 2949                 	sts noise_fx_Sxx_post, r26
002124 93a0 2954                 	sts dpcm_fx_Gxx_pre, r26
002126 93a0 2955                 	sts dpcm_fx_Gxx_post, r26
002128 93a0 2956                 	sts dpcm_fx_Sxx_pre, r26
00212a 93a0 2957                 	sts dpcm_fx_Sxx_post, r26
                                 
00212c 93a0 2822                 	sts song_fx_Bxx, r26 //reset all song effects
00212e 9220 2823                 	sts song_fx_Cxx, zero
002130 9220 2824                 	sts song_fx_Dxx, zero
002132 c09e                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
002133 91ff                      	pop r31
002134 91ef                      	pop r30
002135 91df                      	pop r29
002136 91cf                      	pop r28
002137 91bf                      	pop r27
002138 bfbf                      	out CPU_SREG, r27
002139 94f8                      	cli //disable global interrupts
                                 		
00213a efaf                      	ldi r26, 0xFF
00213b 93a0 2822                 	sts song_fx_Bxx, r26 //reset all song effects
00213d 9220 2823                 	sts song_fx_Cxx, zero
00213f 9220 2824                 	sts song_fx_Dxx, zero
002141 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
002142 91e0 2819                 	lds ZL, song_frames
002144 91f0 281a                 	lds ZH, song_frames+1
002146 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002148 91b0 281c                 	lds r27, song_frame_offset+1
00214a 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
00214b 93a0 281b                 	sts song_frame_offset, r26
00214d 93b0 281c                 	sts song_frame_offset+1, r27
00214f 0fea                      	add ZL, r26
002150 1ffb                      	adc ZH, r27
                                 
002151 91a5                      	lpm r26, Z+ //load the address of the next pattern
002152 91b5                      	lpm r27, Z+
002153 0faa                      	lsl r26
002154 1fbb                      	rol r27
002155 93a0 2825                 	sts pulse1_pattern, r26
002157 93b0 2826                 	sts pulse1_pattern+1, r27
002159 91a5                      	lpm r26, Z+
00215a 91b5                      	lpm r27, Z+
00215b 0faa                      	lsl r26
00215c 1fbb                      	rol r27
00215d 93a0 2876                 	sts pulse2_pattern, r26
00215f 93b0 2877                 	sts pulse2_pattern+1, r27
002161 91a5                      	lpm r26, Z+
002162 91b5                      	lpm r27, Z+
002163 0faa                      	lsl r26
002164 1fbb                      	rol r27
002165 93a0 28c7                 	sts triangle_pattern, r26
002167 93b0 28c8                 	sts triangle_pattern+1, r27
002169 91a5                      	lpm r26, Z+
00216a 91b5                      	lpm r27, Z+
00216b 0faa                      	lsl r26
00216c 1fbb                      	rol r27
00216d 93a0 2913                 	sts noise_pattern, r26
00216f 93b0 2914                 	sts noise_pattern+1, r27
002171 91a5                      	lpm r26, Z+
002172 91b5                      	lpm r27, Z+
002173 0faa                      	lsl r26
002174 1fbb                      	rol r27
002175 93a0 294a                 	sts dpcm_pattern, r26
002177 93b0 294b                 	sts dpcm_pattern+1, r27
                                 
002179 9220 2829                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00217b 9220 282a                 	sts pulse1_pattern_offset+1, zero
00217d 9220 2827                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00217f 9230 2828                 	sts pulse1_pattern_delay_frames, one
002181 9220 287a                 	sts pulse2_pattern_offset, zero
002183 9220 287b                 	sts pulse2_pattern_offset+1, zero
002185 9220 2878                 	sts pulse2_pattern_delay_rows, zero
002187 9230 2879                 	sts pulse2_pattern_delay_frames, one
002189 9220 28cb                 	sts triangle_pattern_offset, zero
00218b 9220 28cc                 	sts triangle_pattern_offset+1, zero
00218d 9220 28c9                 	sts triangle_pattern_delay_rows, zero
00218f 9230 28ca                 	sts triangle_pattern_delay_frames, one
002191 9220 2917                 	sts noise_pattern_offset, zero
002193 9220 2918                 	sts noise_pattern_offset+1, zero
002195 9220 2915                 	sts noise_pattern_delay_rows, zero
002197 9230 2916                 	sts noise_pattern_delay_frames, one
002199 9220 294e                 	sts dpcm_pattern_offset, zero
00219b 9220 294e                 	sts dpcm_pattern_offset, zero
00219d 9220 294c                 	sts dpcm_pattern_delay_rows, zero
00219f 9230 294d                 	sts dpcm_pattern_delay_frames, one
                                 
0021a1 efaf                      	ldi r26, 0xFF
0021a2 93a0 2862                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0021a4 93a0 2863                 	sts pulse1_fx_Gxx_post, r26
0021a6 93a0 2874                 	sts pulse1_fx_Sxx_pre, r26
0021a8 93a0 2875                 	sts pulse1_fx_Sxx_post, r26
0021aa 93a0 28b3                 	sts pulse2_fx_Gxx_pre, r26
0021ac 93a0 28b4                 	sts pulse2_fx_Gxx_post, r26
0021ae 93a0 28c5                 	sts pulse2_fx_Sxx_pre, r26
0021b0 93a0 28c6                 	sts pulse2_fx_Sxx_post, r26
0021b2 93a0 28ff                 	sts triangle_fx_Gxx_pre, r26
0021b4 93a0 2900                 	sts triangle_fx_Gxx_post, r26
0021b6 93a0 2911                 	sts triangle_fx_Sxx_pre, r26
0021b8 93a0 2912                 	sts triangle_fx_Sxx_post, r26
0021ba 93a0 2945                 	sts noise_fx_Gxx_pre, r26
0021bc 93a0 2946                 	sts noise_fx_Gxx_post, r26
0021be 93a0 2948                 	sts noise_fx_Sxx_pre, r26
0021c0 93a0 2949                 	sts noise_fx_Sxx_post, r26
0021c2 93a0 2954                 	sts dpcm_fx_Gxx_pre, r26
0021c4 93a0 2955                 	sts dpcm_fx_Gxx_post, r26
0021c6 93a0 2956                 	sts dpcm_fx_Sxx_pre, r26
0021c8 93a0 2957                 	sts dpcm_fx_Sxx_post, r26
                                 
0021ca 93a0 2822                 	sts song_fx_Bxx, r26 //reset all song effects
0021cc 9220 2823                 	sts song_fx_Cxx, zero
0021ce 9220 2824                 	sts song_fx_Dxx, zero
0021d0 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
0021d1 91a0 2827                 	lds r26, pulse1_pattern_delay_rows
0021d3 91b0 2828                 	lds r27, pulse1_pattern_delay_frames
                                 sound_driver_channel0_decrement_frame_delay:
0021d5 95ba                      	dec r27
0021d6 93b0 2828                 	sts pulse1_pattern_delay_frames, r27
                                 
0021d8 9610                      	adiw r27:r26, 0
0021d9 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
0021da c2e4                      	rjmp sound_driver_channel0_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel0_main:
0021db 91e0 2825                 	lds ZL, pulse1_pattern //current pattern for pulse 1
0021dd 91f0 2826                 	lds ZH, pulse1_pattern+1
0021df 91a0 2829                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
0021e1 91b0 282a                 	lds r27, pulse1_pattern_offset+1
0021e3 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0021e4 1ffb                      	adc ZH, r27
0021e5 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0021e6 35b7                      	cpi r27, 0x57
0021e7 f408                      	brsh sound_driver_channel0_check_if_volume
0021e8 c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
0021e9 36b7                      	cpi r27, 0x67
0021ea f408                      	brsh sound_driver_channel0_check_if_delay
0021eb c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0021ec 3eb3                      	cpi r27, 0xE3
0021ed f408                      	brsh sound_driver_channel0_check_if_instrument
0021ee c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
0021ef f409                      	brne sound_driver_channel0_check_if_release
0021f0 c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
0021f1 3eb4                      	cpi r27, 0xE4
0021f2 f409                      	brne sound_driver_channel0_check_if_end
0021f3 c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
0021f4 3fbf                      	cpi r27, 0xFF
0021f5 f409                      	brne sound_driver_channel0_check_if_fx
0021f6 c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
0021f7 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0021f8 91a4                      	lpm r26, Z //load the fx data into r26
0021f9 d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
0021fa 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0021fb ede4                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
0021fc e7f4                      	ldi ZH, HIGH(channel0_fx << 1)
0021fd 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0021fe 0feb                      	add ZL, r27 //add offset
0021ff 1df2                      	adc ZH, zero
002200 91c5                      	lpm r28, Z+ //load address bytes
002201 91d4                      	lpm r29, Z
002202 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002203 2ffd                      	mov ZH, r29
002204 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
002205 93a0 2848                 	sts pulse1_fx_0xy_sequence, r26
002207 9220 2849                 	sts pulse1_fx_0xy_sequence+1, zero
002209 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00220a 9220 284e                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
00220c 9220 284f                 	sts pulse1_fx_2xx+1, zero
00220e 9220 2848                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
002210 9220 2849                 	sts pulse1_fx_0xy_sequence+1, zero
002212 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002213 937f                      	push r23
002214 2f6a                      	mov r22, r26 //store the rate into r22
002215 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002216 9f67                      	mul r22, r23
002217 917f                      	pop r23
002218 916f                      	pop r22
                                 
002219 9416                      	lsr r1 //shift out the fractional bits
00221a 9407                      	ror r0
00221b 9416                      	lsr r1
00221c 9407                      	ror r0
00221d 9416                      	lsr r1
00221e 9407                      	ror r0
00221f 9416                      	lsr r1
002220 9407                      	ror r0
002221 9200 284a                 	sts pulse1_fx_1xx, r0
002223 9210 284b                 	sts pulse1_fx_1xx+1, r1
002225 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
002226 9220 284a                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
002228 9220 284b                 	sts pulse1_fx_1xx+1, zero
00222a 9220 2848                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00222c 9220 2849                 	sts pulse1_fx_0xy_sequence+1, zero
00222e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00222f 937f                      	push r23
002230 2f6a                      	mov r22, r26 //store the rate into r22
002231 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002232 9f67                      	mul r22, r23
002233 917f                      	pop r23
002234 916f                      	pop r22
                                 
002235 9416                      	lsr r1 //shift out the fractional bits
002236 9407                      	ror r0
002237 9416                      	lsr r1
002238 9407                      	ror r0
002239 9416                      	lsr r1
00223a 9407                      	ror r0
00223b 9416                      	lsr r1
00223c 9407                      	ror r0
00223d 9200 284e                 	sts pulse1_fx_2xx, r0
00223f 9210 284f                 	sts pulse1_fx_2xx+1, r1
002241 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
002242 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002243 937f                      	push r23
002244 2f6a                      	mov r22, r26 //store the rate into r22
002245 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002246 9f67                      	mul r22, r23
002247 917f                      	pop r23
002248 916f                      	pop r22
                                 
002249 9416                      	lsr r1 //shift out the fractional bits
00224a 9407                      	ror r0
00224b 9416                      	lsr r1
00224c 9407                      	ror r0
00224d 9416                      	lsr r1
00224e 9407                      	ror r0
00224f 9416                      	lsr r1
002250 9407                      	ror r0
002251 9200 2856                 	sts pulse1_fx_3xx_speed, r0
002253 9210 2857                 	sts pulse1_fx_3xx_speed+1, r1
                                 
002255 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
002256 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
002257 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
002258 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00225a 91b0 0a8d                 	lds r27, TCB0_CCMPH
00225c 93a0 2852                 	sts pulse1_fx_3xx_start, r26
00225e 93b0 2853                 	sts pulse1_fx_3xx_start+1, r27
                                 
002260 9220 2858                 	sts pulse1_fx_3xx_total_offset, zero
002262 9220 2859                 	sts pulse1_fx_3xx_total_offset+1, zero
002264 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
002265 2fba                      	mov r27, r26
002266 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002267 95a2                      	swap r26
002268 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002269 93a0 285a                 	sts pulse1_fx_4xy_speed, r26
00226b 93b0 285b                 	sts pulse1_fx_4xy_depth, r27
00226d 9220 285c                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
00226f cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
002270 2fba                      	mov r27, r26
002271 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002272 95a2                      	swap r26
002273 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002274 93a0 285d                 	sts pulse1_fx_7xy_speed, r26
002276 93b0 285e                 	sts pulse1_fx_7xy_depth, r27
002278 9220 285f                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
00227a 9220 2860                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
00227c cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
00227d 93a0 2861                 	sts pulse1_fx_Axy, r26
00227f cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
002280 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002282 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
002283 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002285 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
002286 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002288 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
002289 91b0 2800                 	lds r27, pulse1_param
00228b 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
00228c 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
00228d 93b0 2800                 	sts pulse1_param, r27
00228f 6096                      	sbr pulse_channel_flags, 6
002290 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
002291 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002293 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
002294 15a2                      	cp r26, zero
002295 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
002296 91b0 2821                 	lds r27, song_speed
002298 17ab                      	cp r26, r27
002299 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
00229a 93a0 2862                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00229c e0b1                      	ldi r27, 0x01
00229d 93b0 2827                 	sts pulse1_pattern_delay_rows, r27
00229f c22e                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
0022a0 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0022a1 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0022a2 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0022a3 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0022a4 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0022a5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022a6 937f                      	push r23
0022a7 2f6a                      	mov r22, r26
0022a8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022a9 0367                      	mulsu r22, r23
0022aa 917f                      	pop r23
0022ab 916f                      	pop r22
0022ac 9416                      	lsr r1 //shift out the fractional bits
0022ad 9407                      	ror r0
0022ae 9416                      	lsr r1
0022af 9407                      	ror r0
0022b0 9416                      	lsr r1
0022b1 9407                      	ror r0
0022b2 9416                      	lsr r1
0022b3 9407                      	ror r0
0022b4 fe13                      	sbrs r1, 3 //check if result was a negative number
0022b5 c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
0022b6 efb0                      	ldi r27, 0xF0
0022b7 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
0022b8 9200 2864                 	sts pulse1_fx_Pxx_total, r0
0022ba 9210 2865                 	sts pulse1_fx_Pxx_total+1, r1
0022bc cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
0022bd 91e0 2830                 	lds ZL, pulse1_arpeggio_macro
0022bf 91f0 2831                 	lds ZH, pulse1_arpeggio_macro+1
0022c1 9630                      	adiw Z, 0
0022c2 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
0022c3 cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
0022c4 91e0 2838                 	lds ZL, pulse1_pitch_macro
0022c6 91f0 2839                 	lds ZH, pulse1_pitch_macro+1
0022c8 9630                      	adiw Z, 0
0022c9 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
0022ca cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
0022cb 91e0 283e                 	lds ZL, pulse1_hi_pitch_macro
0022cd 91f0 283f                 	lds ZH, pulse1_hi_pitch_macro+1
0022cf 9630                      	adiw Z, 0
0022d0 f009                      	breq sound_driver_channel0_fx_Qxy_process
0022d1 cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
0022d2 2fba                      	mov r27, r26 //copy fx parameters into r27
0022d3 70bf                      	andi r27, 0x0F //mask note index offset
0022d4 91c0 2866                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
0022d6 0fbc                      	add r27, r28
0022d7 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0022d8 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
0022d9 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
0022da 93b0 2866                 	sts pulse1_fx_Qxy_target_note, r27
0022dc e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0022dd e0f0                      	ldi ZH, HIGH(note_table << 1)
0022de 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0022df 0feb                      	add ZL, r27 //add offset
0022e0 1df2                      	adc ZH, zero
0022e1 91c5                      	lpm r28, Z+ //load bytes
0022e2 91d4                      	lpm r29, Z
0022e3 93c0 2867                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
0022e5 93d0 2868                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
0022e7 95a2                      	swap r26
0022e8 70af                      	andi r26, 0x0F //mask effect speed
0022e9 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0022ea 95a3                      	inc r26 //increment the speed by 1
                                 
0022eb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022ec 937f                      	push r23
0022ed 2f6a                      	mov r22, r26 //store the speed data into r27
0022ee eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022ef 9f67                      	mul r22, r23
0022f0 917f                      	pop r23
0022f1 916f                      	pop r22
                                 
0022f2 9416                      	lsr r1 //shift out the fractional bits
0022f3 9407                      	ror r0
0022f4 9416                      	lsr r1
0022f5 9407                      	ror r0
0022f6 9416                      	lsr r1
0022f7 9407                      	ror r0
0022f8 9416                      	lsr r1
0022f9 9407                      	ror r0
                                 
0022fa 9200 2869                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0022fc 9210 286a                 	sts pulse1_fx_Qxy_speed+1, r1
0022fe cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0022ff 91e0 2830                 	lds ZL, pulse1_arpeggio_macro
002301 91f0 2831                 	lds ZH, pulse1_arpeggio_macro+1
002303 9630                      	adiw Z, 0
002304 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
002305 ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
002306 91e0 2838                 	lds ZL, pulse1_pitch_macro
002308 91f0 2839                 	lds ZH, pulse1_pitch_macro+1
00230a 9630                      	adiw Z, 0
00230b f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
00230c cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
00230d 91e0 283e                 	lds ZL, pulse1_hi_pitch_macro
00230f 91f0 283f                 	lds ZH, pulse1_hi_pitch_macro+1
002311 9630                      	adiw Z, 0
002312 f009                      	breq sound_driver_channel0_fx_Rxy_process
002313 cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
002314 2fba                      	mov r27, r26 //copy fx parameters into r27
002315 70bf                      	andi r27, 0x0F //mask note index offset
002316 91c0 286d                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
002318 1bcb                      	sub r28, r27
002319 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
00231a e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
00231b 93c0 286d                 	sts pulse1_fx_Rxy_target_note, r28
00231d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00231e e0f0                      	ldi ZH, HIGH(note_table << 1)
00231f 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
002320 0fec                      	add ZL, r28 //add offset
002321 1df2                      	adc ZH, zero
002322 91c5                      	lpm r28, Z+ //load bytes
002323 91d4                      	lpm r29, Z
002324 93c0 286e                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
002326 93d0 286f                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
002328 95a2                      	swap r26
002329 70af                      	andi r26, 0x0F //mask effect speed
00232a 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00232b 95a3                      	inc r26 //increment the speed by 1
                                 
00232c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00232d 937f                      	push r23
00232e 2f6a                      	mov r22, r26 //store the speed data into r27
00232f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002330 9f67                      	mul r22, r23
002331 917f                      	pop r23
002332 916f                      	pop r22
                                 
002333 9416                      	lsr r1 //shift out the fractional bits
002334 9407                      	ror r0
002335 9416                      	lsr r1
002336 9407                      	ror r0
002337 9416                      	lsr r1
002338 9407                      	ror r0
002339 9416                      	lsr r1
00233a 9407                      	ror r0
                                 
00233b 9200 2870                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
00233d 9210 2871                 	sts pulse1_fx_Rxy_speed+1, r1
00233f ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
002340 15a2                      	cp r26, zero
002341 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
002342 91b0 2821                 	lds r27, song_speed
002344 17ab                      	cp r26, r27
002345 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
002346 93a0 2874                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002348 e0b1                      	ldi r27, 0x01
002349 93b0 2827                 	sts pulse1_pattern_delay_rows, r27
00234b c182                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
00234c ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
00234d ede0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00234e e7f4                      	ldi ZH, HIGH(sequences << 1)
00234f 0fea                      	add ZL, r26 //offset the pointer
002350 1df2                      	adc ZH, zero
                                 
002351 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
002352 95a7                      	ror r26
002353 95a7                      	ror r26
002354 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
002356 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
002357 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
002358 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
002359 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
00235a ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
00235b 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
00235c 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00235d 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00235e 93c0 2800                 	sts pulse1_param, r28
002360 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
002361 ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
002362 ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
002363 ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
002364 ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
002365 93b0 2807                 	sts pulse1_note, r27 //store the note index
002367 93b0 2866                 	sts pulse1_fx_Qxy_target_note, r27
002369 93b0 286d                 	sts pulse1_fx_Rxy_target_note, r27
00236b e0a3                      	ldi r26, 0x03
00236c e0b2                      	ldi r27, 0x02
00236d 93b0 282d                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00236f 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26
002371 93b0 283a                 	sts pulse1_pitch_macro_offset, r27
002373 93b0 2840                 	sts pulse1_hi_pitch_macro_offset, r27
002375 93b0 2845                 	sts pulse1_duty_macro_offset, r27
002377 9220 2836                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
002379 9220 2837                 	sts pulse1_total_pitch_offset+1, zero
00237b 9220 283d                 	sts pulse1_total_hi_pitch_offset, zero
00237d 9220 284c                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00237f 9220 284d                 	sts pulse1_fx_1xx_total+1, zero
002381 9220 2850                 	sts pulse1_fx_2xx_total, zero
002383 9220 2851                 	sts pulse1_fx_2xx_total+1, zero
002385 9220 2858                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
002387 9220 2859                 	sts pulse1_fx_3xx_total_offset+1, zero
002389 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00238b 91b0 0a8d                 	lds r27, TCB0_CCMPH
00238d 93a0 2852                 	sts pulse1_fx_3xx_start, r26
00238f 93b0 2853                 	sts pulse1_fx_3xx_start+1, r27
002391 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
002393 6097                      	sbr pulse_channel_flags, 7 //set reload flag
002394 9220 2867                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002396 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
002398 9220 286b                 	sts pulse1_fx_Qxy_total_offset, zero
00239a 9220 286c                 	sts pulse1_fx_Qxy_total_offset+1, zero
00239c 9220 286e                 	sts pulse1_fx_Rxy_target, zero
00239e 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
0023a0 9220 2872                 	sts pulse1_fx_Rxy_total_offset, zero
0023a2 9220 2873                 	sts pulse1_fx_Rxy_total_offset+1, zero
0023a4 d106                      	rcall sound_driver_channel0_increment_offset
0023a5 ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
0023a6 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
0023a7 91a0 2800                 	lds r26, pulse1_param
0023a9 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0023aa 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
0023ab 93a0 2800                 	sts pulse1_param, r26
0023ad 6096                      	sbr pulse_channel_flags, 6
0023ae d0fc                      	rcall sound_driver_channel0_increment_offset
0023af ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
0023b0 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0023b1 93b0 2827                 	sts pulse1_pattern_delay_rows, r27
0023b3 d0f7                      	rcall sound_driver_channel0_increment_offset
0023b4 c10a                      	rjmp sound_driver_channel0_end
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
0023b5 9220 282b                 	sts pulse1_volume_macro, zero //reset all macro addresses
0023b7 9220 282c                 	sts pulse1_volume_macro+1, zero
0023b9 9220 2830                 	sts pulse1_arpeggio_macro, zero
0023bb 9220 2831                 	sts pulse1_arpeggio_macro+1, zero
0023bd 9220 2838                 	sts pulse1_pitch_macro, zero
0023bf 9220 2839                 	sts pulse1_pitch_macro+1, zero
0023c1 9220 283e                 	sts pulse1_hi_pitch_macro, zero
0023c3 9220 283f                 	sts pulse1_hi_pitch_macro+1, zero
0023c5 9220 2843                 	sts pulse1_duty_macro, zero
0023c7 9220 2844                 	sts pulse1_duty_macro+1, zero
0023c9 9220 2836                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
0023cb 9220 2837                 	sts pulse1_total_pitch_offset+1, zero
0023cd 9220 283d                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0023cf 9631                      	adiw Z, 1 //point to the byte next to the flag
0023d0 91b4                      	lpm r27, Z //store the instrument offset into r27
0023d1 edec                      	ldi ZL, LOW(instruments) //point Z to instruments table
0023d2 e1fa                      	ldi ZH, HIGH(instruments)
0023d3 0feb                      	add ZL, r27 //point Z to offsetted instrument
0023d4 1df2                      	adc ZH, zero
0023d5 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0023d6 1fff                      	rol ZH
0023d7 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0023d8 91b4                      	lpm r27, Z
                                 
0023d9 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0023da 1fbb                      	rol r27
0023db 2fea                      	mov ZL, r26
0023dc 2ffb                      	mov ZH, r27
0023dd 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0023de 9632                      	adiw Z, 2 //point Z to the address of the macro
0023df e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
0023e0 95aa                      	dec r26
0023e1 f019                      	breq sound_driver_channel0_instrument_change_exit
0023e2 95b6                      	lsr r27
0023e3 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
0023e4 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
0023e5 e0a3                      	ldi r26, 0x03
0023e6 e0b2                      	ldi r27, 0x02
0023e7 93b0 282d                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0023e9 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26
0023eb 93b0 283a                 	sts pulse1_pitch_macro_offset, r27
0023ed 93b0 2840                 	sts pulse1_hi_pitch_macro_offset, r27
0023ef 93b0 2845                 	sts pulse1_duty_macro_offset, r27
0023f1 d0c3                      	rcall sound_driver_channel0_increment_offset_twice
0023f2 cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
0023f3 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0023f4 91d5                      	lpm r29, Z+
                                 
0023f5 30a5                      	cpi r26, 5
0023f6 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
0023f7 30a4                      	cpi r26, 4
0023f8 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
0023f9 30a3                      	cpi r26, 3
0023fa f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
0023fb 30a2                      	cpi r26, 2
0023fc f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
0023fd c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
0023fe 93c0 282b                 	sts pulse1_volume_macro, r28
002400 93d0 282c                 	sts pulse1_volume_macro+1, r29
002402 d041                      	rcall sound_driver_channel0_instrument_change_read_header
002403 93c0 282f                 	sts pulse1_volume_macro_release, r28
002405 93d0 282e                 	sts pulse1_volume_macro_loop, r29
002407 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
002408 93c0 2830                 	sts pulse1_arpeggio_macro, r28
00240a 93d0 2831                 	sts pulse1_arpeggio_macro+1, r29
00240c 9220 2867                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00240e 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
002410 9220 286e                 	sts pulse1_fx_Rxy_target, zero
002412 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
002414 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
002415 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
002416 93c0 2838                 	sts pulse1_pitch_macro, r28
002418 93d0 2839                 	sts pulse1_pitch_macro+1, r29
00241a 9220 2867                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00241c 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
00241e 9220 286e                 	sts pulse1_fx_Rxy_target, zero
002420 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
002422 d021                      	rcall sound_driver_channel0_instrument_change_read_header
002423 93c0 283c                 	sts pulse1_pitch_macro_release, r28
002425 93d0 283b                 	sts pulse1_pitch_macro_loop, r29
002427 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
002428 93c0 283e                 	sts pulse1_hi_pitch_macro, r28
00242a 93d0 283f                 	sts pulse1_hi_pitch_macro+1, r29
00242c 9220 2867                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00242e 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
002430 9220 286e                 	sts pulse1_fx_Rxy_target, zero
002432 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
002434 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
002435 93c0 2842                 	sts pulse1_hi_pitch_macro_release, r28
002437 93d0 2841                 	sts pulse1_hi_pitch_macro_loop, r29
002439 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
00243a 93c0 2843                 	sts pulse1_duty_macro, r28
00243c 93d0 2844                 	sts pulse1_duty_macro+1, r29
00243e d005                      	rcall sound_driver_channel0_instrument_change_read_header
00243f 93c0 2847                 	sts pulse1_duty_macro_release, r28
002441 93d0 2846                 	sts pulse1_duty_macro_loop, r29
002443 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
002444 93ef                      	push ZL
002445 93ff                      	push ZH
002446 2fec                      	mov ZL, r28
002447 2ffd                      	mov ZH, r29
002448 0fee                      	lsl ZL
002449 1fff                      	rol ZH
00244a 91c5                      	lpm r28, Z+
00244b 91d4                      	lpm r29, Z
00244c 91ff                      	pop ZH
00244d 91ef                      	pop ZL
00244e 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
00244f 93ef                      	push ZL
002450 93ff                      	push ZH
002451 2fec                      	mov ZL, r28
002452 2ffd                      	mov ZH, r29
002453 0fee                      	lsl ZL
002454 1fff                      	rol ZH
002455 91c5                      	lpm r28, Z+
002456 91d5                      	lpm r29, Z+
002457 93c0 2834                 	sts pulse1_arpeggio_macro_release, r28
002459 93d0 2833                 	sts pulse1_arpeggio_macro_loop, r29
00245b 91c4                      	lpm r28, Z
00245c 93c0 2835                 	sts pulse1_arpeggio_macro_mode, r28
00245e 91ff                      	pop ZH
00245f 91ef                      	pop ZL
002460 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
002461 91b0 282f                 	lds r27, pulse1_volume_macro_release
002463 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002464 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
002465 95b3                      	inc r27
002466 93b0 282d                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
002468 91b0 2834                 	lds r27, pulse1_arpeggio_macro_release
00246a 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00246b f019                      	breq sound_driver_channel0_release_pitch
00246c 95b3                      	inc r27
00246d 93b0 2832                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
00246f 91b0 283c                 	lds r27, pulse1_pitch_macro_release
002471 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002472 f019                      	breq sound_driver_channel0_release_hi_pitch
002473 95b3                      	inc r27
002474 93b0 283a                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
002476 91b0 2842                 	lds r27, pulse1_hi_pitch_macro_release
002478 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002479 f019                      	breq sound_driver_channel0_release_duty
00247a 95b3                      	inc r27
00247b 93b0 2840                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
00247d 91b0 2847                 	lds r27, pulse1_duty_macro_release
00247f 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002480 f019                      	breq sound_driver_channel0_release_exit
002481 95b3                      	inc r27
002482 93b0 2845                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
002484 d026                      	rcall sound_driver_channel0_increment_offset
002485 cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
002486 91e0 2819                 	lds ZL, song_frames
002488 91f0 281a                 	lds ZH, song_frames+1
00248a 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00248c 91b0 281c                 	lds r27, song_frame_offset+1
00248e 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
00248f 93a0 281b                 	sts song_frame_offset, r26
002491 93b0 281c                 	sts song_frame_offset+1, r27
                                 
002493 91c0 281d                 	lds r28, song_size
002495 91d0 281e                 	lds r29, song_size+1
002497 17ac                      	cp r26, r28
002498 07bd                      	cpc r27, r29
002499 f010                      	brlo sound_driver_channel0_next_pattern_exists
00249a 940c 3a52                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
00249c 0fea                      	add ZL, r26
00249d 1ffb                      	adc ZH, r27
                                 
00249e 91a5                      	lpm r26, Z+ //load the address of the next pattern
00249f 91b4                      	lpm r27, Z
0024a0 0faa                      	lsl r26
0024a1 1fbb                      	rol r27
0024a2 93a0 2825                 	sts pulse1_pattern, r26
0024a4 93b0 2826                 	sts pulse1_pattern+1, r27
                                 
0024a6 9220 2829                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0024a8 9220 282a                 	sts pulse1_pattern_offset+1, zero
0024aa cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
0024ab 91e0 2829                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0024ad 91f0 282a                 	lds ZH, pulse1_pattern_offset+1
0024af 9631                      	adiw Z, 1
0024b0 93e0 2829                 	sts pulse1_pattern_offset, ZL
0024b2 93f0 282a                 	sts pulse1_pattern_offset+1, ZH
0024b4 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0024b5 91e0 2829                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0024b7 91f0 282a                 	lds ZH, pulse1_pattern_offset+1
0024b9 9632                      	adiw Z, 2 //increment the pointer twice
0024ba 93e0 2829                 	sts pulse1_pattern_offset, ZL
0024bc 93f0 282a                 	sts pulse1_pattern_offset+1, ZH
0024be 9508                      	ret
                                 
                                 sound_driver_channel0_end:
                                 sound_driver_channel0_check_Sxx_invalid:
0024bf efbf                      	ldi r27, 0xFF
0024c0 91a0 2875                 	lds r26, pulse1_fx_Sxx_post
0024c2 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
0024c3 f419                      	brne sound_driver_channel0_check_Gxx_invalid
0024c4 93b0 2875                 	sts pulse1_fx_Sxx_post, r27
0024c6 9508                      	ret
                                 sound_driver_channel0_check_Gxx_invalid:
0024c7 91a0 2863                 	lds r26, pulse1_fx_Gxx_post
0024c9 15a2                      	cp r26, zero
0024ca f419                      	brne sound_driver_channel1
0024cb 93b0 2863                 	sts pulse1_fx_Gxx_post, r27
0024cd 9508                      	ret
                                 
                                 
                                 sound_driver_channel1:
0024ce 91a0 2878                 	lds r26, pulse2_pattern_delay_rows
0024d0 91b0 2879                 	lds r27, pulse2_pattern_delay_frames
                                 sound_driver_channel1_decrement_frame_delay:
0024d2 95ba                      	dec r27
0024d3 93b0 2879                 	sts pulse2_pattern_delay_frames, r27
                                 
0024d5 9610                      	adiw r27:r26, 0
0024d6 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
0024d7 c2d7                      	rjmp sound_driver_channel1_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel1_main:
0024d8 91e0 2876                 	lds ZL, pulse2_pattern //current pattern for pulse 2
0024da 91f0 2877                 	lds ZH, pulse2_pattern+1
0024dc 91a0 287a                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
0024de 91b0 287b                 	lds r27, pulse2_pattern_offset+1
0024e0 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0024e1 1ffb                      	adc ZH, r27
0024e2 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
0024e3 35b7                      	cpi r27, 0x57
0024e4 f408                      	brsh sound_driver_channel1_check_if_volume
0024e5 c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
0024e6 36b7                      	cpi r27, 0x67
0024e7 f408                      	brsh sound_driver_channel1_check_if_delay
0024e8 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0024e9 3eb3                      	cpi r27, 0xE3
0024ea f408                      	brsh sound_driver_channel1_check_if_instrument
0024eb c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
0024ec f409                      	brne sound_driver_channel1_check_if_release
0024ed c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
0024ee 3eb4                      	cpi r27, 0xE4
0024ef f409                      	brne sound_driver_channel1_check_if_end
0024f0 c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
0024f1 3fbf                      	cpi r27, 0xFF
0024f2 f409                      	brne sound_driver_channel1_check_if_fx
0024f3 c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
0024f4 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0024f5 91a4                      	lpm r26, Z //load the fx data into r26
0024f6 d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
0024f7 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0024f8 e0e8                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
0024f9 e7f5                      	ldi ZH, HIGH(channel1_fx << 1)
0024fa 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0024fb 0feb                      	add ZL, r27 //add offset
0024fc 1df2                      	adc ZH, zero
0024fd 91c5                      	lpm r28, Z+ //load address bytes
0024fe 91d4                      	lpm r29, Z
0024ff 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002500 2ffd                      	mov ZH, r29
002501 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
002502 93a0 2899                 	sts pulse2_fx_0xy_sequence, r26
002504 9220 289a                 	sts pulse2_fx_0xy_sequence+1, zero
002506 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
002507 9220 289f                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
002509 9220 28a0                 	sts pulse2_fx_2xx+1, zero
00250b 9220 2899                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
00250d 9220 289a                 	sts pulse2_fx_0xy_sequence+1, zero
00250f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002510 937f                      	push r23
002511 2f6a                      	mov r22, r26 //store the rate into r22
002512 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002513 9f67                      	mul r22, r23
002514 917f                      	pop r23
002515 916f                      	pop r22
                                 
002516 9416                      	lsr r1 //shift out the fractional bits
002517 9407                      	ror r0
002518 9416                      	lsr r1
002519 9407                      	ror r0
00251a 9416                      	lsr r1
00251b 9407                      	ror r0
00251c 9416                      	lsr r1
00251d 9407                      	ror r0
00251e 9200 289b                 	sts pulse2_fx_1xx, r0
002520 9210 289c                 	sts pulse2_fx_1xx+1, r1
002522 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
002523 9220 289b                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
002525 9220 289c                 	sts pulse2_fx_1xx+1, zero
002527 9220 2899                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
002529 9220 289a                 	sts pulse2_fx_0xy_sequence+1, zero
00252b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00252c 937f                      	push r23
00252d 2f6a                      	mov r22, r26 //store the rate into r22
00252e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00252f 9f67                      	mul r22, r23
002530 917f                      	pop r23
002531 916f                      	pop r22
                                 
002532 9416                      	lsr r1 //shift out the fractional bits
002533 9407                      	ror r0
002534 9416                      	lsr r1
002535 9407                      	ror r0
002536 9416                      	lsr r1
002537 9407                      	ror r0
002538 9416                      	lsr r1
002539 9407                      	ror r0
00253a 9200 289f                 	sts pulse2_fx_2xx, r0
00253c 9210 28a0                 	sts pulse2_fx_2xx+1, r1
00253e cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
00253f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002540 937f                      	push r23
002541 2f6a                      	mov r22, r26 //store the rate into r22
002542 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002543 9f67                      	mul r22, r23
002544 917f                      	pop r23
002545 916f                      	pop r22
                                 
002546 9416                      	lsr r1 //shift out the fractional bits
002547 9407                      	ror r0
002548 9416                      	lsr r1
002549 9407                      	ror r0
00254a 9416                      	lsr r1
00254b 9407                      	ror r0
00254c 9416                      	lsr r1
00254d 9407                      	ror r0
00254e 9200 28a7                 	sts pulse2_fx_3xx_speed, r0
002550 9210 28a8                 	sts pulse2_fx_3xx_speed+1, r1
                                 
002552 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
002553 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
002554 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
002555 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002557 91b0 0a9d                 	lds r27, TCB1_CCMPH
002559 93a0 28a3                 	sts pulse2_fx_3xx_start, r26
00255b 93b0 28a4                 	sts pulse2_fx_3xx_start+1, r27
                                 
00255d 9220 28a9                 	sts pulse2_fx_3xx_total_offset, zero
00255f 9220 28aa                 	sts pulse2_fx_3xx_total_offset+1, zero
002561 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
002562 2fba                      	mov r27, r26
002563 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002564 95a2                      	swap r26
002565 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002566 93a0 28ab                 	sts pulse2_fx_4xy_speed, r26
002568 93b0 28ac                 	sts pulse2_fx_4xy_depth, r27
00256a 9220 28ad                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
00256c cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
00256d 2fba                      	mov r27, r26
00256e 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00256f 95a2                      	swap r26
002570 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002571 93a0 28ae                 	sts pulse2_fx_7xy_speed, r26
002573 93b0 28af                 	sts pulse2_fx_7xy_depth, r27
002575 9220 28b0                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
002577 9220 28b1                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
002579 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
00257a 93a0 28b2                 	sts pulse2_fx_Axy, r26
00257c cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
00257d 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00257f cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
002580 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002582 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
002583 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002585 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
002586 91b0 2808                 	lds r27, pulse2_param
002588 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
002589 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
00258a 93b0 2808                 	sts pulse2_param, r27
00258c 6092                      	sbr pulse_channel_flags, 2
00258d cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
00258e 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002590 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
002591 15a2                      	cp r26, zero
002592 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
002593 91b0 2821                 	lds r27, song_speed
002595 17ab                      	cp r26, r27
002596 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
002597 93a0 28b3                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002599 e0b1                      	ldi r27, 0x01
00259a 93b0 2878                 	sts pulse2_pattern_delay_rows, r27
00259c c221                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
00259d cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
00259e cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
00259f cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
0025a0 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
0025a1 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
0025a2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025a3 937f                      	push r23
0025a4 2f6a                      	mov r22, r26
0025a5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025a6 0367                      	mulsu r22, r23
0025a7 917f                      	pop r23
0025a8 916f                      	pop r22
0025a9 9416                      	lsr r1 //shift out the fractional bits
0025aa 9407                      	ror r0
0025ab 9416                      	lsr r1
0025ac 9407                      	ror r0
0025ad 9416                      	lsr r1
0025ae 9407                      	ror r0
0025af 9416                      	lsr r1
0025b0 9407                      	ror r0
0025b1 fe13                      	sbrs r1, 3 //check if result was a negative number
0025b2 c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
0025b3 efb0                      	ldi r27, 0xF0
0025b4 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
0025b5 9200 28b5                 	sts pulse2_fx_Pxx_total, r0
0025b7 9210 28b6                 	sts pulse2_fx_Pxx_total+1, r1
0025b9 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
0025ba 91e0 2881                 	lds ZL, pulse2_arpeggio_macro
0025bc 91f0 2882                 	lds ZH, pulse2_arpeggio_macro+1
0025be 9630                      	adiw Z, 0
0025bf f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
0025c0 cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
0025c1 91e0 2889                 	lds ZL, pulse2_pitch_macro
0025c3 91f0 288a                 	lds ZH, pulse2_pitch_macro+1
0025c5 9630                      	adiw Z, 0
0025c6 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
0025c7 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
0025c8 91e0 288f                 	lds ZL, pulse2_hi_pitch_macro
0025ca 91f0 2890                 	lds ZH, pulse2_hi_pitch_macro+1
0025cc 9630                      	adiw Z, 0
0025cd f009                      	breq sound_driver_channel1_fx_Qxy_process
0025ce cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
0025cf 2fba                      	mov r27, r26 //copy fx parameters into r27
0025d0 70bf                      	andi r27, 0x0F //mask note index offset
0025d1 91c0 28b7                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
0025d3 0fbc                      	add r27, r28
0025d4 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0025d5 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
0025d6 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
0025d7 93b0 28b7                 	sts pulse2_fx_Qxy_target_note, r27
0025d9 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0025da e0f0                      	ldi ZH, HIGH(note_table << 1)
0025db 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0025dc 0feb                      	add ZL, r27 //add offset
0025dd 1df2                      	adc ZH, zero
0025de 91c5                      	lpm r28, Z+ //load bytes
0025df 91d4                      	lpm r29, Z
0025e0 93c0 28b8                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
0025e2 93d0 28b9                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
0025e4 95a2                      	swap r26
0025e5 70af                      	andi r26, 0x0F //mask effect speed
0025e6 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0025e7 95a3                      	inc r26 //increment the speed by 1
                                 
0025e8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025e9 937f                      	push r23
0025ea 2f6a                      	mov r22, r26 //store the speed data into r27
0025eb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025ec 9f67                      	mul r22, r23
0025ed 917f                      	pop r23
0025ee 916f                      	pop r22
                                 
0025ef 9416                      	lsr r1 //shift out the fractional bits
0025f0 9407                      	ror r0
0025f1 9416                      	lsr r1
0025f2 9407                      	ror r0
0025f3 9416                      	lsr r1
0025f4 9407                      	ror r0
0025f5 9416                      	lsr r1
0025f6 9407                      	ror r0
                                 
0025f7 9200 28ba                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
0025f9 9210 28bb                 	sts pulse2_fx_Qxy_speed+1, r1
0025fb cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
0025fc 91e0 2881                 	lds ZL, pulse2_arpeggio_macro
0025fe 91f0 2882                 	lds ZH, pulse2_arpeggio_macro+1
002600 9630                      	adiw Z, 0
002601 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
002602 ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
002603 91e0 2889                 	lds ZL, pulse2_pitch_macro
002605 91f0 288a                 	lds ZH, pulse2_pitch_macro+1
002607 9630                      	adiw Z, 0
002608 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
002609 cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
00260a 91e0 288f                 	lds ZL, pulse2_hi_pitch_macro
00260c 91f0 2890                 	lds ZH, pulse2_hi_pitch_macro+1
00260e 9630                      	adiw Z, 0
00260f f009                      	breq sound_driver_channel1_fx_Rxy_process
002610 cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
002611 2fba                      	mov r27, r26 //copy fx parameters into r27
002612 70bf                      	andi r27, 0x0F //mask note index offset
002613 91c0 28be                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
002615 1bcb                      	sub r28, r27
002616 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
002617 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
002618 93c0 28be                 	sts pulse2_fx_Rxy_target_note, r28
00261a e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00261b e0f0                      	ldi ZH, HIGH(note_table << 1)
00261c 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00261d 0fec                      	add ZL, r28 //add offset
00261e 1df2                      	adc ZH, zero
00261f 91c5                      	lpm r28, Z+ //load bytes
002620 91d4                      	lpm r29, Z
002621 93c0 28bf                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
002623 93d0 28c0                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
002625 95a2                      	swap r26
002626 70af                      	andi r26, 0x0F //mask effect speed
002627 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
002628 95a3                      	inc r26 //increment the speed by 1
                                 
002629 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00262a 937f                      	push r23
00262b 2f6a                      	mov r22, r26 //store the speed data into r27
00262c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00262d 9f67                      	mul r22, r23
00262e 917f                      	pop r23
00262f 916f                      	pop r22
                                 
002630 9416                      	lsr r1 //shift out the fractional bits
002631 9407                      	ror r0
002632 9416                      	lsr r1
002633 9407                      	ror r0
002634 9416                      	lsr r1
002635 9407                      	ror r0
002636 9416                      	lsr r1
002637 9407                      	ror r0
                                 
002638 9200 28c1                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
00263a 9210 28c2                 	sts pulse2_fx_Rxy_speed+1, r1
00263c ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
00263d 15a2                      	cp r26, zero
00263e f051                      	breq sound_driver_channel1_fx_Sxx_invalid
00263f 91b0 2821                 	lds r27, song_speed
002641 17ab                      	cp r26, r27
002642 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
002643 93a0 28c5                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002645 e0b1                      	ldi r27, 0x01
002646 93b0 2878                 	sts pulse2_pattern_delay_rows, r27
002648 c175                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
002649 ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
00264a ede0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00264b e7f4                      	ldi ZH, HIGH(sequences << 1)
00264c 0fea                      	add ZL, r26 //offset the pointer
00264d 1df2                      	adc ZH, zero
                                 
00264e 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
00264f 95a7                      	ror r26
002650 95a7                      	ror r26
002651 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
002653 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
002654 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
002655 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
002656 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
002657 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
002658 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002659 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00265a 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00265b 93c0 2808                 	sts pulse2_param, r28
00265d ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
00265e ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
00265f ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
002660 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
002661 ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
002662 93b0 280f                 	sts pulse2_note, r27 //store the note index
002664 93b0 28b7                 	sts pulse2_fx_Qxy_target_note, r27
002666 93b0 28be                 	sts pulse2_fx_Rxy_target_note, r27
002668 e0a3                      	ldi r26, 0x03
002669 e0b2                      	ldi r27, 0x02
00266a 93b0 287e                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
00266c 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26
00266e 93b0 288b                 	sts pulse2_pitch_macro_offset, r27
002670 93b0 2891                 	sts pulse2_hi_pitch_macro_offset, r27
002672 93b0 2896                 	sts pulse2_duty_macro_offset, r27
002674 9220 2887                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
002676 9220 2888                 	sts pulse2_total_pitch_offset+1, zero
002678 9220 288e                 	sts pulse2_total_hi_pitch_offset, zero
00267a 9220 289d                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00267c 9220 289e                 	sts pulse2_fx_1xx_total+1, zero
00267e 9220 28a1                 	sts pulse2_fx_2xx_total, zero
002680 9220 28a2                 	sts pulse2_fx_2xx_total+1, zero
002682 9220 28a9                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
002684 9220 28aa                 	sts pulse2_fx_3xx_total_offset+1, zero
002686 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002688 91b0 0a9d                 	lds r27, TCB1_CCMPH
00268a 93a0 28a3                 	sts pulse2_fx_3xx_start, r26
00268c 93b0 28a4                 	sts pulse2_fx_3xx_start+1, r27
00268e 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
002690 6093                      	sbr pulse_channel_flags, 3 //set reload flag
002691 9220 28b8                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002693 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
002695 9220 28bc                 	sts pulse2_fx_Qxy_total_offset, zero
002697 9220 28bd                 	sts pulse2_fx_Qxy_total_offset+1, zero
002699 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
00269b 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
00269d 9220 28c3                 	sts pulse2_fx_Rxy_total_offset, zero
00269f 9220 28c4                 	sts pulse2_fx_Rxy_total_offset+1, zero
0026a1 d0f9                      	rcall sound_driver_channel1_increment_offset
0026a2 ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
0026a3 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
0026a4 91a0 2808                 	lds r26, pulse2_param
0026a6 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0026a7 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
0026a8 93a0 2808                 	sts pulse2_param, r26
0026aa 6092                      	sbr pulse_channel_flags, 2
0026ab d0ef                      	rcall sound_driver_channel1_increment_offset
0026ac ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
0026ad 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0026ae 93b0 2878                 	sts pulse2_pattern_delay_rows, r27
0026b0 d0ea                      	rcall sound_driver_channel1_increment_offset
0026b1 c0fd                      	rjmp sound_driver_channel1_end
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
0026b2 9220 287c                 	sts pulse2_volume_macro, zero //reset all macro addresses
0026b4 9220 287d                 	sts pulse2_volume_macro+1, zero
0026b6 9220 2881                 	sts pulse2_arpeggio_macro, zero
0026b8 9220 2882                 	sts pulse2_arpeggio_macro+1, zero
0026ba 9220 2889                 	sts pulse2_pitch_macro, zero
0026bc 9220 288a                 	sts pulse2_pitch_macro+1, zero
0026be 9220 288f                 	sts pulse2_hi_pitch_macro, zero
0026c0 9220 2890                 	sts pulse2_hi_pitch_macro+1, zero
0026c2 9220 2894                 	sts pulse2_duty_macro, zero
0026c4 9220 2895                 	sts pulse2_duty_macro+1, zero
0026c6 9220 2887                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
0026c8 9220 2888                 	sts pulse2_total_pitch_offset+1, zero
0026ca 9220 288e                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0026cc 9631                      	adiw Z, 1 //point to the byte next to the flag
0026cd 91b4                      	lpm r27, Z //store the instrument offset into r27
0026ce edec                      	ldi ZL, LOW(instruments) //point Z to instruments table
0026cf e1fa                      	ldi ZH, HIGH(instruments)
0026d0 0feb                      	add ZL, r27 //point Z to offsetted instrument
0026d1 1df2                      	adc ZH, zero
0026d2 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0026d3 1fff                      	rol ZH
0026d4 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0026d5 91b4                      	lpm r27, Z
                                 
0026d6 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0026d7 1fbb                      	rol r27
0026d8 2fea                      	mov ZL, r26
0026d9 2ffb                      	mov ZH, r27
0026da 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0026db 9632                      	adiw Z, 2 //point Z to the address of the macro
0026dc e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
0026dd 95aa                      	dec r26
0026de f019                      	breq sound_driver_channel1_instrument_change_exit
0026df 95b6                      	lsr r27
0026e0 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
0026e1 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
0026e2 e0a3                      	ldi r26, 0x03
0026e3 e0b2                      	ldi r27, 0x02
0026e4 93b0 287e                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
0026e6 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26
0026e8 93b0 288b                 	sts pulse2_pitch_macro_offset, r27
0026ea 93b0 2891                 	sts pulse2_hi_pitch_macro_offset, r27
0026ec 93b0 2896                 	sts pulse2_duty_macro_offset, r27
0026ee d0b6                      	rcall sound_driver_channel1_increment_offset_twice
0026ef cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
0026f0 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0026f1 91d5                      	lpm r29, Z+
                                 
0026f2 30a5                      	cpi r26, 5
0026f3 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
0026f4 30a4                      	cpi r26, 4
0026f5 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
0026f6 30a3                      	cpi r26, 3
0026f7 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
0026f8 30a2                      	cpi r26, 2
0026f9 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
0026fa c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
0026fb 93c0 287c                 	sts pulse2_volume_macro, r28
0026fd 93d0 287d                 	sts pulse2_volume_macro+1, r29
0026ff d041                      	rcall sound_driver_channel1_instrument_change_read_header
002700 93c0 2880                 	sts pulse2_volume_macro_release, r28
002702 93d0 287f                 	sts pulse2_volume_macro_loop, r29
002704 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
002705 93c0 2881                 	sts pulse2_arpeggio_macro, r28
002707 93d0 2882                 	sts pulse2_arpeggio_macro+1, r29
002709 9220 28b8                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00270b 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
00270d 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
00270f 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
002711 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
002712 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
002713 93c0 2889                 	sts pulse2_pitch_macro, r28
002715 93d0 288a                 	sts pulse2_pitch_macro+1, r29
002717 9220 28b8                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002719 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
00271b 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
00271d 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
00271f d021                      	rcall sound_driver_channel1_instrument_change_read_header
002720 93c0 288d                 	sts pulse2_pitch_macro_release, r28
002722 93d0 288c                 	sts pulse2_pitch_macro_loop, r29
002724 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
002725 93c0 288f                 	sts pulse2_hi_pitch_macro, r28
002727 93d0 2890                 	sts pulse2_hi_pitch_macro+1, r29
002729 9220 28b8                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00272b 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
00272d 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
00272f 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
002731 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
002732 93c0 2893                 	sts pulse2_hi_pitch_macro_release, r28
002734 93d0 2892                 	sts pulse2_hi_pitch_macro_loop, r29
002736 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
002737 93c0 2894                 	sts pulse2_duty_macro, r28
002739 93d0 2895                 	sts pulse2_duty_macro+1, r29
00273b d005                      	rcall sound_driver_channel1_instrument_change_read_header
00273c 93c0 2898                 	sts pulse2_duty_macro_release, r28
00273e 93d0 2897                 	sts pulse2_duty_macro_loop, r29
002740 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
002741 93ef                      	push ZL
002742 93ff                      	push ZH
002743 2fec                      	mov ZL, r28
002744 2ffd                      	mov ZH, r29
002745 0fee                      	lsl ZL
002746 1fff                      	rol ZH
002747 91c5                      	lpm r28, Z+
002748 91d4                      	lpm r29, Z
002749 91ff                      	pop ZH
00274a 91ef                      	pop ZL
00274b 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
00274c 93ef                      	push ZL
00274d 93ff                      	push ZH
00274e 2fec                      	mov ZL, r28
00274f 2ffd                      	mov ZH, r29
002750 0fee                      	lsl ZL
002751 1fff                      	rol ZH
002752 91c5                      	lpm r28, Z+
002753 91d5                      	lpm r29, Z+
002754 93c0 2885                 	sts pulse2_arpeggio_macro_release, r28
002756 93d0 2884                 	sts pulse2_arpeggio_macro_loop, r29
002758 91c4                      	lpm r28, Z
002759 93c0 2886                 	sts pulse2_arpeggio_macro_mode, r28
00275b 91ff                      	pop ZH
00275c 91ef                      	pop ZL
00275d 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
00275e 91b0 2880                 	lds r27, pulse2_volume_macro_release
002760 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002761 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
002762 95b3                      	inc r27
002763 93b0 287e                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
002765 91b0 2885                 	lds r27, pulse2_arpeggio_macro_release
002767 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002768 f019                      	breq sound_driver_channel1_release_pitch
002769 95b3                      	inc r27
00276a 93b0 2883                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
00276c 91b0 288d                 	lds r27, pulse2_pitch_macro_release
00276e 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00276f f019                      	breq sound_driver_channel1_release_hi_pitch
002770 95b3                      	inc r27
002771 93b0 288b                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
002773 91b0 2893                 	lds r27, pulse2_hi_pitch_macro_release
002775 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002776 f019                      	breq sound_driver_channel1_release_duty
002777 95b3                      	inc r27
002778 93b0 2891                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
00277a 91b0 2898                 	lds r27, pulse2_duty_macro_release
00277c 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00277d f019                      	breq sound_driver_channel1_release_exit
00277e 95b3                      	inc r27
00277f 93b0 2896                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
002781 d019                      	rcall sound_driver_channel1_increment_offset
002782 cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
002783 91e0 2819                 	lds ZL, song_frames
002785 91f0 281a                 	lds ZH, song_frames+1
002787 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002789 91b0 281c                 	lds r27, song_frame_offset+1
00278b 9612                      	adiw r27:r26, 2 //offset for channel 1
00278c 0fea                      	add ZL, r26
00278d 1ffb                      	adc ZH, r27
                                 
00278e 91a5                      	lpm r26, Z+ //load the address of the next pattern
00278f 91b4                      	lpm r27, Z
002790 0faa                      	lsl r26
002791 1fbb                      	rol r27
002792 93a0 2876                 	sts pulse2_pattern, r26
002794 93b0 2877                 	sts pulse2_pattern+1, r27
                                 
002796 9220 287a                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002798 9220 287b                 	sts pulse2_pattern_offset+1, zero
00279a cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
00279b 91e0 287a                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
00279d 91f0 287b                 	lds ZH, pulse2_pattern_offset+1
00279f 9631                      	adiw Z, 1
0027a0 93e0 287a                 	sts pulse2_pattern_offset, ZL
0027a2 93f0 287b                 	sts pulse2_pattern_offset+1, ZH
0027a4 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0027a5 91e0 287a                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
0027a7 91f0 287b                 	lds ZH, pulse2_pattern_offset+1
0027a9 9632                      	adiw Z, 2 //increment the pointer twice
0027aa 93e0 287a                 	sts pulse2_pattern_offset, ZL
0027ac 93f0 287b                 	sts pulse2_pattern_offset+1, ZH
0027ae 9508                      	ret
                                 
                                 sound_driver_channel1_end:
                                 sound_driver_channel1_check_Sxx_invalid:
0027af efbf                      	ldi r27, 0xFF
0027b0 91a0 28c6                 	lds r26, pulse2_fx_Sxx_post
0027b2 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
0027b3 f419                      	brne sound_driver_channel1_check_Gxx_invalid
0027b4 93b0 28c6                 	sts pulse2_fx_Sxx_post, r27
0027b6 9508                      	ret
                                 sound_driver_channel1_check_Gxx_invalid:
0027b7 91a0 28b4                 	lds r26, pulse2_fx_Gxx_post
0027b9 15a2                      	cp r26, zero
0027ba f419                      	brne sound_driver_channel2
0027bb 93b0 28b4                 	sts pulse2_fx_Gxx_post, r27
0027bd 9508                      	ret
                                 
                                 
                                 sound_driver_channel2:
0027be 91a0 28c9                 	lds r26, triangle_pattern_delay_rows
0027c0 91b0 28ca                 	lds r27, triangle_pattern_delay_frames
                                 sound_driver_channel2_decrement_frame_delay:
0027c2 95ba                      	dec r27
0027c3 93b0 28ca                 	sts triangle_pattern_delay_frames, r27
                                 
0027c5 9610                      	adiw r27:r26, 0
0027c6 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
0027c7 c2bf                      	rjmp sound_driver_channel2_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel2_main:
0027c8 91e0 28c7                 	lds ZL, triangle_pattern //current pattern for triangle
0027ca 91f0 28c8                 	lds ZH, triangle_pattern+1
0027cc 91a0 28cb                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
0027ce 91b0 28cc                 	lds r27, triangle_pattern_offset+1
0027d0 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0027d1 1ffb                      	adc ZH, r27
0027d2 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
0027d3 35b7                      	cpi r27, 0x57
0027d4 f408                      	brsh sound_driver_channel2_check_if_volume
0027d5 c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
0027d6 36b7                      	cpi r27, 0x67
0027d7 f408                      	brsh sound_driver_channel2_check_if_delay
0027d8 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0027d9 3eb3                      	cpi r27, 0xE3
0027da f408                      	brsh sound_driver_channel2_check_if_instrument
0027db c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
0027dc f409                      	brne sound_driver_channel2_check_if_release
0027dd c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
0027de 3eb4                      	cpi r27, 0xE4
0027df f409                      	brne sound_driver_channel2_check_if_end
0027e0 c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
0027e1 3fbf                      	cpi r27, 0xFF
0027e2 f409                      	brne sound_driver_channel2_check_if_fx
0027e3 c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
0027e4 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0027e5 91a4                      	lpm r26, Z //load the fx data into r26
0027e6 d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
0027e7 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0027e8 e3ec                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
0027e9 e7f5                      	ldi ZH, HIGH(channel2_fx << 1)
0027ea 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0027eb 0feb                      	add ZL, r27 //add offset
0027ec 1df2                      	adc ZH, zero
0027ed 91c5                      	lpm r28, Z+ //load address bytes
0027ee 91d4                      	lpm r29, Z
0027ef 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0027f0 2ffd                      	mov ZH, r29
0027f1 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
0027f2 93a0 28ea                 	sts triangle_fx_0xy_sequence, r26
0027f4 9220 28eb                 	sts triangle_fx_0xy_sequence+1, zero
0027f6 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
0027f7 9220 28f0                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
0027f9 9220 28f1                 	sts triangle_fx_2xx+1, zero
0027fb 9220 28ea                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
0027fd 9220 28eb                 	sts triangle_fx_0xy_sequence+1, zero
0027ff 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002800 937f                      	push r23
002801 2f6a                      	mov r22, r26 //store the rate into r22
002802 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002803 9f67                      	mul r22, r23
002804 917f                      	pop r23
002805 916f                      	pop r22
                                 
002806 9416                      	lsr r1 //shift out the fractional bits
002807 9407                      	ror r0
002808 9416                      	lsr r1
002809 9407                      	ror r0
00280a 9416                      	lsr r1
00280b 9407                      	ror r0
00280c 9416                      	lsr r1
00280d 9407                      	ror r0
00280e 9200 28ec                 	sts triangle_fx_1xx, r0
002810 9210 28ed                 	sts triangle_fx_1xx+1, r1
002812 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
002813 9220 28ec                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
002815 9220 28ed                 	sts triangle_fx_1xx+1, zero
002817 9220 28ea                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
002819 9220 28eb                 	sts triangle_fx_0xy_sequence+1, zero
00281b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00281c 937f                      	push r23
00281d 2f6a                      	mov r22, r26 //store the rate into r22
00281e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00281f 9f67                      	mul r22, r23
002820 917f                      	pop r23
002821 916f                      	pop r22
                                 
002822 9416                      	lsr r1 //shift out the fractional bits
002823 9407                      	ror r0
002824 9416                      	lsr r1
002825 9407                      	ror r0
002826 9416                      	lsr r1
002827 9407                      	ror r0
002828 9416                      	lsr r1
002829 9407                      	ror r0
00282a 9200 28f0                 	sts triangle_fx_2xx, r0
00282c 9210 28f1                 	sts triangle_fx_2xx+1, r1
00282e cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
00282f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002830 937f                      	push r23
002831 2f6a                      	mov r22, r26 //store the rate into r22
002832 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002833 9f67                      	mul r22, r23
002834 917f                      	pop r23
002835 916f                      	pop r22
                                 
002836 9416                      	lsr r1 //shift out the fractional bits
002837 9407                      	ror r0
002838 9416                      	lsr r1
002839 9407                      	ror r0
00283a 9416                      	lsr r1
00283b 9407                      	ror r0
00283c 9416                      	lsr r1
00283d 9407                      	ror r0
00283e 9200 28f8                 	sts triangle_fx_3xx_speed, r0
002840 9210 28f9                 	sts triangle_fx_3xx_speed+1, r1
                                 
002842 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
002843 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
002844 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
002845 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002847 91b0 0aad                 	lds r27, TCB2_CCMPH
002849 93a0 28f4                 	sts triangle_fx_3xx_start, r26
00284b 93b0 28f5                 	sts triangle_fx_3xx_start+1, r27
                                 
00284d 9220 28fa                 	sts triangle_fx_3xx_total_offset, zero
00284f 9220 28fb                 	sts triangle_fx_3xx_total_offset+1, zero
002851 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
002852 2fba                      	mov r27, r26
002853 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002854 95a2                      	swap r26
002855 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002856 93a0 28fc                 	sts triangle_fx_4xy_speed, r26
002858 93b0 28fd                 	sts triangle_fx_4xy_depth, r27
00285a 9220 28fe                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
00285c cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
00285d cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
00285e cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
00285f 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002861 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
002862 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002864 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
002865 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002867 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
002868 15a2                      	cp r26, zero
002869 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
00286a e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00286b 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00286d cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
00286e 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
002870 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002872 9220 0aad                 	sts TCB2_CCMPH, zero
002874 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
002875 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002877 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
002878 15a2                      	cp r26, zero
002879 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
00287a 91b0 2821                 	lds r27, song_speed
00287c 17ab                      	cp r26, r27
00287d f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
00287e 93a0 28ff                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002880 e0b1                      	ldi r27, 0x01
002881 93b0 28c9                 	sts triangle_pattern_delay_rows, r27
002883 c212                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
002884 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
002885 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
002886 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
002887 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
002888 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
002889 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00288a 937f                      	push r23
00288b 2f6a                      	mov r22, r26
00288c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00288d 0367                      	mulsu r22, r23
00288e 917f                      	pop r23
00288f 916f                      	pop r22
002890 9416                      	lsr r1 //shift out the fractional bits
002891 9407                      	ror r0
002892 9416                      	lsr r1
002893 9407                      	ror r0
002894 9416                      	lsr r1
002895 9407                      	ror r0
002896 9416                      	lsr r1
002897 9407                      	ror r0
002898 fe13                      	sbrs r1, 3 //check if result was a negative number
002899 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
00289a efb0                      	ldi r27, 0xF0
00289b 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
00289c 9200 2901                 	sts triangle_fx_Pxx_total, r0
00289e 9210 2902                 	sts triangle_fx_Pxx_total+1, r1
0028a0 cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
0028a1 91e0 28d2                 	lds ZL, triangle_arpeggio_macro
0028a3 91f0 28d3                 	lds ZH, triangle_arpeggio_macro+1
0028a5 9630                      	adiw Z, 0
0028a6 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
0028a7 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
0028a8 91e0 28da                 	lds ZL, triangle_pitch_macro
0028aa 91f0 28db                 	lds ZH, triangle_pitch_macro+1
0028ac 9630                      	adiw Z, 0
0028ad f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
0028ae cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
0028af 91e0 28e0                 	lds ZL, triangle_hi_pitch_macro
0028b1 91f0 28e1                 	lds ZH, triangle_hi_pitch_macro+1
0028b3 9630                      	adiw Z, 0
0028b4 f009                      	breq sound_driver_channel2_fx_Qxy_process
0028b5 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
0028b6 2fba                      	mov r27, r26 //copy fx parameters into r27
0028b7 70bf                      	andi r27, 0x0F //mask note index offset
0028b8 91c0 2903                 	lds r28, triangle_fx_Qxy_target_note //load current note index
0028ba 0fbc                      	add r27, r28
0028bb 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0028bc f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
0028bd e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
0028be 93b0 2903                 	sts triangle_fx_Qxy_target_note, r27
0028c0 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0028c1 e0f0                      	ldi ZH, HIGH(note_table << 1)
0028c2 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0028c3 0feb                      	add ZL, r27 //add offset
0028c4 1df2                      	adc ZH, zero
0028c5 91c5                      	lpm r28, Z+ //load bytes
0028c6 91d4                      	lpm r29, Z
0028c7 93c0 2904                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
0028c9 93d0 2905                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
0028cb 95a2                      	swap r26
0028cc 70af                      	andi r26, 0x0F //mask effect speed
0028cd 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0028ce 95a3                      	inc r26 //increment the speed by 1
                                 
0028cf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028d0 937f                      	push r23
0028d1 2f6a                      	mov r22, r26 //store the speed data into r27
0028d2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028d3 9f67                      	mul r22, r23
0028d4 917f                      	pop r23
0028d5 916f                      	pop r22
                                 
0028d6 9416                      	lsr r1 //shift out the fractional bits
0028d7 9407                      	ror r0
0028d8 9416                      	lsr r1
0028d9 9407                      	ror r0
0028da 9416                      	lsr r1
0028db 9407                      	ror r0
0028dc 9416                      	lsr r1
0028dd 9407                      	ror r0
                                 
0028de 9200 2906                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
0028e0 9210 2907                 	sts triangle_fx_Qxy_speed+1, r1
0028e2 cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
0028e3 91e0 28d2                 	lds ZL, triangle_arpeggio_macro
0028e5 91f0 28d3                 	lds ZH, triangle_arpeggio_macro+1
0028e7 9630                      	adiw Z, 0
0028e8 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
0028e9 cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
0028ea 91e0 28da                 	lds ZL, triangle_pitch_macro
0028ec 91f0 28db                 	lds ZH, triangle_pitch_macro+1
0028ee 9630                      	adiw Z, 0
0028ef f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
0028f0 ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
0028f1 91e0 28e0                 	lds ZL, triangle_hi_pitch_macro
0028f3 91f0 28e1                 	lds ZH, triangle_hi_pitch_macro+1
0028f5 9630                      	adiw Z, 0
0028f6 f009                      	breq sound_driver_channel2_fx_Rxy_process
0028f7 ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
0028f8 2fba                      	mov r27, r26 //copy fx parameters into r27
0028f9 70bf                      	andi r27, 0x0F //mask note index offset
0028fa 91c0 290a                 	lds r28, triangle_fx_Rxy_target_note //load current note index
0028fc 1bcb                      	sub r28, r27
0028fd f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
0028fe e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
0028ff 93c0 290a                 	sts triangle_fx_Rxy_target_note, r28
002901 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002902 e0f0                      	ldi ZH, HIGH(note_table << 1)
002903 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
002904 0fec                      	add ZL, r28 //add offset
002905 1df2                      	adc ZH, zero
002906 91c5                      	lpm r28, Z+ //load bytes
002907 91d4                      	lpm r29, Z
002908 93c0 290b                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
00290a 93d0 290c                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
00290c 95a2                      	swap r26
00290d 70af                      	andi r26, 0x0F //mask effect speed
00290e 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00290f 95a3                      	inc r26 //increment the speed by 1
                                 
002910 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002911 937f                      	push r23
002912 2f6a                      	mov r22, r26 //store the speed data into r27
002913 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002914 9f67                      	mul r22, r23
002915 917f                      	pop r23
002916 916f                      	pop r22
                                 
002917 9416                      	lsr r1 //shift out the fractional bits
002918 9407                      	ror r0
002919 9416                      	lsr r1
00291a 9407                      	ror r0
00291b 9416                      	lsr r1
00291c 9407                      	ror r0
00291d 9416                      	lsr r1
00291e 9407                      	ror r0
                                 
00291f 9200 290d                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
002921 9210 290e                 	sts triangle_fx_Rxy_speed+1, r1
002923 cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
002924 15a2                      	cp r26, zero
002925 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
002926 91b0 2821                 	lds r27, song_speed
002928 17ab                      	cp r26, r27
002929 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
00292a 93a0 2911                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00292c e0b1                      	ldi r27, 0x01
00292d 93b0 28c9                 	sts triangle_pattern_delay_rows, r27
00292f c166                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
002930 ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
002931 ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
002932 ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
002933 ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
002934 ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
002935 ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
002936 93b0 2812                 	sts triangle_note, r27 //store the note index
002938 93b0 2903                 	sts triangle_fx_Qxy_target_note, r27
00293a 93b0 290a                 	sts triangle_fx_Rxy_target_note, r27
00293c e0a3                      	ldi r26, 0x03
00293d e0b2                      	ldi r27, 0x02
00293e 93b0 28cf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
002940 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26
002942 93b0 28dc                 	sts triangle_pitch_macro_offset, r27
002944 93b0 28e2                 	sts triangle_hi_pitch_macro_offset, r27
002946 93b0 28e7                 	sts triangle_duty_macro_offset, r27
002948 9220 28d8                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
00294a 9220 28d9                 	sts triangle_total_pitch_offset+1, zero
00294c 9220 28df                 	sts triangle_total_hi_pitch_offset, zero
00294e 9220 28ee                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002950 9220 28ef                 	sts triangle_fx_1xx_total+1, zero
002952 9220 28f2                 	sts triangle_fx_2xx_total, zero
002954 9220 28f3                 	sts triangle_fx_2xx_total+1, zero
002956 9220 28fa                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
002958 9220 28fb                 	sts triangle_fx_3xx_total_offset+1, zero
00295a 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00295c 91b0 0aad                 	lds r27, TCB2_CCMPH
00295e 93a0 28f4                 	sts triangle_fx_3xx_start, r26
002960 93b0 28f5                 	sts triangle_fx_3xx_start+1, r27
002962 9220 2904                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002964 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
002966 9220 2908                 	sts triangle_fx_Qxy_total_offset, zero
002968 9220 2909                 	sts triangle_fx_Qxy_total_offset+1, zero
00296a 9220 290b                 	sts triangle_fx_Rxy_target, zero
00296c 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
00296e 9220 290f                 	sts triangle_fx_Rxy_total_offset, zero
002970 9220 2910                 	sts triangle_fx_Rxy_total_offset+1, zero
002972 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002973 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002975 d0fd                      	rcall sound_driver_channel2_increment_offset
002976 ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
002977 d0fb                      	rcall sound_driver_channel2_increment_offset
002978 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
002979 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
00297a e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00297b 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00297d ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
00297e 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
002980 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002982 9220 0aad                 	sts TCB2_CCMPH, zero
002984 ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
002985 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002986 93b0 28c9                 	sts triangle_pattern_delay_rows, r27
002988 d0ea                      	rcall sound_driver_channel2_increment_offset
002989 c0fd                      	rjmp sound_driver_channel2_end
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
00298a 9220 28cd                 	sts triangle_volume_macro, zero //reset all macro addresses
00298c 9220 28ce                 	sts triangle_volume_macro+1, zero
00298e 9220 28d2                 	sts triangle_arpeggio_macro, zero
002990 9220 28d3                 	sts triangle_arpeggio_macro+1, zero
002992 9220 28da                 	sts triangle_pitch_macro, zero
002994 9220 28db                 	sts triangle_pitch_macro+1, zero
002996 9220 28e0                 	sts triangle_hi_pitch_macro, zero
002998 9220 28e1                 	sts triangle_hi_pitch_macro+1, zero
00299a 9220 28e5                 	sts triangle_duty_macro, zero
00299c 9220 28e6                 	sts triangle_duty_macro+1, zero
00299e 9220 28d8                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
0029a0 9220 28d9                 	sts triangle_total_pitch_offset+1, zero
0029a2 9220 28df                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0029a4 9631                      	adiw Z, 1 //point to the byte next to the flag
0029a5 91b4                      	lpm r27, Z //store the instrument offset into r27
0029a6 edec                      	ldi ZL, LOW(instruments) //point Z to instruments table
0029a7 e1fa                      	ldi ZH, HIGH(instruments)
0029a8 0feb                      	add ZL, r27 //point Z to offsetted instrument
0029a9 1df2                      	adc ZH, zero
0029aa 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0029ab 1fff                      	rol ZH
0029ac 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0029ad 91b4                      	lpm r27, Z
                                 
0029ae 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0029af 1fbb                      	rol r27
0029b0 2fea                      	mov ZL, r26
0029b1 2ffb                      	mov ZH, r27
0029b2 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0029b3 9632                      	adiw Z, 2 //point Z to the address of the macro
0029b4 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
0029b5 95aa                      	dec r26
0029b6 f019                      	breq sound_driver_channel2_instrument_change_exit
0029b7 95b6                      	lsr r27
0029b8 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
0029b9 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
0029ba e0a3                      	ldi r26, 0x03
0029bb e0b2                      	ldi r27, 0x02
0029bc 93b0 28cf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
0029be 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26
0029c0 93b0 28dc                 	sts triangle_pitch_macro_offset, r27
0029c2 93b0 28e2                 	sts triangle_hi_pitch_macro_offset, r27
0029c4 93b0 28e7                 	sts triangle_duty_macro_offset, r27
0029c6 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
0029c7 ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
0029c8 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0029c9 91d5                      	lpm r29, Z+
                                 
0029ca 30a5                      	cpi r26, 5
0029cb f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
0029cc 30a4                      	cpi r26, 4
0029cd f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
0029ce 30a3                      	cpi r26, 3
0029cf f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
0029d0 30a2                      	cpi r26, 2
0029d1 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
0029d2 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
0029d3 93c0 28cd                 	sts triangle_volume_macro, r28
0029d5 93d0 28ce                 	sts triangle_volume_macro+1, r29
0029d7 d041                      	rcall sound_driver_channel2_instrument_change_read_header
0029d8 93c0 28d1                 	sts triangle_volume_macro_release, r28
0029da 93d0 28d0                 	sts triangle_volume_macro_loop, r29
0029dc cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
0029dd 93c0 28d2                 	sts triangle_arpeggio_macro, r28
0029df 93d0 28d3                 	sts triangle_arpeggio_macro+1, r29
0029e1 9220 2904                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0029e3 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
0029e5 9220 290b                 	sts triangle_fx_Rxy_target, zero
0029e7 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
0029e9 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
0029ea cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
0029eb 93c0 28da                 	sts triangle_pitch_macro, r28
0029ed 93d0 28db                 	sts triangle_pitch_macro+1, r29
0029ef 9220 2904                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0029f1 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
0029f3 9220 290b                 	sts triangle_fx_Rxy_target, zero
0029f5 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
0029f7 d021                      	rcall sound_driver_channel2_instrument_change_read_header
0029f8 93c0 28de                 	sts triangle_pitch_macro_release, r28
0029fa 93d0 28dd                 	sts triangle_pitch_macro_loop, r29
0029fc cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
0029fd 93c0 28e0                 	sts triangle_hi_pitch_macro, r28
0029ff 93d0 28e1                 	sts triangle_hi_pitch_macro+1, r29
002a01 9220 2904                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002a03 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
002a05 9220 290b                 	sts triangle_fx_Rxy_target, zero
002a07 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
002a09 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
002a0a 93c0 28e4                 	sts triangle_hi_pitch_macro_release, r28
002a0c 93d0 28e3                 	sts triangle_hi_pitch_macro_loop, r29
002a0e cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
002a0f 93c0 28e5                 	sts triangle_duty_macro, r28
002a11 93d0 28e6                 	sts triangle_duty_macro+1, r29
002a13 d005                      	rcall sound_driver_channel2_instrument_change_read_header
002a14 93c0 28e9                 	sts triangle_duty_macro_release, r28
002a16 93d0 28e8                 	sts triangle_duty_macro_loop, r29
002a18 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
002a19 93ef                      	push ZL
002a1a 93ff                      	push ZH
002a1b 2fec                      	mov ZL, r28
002a1c 2ffd                      	mov ZH, r29
002a1d 0fee                      	lsl ZL
002a1e 1fff                      	rol ZH
002a1f 91c5                      	lpm r28, Z+
002a20 91d4                      	lpm r29, Z
002a21 91ff                      	pop ZH
002a22 91ef                      	pop ZL
002a23 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
002a24 93ef                      	push ZL
002a25 93ff                      	push ZH
002a26 2fec                      	mov ZL, r28
002a27 2ffd                      	mov ZH, r29
002a28 0fee                      	lsl ZL
002a29 1fff                      	rol ZH
002a2a 91c5                      	lpm r28, Z+
002a2b 91d5                      	lpm r29, Z+
002a2c 93c0 28d6                 	sts triangle_arpeggio_macro_release, r28
002a2e 93d0 28d5                 	sts triangle_arpeggio_macro_loop, r29
002a30 91c4                      	lpm r28, Z
002a31 93c0 28d7                 	sts triangle_arpeggio_macro_mode, r28
002a33 91ff                      	pop ZH
002a34 91ef                      	pop ZL
002a35 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
002a36 91b0 28d1                 	lds r27, triangle_volume_macro_release
002a38 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002a39 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
002a3a 95b3                      	inc r27
002a3b 93b0 28cf                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
002a3d 91b0 28d6                 	lds r27, triangle_arpeggio_macro_release
002a3f 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002a40 f019                      	breq sound_driver_channel2_release_pitch
002a41 95b3                      	inc r27
002a42 93b0 28d4                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
002a44 91b0 28de                 	lds r27, triangle_pitch_macro_release
002a46 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002a47 f019                      	breq sound_driver_channel2_release_hi_pitch
002a48 95b3                      	inc r27
002a49 93b0 28dc                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
002a4b 91b0 28e4                 	lds r27, triangle_hi_pitch_macro_release
002a4d 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002a4e f019                      	breq sound_driver_channel2_release_duty
002a4f 95b3                      	inc r27
002a50 93b0 28e2                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
002a52 91b0 28e9                 	lds r27, triangle_duty_macro_release
002a54 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002a55 f019                      	breq sound_driver_channel2_release_exit
002a56 95b3                      	inc r27
002a57 93b0 28e7                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
002a59 d019                      	rcall sound_driver_channel2_increment_offset
002a5a cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
002a5b 91e0 2819                 	lds ZL, song_frames
002a5d 91f0 281a                 	lds ZH, song_frames+1
002a5f 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002a61 91b0 281c                 	lds r27, song_frame_offset+1
002a63 9614                      	adiw r27:r26, 4 //offset for channel 2
002a64 0fea                      	add ZL, r26
002a65 1ffb                      	adc ZH, r27
                                 
002a66 91a5                      	lpm r26, Z+ //load the address of the next pattern
002a67 91b4                      	lpm r27, Z
002a68 0faa                      	lsl r26
002a69 1fbb                      	rol r27
002a6a 93a0 28c7                 	sts triangle_pattern, r26
002a6c 93b0 28c8                 	sts triangle_pattern+1, r27
                                 
002a6e 9220 28cb                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002a70 9220 28cc                 	sts triangle_pattern_offset+1, zero
002a72 cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
002a73 91e0 28cb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
002a75 91f0 28cc                 	lds ZH, triangle_pattern_offset+1
002a77 9631                      	adiw Z, 1
002a78 93e0 28cb                 	sts triangle_pattern_offset, ZL
002a7a 93f0 28cc                 	sts triangle_pattern_offset+1, ZH
002a7c 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002a7d 91e0 28cb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
002a7f 91f0 28cc                 	lds ZH, triangle_pattern_offset+1
002a81 9632                      	adiw Z, 2 //increment the pointer twice
002a82 93e0 28cb                 	sts triangle_pattern_offset, ZL
002a84 93f0 28cc                 	sts triangle_pattern_offset+1, ZH
002a86 9508                      	ret
                                 
                                 sound_driver_channel2_end:
                                 sound_driver_channel2_check_Sxx_invalid:
002a87 efbf                      	ldi r27, 0xFF
002a88 91a0 2912                 	lds r26, triangle_fx_Sxx_post
002a8a 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
002a8b f419                      	brne sound_driver_channel2_check_Gxx_invalid
002a8c 93b0 2912                 	sts triangle_fx_Sxx_post, r27
002a8e 9508                      	ret
                                 sound_driver_channel2_check_Gxx_invalid:
002a8f 91a0 2900                 	lds r26, triangle_fx_Gxx_post
002a91 15a2                      	cp r26, zero
002a92 f419                      	brne sound_driver_channel3
002a93 93b0 2900                 	sts triangle_fx_Gxx_post, r27
002a95 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3:
002a96 91a0 2915                 	lds r26, noise_pattern_delay_rows
002a98 91b0 2916                 	lds r27, noise_pattern_delay_frames
                                 sound_driver_channel3_decrement_frame_delay:
002a9a 95ba                      	dec r27
002a9b 93b0 2916                 	sts noise_pattern_delay_frames, r27
                                 
002a9d 9610                      	adiw r27:r26, 0
002a9e f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
002a9f c1b9                      	rjmp sound_driver_channel3_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel3_main:
002aa0 91e0 2913                 	lds ZL, noise_pattern //current pattern for noise
002aa2 91f0 2914                 	lds ZH, noise_pattern+1
002aa4 91a0 2917                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
002aa6 91b0 2918                 	lds r27, noise_pattern_offset+1
002aa8 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
002aa9 1ffb                      	adc ZH, r27
002aaa 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
002aab 35b7                      	cpi r27, 0x57
002aac f408                      	brsh sound_driver_channel3_check_if_volume
002aad c096                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
002aae 36b7                      	cpi r27, 0x67
002aaf f408                      	brsh sound_driver_channel3_check_if_delay
002ab0 c0b1                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
002ab1 3eb3                      	cpi r27, 0xE3
002ab2 f408                      	brsh sound_driver_channel3_check_if_instrument
002ab3 c0b7                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
002ab4 f409                      	brne sound_driver_channel3_check_if_release
002ab5 c0ba                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
002ab6 3eb4                      	cpi r27, 0xE4
002ab7 f409                      	brne sound_driver_channel3_check_if_end
002ab8 c14b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
002ab9 3fbf                      	cpi r27, 0xFF
002aba f409                      	brne sound_driver_channel3_check_if_fx
002abb c16d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
002abc 9631                      	adiw Z, 1 //point Z to the byte next to the flag
002abd 91a4                      	lpm r26, Z //load the fx data into r26
002abe d190                      	rcall sound_driver_channel3_increment_offset_twice
                                 
002abf 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
002ac0 e7e0                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
002ac1 e7f5                      	ldi ZH, HIGH(channel3_fx << 1)
002ac2 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
002ac3 0feb                      	add ZL, r27 //add offset
002ac4 1df2                      	adc ZH, zero
002ac5 91c5                      	lpm r28, Z+ //load address bytes
002ac6 91d4                      	lpm r29, Z
002ac7 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002ac8 2ffd                      	mov ZH, r29
002ac9 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
002aca 93a0 2936                 	sts noise_fx_0xy_sequence, r26
002acc 9220 2937                 	sts noise_fx_0xy_sequence+1, zero
002ace cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
002acf 9220 293a                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
002ad1 9220 2936                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002ad3 9220 2937                 	sts noise_fx_0xy_sequence+1, zero
002ad5 93a0 2938                 	sts noise_fx_1xx, r26
002ad7 cfc8                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
002ad8 9220 2938                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
002ada 9220 2936                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002adc 9220 2937                 	sts noise_fx_0xy_sequence+1, zero
002ade 93a0 293a                 	sts noise_fx_2xx, r26
002ae0 cfbf                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
002ae1 cfbe                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
002ae2 2fba                      	mov r27, r26
002ae3 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002ae4 95a2                      	swap r26
002ae5 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002ae6 93a0 293c                 	sts noise_fx_4xy_speed, r26
002ae8 93b0 293d                 	sts noise_fx_4xy_depth, r27
002aea 9220 293e                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
002aec 9220 293f                 	sts noise_fx_4xy_offset, zero
002aee cfb1                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
002aef 2fba                      	mov r27, r26
002af0 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002af1 95a2                      	swap r26
002af2 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002af3 93a0 2940                 	sts noise_fx_7xy_speed, r26
002af5 93b0 2941                 	sts noise_fx_7xy_depth, r27
002af7 9220 2942                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
002af9 9220 2943                 	sts noise_fx_7xy_value, zero //reset the tremelo value
002afb cfa4                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
002afc 93a0 2944                 	sts noise_fx_Axy, r26
002afe cfa1                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002aff 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002b01 cf9e                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
002b02 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002b04 cf9b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
002b05 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002b07 cf98                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
002b08 91b0 2813                 	lds r27, noise_param
002b0a 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
002b0b 2bba                      	or r27, r26 //move new VVVV bits into noise_param
002b0c 93b0 2813                 	sts noise_param, r27
002b0e cf91                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002b0f 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002b11 cf8e                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
002b12 15a2                      	cp r26, zero
002b13 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
002b14 91b0 2821                 	lds r27, song_speed
002b16 17ab                      	cp r26, r27
002b17 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
002b18 93a0 2945                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002b1a e0b1                      	ldi r27, 0x01
002b1b 93b0 2915                 	sts noise_pattern_delay_rows, r27
002b1d c14a                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
002b1e cf81                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
002b1f cf80                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
002b20 cf7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
002b21 cf7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
002b22 cf7d                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
002b23 93a0 2947                 	sts noise_fx_Pxx_total, r26
002b25 cf7a                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Qxy: //note slide up
002b26 cf79                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Rxy: //note slide down
002b27 cf78                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
002b28 15a2                      	cp r26, zero
002b29 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
002b2a 91b0 2821                 	lds r27, song_speed
002b2c 17ab                      	cp r26, r27
002b2d f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
002b2e 93a0 2948                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002b30 e0b1                      	ldi r27, 0x01
002b31 93b0 2915                 	sts noise_pattern_delay_rows, r27
002b33 c134                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
002b34 cf6b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
002b35 95a6                      	lsr r26
002b36 95a7                      	ror r26 //move mode bit to bit 7
002b37 91b0 2814                 	lds r27, noise_period
002b39 77bf                      	andi r27, 0b01111111
002b3a 2bba                      	or r27, r26 //store the new noise mode
002b3b 93b0 2813                 	sts noise_param, r27
                                 
002b3d 776f                      	andi noise_sequence_HIGH, 0b01111111
002b3e 2b6a                      	or noise_sequence_HIGH, r26
002b3f cf60                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
002b40 cf5f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
002b41 cf5e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
002b42 cf5d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
002b43 cf5c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
002b44 93b0 2817                 	sts noise_note, r27
002b46 93b0 2818                 	sts noise_adjusted_note, r27
002b48 e0a3                      	ldi r26, 0x03
002b49 e0b2                      	ldi r27, 0x02
002b4a 93b0 291b                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002b4c 93a0 2920                 	sts noise_arpeggio_macro_offset, r26
002b4e 93b0 2928                 	sts noise_pitch_macro_offset, r27
002b50 93b0 292e                 	sts noise_hi_pitch_macro_offset, r27
002b52 93b0 2933                 	sts noise_duty_macro_offset, r27
002b54 9220 2924                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
002b56 9220 2925                 	sts noise_total_pitch_offset+1, zero
002b58 9220 292b                 	sts noise_total_hi_pitch_offset, zero
002b5a 9220 2939                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002b5c 9220 293b                 	sts noise_fx_2xx_total, zero
002b5e 9220 293f                 	sts noise_fx_4xy_offset, zero
002b60 d0e4                      	rcall sound_driver_channel3_increment_offset
002b61 cf3e                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
002b62 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
002b63 91a0 2813                 	lds r26, noise_param
002b65 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
002b66 2bab                      	or r26, r27 //move new VVVV bits into noise_param
002b67 93a0 2813                 	sts noise_param, r26
002b69 d0db                      	rcall sound_driver_channel3_increment_offset
002b6a cf35                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
002b6b 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002b6c 93b0 2915                 	sts noise_pattern_delay_rows, r27
002b6e d0d6                      	rcall sound_driver_channel3_increment_offset
002b6f c0e9                      	rjmp sound_driver_channel3_end
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
002b70 9220 2919                 	sts noise_volume_macro, zero //reset all macro addresses
002b72 9220 291a                 	sts noise_volume_macro+1, zero
002b74 9220 291e                 	sts noise_arpeggio_macro, zero
002b76 9220 291f                 	sts noise_arpeggio_macro+1, zero
002b78 9220 2926                 	sts noise_pitch_macro, zero
002b7a 9220 2927                 	sts noise_pitch_macro+1, zero
002b7c 9220 292c                 	sts noise_hi_pitch_macro, zero
002b7e 9220 292d                 	sts noise_hi_pitch_macro+1, zero
002b80 9220 2931                 	sts noise_duty_macro, zero
002b82 9220 2932                 	sts noise_duty_macro+1, zero
002b84 9220 2924                 	sts noise_total_pitch_offset, zero //reset the pitch offset
002b86 9220 2925                 	sts noise_total_pitch_offset+1, zero
002b88 9220 292b                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
002b8a 9631                      	adiw Z, 1 //point to the byte next to the flag
002b8b 91b4                      	lpm r27, Z //store the instrument offset into r27
002b8c edec                      	ldi ZL, LOW(instruments) //point Z to instruments table
002b8d e1fa                      	ldi ZH, HIGH(instruments)
002b8e 0feb                      	add ZL, r27 //point Z to offsetted instrument
002b8f 1df2                      	adc ZH, zero
002b90 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
002b91 1fff                      	rol ZH
002b92 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
002b93 91b4                      	lpm r27, Z
                                 
002b94 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
002b95 1fbb                      	rol r27
002b96 2fea                      	mov ZL, r26
002b97 2ffb                      	mov ZH, r27
002b98 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
002b99 9632                      	adiw Z, 2 //point Z to the address of the macro
002b9a e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
002b9b 95aa                      	dec r26
002b9c f019                      	breq sound_driver_channel3_instrument_change_exit
002b9d 95b6                      	lsr r27
002b9e f078                      	brcs sound_driver_channel3_instrument_change_load_macro
002b9f cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
002ba0 e0a3                      	ldi r26, 0x03
002ba1 e0b2                      	ldi r27, 0x02
002ba2 93b0 291b                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002ba4 93a0 2920                 	sts noise_arpeggio_macro_offset, r26
002ba6 93b0 2928                 	sts noise_pitch_macro_offset, r27
002ba8 93b0 292e                 	sts noise_hi_pitch_macro_offset, r27
002baa 93b0 2933                 	sts noise_duty_macro_offset, r27
002bac d0a2                      	rcall sound_driver_channel3_increment_offset_twice
002bad cef2                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
002bae 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
002baf 91d5                      	lpm r29, Z+
                                 
002bb0 30a5                      	cpi r26, 5
002bb1 f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
002bb2 30a4                      	cpi r26, 4
002bb3 f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
002bb4 30a3                      	cpi r26, 3
002bb5 f099                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
002bb6 30a2                      	cpi r26, 2
002bb7 f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
002bb8 c024                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
002bb9 93c0 2919                 	sts noise_volume_macro, r28
002bbb 93d0 291a                 	sts noise_volume_macro+1, r29
002bbd d029                      	rcall sound_driver_channel3_instrument_change_read_header
002bbe 93c0 291d                 	sts noise_volume_macro_release, r28
002bc0 93d0 291c                 	sts noise_volume_macro_loop, r29
002bc2 cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
002bc3 93c0 291e                 	sts noise_arpeggio_macro, r28
002bc5 93d0 291f                 	sts noise_arpeggio_macro+1, r29
002bc7 d02a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
002bc8 cfd2                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
002bc9 93c0 2926                 	sts noise_pitch_macro, r28
002bcb 93d0 2927                 	sts noise_pitch_macro+1, r29
002bcd d019                      	rcall sound_driver_channel3_instrument_change_read_header
002bce 93c0 292a                 	sts noise_pitch_macro_release, r28
002bd0 93d0 2929                 	sts noise_pitch_macro_loop, r29
002bd2 cfc8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
002bd3 93c0 292c                 	sts noise_hi_pitch_macro, r28
002bd5 93d0 292d                 	sts noise_hi_pitch_macro+1, r29
002bd7 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
002bd8 93c0 2930                 	sts noise_hi_pitch_macro_release, r28
002bda 93d0 292f                 	sts noise_hi_pitch_macro_loop, r29
002bdc cfbe                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
002bdd 93c0 2931                 	sts noise_duty_macro, r28
002bdf 93d0 2932                 	sts noise_duty_macro+1, r29
002be1 d005                      	rcall sound_driver_channel3_instrument_change_read_header
002be2 93c0 2935                 	sts noise_duty_macro_release, r28
002be4 93d0 2934                 	sts noise_duty_macro_loop, r29
002be6 cfb4                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
002be7 93ef                      	push ZL
002be8 93ff                      	push ZH
002be9 2fec                      	mov ZL, r28
002bea 2ffd                      	mov ZH, r29
002beb 0fee                      	lsl ZL
002bec 1fff                      	rol ZH
002bed 91c5                      	lpm r28, Z+
002bee 91d4                      	lpm r29, Z
002bef 91ff                      	pop ZH
002bf0 91ef                      	pop ZL
002bf1 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
002bf2 93ef                      	push ZL
002bf3 93ff                      	push ZH
002bf4 2fec                      	mov ZL, r28
002bf5 2ffd                      	mov ZH, r29
002bf6 0fee                      	lsl ZL
002bf7 1fff                      	rol ZH
002bf8 91c5                      	lpm r28, Z+
002bf9 91d5                      	lpm r29, Z+
002bfa 93c0 2922                 	sts noise_arpeggio_macro_release, r28
002bfc 93d0 2921                 	sts noise_arpeggio_macro_loop, r29
002bfe 91c4                      	lpm r28, Z
002bff 93c0 2923                 	sts noise_arpeggio_macro_mode, r28
002c01 91ff                      	pop ZH
002c02 91ef                      	pop ZL
002c03 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
002c04 91b0 291d                 	lds r27, noise_volume_macro_release
002c06 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002c07 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
002c08 95b3                      	inc r27
002c09 93b0 291b                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
002c0b 91b0 2922                 	lds r27, noise_arpeggio_macro_release
002c0d 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002c0e f019                      	breq sound_driver_channel3_release_pitch
002c0f 95b3                      	inc r27
002c10 93b0 2920                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
002c12 91b0 292a                 	lds r27, noise_pitch_macro_release
002c14 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002c15 f019                      	breq sound_driver_channel3_release_hi_pitch
002c16 95b3                      	inc r27
002c17 93b0 2928                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
002c19 91b0 2930                 	lds r27, noise_hi_pitch_macro_release
002c1b 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002c1c f019                      	breq sound_driver_channel3_release_duty
002c1d 95b3                      	inc r27
002c1e 93b0 292e                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
002c20 91b0 2935                 	lds r27, noise_duty_macro_release
002c22 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002c23 f019                      	breq sound_driver_channel3_release_exit
002c24 95b3                      	inc r27
002c25 93b0 2933                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
002c27 d01d                      	rcall sound_driver_channel3_increment_offset
002c28 ce77                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
002c29 91e0 2819                 	lds ZL, song_frames
002c2b 91f0 281a                 	lds ZH, song_frames+1
002c2d 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002c2f 91b0 281c                 	lds r27, song_frame_offset+1
002c31 93a0 281b                 	sts song_frame_offset, r26
002c33 93b0 281c                 	sts song_frame_offset+1, r27
002c35 9616                      	adiw r27:r26, 6 //offset for channel 3
002c36 0fea                      	add ZL, r26
002c37 1ffb                      	adc ZH, r27
                                 
002c38 91a5                      	lpm r26, Z+ //load the address of the next pattern
002c39 91b4                      	lpm r27, Z
002c3a 0faa                      	lsl r26
002c3b 1fbb                      	rol r27
002c3c 93a0 2913                 	sts noise_pattern, r26
002c3e 93b0 2914                 	sts noise_pattern+1, r27
                                 
002c40 9220 2917                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002c42 9220 2918                 	sts noise_pattern_offset+1, zero
002c44 ce5b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
002c45 91e0 2917                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002c47 91f0 2918                 	lds ZH, noise_pattern_offset+1
002c49 9631                      	adiw Z, 1
002c4a 93e0 2917                 	sts noise_pattern_offset, ZL
002c4c 93f0 2918                 	sts noise_pattern_offset+1, ZH
002c4e 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002c4f 91e0 2917                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002c51 91f0 2918                 	lds ZH, noise_pattern_offset+1
002c53 9632                      	adiw Z, 2 //increment the pointer twice
002c54 93e0 2917                 	sts noise_pattern_offset, ZL
002c56 93f0 2918                 	sts noise_pattern_offset+1, ZH
002c58 9508                      	ret
                                 
                                 sound_driver_channel3_end:
                                 sound_driver_channel3_check_Sxx_invalid:
002c59 efbf                      	ldi r27, 0xFF
002c5a 91a0 2949                 	lds r26, noise_fx_Sxx_post
002c5c 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
002c5d f419                      	brne sound_driver_channel3_check_Gxx_invalid
002c5e 93b0 2949                 	sts noise_fx_Sxx_post, r27
002c60 9508                      	ret
                                 sound_driver_channel3_check_Gxx_invalid:
002c61 91a0 2946                 	lds r26, noise_fx_Gxx_post
002c63 15a2                      	cp r26, zero
002c64 f419                      	brne sound_driver_channel4
002c65 93b0 2946                 	sts noise_fx_Gxx_post, r27
002c67 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel4:
002c68 91a0 294c                 	lds r26, dpcm_pattern_delay_rows
002c6a 91b0 294d                 	lds r27, dpcm_pattern_delay_frames
                                 sound_driver_channel4_decrement_frame_delay:
002c6c 95ba                      	dec r27
002c6d 93b0 294d                 	sts dpcm_pattern_delay_frames, r27
                                 
002c6f 9610                      	adiw r27:r26, 0
002c70 f009                      	breq sound_driver_channel4_main //if the pattern delay is 0, proceed with sound driver procedures
002c71 c0cc                      	rjmp sound_driver_channel4_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel4_main:
002c72 91e0 294a                 	lds ZL, dpcm_pattern //current pattern for dpcm
002c74 91f0 294b                 	lds ZH, dpcm_pattern+1
002c76 91a0 294e                 	lds r26, dpcm_pattern_offset //current offset in the pattern for dpcm
002c78 91b0 294f                 	lds r27, dpcm_pattern_offset+1
002c7a 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
002c7b 1ffb                      	adc ZH, r27
002c7c 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel4_check_if_note: //check if data is a note (0x00 - 0x56)
002c7d 35b7                      	cpi r27, 0x57
002c7e f408                      	brsh sound_driver_channel4_check_if_volume
002c7f c056                      	rjmp sound_driver_channel4_note
                                 sound_driver_channel4_check_if_volume: //check if data is volume (0x57-0x66)
002c80 36b7                      	cpi r27, 0x67
002c81 f408                      	brsh sound_driver_channel4_check_if_delay
002c82 c080                      	rjmp sound_driver_channel4_volume
                                 sound_driver_channel4_check_if_delay: //check if data is a delay (0x67 - 0xE2)
002c83 3eb3                      	cpi r27, 0xE3
002c84 f408                      	brsh sound_driver_channel4_check_if_instrument
002c85 c07f                      	rjmp sound_driver_channel4_delay
                                 sound_driver_channel4_check_if_instrument: //check for instrument flag (0xE3)
002c86 f409                      	brne sound_driver_channel4_check_if_release
002c87 c082                      	rjmp sound_driver_channel4_instrument_change 
                                 sound_driver_channel4_check_if_release: //check for note release flag (0xE4)
002c88 3eb4                      	cpi r27, 0xE4
002c89 f409                      	brne sound_driver_channel4_check_if_end
002c8a c081                      	rjmp sound_driver_channel4_release
                                 sound_driver_channel4_check_if_end:
002c8b 3fbf                      	cpi r27, 0xFF
002c8c f409                      	brne sound_driver_channel4_check_if_fx
002c8d c080                      	rjmp sound_driver_channel4_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel4_check_if_fx: //fx flags (0xE5 - 0xFE)
002c8e 9631                      	adiw Z, 1 //point Z to the byte next to the flag
002c8f 91a4                      	lpm r26, Z //load the fx data into r26
002c90 d0a3                      	rcall sound_driver_channel4_increment_offset_twice
                                 
002c91 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
002c92 eae4                      	ldi ZL, LOW(channel4_fx << 1) //load in note table
002c93 e7f5                      	ldi ZH, HIGH(channel4_fx << 1)
002c94 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
002c95 0feb                      	add ZL, r27 //add offset
002c96 1df2                      	adc ZH, zero
002c97 91c5                      	lpm r28, Z+ //load address bytes
002c98 91d4                      	lpm r29, Z
002c99 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002c9a 2ffd                      	mov ZH, r29
002c9b 9409                      	ijmp
                                 
                                 
                                 
                                 sound_driver_channel4_fx_0xy: //arpeggio
002c9c cfd5                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_1xx: //pitch slide up
002c9d cfd4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_2xx: //pitch slide down
002c9e cfd3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_3xx: //automatic portamento
002c9f cfd2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_4xy: //vibrato
002ca0 cfd1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_7xy: //tremelo
002ca1 cfd0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Axy: //volume slide
002ca2 cfcf                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel4_fx_Bxx:
002ca3 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002ca5 cfcc                      	rjmp sound_driver_channel4_main
                                 
                                 //HALT
                                 sound_driver_channel4_fx_Cxx:
002ca6 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002ca8 cfc9                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel4_fx_Dxx:
002ca9 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002cab cfc6                      	rjmp sound_driver_channel4_main
                                 
                                 sound_driver_channel4_fx_Exx: //volume
002cac cfc5                      	rjmp sound_driver_channel4_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel4_fx_Fxx:
002cad 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002caf cfc2                      	rjmp sound_driver_channel4_main
                                 
                                 //DELAY
                                 sound_driver_channel4_fx_Gxx:
002cb0 15a2                      	cp r26, zero
002cb1 f051                      	breq sound_driver_channel4_fx_Gxx_invalid
002cb2 91b0 2821                 	lds r27, song_speed
002cb4 17ab                      	cp r26, r27
002cb5 f430                      	brsh sound_driver_channel4_fx_Gxx_invalid
002cb6 93a0 2954                 	sts dpcm_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002cb8 e0b1                      	ldi r27, 0x01
002cb9 93b0 294c                 	sts dpcm_pattern_delay_rows, r27
002cbb c091                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Gxx_invalid:
002cbc cfb5                      	rjmp sound_driver_channel4_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Hxy: //hardware sweep up
002cbd cfb4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixy: //hardware sweep down
002cbe cfb3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Hxx: //FDS modulation depth
002cbf cfb2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixx: //FDS modulation speed
002cc0 cfb1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Pxx: //fine pitch
002cc1 cfb0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Qxy: //note slide up
002cc2 cfaf                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Rxy: //note slide down
002cc3 cfae                      	rjmp sound_driver_channel4_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel4_fx_Sxx:
002cc4 15a2                      	cp r26, zero
002cc5 f051                      	breq sound_driver_channel4_fx_Sxx_invalid
002cc6 91b0 2821                 	lds r27, song_speed
002cc8 17ab                      	cp r26, r27
002cc9 f430                      	brsh sound_driver_channel4_fx_Sxx_invalid
002cca 93a0 2956                 	sts dpcm_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002ccc e0b1                      	ldi r27, 0x01
002ccd 93b0 294c                 	sts dpcm_pattern_delay_rows, r27
002ccf c07d                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Sxx_invalid:
002cd0 cfa1                      	rjmp sound_driver_channel4_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Vxx: //duty
002cd1 cfa0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Wxx: //DPCM sample speed
002cd2 cf9f                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Xxx: //DPCM sample retrigger
002cd3 cf9e                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Yxx: //DPCM sample offset
002cd4 cf9d                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Zxx: //DPCM sample delta counter
002cd5 cf9c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_note:
002cd6 9631                      	adiw Z, 1 //point to the byte next to the flag
002cd7 90f4                      	lpm dpcm_period, Z //store the DPCM sample rate
002cd8 edec                      	ldi ZL, LOW(dpcm_samples) //point Z to dpcm_samples table
002cd9 e1fa                      	ldi ZH, HIGH(dpcm_samples)
002cda 0feb                      	add ZL, r27 //point Z to offsetted sample
002cdb 1df2                      	adc ZH, zero
002cdc 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the samples's address
002cdd 1fff                      	rol ZH
002cde 91a5                      	lpm r26, Z+ //r26:r27 now points to the sample
002cdf 91b4                      	lpm r27, Z
                                 
002ce0 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the sample's data
002ce1 1fbb                      	rol r27
002ce2 2fea                      	mov ZL, r26
002ce3 2ffb                      	mov ZH, r27
002ce4 91b4                      	lpm r27, Z //get sample length
002ce5 ef70                      	ldi dpcm_length_LOW, 0b11110000
002ce6 e08f                      	ldi dpcm_length_HIGH, 0b00001111
002ce7 95b2                      	swap r27
002ce8 237b                      	and dpcm_length_LOW, r27
002ce9 238b                      	and dpcm_length_HIGH, r27
                                 
002cea 93e0 2950                 	sts dpcm_sample, ZL //store address to sample
002cec 93f0 2951                 	sts dpcm_sample+1, ZH
002cee 9230 2952                 	sts dpcm_sample_offset, one //reset sample offset to 1 (0th byte contains length)
002cf0 9220 2953                 	sts dpcm_sample_offset+1, zero
                                 
002cf2 2ce2                      	mov dpcm_bit_counter, zero
                                 
002cf3 e6e2                      	ldi ZL, LOW(dpcm_period_table << 1) //load in dpcm period table
002cf4 e0f1                      	ldi ZH, HIGH(dpcm_period_table << 1)
002cf5 0cff                      	lsl dpcm_period //double the offset for the period table because we are getting byte data
002cf6 0def                      	add ZL, dpcm_period //add offset
002cf7 1df2                      	adc ZH, zero
002cf8 91a5                      	lpm r26, Z+ //load bytes
002cf9 91b4                      	lpm r27, Z
002cfa 93a0 0a26                 	sts TCA0_SINGLE_PER, r26 //load the LOW bits for timer
002cfc 93b0 0a27                 	sts TCA0_SINGlE_PER + 1, r27 //load the HIGH bits for timer
002cfe e0a3                      	ldi r26, TCA_SINGLE_CLKSEL_DIV2_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 2 and enable timer
002cff 93a0 0a00                 	sts TCA0_SINGLE_CTRLA, r26
                                 
002d01 d032                      	rcall sound_driver_channel4_increment_offset_twice
002d02 cf6f                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_volume:
002d03 d026                      	rcall sound_driver_channel4_increment_offset
002d04 cf6d                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_delay:
002d05 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002d06 93b0 294c                 	sts dpcm_pattern_delay_rows, r27
002d08 d021                      	rcall sound_driver_channel4_increment_offset
002d09 c034                      	rjmp sound_driver_channel4_end
                                 
                                 
                                 
                                 sound_driver_channel4_instrument_change:
002d0a d029                      	rcall sound_driver_channel4_increment_offset_twice
002d0b cf66                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_release:
002d0c d01d                      	rcall sound_driver_channel4_increment_offset
002d0d cf64                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_next_pattern:
002d0e 91e0 2819                 	lds ZL, song_frames
002d10 91f0 281a                 	lds ZH, song_frames+1
002d12 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002d14 91b0 281c                 	lds r27, song_frame_offset+1
002d16 93a0 281b                 	sts song_frame_offset, r26
002d18 93b0 281c                 	sts song_frame_offset+1, r27
002d1a 9618                      	adiw r27:r26, 8 //offset for channel 4
002d1b 0fea                      	add ZL, r26
002d1c 1ffb                      	adc ZH, r27
                                 
002d1d 91a5                      	lpm r26, Z+ //load the address of the next pattern
002d1e 91b4                      	lpm r27, Z
002d1f 0faa                      	lsl r26
002d20 1fbb                      	rol r27
002d21 93a0 294a                 	sts dpcm_pattern, r26
002d23 93b0 294b                 	sts dpcm_pattern+1, r27
                                 
002d25 9220 294e                 	sts dpcm_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002d27 9220 294f                 	sts dpcm_pattern_offset+1, zero
002d29 cf48                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_increment_offset:
002d2a 91e0 294e                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002d2c 91f0 294f                 	lds ZH, dpcm_pattern_offset+1
002d2e 9631                      	adiw Z, 1
002d2f 93e0 294e                 	sts dpcm_pattern_offset, ZL
002d31 93f0 294f                 	sts dpcm_pattern_offset+1, ZH
002d33 9508                      	ret
                                 
                                 sound_driver_channel4_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002d34 91e0 294e                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002d36 91f0 294f                 	lds ZH, dpcm_pattern_offset+1
002d38 9632                      	adiw Z, 2 //increment the pointer twice
002d39 93e0 294e                 	sts dpcm_pattern_offset, ZL
002d3b 93f0 294f                 	sts dpcm_pattern_offset+1, ZH
002d3d 9508                      	ret
                                 
                                 sound_driver_channel4_end:
                                 sound_driver_channel4_check_Sxx_invalid:
002d3e efbf                      	ldi r27, 0xFF
002d3f 91a0 2957                 	lds r26, dpcm_fx_Sxx_post
002d41 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
002d42 f419                      	brne sound_driver_channel4_check_Gxx_invalid
002d43 93b0 2957                 	sts dpcm_fx_Sxx_post, r27
002d45 9508                      	ret
                                 sound_driver_channel4_check_Gxx_invalid:
002d46 91a0 2955                 	lds r26, dpcm_fx_Gxx_post
002d48 15a2                      	cp r26, zero
002d49 f419                      	brne sound_driver_calculate_delays
002d4a 93b0 2955                 	sts dpcm_fx_Gxx_post, r27
002d4c 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
002d4d 91f0 2821                 	lds r31, song_speed
                                 
                                 sound_driver_calculate_delays_pulse1:
002d4f 91a0 2828                 	lds r26, pulse1_pattern_delay_frames
002d51 11a2                      	cpse r26, zero
002d52 c044                      	rjmp sound_driver_calculate_delays_pulse2
002d53 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002d54 2faf                      	mov r26, r31 //move speed into r26
002d55 91b0 2827                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002d57 15b2                      	cp r27, zero
002d58 f409                      	brne PC+2
002d59 c03d                      	rjmp sound_driver_calculate_delays_pulse2
002d5a 95ba                      	dec r27
002d5b 93b0 2827                 	sts pulse1_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002d5d efbf                      	ldi r27, 0xFF
002d5e 91c0 2874                 	lds r28, pulse1_fx_Sxx_pre
002d60 91d0 2875                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002d62 17cb                      	cp r28, r27
002d63 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002d64 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
002d65 17db                      	cp r29, r27
002d66 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
002d67 c014                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
002d68 91c0 2862                 	lds r28, pulse1_fx_Gxx_pre
002d6a 91d0 2863                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
002d6c 17cb                      	cp r28, r27
002d6d f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
002d6e c011                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
002d6f 17db                      	cp r29, r27
002d70 f121                      	breq sound_driver_calculate_delays_pulse1_store
002d71 c018                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
002d72 93b0 2874                 	sts pulse1_fx_Sxx_pre, r27
002d74 1bac                      	sub r26, r28 //(song speed)-Sxx
002d75 93a0 2875                 	sts pulse1_fx_Sxx_post, r26
002d77 93c0 2828                 	sts pulse1_pattern_delay_frames, r28
002d79 11a2                      	cpse r26, zero
002d7a c01c                      	rjmp sound_driver_calculate_delays_pulse2
002d7b c012                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
002d7c 93b0 2875                 	sts pulse1_fx_Sxx_post, r27
002d7e 2fad                      	mov r26, r29
002d7f c015                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
002d80 93b0 2862                 	sts pulse1_fx_Gxx_pre, r27
002d82 1bac                      	sub r26, r28 //(song speed)-Gxx
002d83 93a0 2863                 	sts pulse1_fx_Gxx_post, r26
002d85 93c0 2828                 	sts pulse1_pattern_delay_frames, r28
002d87 11a2                      	cpse r26, zero
002d88 c00e                      	rjmp sound_driver_calculate_delays_pulse2
002d89 c004                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
002d8a 93b0 2863                 	sts pulse1_fx_Gxx_post, r27
002d8c 2fad                      	mov r26, r29
002d8d c007                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid:
002d8e 9220 2828                 	sts pulse1_pattern_delay_frames, zero
002d90 940e 21db                 	call sound_driver_channel0_main
002d92 91f0 2821                 	lds r31, song_speed
002d94 cfba                      	rjmp sound_driver_calculate_delays_pulse1
                                 
                                 sound_driver_calculate_delays_pulse1_store:
002d95 93a0 2828                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
002d97 91a0 2879                 	lds r26, pulse2_pattern_delay_frames
002d99 11a2                      	cpse r26, zero
002d9a c044                      	rjmp sound_driver_calculate_delays_triangle
002d9b c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
002d9c 2faf                      	mov r26, r31 //move the speed to r26
002d9d 91b0 2878                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
002d9f 15b2                      	cp r27, zero
002da0 f409                      	brne PC+2
002da1 c03d                      	rjmp sound_driver_calculate_delays_triangle
002da2 95ba                      	dec r27
002da3 93b0 2878                 	sts pulse2_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
002da5 efbf                      	ldi r27, 0xFF
002da6 91c0 28c5                 	lds r28, pulse2_fx_Sxx_pre
002da8 91d0 28c6                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
002daa 17cb                      	cp r28, r27
002dab f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
002dac c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
002dad 17db                      	cp r29, r27
002dae f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
002daf c014                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
002db0 91c0 28b3                 	lds r28, pulse2_fx_Gxx_pre
002db2 91d0 28b4                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
002db4 17cb                      	cp r28, r27
002db5 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
002db6 c011                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
002db7 17db                      	cp r29, r27
002db8 f121                      	breq sound_driver_calculate_delays_pulse2_store
002db9 c018                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
002dba 93b0 28c5                 	sts pulse2_fx_Sxx_pre, r27
002dbc 1bac                      	sub r26, r28 //(song speed)-Sxx
002dbd 93a0 28c6                 	sts pulse2_fx_Sxx_post, r26
002dbf 93c0 2879                 	sts pulse2_pattern_delay_frames, r28
002dc1 11a2                      	cpse r26, zero
002dc2 c01c                      	rjmp sound_driver_calculate_delays_triangle
002dc3 c012                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
002dc4 93b0 28c6                 	sts pulse2_fx_Sxx_post, r27
002dc6 2fad                      	mov r26, r29
002dc7 c015                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
002dc8 93b0 28b3                 	sts pulse2_fx_Gxx_pre, r27
002dca 1bac                      	sub r26, r28 //(song speed)-1-Gxx
002dcb 93a0 28b4                 	sts pulse2_fx_Gxx_post, r26
002dcd 93c0 2879                 	sts pulse2_pattern_delay_frames, r28
002dcf 11a2                      	cpse r26, zero
002dd0 c00e                      	rjmp sound_driver_calculate_delays_triangle
002dd1 c004                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
002dd2 93b0 28b4                 	sts pulse2_fx_Gxx_post, r27
002dd4 2fad                      	mov r26, r29
002dd5 c007                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid:
002dd6 9220 2879                 	sts pulse2_pattern_delay_frames, zero
002dd8 940e 24d8                 	call sound_driver_channel1_main
002dda 91f0 2821                 	lds r31, song_speed
002ddc cfba                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_store:
002ddd 93a0 2879                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
002ddf 91a0 28ca                 	lds r26, triangle_pattern_delay_frames
002de1 11a2                      	cpse r26, zero
002de2 c044                      	rjmp sound_driver_calculate_delays_noise
002de3 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
002de4 2faf                      	mov r26, r31 //move the speed to r26
002de5 91b0 28c9                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
002de7 15b2                      	cp r27, zero
002de8 f409                      	brne PC+2
002de9 c03d                      	rjmp sound_driver_calculate_delays_noise
002dea 95ba                      	dec r27
002deb 93b0 28c9                 	sts triangle_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
002ded efbf                      	ldi r27, 0xFF
002dee 91c0 2911                 	lds r28, triangle_fx_Sxx_pre
002df0 91d0 2912                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
002df2 17cb                      	cp r28, r27
002df3 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
002df4 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
002df5 17db                      	cp r29, r27
002df6 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
002df7 c014                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
002df8 91c0 28ff                 	lds r28, triangle_fx_Gxx_pre
002dfa 91d0 2900                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
002dfc 17cb                      	cp r28, r27
002dfd f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
002dfe c011                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
002dff 17db                      	cp r29, r27
002e00 f121                      	breq sound_driver_calculate_delays_triangle_store
002e01 c018                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
002e02 93b0 2911                 	sts triangle_fx_Sxx_pre, r27
002e04 1bac                      	sub r26, r28 //(song speed)-Sxx
002e05 93a0 2912                 	sts triangle_fx_Sxx_post, r26
002e07 93c0 28ca                 	sts triangle_pattern_delay_frames, r28
002e09 11a2                      	cpse r26, zero
002e0a c01c                      	rjmp sound_driver_calculate_delays_noise
002e0b c012                      	rjmp sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
002e0c 93b0 2912                 	sts triangle_fx_Sxx_post, r27
002e0e 2fad                      	mov r26, r29
002e0f c015                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002e10 93b0 28ff                 	sts triangle_fx_Gxx_pre, r27
002e12 1bac                      	sub r26, r28 //(song speed)-Gxx
002e13 93a0 2900                 	sts triangle_fx_Gxx_post, r26
002e15 93c0 28ca                 	sts triangle_pattern_delay_frames, r28
002e17 11a2                      	cpse r26, zero
002e18 c00e                      	rjmp sound_driver_calculate_delays_noise
002e19 c004                      	rjmp sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
002e1a 93b0 2900                 	sts triangle_fx_Gxx_post, r27
002e1c 2fad                      	mov r26, r29
002e1d c007                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid:
002e1e 9220 28ca                 	sts triangle_pattern_delay_frames, zero
002e20 940e 27c8                 	call sound_driver_channel2_main
002e22 91f0 2821                 	lds r31, song_speed
002e24 cfba                      	rjmp sound_driver_calculate_delays_triangle
                                 
                                 sound_driver_calculate_delays_triangle_store:
002e25 93a0 28ca                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
002e27 91a0 2916                 	lds r26, noise_pattern_delay_frames
002e29 11a2                      	cpse r26, zero
002e2a c044                      	rjmp sound_driver_calculate_delays_dpcm
002e2b c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
002e2c 2faf                      	mov r26, r31 //move the speed to r26
002e2d 91b0 2915                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
002e2f 15b2                      	cp r27, zero
002e30 f409                      	brne PC+2
002e31 c03d                      	rjmp sound_driver_calculate_delays_dpcm
002e32 95ba                      	dec r27
002e33 93b0 2915                 	sts noise_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
002e35 efbf                      	ldi r27, 0xFF
002e36 91c0 2948                 	lds r28, noise_fx_Sxx_pre
002e38 91d0 2949                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
002e3a 17cb                      	cp r28, r27
002e3b f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
002e3c c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
002e3d 17db                      	cp r29, r27
002e3e f009                      	breq sound_driver_calculate_delays_noise_Gxx
002e3f c014                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
002e40 91c0 2945                 	lds r28, noise_fx_Gxx_pre
002e42 91d0 2946                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
002e44 17cb                      	cp r28, r27
002e45 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002e46 c011                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002e47 17db                      	cp r29, r27
002e48 f121                      	breq sound_driver_calculate_delays_noise_store
002e49 c018                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
002e4a 93b0 2948                 	sts noise_fx_Sxx_pre, r27
002e4c 1bac                      	sub r26, r28 //(song speed)-Sxx
002e4d 93a0 2949                 	sts noise_fx_Sxx_post, r26
002e4f 93c0 2916                 	sts noise_pattern_delay_frames, r28
002e51 11a2                      	cpse r26, zero
002e52 c01c                      	rjmp sound_driver_calculate_delays_dpcm
002e53 c012                      	rjmp sound_driver_calculate_delays_noise_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
002e54 93b0 2949                 	sts noise_fx_Sxx_post, r27
002e56 2fad                      	mov r26, r29
002e57 c015                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002e58 93b0 2945                 	sts noise_fx_Gxx_pre, r27
002e5a 1bac                      	sub r26, r28 //(song speed)-Gxx
002e5b 93a0 2946                 	sts noise_fx_Gxx_post, r26
002e5d 93c0 2916                 	sts noise_pattern_delay_frames, r28
002e5f 11a2                      	cpse r26, zero
002e60 c00e                      	rjmp sound_driver_calculate_delays_dpcm
002e61 c004                      	rjmp sound_driver_calculate_delays_noise_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
002e62 93b0 2946                 	sts noise_fx_Gxx_post, r27
002e64 2fad                      	mov r26, r29
002e65 c007                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Sxx_Gxx_invalid:
002e66 9220 2916                 	sts noise_pattern_delay_frames, zero
002e68 940e 2aa0                 	call sound_driver_channel3_main
002e6a 91f0 2821                 	lds r31, song_speed
002e6c cfba                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_noise_store:
002e6d 93a0 2916                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
002e6f 91a0 294d                 	lds r26, dpcm_pattern_delay_frames
002e71 11a2                      	cpse r26, zero
002e72 c044                      	rjmp sound_driver_instrument_fx_routine
002e73 c000                      	rjmp sound_driver_calculate_delays_dpcm_main
                                 
                                 sound_driver_calculate_delays_dpcm_main:
002e74 2faf                      	mov r26, r31 //move the speed to r26
002e75 91b0 294c                 	lds r27, dpcm_pattern_delay_rows //decrement the delay rows
002e77 15b2                      	cp r27, zero
002e78 f409                      	brne PC+2
002e79 c03d                      	rjmp sound_driver_instrument_fx_routine
002e7a 95ba                      	dec r27
002e7b 93b0 294c                 	sts dpcm_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx:
002e7d efbf                      	ldi r27, 0xFF
002e7e 91c0 2956                 	lds r28, dpcm_fx_Sxx_pre
002e80 91d0 2957                 	lds r29, dpcm_fx_Sxx_post
                                 sound_driver_calculate_delays_dpcm_Sxx_check_pre:
002e82 17cb                      	cp r28, r27
002e83 f009                      	breq sound_driver_calculate_delays_dpcm_Sxx_check_post
002e84 c00d                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_pre
                                 sound_driver_calculate_delays_dpcm_Sxx_check_post:
002e85 17db                      	cp r29, r27
002e86 f009                      	breq sound_driver_calculate_delays_dpcm_Gxx
002e87 c014                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx:
002e88 91c0 2954                 	lds r28, dpcm_fx_Gxx_pre
002e8a 91d0 2955                 	lds r29, dpcm_fx_Gxx_post
                                 sound_driver_calculate_delays_dpcm_Gxx_check_pre:
002e8c 17cb                      	cp r28, r27
002e8d f009                      	breq sound_driver_calculate_delays_dpcm_Gxx_check_post
002e8e c011                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_pre
                                 sound_driver_calculate_delays_dpcm_Gxx_check_post:
002e8f 17db                      	cp r29, r27
002e90 f121                      	breq sound_driver_calculate_delays_dpcm_store
002e91 c018                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_pre:
002e92 93b0 2956                 	sts dpcm_fx_Sxx_pre, r27
002e94 1bac                      	sub r26, r28 //(song speed)-Sxx
002e95 93a0 2957                 	sts dpcm_fx_Sxx_post, r26
002e97 93c0 294d                 	sts dpcm_pattern_delay_frames, r28
002e99 11a2                      	cpse r26, zero
002e9a c01c                      	rjmp sound_driver_instrument_fx_routine
002e9b c012                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_post:
002e9c 93b0 2957                 	sts dpcm_fx_Sxx_post, r27
002e9e 2fad                      	mov r26, r29
002e9f c015                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx_pre:
002ea0 93b0 2954                 	sts dpcm_fx_Gxx_pre, r27
002ea2 1bac                      	sub r26, r28 //(song speed)-Gxx
002ea3 93a0 2955                 	sts dpcm_fx_Gxx_post, r26
002ea5 93c0 294d                 	sts dpcm_pattern_delay_frames, r28
002ea7 11a2                      	cpse r26, zero
002ea8 c00e                      	rjmp sound_driver_instrument_fx_routine
002ea9 c004                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_dpcm_Gxx_post:
002eaa 93b0 2955                 	sts dpcm_fx_Gxx_post, r27
002eac 2fad                      	mov r26, r29
002ead c007                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid:
002eae 9220 294d                 	sts dpcm_pattern_delay_frames, zero
002eb0 940e 2c72                 	call sound_driver_channel4_main
002eb2 91f0 2821                 	lds r31, song_speed
002eb4 cfba                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_dpcm_store:
002eb5 93a0 294d                 	sts dpcm_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002eb7 91e0 282b                 	lds ZL, pulse1_volume_macro
002eb9 91f0 282c                 	lds ZH, pulse1_volume_macro+1
002ebb 9630                      	adiw Z, 0
002ebc f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
002ebd 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002ebe 1fff                      	rol ZH
002ebf 91a0 282d                 	lds r26, pulse1_volume_macro_offset
002ec1 0fea                      	add ZL, r26
002ec2 1df2                      	adc ZH, zero
                                 
002ec3 91b0 282f                 	lds r27, pulse1_volume_macro_release
002ec5 17ba                      	cp r27, r26
002ec6 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
002ec7 91a0 282e                 	lds r26, pulse1_volume_macro_loop
002ec9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002eca f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ecb c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
002ecc 95a3                      	inc r26 //increment the macro offset
002ecd 93a0 282d                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
002ecf 91b4                      	lpm r27, Z //load volume data into r27
002ed0 3fbf                      	cpi r27, 0xFF //check for macro end flag
002ed1 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
002ed2 91b0 282f                 	lds r27, pulse1_volume_macro_release
002ed4 3fbf                      	cpi r27, 0xFF
002ed5 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
002ed6 91b0 282e                 	lds r27, pulse1_volume_macro_loop //load the loop index
002ed8 93b0 282d                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
002eda cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
002edb 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002edc 93a0 282d                 	sts pulse1_volume_macro_offset, r26
002ede cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
002edf ede8                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002ee0 e7f5                      	ldi ZH, HIGH(volumes << 1)
002ee1 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002ee2 0feb                      	add ZL, r27 //add offset to the table
002ee3 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
002ee4 91b0 2800                 	lds r27, pulse1_param //load main volume
002ee6 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002ee7 91a0 2860                 	lds r26, pulse1_fx_7xy_value
002ee9 30a0                      	cpi r26, 0x00
002eea f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
002eeb 0feb                      	add ZL, r27 //offset the volume table by the main volume
002eec 1df2                      	adc ZH, zero
002eed 91b4                      	lpm r27, Z
002eee 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002ef0 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002ef1 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002ef3 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002ef4 91a0 2860                 	lds r26, pulse1_fx_7xy_value
002ef6 30a0                      	cpi r26, 0x00
002ef7 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
002ef8 93b0 2806                 	sts pulse1_output_volume, r27
002efa c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
002efb 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002efc f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
002efd f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
002efe 0feb                      	add ZL, r27 //offset the volume table by the main volume
002eff 1df2                      	adc ZH, zero
002f00 91b4                      	lpm r27, Z
002f01 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002f03 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002f04 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f05 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f06 1df2                      	adc ZH, zero
002f07 91b4                      	lpm r27, Z
002f08 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002f0a c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
002f0b 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f0c f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002f0d f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002f0e 93b0 2806                 	sts pulse1_output_volume, r27
002f10 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002f11 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f12 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002f14 91e0 2830                 	lds ZL, pulse1_arpeggio_macro
002f16 91f0 2831                 	lds ZH, pulse1_arpeggio_macro+1
002f18 9630                      	adiw Z, 0
002f19 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002f1a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f1b 1fff                      	rol ZH
002f1c 91a0 2832                 	lds r26, pulse1_arpeggio_macro_offset
002f1e 0fea                      	add ZL, r26
002f1f 1df2                      	adc ZH, zero
                                 
002f20 91b0 2834                 	lds r27, pulse1_arpeggio_macro_release
002f22 17ba                      	cp r27, r26
002f23 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002f24 91a0 2833                 	lds r26, pulse1_arpeggio_macro_loop
002f26 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f27 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002f28 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
002f29 95a3                      	inc r26 //increment the macro offset
002f2a 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
002f2c 91b4                      	lpm r27, Z //load arpeggio data into r27
002f2d 38b0                      	cpi r27, 0x80 //check for macro end flag
002f2e f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002f2f c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002f30 50a1                      	subi r26, 1 //keep the offset at the end flag
002f31 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26
002f33 91b0 2835                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002f35 30b1                      	cpi r27, 0x01
002f36 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
002f37 91b0 2834                 	lds r27, pulse1_arpeggio_macro_release
002f39 3fbf                      	cpi r27, 0xFF
002f3a f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
002f3b 91b0 2833                 	lds r27, pulse1_arpeggio_macro_loop
002f3d 3fbf                      	cpi r27, 0xFF
002f3e f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002f3f c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002f40 91b0 2834                 	lds r27, pulse1_arpeggio_macro_release
002f42 3fbf                      	cpi r27, 0xFF
002f43 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
002f44 91b0 2833                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
002f46 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002f47 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
002f48 91c0 2848                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
002f4a 91d0 2849                 	lds r29, pulse1_fx_0xy_sequence+1
002f4c 9620                      	adiw r29:r28, 0
002f4d f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002f4e 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002f4f 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
002f51 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002f52 93b0 2832                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
002f54 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
002f55 91c0 2848                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
002f57 91d0 2849                 	lds r29, pulse1_fx_0xy_sequence+1
002f59 9620                      	adiw r29:r28, 0 //check for 0xy effect
002f5a f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
002f5b 95d6                      	lsr r29
002f5c 95c7                      	ror r28
002f5d 95d7                      	ror r29
002f5e 95c7                      	ror r28
002f5f 95d7                      	ror r29
002f60 95c7                      	ror r28
002f61 95d7                      	ror r29
002f62 95c7                      	ror r28
002f63 95d7                      	ror r29
002f64 95d2                      	swap r29
                                 
002f65 93c0 2848                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
002f67 93d0 2849                 	sts pulse1_fx_0xy_sequence+1, r29
002f69 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002f6a 91a0 2807                 	lds r26, pulse1_note //load the current note index
002f6c 0fac                      	add r26, r28 //add the note offset
002f6d c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002f6e 91a0 2807                 	lds r26, pulse1_note //load the current note index
002f70 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002f71 9220 2836                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002f73 9220 2837                 	sts pulse1_total_pitch_offset+1, zero
002f75 9220 283d                 	sts pulse1_total_hi_pitch_offset, zero
002f77 91a0 2835                 	lds r26, pulse1_arpeggio_macro_mode
002f79 30a1                      	cpi r26, 0x01 //absolute mode
002f7a f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
002f7b f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
002f7c c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
002f7d 91a0 2807                 	lds r26, pulse1_note //load the current note index
002f7f 0fab                      	add r26, r27 //offset the note with the arpeggio data
002f80 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002f81 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002f82 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002f83 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002f84 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002f85 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
002f86 fda7                      	sbrc r26, 7 //check if result is negative
002f87 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002f88 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
002f89 2fab                      	mov r26, r27 //move the arpeggio data into r26
002f8a c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
002f8b 91a0 2807                 	lds r26, pulse1_note //load the current note index
002f8d 0fab                      	add r26, r27 //offset the note with the arpeggio data
002f8e fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002f8f c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002f90 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002f92 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002f93 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002f94 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002f95 93a0 2807                 	sts pulse1_note, r26
002f97 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
002f98 fda7                      	sbrc r26, 7 //check if result is negative
002f99 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002f9a 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
002f9c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002f9d e0f0                      	ldi ZH, HIGH(note_table << 1)
002f9e 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002f9f 0fea                      	add ZL, r26 //add offset
002fa0 1df2                      	adc ZH, zero
002fa1 91a5                      	lpm r26, Z+ //load bytes
002fa2 91b4                      	lpm r27, Z
002fa3 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002fa5 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002fa7 93a0 2854                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002fa9 93b0 2855                 	sts pulse1_fx_3xx_target+1, r27
002fab c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
002fac 91e0 2838                 	lds ZL, pulse1_pitch_macro
002fae 91f0 2839                 	lds ZH, pulse1_pitch_macro+1
002fb0 9630                      	adiw Z, 0
002fb1 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002fb2 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002fb3 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002fb4 1fff                      	rol ZH
002fb5 91a0 283a                 	lds r26, pulse1_pitch_macro_offset
002fb7 0fea                      	add ZL, r26
002fb8 1df2                      	adc ZH, zero
                                 
002fb9 91b0 283c                 	lds r27, pulse1_pitch_macro_release
002fbb 17ba                      	cp r27, r26
002fbc f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
002fbd 91a0 283b                 	lds r26, pulse1_pitch_macro_loop
002fbf 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002fc0 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002fc1 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
002fc2 95a3                      	inc r26 //increment the macro offset
002fc3 93a0 283a                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
002fc5 91b4                      	lpm r27, Z //load pitch data into r27
002fc6 38b0                      	cpi r27, 0x80 //check for macro end flag
002fc7 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
002fc8 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002fc9 93a0 283a                 	sts pulse1_pitch_macro_offset, r26
002fcb 91b0 283c                 	lds r27, pulse1_pitch_macro_release
002fcd 3fbf                      	cpi r27, 0xFF
002fce f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
002fcf 91b0 283b                 	lds r27, pulse1_pitch_macro_loop //load the loop index
002fd1 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002fd2 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002fd3 93b0 283a                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
002fd5 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002fd6 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002fd7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002fd8 937f                      	push r23
002fd9 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002fda eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002fdb 0367                      	mulsu r22, r23
002fdc 917f                      	pop r23
002fdd 916f                      	pop r22
                                 
002fde 9416                      	lsr r1 //shift out the fractional bits
002fdf 9407                      	ror r0
002fe0 9416                      	lsr r1
002fe1 9407                      	ror r0
002fe2 9416                      	lsr r1
002fe3 9407                      	ror r0
002fe4 9416                      	lsr r1
002fe5 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
002fe6 fe13                      	sbrs r1, 3 //check if result was a negative number
002fe7 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
002fe8 efc0                      	ldi r28, 0xF0
002fe9 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
002fea 70b7                      	andi r27, 0b00000111
002feb f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
002fec e0b1                      	ldi r27, 0x01
002fed 0e0b                      	add r0, r27
002fee 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002fef 91a0 2836                 	lds r26, pulse1_total_pitch_offset
002ff1 91b0 2837                 	lds r27, pulse1_total_pitch_offset+1
002ff3 0e0a                      	add r0, r26
002ff4 1e1b                      	adc r1, r27
002ff5 9200 2836                 	sts pulse1_total_pitch_offset, r0
002ff7 9210 2837                 	sts pulse1_total_pitch_offset+1, r1
002ff9 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002ffb 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002ffd 0da0                      	add r26, r0 //offset the timer values
002ffe 1db1                      	adc r27, r1
                                 	
002fff 91c0 284c                 	lds r28, pulse1_fx_1xx_total
003001 91d0 284d                 	lds r29, pulse1_fx_1xx_total+1
003003 1bac                      	sub r26, r28
003004 0bbd                      	sbc r27, r29
003005 91c0 2850                 	lds r28, pulse1_fx_2xx_total
003007 91d0 2851                 	lds r29, pulse1_fx_2xx_total+1
003009 0fac                      	add r26, r28
00300a 1fbd                      	adc r27, r29
00300b 91c0 2864                 	lds r28, pulse1_fx_Pxx_total
00300d 91d0 2865                 	lds r29, pulse1_fx_Pxx_total+1
00300f 0fac                      	add r26, r28
003010 1fbd                      	adc r27, r29
003011 91c0 286b                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
003013 91d0 286c                 	lds r29, pulse1_fx_Qxy_total_offset+1
003015 1bac                      	sub r26, r28
003016 0bbd                      	sbc r27, r29
003017 91c0 2872                 	lds r28, pulse1_fx_Rxy_total_offset
003019 91d0 2873                 	lds r29, pulse1_fx_Rxy_total_offset+1
00301b 0fac                      	add r26, r28
00301c 1fbd                      	adc r27, r29
                                 
00301d e5c9                      	ldi r28, 0x59
00301e e0d0                      	ldi r29, 0x00
00301f 17ac                      	cp r26, r28
003020 07bd                      	cpc r27, r29
003021 f030                      	brlo sound_driver_instrument_routine_channel0_pitch_min
                                 
003022 e5ca                      	ldi r28, 0x5A
003023 e5d9                      	ldi r29, 0x59
003024 17ac                      	cp r26, r28
003025 07bd                      	cpc r27, r29
003026 f420                      	brsh sound_driver_instrument_routine_channel0_pitch_max
003027 c006                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_min:
003028 e5c9                      	ldi r28, 0x59
003029 e0d0                      	ldi r29, 0x00
00302a c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_max:
00302b e5c9                      	ldi r28, 0x59
00302c e5d9                      	ldi r29, 0x59
00302d c000                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_store:
00302e 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
003030 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
003032 91e0 283e                 	lds ZL, pulse1_hi_pitch_macro
003034 91f0 283f                 	lds ZH, pulse1_hi_pitch_macro+1
003036 9630                      	adiw Z, 0
003037 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
003038 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
003039 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00303a 1fff                      	rol ZH
00303b 91a0 2840                 	lds r26, pulse1_hi_pitch_macro_offset
00303d 0fea                      	add ZL, r26
00303e 1df2                      	adc ZH, zero
                                 
00303f 91b0 2842                 	lds r27, pulse1_hi_pitch_macro_release
003041 17ba                      	cp r27, r26
003042 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
003043 91a0 2841                 	lds r26, pulse1_hi_pitch_macro_loop
003045 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003046 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003047 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
003048 95a3                      	inc r26 //increment the macro offset
003049 93a0 2840                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
00304b 91b4                      	lpm r27, Z //load hi pitch data into r27
00304c 38b0                      	cpi r27, 0x80 //check for macro end flag
00304d f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
00304e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00304f 93a0 2840                 	sts pulse1_hi_pitch_macro_offset, r26
003051 91b0 2842                 	lds r27, pulse1_hi_pitch_macro_release
003053 3fbf                      	cpi r27, 0xFF
003054 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
003055 91b0 2841                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
003057 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003058 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
003059 93b0 2840                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
00305b cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
00305c 91b0 283d                 	lds r27, pulse1_total_hi_pitch_offset
00305e c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
00305f 91a0 283d                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
003061 0fba                      	add r27, r26
003062 93b0 283d                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
003064 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003065 937f                      	push r23
003066 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
003067 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003068 0367                      	mulsu r22, r23
003069 917f                      	pop r23
00306a 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
00306b 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00306d 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00306f 0da0                      	add r26, r0 //offset the timer values
003070 1db1                      	adc r27, r1
003071 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
003073 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
003075 91e0 2843                 	lds ZL, pulse1_duty_macro
003077 91f0 2844                 	lds ZH, pulse1_duty_macro+1
003079 9630                      	adiw Z, 0
00307a f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
00307b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00307c 1fff                      	rol ZH
00307d 91a0 2845                 	lds r26, pulse1_duty_macro_offset
00307f 0fea                      	add ZL, r26
003080 1df2                      	adc ZH, zero
                                 
003081 91b0 2847                 	lds r27, pulse1_duty_macro_release
003083 17ba                      	cp r27, r26
003084 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
003085 91a0 2846                 	lds r26, pulse1_duty_macro_loop
003087 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003088 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003089 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
00308a 95a3                      	inc r26 //increment the macro offset
00308b 93a0 2845                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
00308d 91b4                      	lpm r27, Z //load pitch data into r27
00308e 3fbf                      	cpi r27, 0xFF //check for macro end flag
00308f f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
003090 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003091 93a0 2845                 	sts pulse1_duty_macro_offset, r26
003093 91b0 2847                 	lds r27, pulse1_duty_macro_release
003095 3fbf                      	cpi r27, 0xFF
003096 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
003097 91b0 2846                 	lds r27, pulse1_duty_macro_loop //load the loop index
003099 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00309a f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00309b 93b0 2845                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
00309d cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
00309e ede0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00309f e7f4                      	ldi ZH, HIGH(sequences << 1)
0030a0 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0030a1 1df2                      	adc ZH, zero
                                 
0030a2 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0030a3 95b7                      	ror r27
0030a4 95b7                      	ror r27
0030a5 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0030a7 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0030a8 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0030a9 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0030aa c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0030ab c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0030ac 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
0030ad 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0030ae 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0030af 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0030b1 91e0 284a                 	lds ZL, pulse1_fx_1xx
0030b3 91f0 284b                 	lds ZH, pulse1_fx_1xx+1
0030b5 9630                      	adiw Z, 0
0030b6 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0030b7 91a0 284c                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0030b9 91b0 284d                 	lds r27, pulse1_fx_1xx_total+1
0030bb 0fae                      	add r26, ZL //increase the total offset by the rate
0030bc 1fbf                      	adc r27, ZH
0030bd 93a0 284c                 	sts pulse1_fx_1xx_total, r26
0030bf 93b0 284d                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0030c1 91e0 284e                 	lds ZL, pulse1_fx_2xx
0030c3 91f0 284f                 	lds ZH, pulse1_fx_2xx+1
0030c5 9630                      	adiw Z, 0
0030c6 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0030c7 91a0 2850                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0030c9 91b0 2851                 	lds r27, pulse1_fx_2xx_total+1
0030cb 0fae                      	add r26, ZL //increase the total offset by the rate
0030cc 1fbf                      	adc r27, ZH
0030cd 93a0 2850                 	sts pulse1_fx_2xx_total, r26
0030cf 93b0 2851                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0030d1 91e0 2856                 	lds ZL, pulse1_fx_3xx_speed
0030d3 91f0 2857                 	lds ZH, pulse1_fx_3xx_speed+1
0030d5 9630                      	adiw Z, 0
0030d6 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0030d7 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0030d8 91a0 2852                 	lds r26, pulse1_fx_3xx_start
0030da 91b0 2853                 	lds r27, pulse1_fx_3xx_start+1
0030dc 9610                      	adiw r26:r27, 0
0030dd f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0030de c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0030df 91c0 2854                 	lds r28, pulse1_fx_3xx_target
0030e1 91d0 2855                 	lds r29, pulse1_fx_3xx_target+1
                                 
0030e3 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0030e4 07bd                      	cpc r27, r29
0030e5 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0030e6 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0030e7 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0030e8 9220 2852                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0030ea 9220 2853                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0030ec c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0030ed 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0030ee 0bdb                      	sbc r29, r27
0030ef 91a0 2858                 	lds r26, pulse1_fx_3xx_total_offset
0030f1 91b0 2859                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0030f3 0fae                      	add r26, ZL //add the speed to the total offset
0030f4 1fbf                      	adc r27, ZH
0030f5 1bca                      	sub r28, r26 //invert the total difference with the total offset
0030f6 0bdb                      	sbc r29, r27
0030f7 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0030f8 93a0 2858                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0030fa 93b0 2859                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0030fc 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0030fe 91b0 0a8d                 	lds r27, TCB0_CCMPH
003100 1bac                      	sub r26, r28 //offset the current timer period with the total offset
003101 0bbd                      	sbc r27, r29
003102 93a0 0a8c                 	sts TCB0_CCMPL, r26
003104 93b0 0a8d                 	sts TCB0_CCMPH, r27
003106 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
003107 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
003108 0bbd                      	sbc r27, r29
003109 91c0 2858                 	lds r28, pulse1_fx_3xx_total_offset
00310b 91d0 2859                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
00310d 0fce                      	add r28, ZL //add the speed to the total offset
00310e 1fdf                      	adc r29, ZH
00310f 1bac                      	sub r26, r28 //invert the total difference with the total offset
003110 0bbd                      	sbc r27, r29
003111 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
003112 93c0 2858                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
003114 93d0 2859                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
003116 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
003118 91d0 0a8d                 	lds r29, TCB0_CCMPH
00311a 0fca                      	add r28, r26 //offset the current timer period with the total offset
00311b 1fdb                      	adc r29, r27
00311c 93c0 0a8c                 	sts TCB0_CCMPL, r28
00311e 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
003120 91a0 285a                 	lds r26, pulse1_fx_4xy_speed
003122 15a2                      	cp r26, zero
003123 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
003124 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
003125 91b0 285b                 	lds r27, pulse1_fx_4xy_depth
003127 91c0 285c                 	lds r28, pulse1_fx_4xy_phase
003129 0fca                      	add r28, r26 //increase the phase by the speed
00312a 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00312b f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00312c e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
00312d 93c0 285c                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
00312f 31c0                      	cpi r28, 16
003130 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
003131 32c0                      	cpi r28, 32
003132 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
003133 33c0                      	cpi r28, 48
003134 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
003135 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
003136 70cf                      	andi r28, 0x0F //mask for values 0-15
003137 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
003138 6fc0                      	ori r28, 0xF0
003139 95c0                      	com r28 //invert values 0-15
00313a c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
00313b 70cf                      	andi r28, 0x0F //mask for values 0-15
00313c c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
00313d 6fc0                      	ori r28, 0xF0
00313e 95c0                      	com r28 //invert values 0-15
00313f c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
003140 95b2                      	swap r27 //multiply depth by 16
003141 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003142 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003143 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003144 0fec                      	add ZL, r28 //offset the table by the depth+phase
003145 1df2                      	adc ZH, zero
003146 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
003147 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003148 937f                      	push r23
003149 2f6c                      	mov r22, r28 //store the vibrato value into r22
00314a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00314b 9f67                      	mul r22, r23
00314c 917f                      	pop r23
00314d 916f                      	pop r22
                                 
00314e 9416                      	lsr r1 //shift out the fractional bits
00314f 9407                      	ror r0
003150 9416                      	lsr r1
003151 9407                      	ror r0
003152 9416                      	lsr r1
003153 9407                      	ror r0
003154 9416                      	lsr r1
003155 9407                      	ror r0
                                 	
003156 91a0 0a8c                 	lds r26, TCB0_CCMPL
003158 91b0 0a8d                 	lds r27, TCB0_CCMPH
00315a 0da0                      	add r26, r0
00315b 1db1                      	adc r27, r1
00315c 93a0 0a8c                 	sts TCB0_CCMPL, r26
00315e 93b0 0a8d                 	sts TCB0_CCMPH, r27
003160 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
003161 95b2                      	swap r27 //multiply depth by 16
003162 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
003163 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003164 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003165 0fec                      	add ZL, r28 //offset the table by the depth+phase
003166 1df2                      	adc ZH, zero
003167 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003168 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003169 937f                      	push r23
00316a 2f6c                      	mov r22, r28 //store the vibrato value into r22
00316b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00316c 9f67                      	mul r22, r23
00316d 917f                      	pop r23
00316e 916f                      	pop r22
                                 
00316f 9416                      	lsr r1 //shift out the fractional bits
003170 9407                      	ror r0
003171 9416                      	lsr r1
003172 9407                      	ror r0
003173 9416                      	lsr r1
003174 9407                      	ror r0
003175 9416                      	lsr r1
003176 9407                      	ror r0
                                 
003177 91a0 0a8c                 	lds r26, TCB0_CCMPL
003179 91b0 0a8d                 	lds r27, TCB0_CCMPH
00317b 19a0                      	sub r26, r0
00317c 09b1                      	sbc r27, r1
00317d 93a0 0a8c                 	sts TCB0_CCMPL, r26
00317f 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
003181 91a0 285d                 	lds r26, pulse1_fx_7xy_speed
003183 15a2                      	cp r26, zero
003184 f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
003185 91b0 285e                 	lds r27, pulse1_fx_7xy_depth
003187 91c0 285f                 	lds r28, pulse1_fx_7xy_phase
003189 0fca                      	add r28, r26 //increase the phase by the speed
00318a 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00318b f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00318c e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
00318d 93c0 285f                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
00318f 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
003190 ffc4                      	sbrs r28, 4
003191 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
003192 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
003193 70cf                      	andi r28, 0x0F //mask for values 0-15
003194 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
003195 6fc0                      	ori r28, 0xF0
003196 95c0                      	com r28 //invert values 0-15
003197 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
003198 95b2                      	swap r27 //multiply depth by 16
003199 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00319a e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00319b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00319c 0fec                      	add ZL, r28 //offset the table by the depth+phase
00319d 1df2                      	adc ZH, zero
00319e 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00319f 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0031a0 93c0 2860                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
0031a2 91b0 2861                 	lds r27, pulse1_fx_Axy
0031a4 15b2                      	cp r27, zero
0031a5 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0031a6 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0031a8 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0031aa 2fda                      	mov r29, r26 //copy fractional volume into r29
0031ab 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0031ac 95e2                      	swap r30
0031ad 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0031ae 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0031af 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0031b0 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0031b1 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0031b2 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0031b3 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0031b4 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0031b5 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0031b6 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0031b7 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0031b8 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0031b9 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0031ba e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0031bb 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0031bd 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0031be 95a2                      	swap r26
0031bf 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0031c0 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0031c1 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0031c3 91e0 2867                 	lds ZL, pulse1_fx_Qxy_target
0031c5 91f0 2868                 	lds ZH, pulse1_fx_Qxy_target+1
0031c7 9630                      	adiw Z, 0
0031c8 f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0031c9 91a0 286b                 	lds r26, pulse1_fx_Qxy_total_offset
0031cb 91b0 286c                 	lds r27, pulse1_fx_Qxy_total_offset+1
0031cd 91c0 0a8c                 	lds r28, TCB0_CCMPL
0031cf 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0031d1 1bec                      	sub ZL, r28 //calculate the difference to the target
0031d2 0bfd                      	sbc ZH, r29
0031d3 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0031d4 f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0031d5 9220 286b                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
0031d7 9220 286c                 	sts pulse1_fx_Qxy_total_offset+1, zero
0031d9 9220 2867                 	sts pulse1_fx_Qxy_target, zero
0031db 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
0031dd 91b0 2866                 	lds r27, pulse1_fx_Qxy_target_note
0031df 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
0031e1 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0031e2 91c0 2869                 	lds r28, pulse1_fx_Qxy_speed
0031e4 91d0 286a                 	lds r29, pulse1_fx_Qxy_speed+1
0031e6 0fac                      	add r26, r28 //increase the total offset by the speed
0031e7 1fbd                      	adc r27, r29
0031e8 93a0 286b                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0031ea 93b0 286c                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0031ec 91e0 286e                 	lds ZL, pulse1_fx_Rxy_target
0031ee 91f0 286f                 	lds ZH, pulse1_fx_Rxy_target+1
0031f0 9630                      	adiw Z, 0
0031f1 f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0031f2 91a0 2872                 	lds r26, pulse1_fx_Rxy_total_offset
0031f4 91b0 2873                 	lds r27, pulse1_fx_Rxy_total_offset+1
0031f6 91c0 0a8c                 	lds r28, TCB0_CCMPL
0031f8 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0031fa 1bce                      	sub r28, ZL //calculate the difference to the target
0031fb 0bdf                      	sbc r29, ZH
0031fc f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0031fd f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0031fe 9220 2872                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
003200 9220 2873                 	sts pulse1_fx_Rxy_total_offset+1, zero
003202 9220 286e                 	sts pulse1_fx_Rxy_target, zero
003204 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
003206 91b0 286d                 	lds r27, pulse1_fx_Rxy_target_note
003208 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
00320a c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
00320b 91c0 2870                 	lds r28, pulse1_fx_Rxy_speed
00320d 91d0 2871                 	lds r29, pulse1_fx_Rxy_speed+1
00320f 0fac                      	add r26, r28 //increase the total offset by the speed
003210 1fbd                      	adc r27, r29
003211 93a0 2872                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
003213 93b0 2873                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
003215 91e0 287c                 	lds ZL, pulse2_volume_macro
003217 91f0 287d                 	lds ZH, pulse2_volume_macro+1
003219 9630                      	adiw Z, 0
00321a f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
00321b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00321c 1fff                      	rol ZH
00321d 91a0 287e                 	lds r26, pulse2_volume_macro_offset
00321f 0fea                      	add ZL, r26
003220 1df2                      	adc ZH, zero
                                 
003221 91b0 2880                 	lds r27, pulse2_volume_macro_release
003223 17ba                      	cp r27, r26
003224 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
003225 91a0 287f                 	lds r26, pulse2_volume_macro_loop
003227 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003228 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003229 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
00322a 95a3                      	inc r26 //increment the macro offset
00322b 93a0 287e                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
00322d 91b4                      	lpm r27, Z //load volume data into r27
00322e 3fbf                      	cpi r27, 0xFF //check for macro end flag
00322f f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
003230 91b0 2880                 	lds r27, pulse2_volume_macro_release
003232 3fbf                      	cpi r27, 0xFF
003233 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
003234 91b0 287f                 	lds r27, pulse2_volume_macro_loop //load the loop index
003236 93b0 287e                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
003238 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
003239 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00323a 93a0 287e                 	sts pulse2_volume_macro_offset, r26
00323c cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
00323d ede8                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
00323e e7f5                      	ldi ZH, HIGH(volumes << 1)
00323f 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
003240 0feb                      	add ZL, r27 //add offset to the table
003241 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
003242 91b0 2808                 	lds r27, pulse2_param //load main volume
003244 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
003245 91a0 28b1                 	lds r26, pulse2_fx_7xy_value
003247 30a0                      	cpi r26, 0x00
003248 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
003249 0feb                      	add ZL, r27 //offset the volume table by the main volume
00324a 1df2                      	adc ZH, zero
00324b 91b4                      	lpm r27, Z
00324c 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00324e c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
00324f 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
003251 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
003252 91a0 28b1                 	lds r26, pulse2_fx_7xy_value
003254 30a0                      	cpi r26, 0x00
003255 f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
003256 93b0 280e                 	sts pulse2_output_volume, r27
003258 c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
003259 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00325a f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
00325b f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
00325c 0feb                      	add ZL, r27 //offset the volume table by the main volume
00325d 1df2                      	adc ZH, zero
00325e 91b4                      	lpm r27, Z
00325f 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
003261 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
003262 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
003263 0feb                      	add ZL, r27 //offset the volume table by the main volume
003264 1df2                      	adc ZH, zero
003265 91b4                      	lpm r27, Z
003266 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
003268 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
003269 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00326a f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00326b f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00326c 93b0 280e                 	sts pulse2_output_volume, r27
00326e c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
00326f e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
003270 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
003272 91e0 2881                 	lds ZL, pulse2_arpeggio_macro
003274 91f0 2882                 	lds ZH, pulse2_arpeggio_macro+1
003276 9630                      	adiw Z, 0
003277 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
003278 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
003279 1fff                      	rol ZH
00327a 91a0 2883                 	lds r26, pulse2_arpeggio_macro_offset
00327c 0fea                      	add ZL, r26
00327d 1df2                      	adc ZH, zero
                                 
00327e 91b0 2885                 	lds r27, pulse2_arpeggio_macro_release
003280 17ba                      	cp r27, r26
003281 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
003282 91a0 2884                 	lds r26, pulse2_arpeggio_macro_loop
003284 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003285 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
003286 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
003287 95a3                      	inc r26 //increment the macro offset
003288 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
00328a 91b4                      	lpm r27, Z //load arpeggio data into r27
00328b 38b0                      	cpi r27, 0x80 //check for macro end flag
00328c f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
00328d c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
00328e 50a1                      	subi r26, 1 //keep the offset at the end flag
00328f 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26
003291 91b0 2886                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
003293 30b1                      	cpi r27, 0x01
003294 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
003295 91b0 2885                 	lds r27, pulse2_arpeggio_macro_release
003297 3fbf                      	cpi r27, 0xFF
003298 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
003299 91b0 2884                 	lds r27, pulse2_arpeggio_macro_loop
00329b 3fbf                      	cpi r27, 0xFF
00329c f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00329d c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
00329e 91b0 2885                 	lds r27, pulse2_arpeggio_macro_release
0032a0 3fbf                      	cpi r27, 0xFF
0032a1 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
0032a2 91b0 2884                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
0032a4 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0032a5 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
0032a6 91c0 2899                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
0032a8 91d0 289a                 	lds r29, pulse2_fx_0xy_sequence+1
0032aa 9620                      	adiw r29:r28, 0
0032ab f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0032ac 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0032ad 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
0032af cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
0032b0 93b0 2883                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
0032b2 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
0032b3 91c0 2899                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
0032b5 91d0 289a                 	lds r29, pulse2_fx_0xy_sequence+1
0032b7 9620                      	adiw r29:r28, 0 //check for 0xy effect
0032b8 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
0032b9 95d6                      	lsr r29
0032ba 95c7                      	ror r28
0032bb 95d7                      	ror r29
0032bc 95c7                      	ror r28
0032bd 95d7                      	ror r29
0032be 95c7                      	ror r28
0032bf 95d7                      	ror r29
0032c0 95c7                      	ror r28
0032c1 95d7                      	ror r29
0032c2 95d2                      	swap r29
                                 
0032c3 93c0 2899                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
0032c5 93d0 289a                 	sts pulse2_fx_0xy_sequence+1, r29
0032c7 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0032c8 91a0 280f                 	lds r26, pulse2_note //load the current note index
0032ca 0fac                      	add r26, r28 //add the note offset
0032cb c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0032cc 91a0 280f                 	lds r26, pulse2_note //load the current note index
0032ce c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0032cf 9220 2887                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0032d1 9220 2888                 	sts pulse2_total_pitch_offset+1, zero
0032d3 9220 288e                 	sts pulse2_total_hi_pitch_offset, zero
0032d5 91a0 2886                 	lds r26, pulse2_arpeggio_macro_mode
0032d7 30a1                      	cpi r26, 0x01 //absolute mode
0032d8 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0032d9 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0032da c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0032db 91a0 280f                 	lds r26, pulse2_note //load the current note index
0032dd 0fab                      	add r26, r27 //offset the note with the arpeggio data
0032de fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0032df c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0032e0 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0032e1 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0032e2 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0032e3 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0032e4 fda7                      	sbrc r26, 7 //check if result is negative
0032e5 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0032e6 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0032e7 2fab                      	mov r26, r27 //move the arpeggio data into r26
0032e8 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0032e9 91a0 280f                 	lds r26, pulse2_note //load the current note index
0032eb 0fab                      	add r26, r27 //offset the note with the arpeggio data
0032ec fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0032ed c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0032ee 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0032f0 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0032f1 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0032f2 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0032f3 93a0 280f                 	sts pulse2_note, r26
0032f5 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0032f6 fda7                      	sbrc r26, 7 //check if result is negative
0032f7 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0032f8 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
0032fa e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0032fb e0f0                      	ldi ZH, HIGH(note_table << 1)
0032fc 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0032fd 0fea                      	add ZL, r26 //add offset
0032fe 1df2                      	adc ZH, zero
0032ff 91a5                      	lpm r26, Z+ //load bytes
003300 91b4                      	lpm r27, Z
003301 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
003303 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
003305 93a0 28a5                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
003307 93b0 28a6                 	sts pulse2_fx_3xx_target+1, r27
003309 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
00330a 91e0 2889                 	lds ZL, pulse2_pitch_macro
00330c 91f0 288a                 	lds ZH, pulse2_pitch_macro+1
00330e 9630                      	adiw Z, 0
00330f f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
003310 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
003311 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003312 1fff                      	rol ZH
003313 91a0 288b                 	lds r26, pulse2_pitch_macro_offset
003315 0fea                      	add ZL, r26
003316 1df2                      	adc ZH, zero
                                 
003317 91b0 288d                 	lds r27, pulse2_pitch_macro_release
003319 17ba                      	cp r27, r26
00331a f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
00331b 91a0 288c                 	lds r26, pulse2_pitch_macro_loop
00331d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00331e f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00331f c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
003320 95a3                      	inc r26 //increment the macro offset
003321 93a0 288b                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
003323 91b4                      	lpm r27, Z //load pitch data into r27
003324 38b0                      	cpi r27, 0x80 //check for macro end flag
003325 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
003326 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003327 93a0 288b                 	sts pulse2_pitch_macro_offset, r26
003329 91b0 288d                 	lds r27, pulse2_pitch_macro_release
00332b 3fbf                      	cpi r27, 0xFF
00332c f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
00332d 91b0 288c                 	lds r27, pulse2_pitch_macro_loop //load the loop index
00332f 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003330 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
003331 93b0 288b                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
003333 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
003334 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
003335 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003336 937f                      	push r23
003337 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
003338 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003339 0367                      	mulsu r22, r23
00333a 917f                      	pop r23
00333b 916f                      	pop r22
                                 
00333c 9416                      	lsr r1 //shift out the fractional bits
00333d 9407                      	ror r0
00333e 9416                      	lsr r1
00333f 9407                      	ror r0
003340 9416                      	lsr r1
003341 9407                      	ror r0
003342 9416                      	lsr r1
003343 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
003344 fe13                      	sbrs r1, 3 //check if result was a negative number
003345 c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
003346 efc0                      	ldi r28, 0xF0
003347 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
003348 70b7                      	andi r27, 0b00000111
003349 f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
00334a e0b1                      	ldi r27, 0x01
00334b 0e0b                      	add r0, r27
00334c 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
00334d 91a0 2887                 	lds r26, pulse2_total_pitch_offset
00334f 91b0 2888                 	lds r27, pulse2_total_pitch_offset+1
003351 0e0a                      	add r0, r26
003352 1e1b                      	adc r1, r27
003353 9200 2887                 	sts pulse2_total_pitch_offset, r0
003355 9210 2888                 	sts pulse2_total_pitch_offset+1, r1
003357 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
003359 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
00335b 0da0                      	add r26, r0 //offset the timer values
00335c 1db1                      	adc r27, r1
                                 	
00335d 91c0 289d                 	lds r28, pulse2_fx_1xx_total
00335f 91d0 289e                 	lds r29, pulse2_fx_1xx_total+1
003361 1bac                      	sub r26, r28
003362 0bbd                      	sbc r27, r29
003363 91c0 28a1                 	lds r28, pulse2_fx_2xx_total
003365 91d0 28a2                 	lds r29, pulse2_fx_2xx_total+1
003367 0fac                      	add r26, r28
003368 1fbd                      	adc r27, r29
003369 91c0 28b5                 	lds r28, pulse2_fx_Pxx_total
00336b 91d0 28b6                 	lds r29, pulse2_fx_Pxx_total+1
00336d 0fac                      	add r26, r28
00336e 1fbd                      	adc r27, r29
00336f 91c0 28bc                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
003371 91d0 28bd                 	lds r29, pulse2_fx_Qxy_total_offset+1
003373 1bac                      	sub r26, r28
003374 0bbd                      	sbc r27, r29
003375 91c0 28c3                 	lds r28, pulse2_fx_Rxy_total_offset
003377 91d0 28c4                 	lds r29, pulse2_fx_Rxy_total_offset+1
003379 0fac                      	add r26, r28
00337a 1fbd                      	adc r27, r29
                                 
00337b e5c9                      	ldi r28, 0x59
00337c e0d0                      	ldi r29, 0x00
00337d 17ac                      	cp r26, r28
00337e 07bd                      	cpc r27, r29
00337f f030                      	brlo sound_driver_instrument_routine_channel1_pitch_min
                                 
003380 e5ca                      	ldi r28, 0x5A
003381 e5d9                      	ldi r29, 0x59
003382 17ac                      	cp r26, r28
003383 07bd                      	cpc r27, r29
003384 f420                      	brsh sound_driver_instrument_routine_channel1_pitch_max
003385 c006                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_min:
003386 e5c9                      	ldi r28, 0x59
003387 e0d0                      	ldi r29, 0x00
003388 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_max:
003389 e5c9                      	ldi r28, 0x59
00338a e5d9                      	ldi r29, 0x59
00338b c000                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_store:
00338c 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
00338e 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
003390 91e0 288f                 	lds ZL, pulse2_hi_pitch_macro
003392 91f0 2890                 	lds ZH, pulse2_hi_pitch_macro+1
003394 9630                      	adiw Z, 0
003395 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
003396 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
003397 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003398 1fff                      	rol ZH
003399 91a0 2891                 	lds r26, pulse2_hi_pitch_macro_offset
00339b 0fea                      	add ZL, r26
00339c 1df2                      	adc ZH, zero
                                 
00339d 91b0 2893                 	lds r27, pulse2_hi_pitch_macro_release
00339f 17ba                      	cp r27, r26
0033a0 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0033a1 91a0 2892                 	lds r26, pulse2_hi_pitch_macro_loop
0033a3 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0033a4 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0033a5 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
0033a6 95a3                      	inc r26 //increment the macro offset
0033a7 93a0 2891                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
0033a9 91b4                      	lpm r27, Z //load hi pitch data into r27
0033aa 38b0                      	cpi r27, 0x80 //check for macro end flag
0033ab f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
0033ac 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0033ad 93a0 2891                 	sts pulse2_hi_pitch_macro_offset, r26
0033af 91b0 2893                 	lds r27, pulse2_hi_pitch_macro_release
0033b1 3fbf                      	cpi r27, 0xFF
0033b2 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
0033b3 91b0 2892                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
0033b5 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0033b6 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0033b7 93b0 2891                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
0033b9 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
0033ba 91b0 288e                 	lds r27, pulse2_total_hi_pitch_offset
0033bc c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
0033bd 91a0 288e                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
0033bf 0fba                      	add r27, r26
0033c0 93b0 288e                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
0033c2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0033c3 937f                      	push r23
0033c4 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0033c5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0033c6 0367                      	mulsu r22, r23
0033c7 917f                      	pop r23
0033c8 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
0033c9 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0033cb 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0033cd 0da0                      	add r26, r0 //offset the timer values
0033ce 1db1                      	adc r27, r1
0033cf 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0033d1 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
0033d3 91e0 2894                 	lds ZL, pulse2_duty_macro
0033d5 91f0 2895                 	lds ZH, pulse2_duty_macro+1
0033d7 9630                      	adiw Z, 0
0033d8 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
0033d9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0033da 1fff                      	rol ZH
0033db 91a0 2896                 	lds r26, pulse2_duty_macro_offset
0033dd 0fea                      	add ZL, r26
0033de 1df2                      	adc ZH, zero
                                 
0033df 91b0 2898                 	lds r27, pulse2_duty_macro_release
0033e1 17ba                      	cp r27, r26
0033e2 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
0033e3 91a0 2897                 	lds r26, pulse2_duty_macro_loop
0033e5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0033e6 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0033e7 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
0033e8 95a3                      	inc r26 //increment the macro offset
0033e9 93a0 2896                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
0033eb 91b4                      	lpm r27, Z //load pitch data into r27
0033ec 3fbf                      	cpi r27, 0xFF //check for macro end flag
0033ed f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
0033ee 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0033ef 93a0 2896                 	sts pulse2_duty_macro_offset, r26
0033f1 91b0 2898                 	lds r27, pulse2_duty_macro_release
0033f3 3fbf                      	cpi r27, 0xFF
0033f4 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
0033f5 91b0 2897                 	lds r27, pulse2_duty_macro_loop //load the loop index
0033f7 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0033f8 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0033f9 93b0 2896                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
0033fb cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
0033fc ede0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0033fd e7f4                      	ldi ZH, HIGH(sequences << 1)
0033fe 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0033ff 1df2                      	adc ZH, zero
                                 
003400 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
003401 95b7                      	ror r27
003402 95b7                      	ror r27
003403 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
003405 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
003406 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
003407 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
003408 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
003409 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
00340a 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
00340b 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00340c 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00340d 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
00340f 91e0 289b                 	lds ZL, pulse2_fx_1xx
003411 91f0 289c                 	lds ZH, pulse2_fx_1xx+1
003413 9630                      	adiw Z, 0
003414 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
003415 91a0 289d                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
003417 91b0 289e                 	lds r27, pulse2_fx_1xx_total+1
003419 0fae                      	add r26, ZL //increase the total offset by the rate
00341a 1fbf                      	adc r27, ZH
00341b 93a0 289d                 	sts pulse2_fx_1xx_total, r26
00341d 93b0 289e                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
00341f 91e0 289f                 	lds ZL, pulse2_fx_2xx
003421 91f0 28a0                 	lds ZH, pulse2_fx_2xx+1
003423 9630                      	adiw Z, 0
003424 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
003425 91a0 28a1                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
003427 91b0 28a2                 	lds r27, pulse2_fx_2xx_total+1
003429 0fae                      	add r26, ZL //increase the total offset by the rate
00342a 1fbf                      	adc r27, ZH
00342b 93a0 28a1                 	sts pulse2_fx_2xx_total, r26
00342d 93b0 28a2                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
00342f 91e0 28a7                 	lds ZL, pulse2_fx_3xx_speed
003431 91f0 28a8                 	lds ZH, pulse2_fx_3xx_speed+1
003433 9630                      	adiw Z, 0
003434 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
003435 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
003436 91a0 28a3                 	lds r26, pulse2_fx_3xx_start
003438 91b0 28a4                 	lds r27, pulse2_fx_3xx_start+1
00343a 9610                      	adiw r26:r27, 0
00343b f409                      	brne sound_driver_channel1_fx_3xx_routine_main
00343c c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
00343d 91c0 28a5                 	lds r28, pulse2_fx_3xx_target
00343f 91d0 28a6                 	lds r29, pulse2_fx_3xx_target+1
                                 
003441 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
003442 07bd                      	cpc r27, r29
003443 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
003444 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
003445 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
003446 9220 28a3                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
003448 9220 28a4                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
00344a c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
00344b 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
00344c 0bdb                      	sbc r29, r27
00344d 91a0 28a9                 	lds r26, pulse2_fx_3xx_total_offset
00344f 91b0 28aa                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
003451 0fae                      	add r26, ZL //add the speed to the total offset
003452 1fbf                      	adc r27, ZH
003453 1bca                      	sub r28, r26 //invert the total difference with the total offset
003454 0bdb                      	sbc r29, r27
003455 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
003456 93a0 28a9                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
003458 93b0 28aa                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
00345a 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
00345c 91b0 0a9d                 	lds r27, TCB1_CCMPH
00345e 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00345f 0bbd                      	sbc r27, r29
003460 93a0 0a9c                 	sts TCB1_CCMPL, r26
003462 93b0 0a9d                 	sts TCB1_CCMPH, r27
003464 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
003465 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
003466 0bbd                      	sbc r27, r29
003467 91c0 28a9                 	lds r28, pulse2_fx_3xx_total_offset
003469 91d0 28aa                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
00346b 0fce                      	add r28, ZL //add the speed to the total offset
00346c 1fdf                      	adc r29, ZH
00346d 1bac                      	sub r26, r28 //invert the total difference with the total offset
00346e 0bbd                      	sbc r27, r29
00346f f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
003470 93c0 28a9                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
003472 93d0 28aa                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
003474 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
003476 91d0 0a9d                 	lds r29, TCB1_CCMPH
003478 0fca                      	add r28, r26 //offset the current timer period with the total offset
003479 1fdb                      	adc r29, r27
00347a 93c0 0a9c                 	sts TCB1_CCMPL, r28
00347c 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
00347e 91a0 28ab                 	lds r26, pulse2_fx_4xy_speed
003480 15a2                      	cp r26, zero
003481 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
003482 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
003483 91b0 28ac                 	lds r27, pulse2_fx_4xy_depth
003485 91c0 28ad                 	lds r28, pulse2_fx_4xy_phase
003487 0fca                      	add r28, r26 //increase the phase by the speed
003488 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
003489 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00348a e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
00348b 93c0 28ad                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
00348d 31c0                      	cpi r28, 16
00348e f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
00348f 32c0                      	cpi r28, 32
003490 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
003491 33c0                      	cpi r28, 48
003492 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
003493 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
003494 70cf                      	andi r28, 0x0F //mask for values 0-15
003495 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
003496 6fc0                      	ori r28, 0xF0
003497 95c0                      	com r28 //invert values 0-15
003498 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
003499 70cf                      	andi r28, 0x0F //mask for values 0-15
00349a c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
00349b 6fc0                      	ori r28, 0xF0
00349c 95c0                      	com r28 //invert values 0-15
00349d c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
00349e 95b2                      	swap r27 //multiply depth by 16
00349f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0034a0 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0034a1 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0034a2 0fec                      	add ZL, r28 //offset the table by the depth+phase
0034a3 1df2                      	adc ZH, zero
0034a4 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0034a5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0034a6 937f                      	push r23
0034a7 2f6c                      	mov r22, r28 //store the vibrato value into r22
0034a8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0034a9 9f67                      	mul r22, r23
0034aa 917f                      	pop r23
0034ab 916f                      	pop r22
                                 
0034ac 9416                      	lsr r1 //shift out the fractional bits
0034ad 9407                      	ror r0
0034ae 9416                      	lsr r1
0034af 9407                      	ror r0
0034b0 9416                      	lsr r1
0034b1 9407                      	ror r0
0034b2 9416                      	lsr r1
0034b3 9407                      	ror r0
                                 	
0034b4 91a0 0a9c                 	lds r26, TCB1_CCMPL
0034b6 91b0 0a9d                 	lds r27, TCB1_CCMPH
0034b8 0da0                      	add r26, r0
0034b9 1db1                      	adc r27, r1
0034ba 93a0 0a9c                 	sts TCB1_CCMPL, r26
0034bc 93b0 0a9d                 	sts TCB1_CCMPH, r27
0034be c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
0034bf 95b2                      	swap r27 //multiply depth by 16
0034c0 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0034c1 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0034c2 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0034c3 0fec                      	add ZL, r28 //offset the table by the depth+phase
0034c4 1df2                      	adc ZH, zero
0034c5 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0034c6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0034c7 937f                      	push r23
0034c8 2f6c                      	mov r22, r28 //store the vibrato value into r22
0034c9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0034ca 9f67                      	mul r22, r23
0034cb 917f                      	pop r23
0034cc 916f                      	pop r22
                                 
0034cd 9416                      	lsr r1 //shift out the fractional bits
0034ce 9407                      	ror r0
0034cf 9416                      	lsr r1
0034d0 9407                      	ror r0
0034d1 9416                      	lsr r1
0034d2 9407                      	ror r0
0034d3 9416                      	lsr r1
0034d4 9407                      	ror r0
                                 
0034d5 91a0 0a9c                 	lds r26, TCB1_CCMPL
0034d7 91b0 0a9d                 	lds r27, TCB1_CCMPH
0034d9 19a0                      	sub r26, r0
0034da 09b1                      	sbc r27, r1
0034db 93a0 0a9c                 	sts TCB1_CCMPL, r26
0034dd 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
0034df 91a0 28ae                 	lds r26, pulse2_fx_7xy_speed
0034e1 15a2                      	cp r26, zero
0034e2 f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0034e3 91b0 28af                 	lds r27, pulse2_fx_7xy_depth
0034e5 91c0 28b0                 	lds r28, pulse2_fx_7xy_phase
0034e7 0fca                      	add r28, r26 //increase the phase by the speed
0034e8 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0034e9 f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0034ea e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
0034eb 93c0 28b0                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
0034ed 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0034ee ffc4                      	sbrs r28, 4
0034ef c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
0034f0 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
0034f1 70cf                      	andi r28, 0x0F //mask for values 0-15
0034f2 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
0034f3 6fc0                      	ori r28, 0xF0
0034f4 95c0                      	com r28 //invert values 0-15
0034f5 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
0034f6 95b2                      	swap r27 //multiply depth by 16
0034f7 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0034f8 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0034f9 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0034fa 0fec                      	add ZL, r28 //offset the table by the depth+phase
0034fb 1df2                      	adc ZH, zero
0034fc 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0034fd 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0034fe 93c0 28b1                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
003500 91b0 28b2                 	lds r27, pulse2_fx_Axy
003502 15b2                      	cp r27, zero
003503 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
003504 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
003506 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
003508 2fda                      	mov r29, r26 //copy fractional volume into r29
003509 2fec                      	mov r30, r28 //copy the pulse2_param into r30
00350a 95e2                      	swap r30
00350b 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
00350c 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
00350d 17ed                      	cp r30, r29 //compare the fractional and integer volumes
00350e f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
00350f 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
003510 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
003511 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
003512 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
003513 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
003514 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
003515 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
003516 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
003517 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
003518 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
003519 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
00351b 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
00351c 95a2                      	swap r26
00351d 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
00351e 2bca                      	or r28, r26 //store the new volume back into pulse2_param
00351f 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
003521 91e0 28b8                 	lds ZL, pulse2_fx_Qxy_target
003523 91f0 28b9                 	lds ZH, pulse2_fx_Qxy_target+1
003525 9630                      	adiw Z, 0
003526 f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
003527 91a0 28bc                 	lds r26, pulse2_fx_Qxy_total_offset
003529 91b0 28bd                 	lds r27, pulse2_fx_Qxy_total_offset+1
00352b 91c0 0a9c                 	lds r28, TCB1_CCMPL
00352d 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
00352f 1bec                      	sub ZL, r28 //calculate the difference to the target
003530 0bfd                      	sbc ZH, r29
003531 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
003532 f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
003533 9220 28bc                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
003535 9220 28bd                 	sts pulse2_fx_Qxy_total_offset+1, zero
003537 9220 28b8                 	sts pulse2_fx_Qxy_target, zero
003539 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
00353b 91b0 28b7                 	lds r27, pulse2_fx_Qxy_target_note
00353d 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
00353f c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
003540 91c0 28ba                 	lds r28, pulse2_fx_Qxy_speed
003542 91d0 28bb                 	lds r29, pulse2_fx_Qxy_speed+1
003544 0fac                      	add r26, r28 //increase the total offset by the speed
003545 1fbd                      	adc r27, r29
003546 93a0 28bc                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
003548 93b0 28bd                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
00354a 91e0 28bf                 	lds ZL, pulse2_fx_Rxy_target
00354c 91f0 28c0                 	lds ZH, pulse2_fx_Rxy_target+1
00354e 9630                      	adiw Z, 0
00354f f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
003550 91a0 28c3                 	lds r26, pulse2_fx_Rxy_total_offset
003552 91b0 28c4                 	lds r27, pulse2_fx_Rxy_total_offset+1
003554 91c0 0a9c                 	lds r28, TCB1_CCMPL
003556 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
003558 1bce                      	sub r28, ZL //calculate the difference to the target
003559 0bdf                      	sbc r29, ZH
00355a f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
00355b f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
00355c 9220 28c3                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
00355e 9220 28c4                 	sts pulse2_fx_Rxy_total_offset+1, zero
003560 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
003562 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
003564 91b0 28be                 	lds r27, pulse2_fx_Rxy_target_note
003566 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
003568 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
003569 91c0 28c1                 	lds r28, pulse2_fx_Rxy_speed
00356b 91d0 28c2                 	lds r29, pulse2_fx_Rxy_speed+1
00356d 0fac                      	add r26, r28 //increase the total offset by the speed
00356e 1fbd                      	adc r27, r29
00356f 93a0 28c3                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
003571 93b0 28c4                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
003573 91e0 28cd                 	lds ZL, triangle_volume_macro
003575 91f0 28ce                 	lds ZH, triangle_volume_macro+1
003577 9630                      	adiw Z, 0
003578 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
003579 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00357a 1fff                      	rol ZH
00357b 91a0 28cf                 	lds r26, triangle_volume_macro_offset
00357d 0fea                      	add ZL, r26
00357e 1df2                      	adc ZH, zero
                                 
00357f 91b0 28d1                 	lds r27, triangle_volume_macro_release
003581 17ba                      	cp r27, r26
003582 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
003583 91a0 28d0                 	lds r26, triangle_volume_macro_loop
003585 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003586 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003587 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
003588 95a3                      	inc r26 //increment the macro offset
003589 93a0 28cf                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
00358b 91b4                      	lpm r27, Z //load volume data into r27
00358c 3fbf                      	cpi r27, 0xFF //check for macro end flag
00358d f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
00358e 91b0 28d1                 	lds r27, triangle_volume_macro_release
003590 3fbf                      	cpi r27, 0xFF
003591 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
003592 91b0 28d0                 	lds r27, triangle_volume_macro_loop //load the loop index
003594 93b0 28cf                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
003596 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
003597 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
003598 93a0 28cf                 	sts triangle_volume_macro_offset, r26
00359a cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
00359b 15b2                      	cp r27, zero
00359c f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
00359d 91b0 0aa5                 	lds r27, TCB2_INTCTRL
00359f 30b1                      	cpi r27, TCB_CAPT_bm
0035a0 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
0035a1 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0035a2 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0035a4 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
0035a5 9220 0aa5                 	sts TCB2_INTCTRL, zero
0035a7 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
0035a9 9220 0aad                 	sts TCB2_CCMPH, zero
0035ab c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0035ac 91e0 28d2                 	lds ZL, triangle_arpeggio_macro
0035ae 91f0 28d3                 	lds ZH, triangle_arpeggio_macro+1
0035b0 9630                      	adiw Z, 0
0035b1 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0035b2 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0035b3 1fff                      	rol ZH
0035b4 91a0 28d4                 	lds r26, triangle_arpeggio_macro_offset
0035b6 0fea                      	add ZL, r26
0035b7 1df2                      	adc ZH, zero
                                 
0035b8 91b0 28d6                 	lds r27, triangle_arpeggio_macro_release
0035ba 17ba                      	cp r27, r26
0035bb f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0035bc 91a0 28d5                 	lds r26, triangle_arpeggio_macro_loop
0035be 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0035bf f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0035c0 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
0035c1 95a3                      	inc r26 //increment the macro offset
0035c2 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
0035c4 91b4                      	lpm r27, Z //load arpeggio data into r27
0035c5 38b0                      	cpi r27, 0x80 //check for macro end flag
0035c6 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
0035c7 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
0035c8 50a1                      	subi r26, 1 //keep the offset at the end flag
0035c9 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26
0035cb 91b0 28d7                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0035cd 30b1                      	cpi r27, 0x01
0035ce f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
0035cf 91b0 28d6                 	lds r27, triangle_arpeggio_macro_release
0035d1 3fbf                      	cpi r27, 0xFF
0035d2 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
0035d3 91b0 28d5                 	lds r27, triangle_arpeggio_macro_loop
0035d5 3fbf                      	cpi r27, 0xFF
0035d6 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0035d7 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
0035d8 91b0 28d6                 	lds r27, triangle_arpeggio_macro_release
0035da 3fbf                      	cpi r27, 0xFF
0035db f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
0035dc 91b0 28d5                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
0035de 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0035df f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
0035e0 91c0 28ea                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
0035e2 91d0 28eb                 	lds r29, triangle_fx_0xy_sequence+1
0035e4 9620                      	adiw r29:r28, 0
0035e5 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0035e6 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0035e7 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
0035e9 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
0035ea 93b0 28d4                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
0035ec cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
0035ed 91c0 28ea                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
0035ef 91d0 28eb                 	lds r29, triangle_fx_0xy_sequence+1
0035f1 9620                      	adiw r29:r28, 0 //check for 0xy effect
0035f2 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
0035f3 95d6                      	lsr r29
0035f4 95c7                      	ror r28
0035f5 95d7                      	ror r29
0035f6 95c7                      	ror r28
0035f7 95d7                      	ror r29
0035f8 95c7                      	ror r28
0035f9 95d7                      	ror r29
0035fa 95c7                      	ror r28
0035fb 95d7                      	ror r29
0035fc 95d2                      	swap r29
                                 
0035fd 93c0 28ea                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
0035ff 93d0 28eb                 	sts triangle_fx_0xy_sequence+1, r29
003601 70cf                      	andi r28, 0x0F //mask out the 4 LSB
003602 91a0 2812                 	lds r26, triangle_note //load the current note index
003604 0fac                      	add r26, r28 //add the note offset
003605 c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
003606 91a0 2812                 	lds r26, triangle_note //load the current note index
003608 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
003609 9220 28d8                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00360b 9220 28d9                 	sts triangle_total_pitch_offset+1, zero
00360d 9220 28df                 	sts triangle_total_hi_pitch_offset, zero
00360f 91a0 28d7                 	lds r26, triangle_arpeggio_macro_mode
003611 30a1                      	cpi r26, 0x01 //absolute mode
003612 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
003613 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
003614 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
003615 91a0 2812                 	lds r26, triangle_note //load the current note index
003617 0fab                      	add r26, r27 //offset the note with the arpeggio data
003618 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
003619 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
00361a 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00361b f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
00361c e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00361d c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
00361e fda7                      	sbrc r26, 7 //check if result is negative
00361f e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
003620 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
003621 2fab                      	mov r26, r27 //move the arpeggio data into r26
003622 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
003623 91a0 2812                 	lds r26, triangle_note //load the current note index
003625 0fab                      	add r26, r27 //offset the note with the arpeggio data
003626 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
003627 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
003628 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
00362a 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00362b f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
00362c e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00362d 93a0 2812                 	sts triangle_note, r26
00362f c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
003630 fda7                      	sbrc r26, 7 //check if result is negative
003631 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
003632 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
003634 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
003635 e0f0                      	ldi ZH, HIGH(note_table << 1)
003636 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
003637 0fea                      	add ZL, r26 //add offset
003638 1df2                      	adc ZH, zero
003639 91a5                      	lpm r26, Z+ //load bytes
00363a 91b4                      	lpm r27, Z
00363b 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
00363d 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
00363f 93a0 28f6                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
003641 93b0 28f7                 	sts triangle_fx_3xx_target+1, r27
003643 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
003644 91e0 28da                 	lds ZL, triangle_pitch_macro
003646 91f0 28db                 	lds ZH, triangle_pitch_macro+1
003648 9630                      	adiw Z, 0
003649 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
00364a c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
00364b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00364c 1fff                      	rol ZH
00364d 91a0 28dc                 	lds r26, triangle_pitch_macro_offset
00364f 0fea                      	add ZL, r26
003650 1df2                      	adc ZH, zero
                                 
003651 91b0 28de                 	lds r27, triangle_pitch_macro_release
003653 17ba                      	cp r27, r26
003654 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
003655 91a0 28dd                 	lds r26, triangle_pitch_macro_loop
003657 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003658 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003659 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
00365a 95a3                      	inc r26 //increment the macro offset
00365b 93a0 28dc                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
00365d 91b4                      	lpm r27, Z //load pitch data into r27
00365e 38b0                      	cpi r27, 0x80 //check for macro end flag
00365f f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
003660 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003661 93a0 28dc                 	sts triangle_pitch_macro_offset, r26
003663 91b0 28de                 	lds r27, triangle_pitch_macro_release
003665 3fbf                      	cpi r27, 0xFF
003666 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
003667 91b0 28dd                 	lds r27, triangle_pitch_macro_loop //load the loop index
003669 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00366a f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00366b 93b0 28dc                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
00366d cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
00366e e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
00366f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003670 937f                      	push r23
003671 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
003672 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003673 0367                      	mulsu r22, r23
003674 917f                      	pop r23
003675 916f                      	pop r22
                                 
003676 9416                      	lsr r1 //shift out the fractional bits
003677 9407                      	ror r0
003678 9416                      	lsr r1
003679 9407                      	ror r0
00367a 9416                      	lsr r1
00367b 9407                      	ror r0
00367c 9416                      	lsr r1
00367d 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
00367e fe13                      	sbrs r1, 3 //check if result was a negative number
00367f c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
003680 efc0                      	ldi r28, 0xF0
003681 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
003682 70b7                      	andi r27, 0b00000111
003683 f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
003684 e0b1                      	ldi r27, 0x01
003685 0e0b                      	add r0, r27
003686 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
003687 91a0 28d8                 	lds r26, triangle_total_pitch_offset
003689 91b0 28d9                 	lds r27, triangle_total_pitch_offset+1
00368b 0e0a                      	add r0, r26
00368c 1e1b                      	adc r1, r27
00368d 9200 28d8                 	sts triangle_total_pitch_offset, r0
00368f 9210 28d9                 	sts triangle_total_pitch_offset+1, r1
003691 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
003693 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
003695 0da0                      	add r26, r0 //offset the timer values
003696 1db1                      	adc r27, r1
                                 	
003697 91c0 28ee                 	lds r28, triangle_fx_1xx_total
003699 91d0 28ef                 	lds r29, triangle_fx_1xx_total+1
00369b 1bac                      	sub r26, r28
00369c 0bbd                      	sbc r27, r29
00369d 91c0 28f2                 	lds r28, triangle_fx_2xx_total
00369f 91d0 28f3                 	lds r29, triangle_fx_2xx_total+1
0036a1 0fac                      	add r26, r28
0036a2 1fbd                      	adc r27, r29
0036a3 91c0 2901                 	lds r28, triangle_fx_Pxx_total
0036a5 91d0 2902                 	lds r29, triangle_fx_Pxx_total+1
0036a7 0fac                      	add r26, r28
0036a8 1fbd                      	adc r27, r29
0036a9 91c0 2908                 	lds r28, triangle_fx_Qxy_total_offset
0036ab 91d0 2909                 	lds r29, triangle_fx_Qxy_total_offset+1
0036ad 1bac                      	sub r26, r28
0036ae 0bbd                      	sbc r27, r29
0036af 91c0 290f                 	lds r28, triangle_fx_Rxy_total_offset
0036b1 91d0 2910                 	lds r29, triangle_fx_Rxy_total_offset+1
0036b3 0fac                      	add r26, r28
0036b4 1fbd                      	adc r27, r29
                                 
0036b5 e5c9                      	ldi r28, 0x59
0036b6 e0d0                      	ldi r29, 0x00
0036b7 17ac                      	cp r26, r28
0036b8 07bd                      	cpc r27, r29
0036b9 f030                      	brlo sound_driver_instrument_routine_channel2_pitch_min
                                 
0036ba e5ca                      	ldi r28, 0x5A
0036bb e5d9                      	ldi r29, 0x59
0036bc 17ac                      	cp r26, r28
0036bd 07bd                      	cpc r27, r29
0036be f420                      	brsh sound_driver_instrument_routine_channel2_pitch_max
0036bf c006                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_min:
0036c0 e5c9                      	ldi r28, 0x59
0036c1 e0d0                      	ldi r29, 0x00
0036c2 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_max:
0036c3 e5c9                      	ldi r28, 0x59
0036c4 e5d9                      	ldi r29, 0x59
0036c5 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_store:
0036c6 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
0036c8 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
0036ca 91e0 28e0                 	lds ZL, triangle_hi_pitch_macro
0036cc 91f0 28e1                 	lds ZH, triangle_hi_pitch_macro+1
0036ce 9630                      	adiw Z, 0
0036cf f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
0036d0 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
0036d1 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0036d2 1fff                      	rol ZH
0036d3 91a0 28e2                 	lds r26, triangle_hi_pitch_macro_offset
0036d5 0fea                      	add ZL, r26
0036d6 1df2                      	adc ZH, zero
                                 
0036d7 91b0 28e4                 	lds r27, triangle_hi_pitch_macro_release
0036d9 17ba                      	cp r27, r26
0036da f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0036db 91a0 28e3                 	lds r26, triangle_hi_pitch_macro_loop
0036dd 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0036de f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0036df c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
0036e0 95a3                      	inc r26 //increment the macro offset
0036e1 93a0 28e2                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
0036e3 91b4                      	lpm r27, Z //load hi pitch data into r27
0036e4 38b0                      	cpi r27, 0x80 //check for macro end flag
0036e5 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
0036e6 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0036e7 93a0 28e2                 	sts triangle_hi_pitch_macro_offset, r26
0036e9 91b0 28e4                 	lds r27, triangle_hi_pitch_macro_release
0036eb 3fbf                      	cpi r27, 0xFF
0036ec f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
0036ed 91b0 28e3                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
0036ef 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0036f0 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0036f1 93b0 28e2                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
0036f3 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
0036f4 91b0 28df                 	lds r27, triangle_total_hi_pitch_offset
0036f6 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
0036f7 91a0 28df                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
0036f9 0fba                      	add r27, r26
0036fa 93b0 28df                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
0036fc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0036fd 937f                      	push r23
0036fe 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0036ff eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003700 0367                      	mulsu r22, r23
003701 917f                      	pop r23
003702 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
003703 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
003705 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
003707 0da0                      	add r26, r0 //offset the timer values
003708 1db1                      	adc r27, r1
003709 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
00370b 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
00370d 91e0 28ec                 	lds ZL, triangle_fx_1xx
00370f 91f0 28ed                 	lds ZH, triangle_fx_1xx+1
003711 9630                      	adiw Z, 0
003712 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
003713 91a0 28ee                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
003715 91b0 28ef                 	lds r27, triangle_fx_1xx_total+1
003717 0fae                      	add r26, ZL //increase the total offset by the rate
003718 1fbf                      	adc r27, ZH
003719 93a0 28ee                 	sts triangle_fx_1xx_total, r26
00371b 93b0 28ef                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
00371d 91e0 28f0                 	lds ZL, triangle_fx_2xx
00371f 91f0 28f1                 	lds ZH, triangle_fx_2xx+1
003721 9630                      	adiw Z, 0
003722 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
003723 91a0 28f2                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
003725 91b0 28f3                 	lds r27, triangle_fx_2xx_total+1
003727 0fae                      	add r26, ZL //increase the total offset by the rate
003728 1fbf                      	adc r27, ZH
003729 93a0 28f2                 	sts triangle_fx_2xx_total, r26
00372b 93b0 28f3                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
00372d 91e0 28f8                 	lds ZL, triangle_fx_3xx_speed
00372f 91f0 28f9                 	lds ZH, triangle_fx_3xx_speed+1
003731 9630                      	adiw Z, 0
003732 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
003733 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
003734 91a0 28f4                 	lds r26, triangle_fx_3xx_start
003736 91b0 28f5                 	lds r27, triangle_fx_3xx_start+1
003738 9610                      	adiw r26:r27, 0
003739 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
00373a c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
00373b 91c0 28f6                 	lds r28, triangle_fx_3xx_target
00373d 91d0 28f7                 	lds r29, triangle_fx_3xx_target+1
                                 
00373f 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
003740 07bd                      	cpc r27, r29
003741 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
003742 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
003743 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
003744 9220 28f4                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
003746 9220 28f5                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
003748 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
003749 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
00374a 0bdb                      	sbc r29, r27
00374b 91a0 28fa                 	lds r26, triangle_fx_3xx_total_offset
00374d 91b0 28fb                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
00374f 0fae                      	add r26, ZL //add the speed to the total offset
003750 1fbf                      	adc r27, ZH
003751 1bca                      	sub r28, r26 //invert the total difference with the total offset
003752 0bdb                      	sbc r29, r27
003753 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
003754 93a0 28fa                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
003756 93b0 28fb                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
003758 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
00375a 91b0 0aad                 	lds r27, TCB2_CCMPH
00375c 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00375d 0bbd                      	sbc r27, r29
00375e 93a0 0aac                 	sts TCB2_CCMPL, r26
003760 93b0 0aad                 	sts TCB2_CCMPH, r27
003762 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
003763 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
003764 0bbd                      	sbc r27, r29
003765 91c0 28fa                 	lds r28, triangle_fx_3xx_total_offset
003767 91d0 28fb                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
003769 0fce                      	add r28, ZL //add the speed to the total offset
00376a 1fdf                      	adc r29, ZH
00376b 1bac                      	sub r26, r28 //invert the total difference with the total offset
00376c 0bbd                      	sbc r27, r29
00376d f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00376e 93c0 28fa                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
003770 93d0 28fb                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
003772 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
003774 91d0 0aad                 	lds r29, TCB2_CCMPH
003776 0fca                      	add r28, r26 //offset the current timer period with the total offset
003777 1fdb                      	adc r29, r27
003778 93c0 0aac                 	sts TCB2_CCMPL, r28
00377a 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
00377c 91a0 28fc                 	lds r26, triangle_fx_4xy_speed
00377e 15a2                      	cp r26, zero
00377f f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
003780 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
003781 91b0 28fd                 	lds r27, triangle_fx_4xy_depth
003783 91c0 28fe                 	lds r28, triangle_fx_4xy_phase
003785 0fca                      	add r28, r26 //increase the phase by the speed
003786 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
003787 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
003788 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
003789 93c0 28fe                 	sts triangle_fx_4xy_phase, r28 //store the new phase
00378b 31c0                      	cpi r28, 16
00378c f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
00378d 32c0                      	cpi r28, 32
00378e f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
00378f 33c0                      	cpi r28, 48
003790 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
003791 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
003792 70cf                      	andi r28, 0x0F //mask for values 0-15
003793 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
003794 6fc0                      	ori r28, 0xF0
003795 95c0                      	com r28 //invert values 0-15
003796 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
003797 70cf                      	andi r28, 0x0F //mask for values 0-15
003798 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
003799 6fc0                      	ori r28, 0xF0
00379a 95c0                      	com r28 //invert values 0-15
00379b c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
00379c 95b2                      	swap r27 //multiply depth by 16
00379d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00379e e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00379f e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0037a0 0fec                      	add ZL, r28 //offset the table by the depth+phase
0037a1 1df2                      	adc ZH, zero
0037a2 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0037a3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0037a4 937f                      	push r23
0037a5 2f6c                      	mov r22, r28 //store the vibrato value into r22
0037a6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0037a7 9f67                      	mul r22, r23
0037a8 917f                      	pop r23
0037a9 916f                      	pop r22
                                 
0037aa 9416                      	lsr r1 //shift out the fractional bits
0037ab 9407                      	ror r0
0037ac 9416                      	lsr r1
0037ad 9407                      	ror r0
0037ae 9416                      	lsr r1
0037af 9407                      	ror r0
0037b0 9416                      	lsr r1
0037b1 9407                      	ror r0
                                 	
0037b2 91a0 0aac                 	lds r26, TCB2_CCMPL
0037b4 91b0 0aad                 	lds r27, TCB2_CCMPH
0037b6 0da0                      	add r26, r0
0037b7 1db1                      	adc r27, r1
0037b8 93a0 0aac                 	sts TCB2_CCMPL, r26
0037ba 93b0 0aad                 	sts TCB2_CCMPH, r27
0037bc c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
0037bd 95b2                      	swap r27 //multiply depth by 16
0037be 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0037bf e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0037c0 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0037c1 0fec                      	add ZL, r28 //offset the table by the depth+phase
0037c2 1df2                      	adc ZH, zero
0037c3 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0037c4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0037c5 937f                      	push r23
0037c6 2f6c                      	mov r22, r28 //store the vibrato value into r22
0037c7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0037c8 9f67                      	mul r22, r23
0037c9 917f                      	pop r23
0037ca 916f                      	pop r22
                                 
0037cb 9416                      	lsr r1 //shift out the fractional bits
0037cc 9407                      	ror r0
0037cd 9416                      	lsr r1
0037ce 9407                      	ror r0
0037cf 9416                      	lsr r1
0037d0 9407                      	ror r0
0037d1 9416                      	lsr r1
0037d2 9407                      	ror r0
                                 
0037d3 91a0 0aac                 	lds r26, TCB2_CCMPL
0037d5 91b0 0aad                 	lds r27, TCB2_CCMPH
0037d7 19a0                      	sub r26, r0
0037d8 09b1                      	sbc r27, r1
0037d9 93a0 0aac                 	sts TCB2_CCMPL, r26
0037db 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
0037dd 91e0 2904                 	lds ZL, triangle_fx_Qxy_target
0037df 91f0 2905                 	lds ZH, triangle_fx_Qxy_target+1
0037e1 9630                      	adiw Z, 0
0037e2 f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0037e3 91a0 2908                 	lds r26, triangle_fx_Qxy_total_offset
0037e5 91b0 2909                 	lds r27, triangle_fx_Qxy_total_offset+1
0037e7 91c0 0aac                 	lds r28, TCB2_CCMPL
0037e9 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
0037eb 1bec                      	sub ZL, r28 //calculate the difference to the target
0037ec 0bfd                      	sbc ZH, r29
0037ed f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
0037ee f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
0037ef 9220 2908                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
0037f1 9220 2909                 	sts triangle_fx_Qxy_total_offset+1, zero
0037f3 9220 2904                 	sts triangle_fx_Qxy_target, zero
0037f5 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
0037f7 91b0 2903                 	lds r27, triangle_fx_Qxy_target_note
0037f9 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
0037fb c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
0037fc 91c0 2906                 	lds r28, triangle_fx_Qxy_speed
0037fe 91d0 2907                 	lds r29, triangle_fx_Qxy_speed+1
003800 0fac                      	add r26, r28 //increase the total offset by the speed
003801 1fbd                      	adc r27, r29
003802 93a0 2908                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
003804 93b0 2909                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
003806 91e0 290b                 	lds ZL, triangle_fx_Rxy_target
003808 91f0 290c                 	lds ZH, triangle_fx_Rxy_target+1
00380a 9630                      	adiw Z, 0
00380b f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
00380c 91a0 290f                 	lds r26, triangle_fx_Rxy_total_offset
00380e 91b0 2910                 	lds r27, triangle_fx_Rxy_total_offset+1
003810 91c0 0aac                 	lds r28, TCB2_CCMPL
003812 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
003814 1bce                      	sub r28, ZL //calculate the difference to the target
003815 0bdf                      	sbc r29, ZH
003816 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
003817 f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
003818 9220 290f                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
00381a 9220 2910                 	sts triangle_fx_Rxy_total_offset+1, zero
00381c 9220 290b                 	sts triangle_fx_Rxy_target, zero
00381e 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
003820 91b0 290a                 	lds r27, triangle_fx_Rxy_target_note
003822 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
003824 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
003825 91c0 290d                 	lds r28, triangle_fx_Rxy_speed
003827 91d0 290e                 	lds r29, triangle_fx_Rxy_speed+1
003829 0fac                      	add r26, r28 //increase the total offset by the speed
00382a 1fbd                      	adc r27, r29
00382b 93a0 290f                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
00382d 93b0 2910                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
00382f 91e0 2919                 	lds ZL, noise_volume_macro
003831 91f0 291a                 	lds ZH, noise_volume_macro+1
003833 9630                      	adiw Z, 0
003834 f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
003835 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
003836 1fff                      	rol ZH
003837 91a0 291b                 	lds r26, noise_volume_macro_offset
003839 0fea                      	add ZL, r26
00383a 1df2                      	adc ZH, zero
                                 
00383b 91b0 291d                 	lds r27, noise_volume_macro_release
00383d 17ba                      	cp r27, r26
00383e f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
00383f 91a0 291c                 	lds r26, noise_volume_macro_loop
003841 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003842 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003843 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
003844 95a3                      	inc r26 //increment the macro offset
003845 93a0 291b                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
003847 91b4                      	lpm r27, Z //load volume data into r27
003848 3fbf                      	cpi r27, 0xFF //check for macro end flag
003849 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
00384a 91b0 291d                 	lds r27, noise_volume_macro_release
00384c 3fbf                      	cpi r27, 0xFF
00384d f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
00384e 91b0 291c                 	lds r27, noise_volume_macro_loop //load the loop index
003850 93b0 291b                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
003852 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
003853 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
003854 93a0 291b                 	sts noise_volume_macro_offset, r26
003856 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
003857 ede8                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
003858 e7f5                      	ldi ZH, HIGH(volumes << 1)
003859 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
00385a 0feb                      	add ZL, r27 //add offset to the table
00385b 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
00385c 91b0 2813                 	lds r27, noise_param //load main volume
00385e 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00385f 91a0 2943                 	lds r26, noise_fx_7xy_value
003861 30a0                      	cpi r26, 0x00
003862 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
003863 0feb                      	add ZL, r27 //offset the volume table by the main volume
003864 1df2                      	adc ZH, zero
003865 91b4                      	lpm r27, Z
003866 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
003868 c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
003869 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
00386b 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00386c 91a0 2943                 	lds r26, noise_fx_7xy_value
00386e 30a0                      	cpi r26, 0x00
00386f f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
003870 93b0 2816                 	sts noise_output_volume, r27
003872 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
003873 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
003874 f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
003875 f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
003876 0feb                      	add ZL, r27 //offset the volume table by the main volume
003877 1df2                      	adc ZH, zero
003878 91b4                      	lpm r27, Z
003879 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
00387b c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
00387c e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00387d 0feb                      	add ZL, r27 //offset the volume table by the main volume
00387e 1df2                      	adc ZH, zero
00387f 91b4                      	lpm r27, Z
003880 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
003882 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
003883 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
003884 f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
003885 f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
003886 93b0 2816                 	sts noise_output_volume, r27
003888 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
003889 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00388a 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00388c 91e0 291e                 	lds ZL, noise_arpeggio_macro
00388e 91f0 291f                 	lds ZH, noise_arpeggio_macro+1
003890 9630                      	adiw Z, 0
003891 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
003892 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
003893 1fff                      	rol ZH
003894 91a0 2920                 	lds r26, noise_arpeggio_macro_offset
003896 0fea                      	add ZL, r26
003897 1df2                      	adc ZH, zero
                                 
003898 91b0 2922                 	lds r27, noise_arpeggio_macro_release
00389a 17ba                      	cp r27, r26
00389b f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00389c 91a0 2921                 	lds r26, noise_arpeggio_macro_loop
00389e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00389f f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0038a0 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
0038a1 95a3                      	inc r26 //increment the macro offset
0038a2 93a0 2920                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
0038a4 91b4                      	lpm r27, Z //load arpeggio data into r27
0038a5 38b0                      	cpi r27, 0x80 //check for macro end flag
0038a6 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
0038a7 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
0038a8 50a1                      	subi r26, 1 //keep the offset at the end flag
0038a9 93a0 2920                 	sts noise_arpeggio_macro_offset, r26
0038ab 91b0 2923                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0038ad 30b1                      	cpi r27, 0x01
0038ae f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
0038af 91b0 2922                 	lds r27, noise_arpeggio_macro_release
0038b1 3fbf                      	cpi r27, 0xFF
0038b2 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
0038b3 91b0 2921                 	lds r27, noise_arpeggio_macro_loop
0038b5 3fbf                      	cpi r27, 0xFF
0038b6 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0038b7 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
0038b8 91b0 2922                 	lds r27, noise_arpeggio_macro_release
0038ba 3fbf                      	cpi r27, 0xFF
0038bb f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
0038bc 91b0 2921                 	lds r27, noise_arpeggio_macro_loop //load the loop index
0038be 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0038bf f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
0038c0 91c0 2936                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
0038c2 91d0 2937                 	lds r29, noise_fx_0xy_sequence+1
0038c4 9620                      	adiw r29:r28, 0
0038c5 f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0038c6 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0038c7 93a0 2920                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
0038c9 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
0038ca 93b0 2920                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
0038cc cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
0038cd 91c0 2936                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
0038cf 91d0 2937                 	lds r29, noise_fx_0xy_sequence+1
0038d1 9620                      	adiw r29:r28, 0 //check for 0xy effect
0038d2 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
0038d3 95d6                      	lsr r29
0038d4 95c7                      	ror r28
0038d5 95d7                      	ror r29
0038d6 95c7                      	ror r28
0038d7 95d7                      	ror r29
0038d8 95c7                      	ror r28
0038d9 95d7                      	ror r29
0038da 95c7                      	ror r28
0038db 95d7                      	ror r29
0038dc 95d2                      	swap r29
                                 
0038dd 93c0 2936                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
0038df 93d0 2937                 	sts noise_fx_0xy_sequence+1, r29
0038e1 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0038e2 91a0 2817                 	lds r26, noise_note //load the current note index
0038e4 0fac                      	add r26, r28 //add the note offset
0038e5 c01c                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0038e6 91a0 2817                 	lds r26, noise_note //load the current note index
0038e8 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
0038e9 9220 2924                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0038eb 9220 2925                 	sts noise_total_pitch_offset+1, zero
0038ed 9220 292b                 	sts noise_total_hi_pitch_offset, zero
0038ef 91a0 2923                 	lds r26, noise_arpeggio_macro_mode
0038f1 30a1                      	cpi r26, 0x01 //absolute mode
0038f2 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
0038f3 f031                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
0038f4 c007                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
0038f5 91a0 2817                 	lds r26, noise_note //load the current note index
0038f7 0fab                      	add r26, r27 //offset the note with the arpeggio data
0038f8 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
0038f9 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
0038fa 2fab                      	mov r26, r27 //move the arpeggio data into r26
0038fb c006                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
0038fc 91a0 2817                 	lds r26, noise_note //load the current note index
0038fe 0fab                      	add r26, r27 //offset the note with the arpeggio data
0038ff 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
003900 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
003902 93a0 2818                 	sts noise_adjusted_note, r26
003904 c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
003905 91e0 2926                 	lds ZL, noise_pitch_macro
003907 91f0 2927                 	lds ZH, noise_pitch_macro+1
003909 9630                      	adiw Z, 0
00390a f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
00390b c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
00390c 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00390d 1fff                      	rol ZH
00390e 91a0 2928                 	lds r26, noise_pitch_macro_offset
003910 0fea                      	add ZL, r26
003911 1df2                      	adc ZH, zero
                                 
003912 91b0 292a                 	lds r27, noise_pitch_macro_release
003914 17ba                      	cp r27, r26
003915 f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
003916 91a0 2929                 	lds r26, noise_pitch_macro_loop
003918 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003919 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00391a c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
00391b 95a3                      	inc r26 //increment the macro offset
00391c 93a0 2928                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
00391e 91b4                      	lpm r27, Z //load pitch data into r27
00391f 38b0                      	cpi r27, 0x80 //check for macro end flag
003920 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
003921 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003922 93a0 2928                 	sts noise_pitch_macro_offset, r26
003924 91b0 292a                 	lds r27, noise_pitch_macro_release
003926 3fbf                      	cpi r27, 0xFF
003927 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
003928 91b0 2929                 	lds r27, noise_pitch_macro_loop //load the loop index
00392a 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00392b f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00392c 93b0 2928                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
00392e cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
00392f e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
003930 91a0 2924                 	lds r26, noise_total_pitch_offset
003932 0fba                      	add r27, r26
003933 93b0 2924                 	sts noise_total_pitch_offset, r27
003935 91a0 2818                 	lds r26, noise_adjusted_note
003937 1bab                      	sub r26, r27
                                 	
003938 91b0 2939                 	lds r27, noise_fx_1xx_total
00393a 0fab                      	add r26, r27
00393b 91b0 293b                 	lds r27, noise_fx_2xx_total
00393d 1bab                      	sub r26, r27
00393e 91b0 293f                 	lds r27, noise_fx_4xy_offset
003940 1bab                      	sub r26, r27
003941 91b0 2947                 	lds r27, noise_fx_Pxx_total
003943 1bab                      	sub r26, r27
                                 
003944 70af                      	andi r26, 0x0F
                                 
003945 e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
003946 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
003947 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
003948 0fea                      	add ZL, r26 //add offset
003949 1df2                      	adc ZH, zero
00394a 91a5                      	lpm r26, Z+ //load bytes
00394b 91b4                      	lpm r27, Z
00394c 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
00394e 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
003950 91e0 292c                 	lds ZL, noise_hi_pitch_macro
003952 91f0 292d                 	lds ZH, noise_hi_pitch_macro+1
003954 9630                      	adiw Z, 0
003955 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
003956 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
003957 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003958 1fff                      	rol ZH
003959 91a0 292e                 	lds r26, noise_hi_pitch_macro_offset
00395b 0fea                      	add ZL, r26
00395c 1df2                      	adc ZH, zero
                                 
00395d 91b0 2930                 	lds r27, noise_hi_pitch_macro_release
00395f 17ba                      	cp r27, r26
003960 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
003961 91a0 292f                 	lds r26, noise_hi_pitch_macro_loop
003963 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003964 f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003965 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
003966 95a3                      	inc r26 //increment the macro offset
003967 93a0 292e                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
003969 91b4                      	lpm r27, Z //load hi pitch data into r27
00396a 38b0                      	cpi r27, 0x80 //check for macro end flag
00396b f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
00396c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00396d 93a0 292e                 	sts noise_hi_pitch_macro_offset, r26
00396f 91b0 2930                 	lds r27, noise_hi_pitch_macro_release
003971 3fbf                      	cpi r27, 0xFF
003972 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
003973 91b0 292f                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
003975 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003976 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
003977 93b0 292e                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
003979 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
00397a 91b0 292b                 	lds r27, noise_total_hi_pitch_offset
00397c c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
00397d 91a0 292b                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
00397f 0fba                      	add r27, r26
003980 93b0 292b                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
003982 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003983 937f                      	push r23
003984 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
003985 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003986 0367                      	mulsu r22, r23
003987 917f                      	pop r23
003988 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
003989 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
00398b 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
00398d 0da0                      	add r26, r0 //offset the timer values
00398e 1db1                      	adc r27, r1
00398f 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
003991 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
003993 91e0 2931                 	lds ZL, noise_duty_macro
003995 91f0 2932                 	lds ZH, noise_duty_macro+1
003997 9630                      	adiw Z, 0
003998 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
003999 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00399a 1fff                      	rol ZH
00399b 91a0 2933                 	lds r26, noise_duty_macro_offset
00399d 0fea                      	add ZL, r26
00399e 1df2                      	adc ZH, zero
                                 
00399f 91b0 2935                 	lds r27, noise_duty_macro_release
0039a1 17ba                      	cp r27, r26
0039a2 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
0039a3 91a0 2934                 	lds r26, noise_duty_macro_loop
0039a5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0039a6 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0039a7 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
0039a8 95a3                      	inc r26 //increment the macro offset
0039a9 93a0 2933                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
0039ab 91b4                      	lpm r27, Z //load pitch data into r27
0039ac 3fbf                      	cpi r27, 0xFF //check for macro end flag
0039ad f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
0039ae 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0039af 93a0 2933                 	sts noise_duty_macro_offset, r26
0039b1 91b0 2935                 	lds r27, noise_duty_macro_release
0039b3 3fbf                      	cpi r27, 0xFF
0039b4 f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
0039b5 91b0 2934                 	lds r27, noise_duty_macro_loop //load the loop index
0039b7 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0039b8 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0039b9 93b0 2933                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
0039bb cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
0039bc 95b6                      	lsr r27
0039bd 95b7                      	ror r27 //move mode bit to bit 7
0039be 91c0 2814                 	lds r28, noise_period
0039c0 77cf                      	andi r28, 0b01111111
0039c1 2bcb                      	or r28, r27 //store the new noise mode
0039c2 93c0 2814                 	sts noise_period, r28
                                 
0039c4 776f                      	andi noise_sequence_HIGH, 0b01111111
0039c5 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
0039c6 91e0 2938                 	lds ZL, noise_fx_1xx
0039c8 30e0                      	cpi ZL, 0
0039c9 f029                      	breq sound_driver_channel3_fx_2xx_routine
                                 
0039ca 91a0 2939                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
0039cc 0fae                      	add r26, ZL //increase the total offset by the rate
0039cd 93a0 2939                 	sts noise_fx_1xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
0039cf 91e0 293a                 	lds ZL, noise_fx_2xx
0039d1 30e0                      	cpi ZL, 0
0039d2 f029                      	breq sound_driver_channel3_fx_3xx_routine
                                 
0039d3 91a0 293b                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
0039d5 0fae                      	add r26, ZL //increase the total offset by the rate
0039d6 93a0 293b                 	sts noise_fx_2xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
0039d8 91a0 293c                 	lds r26, noise_fx_4xy_speed
0039da 15a2                      	cp r26, zero
0039db f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
0039dc c033                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
0039dd 91b0 293d                 	lds r27, noise_fx_4xy_depth
0039df 91c0 293e                 	lds r28, noise_fx_4xy_phase
0039e1 0fca                      	add r28, r26 //increase the phase by the speed
0039e2 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0039e3 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0039e4 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
0039e5 93c0 293e                 	sts noise_fx_4xy_phase, r28 //store the new phase
0039e7 31c0                      	cpi r28, 16
0039e8 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
0039e9 32c0                      	cpi r28, 32
0039ea f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
0039eb 33c0                      	cpi r28, 48
0039ec f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
0039ed c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
0039ee 70cf                      	andi r28, 0x0F //mask for values 0-15
0039ef c014                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
0039f0 6fc0                      	ori r28, 0xF0
0039f1 95c0                      	com r28 //invert values 0-15
0039f2 c011                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
0039f3 70cf                      	andi r28, 0x0F //mask for values 0-15
0039f4 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
0039f5 6fc0                      	ori r28, 0xF0
0039f6 95c0                      	com r28 //invert values 0-15
0039f7 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
0039f8 95b2                      	swap r27 //multiply depth by 16
0039f9 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0039fa e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0039fb e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0039fc 0fec                      	add ZL, r28 //offset the table by the depth+phase
0039fd 1df2                      	adc ZH, zero
0039fe 91c4                      	lpm r28, Z //load the tremelo value into r28
0039ff 95c2                      	swap r28
003a00 70cf                      	andi r28, 0x0F
                                 
003a01 93c0 293f                 	sts noise_fx_4xy_offset, r28
003a03 c00c                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
003a04 95b2                      	swap r27 //multiply depth by 16
003a05 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
003a06 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003a07 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003a08 0fec                      	add ZL, r28 //offset the table by the depth+phase
003a09 1df2                      	adc ZH, zero
003a0a 91c4                      	lpm r28, Z //load the vibrato value into r28
003a0b 95c2                      	swap r28
003a0c 70cf                      	andi r28, 0x0F
                                 
003a0d 95c1                      	neg r28
003a0e 93c0 293f                 	sts noise_fx_4xy_offset, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
003a10 91a0 2940                 	lds r26, noise_fx_7xy_speed
003a12 15a2                      	cp r26, zero
003a13 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
003a14 91b0 2941                 	lds r27, noise_fx_7xy_depth
003a16 91c0 2942                 	lds r28, noise_fx_7xy_phase
003a18 0fca                      	add r28, r26 //increase the phase by the speed
003a19 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
003a1a f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
003a1b e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
003a1c 93c0 2942                 	sts noise_fx_7xy_phase, r28 //store the new phase
003a1e 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
003a1f ffc4                      	sbrs r28, 4
003a20 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
003a21 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
003a22 70cf                      	andi r28, 0x0F //mask for values 0-15
003a23 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
003a24 6fc0                      	ori r28, 0xF0
003a25 95c0                      	com r28 //invert values 0-15
003a26 c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
003a27 95b2                      	swap r27 //multiply depth by 16
003a28 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003a29 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003a2a e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003a2b 0fec                      	add ZL, r28 //offset the table by the depth+phase
003a2c 1df2                      	adc ZH, zero
003a2d 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003a2e 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
003a2f 93c0 2943                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
003a31 91b0 2944                 	lds r27, noise_fx_Axy
003a33 15b2                      	cp r27, zero
003a34 f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
003a35 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
003a37 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
003a39 2fda                      	mov r29, r26 //copy fractional volume into r29
003a3a 2fec                      	mov r30, r28 //copy the noise_param into r30
003a3b 95e2                      	swap r30
003a3c 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
003a3d 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
003a3e 17ed                      	cp r30, r29 //compare the fractional and integer volumes
003a3f f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
003a40 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
003a41 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
003a42 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
003a43 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
003a44 f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
003a45 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
003a46 c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
003a47 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
003a48 f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
003a49 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
003a4a 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
003a4c 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
003a4d 95a2                      	swap r26
003a4e 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
003a4f 2bca                      	or r28, r26 //store the new volume back into noise_param
003a50 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Qxy_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
                                 
                                 
                                 
                                 sound_driver_exit:
003a52 91ff                      	pop r31
003a53 91ef                      	pop r30
003a54 91df                      	pop r29
003a55 91cf                      	pop r28
003a56 940c 1f5c                 	jmp sequence_1_3
                                 
                                 
                                 
                                 //TABLES
003a58 7f05
003a59 010a
003a5a 0214
003a5b 0328
003a5c 0450
003a5d 051e
003a5e 0607
003a5f 070d
003a60 0806
003a61 090c
003a62 0a18
003a63 0b30
003a64 0c60
003a65 0d24
003a66 0e08
003a67 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
003a68 0301
003a69 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
003a6a 2205
003a6b 220a
003a6c 2226
003a6d 2242
003a6e 2265                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
003a6f 2270
003a70 227d
003a71 2280
003a72 2283
003a73 2286                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
003a74 2289
003a75 2291
003a76 2294
003a77 22a1
003a78 22a2                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
003a79 22a3
003a7a 22a4
003a7b 22a5
003a7c 22bd
003a7d 22ff                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
003a7e 2340
003a7f 234d
003a80 2361
003a81 2362
003a82 2363                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
003a83 2364                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
003a84 2502
003a85 2507
003a86 2523
003a87 253f
003a88 2562                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
003a89 256d
003a8a 257a
003a8b 257d
003a8c 2580
003a8d 2583                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
003a8e 2586
003a8f 258e
003a90 2591
003a91 259e
003a92 259f                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
003a93 25a0
003a94 25a1
003a95 25a2
003a96 25ba
003a97 25fc                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
003a98 263d
003a99 264a
003a9a 265e
003a9b 265f
003a9c 2660                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
003a9d 2661                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
003a9e 27f2
003a9f 27f7
003aa0 2813
003aa1 282f
003aa2 2852                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
003aa3 285d
003aa4 285e
003aa5 285f
003aa6 2862
003aa7 2865                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
003aa8 2868
003aa9 2875
003aaa 2878
003aab 2885
003aac 2886                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
003aad 2887
003aae 2888
003aaf 2889
003ab0 28a1
003ab1 28e3                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
003ab2 2924
003ab3 2931
003ab4 2932
003ab5 2933
003ab6 2934                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
003ab7 2935                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
003ab8 2aca
003ab9 2acf
003aba 2ad8
003abb 2ae1
003abc 2ae2                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
003abd 2aef
003abe 2afc
003abf 2aff
003ac0 2b02
003ac1 2b05                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
003ac2 2b08
003ac3 2b0f
003ac4 2b12
003ac5 2b1f
003ac6 2b20                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
003ac7 2b21
003ac8 2b22
003ac9 2b23
003aca 2b26
003acb 2b27                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
003acc 2b28
003acd 2b35
003ace 2b40
003acf 2b41
003ad0 2b42                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
003ad1 2b43                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 channel4_fx:
003ad2 2c9c
003ad3 2c9d
003ad4 2c9e
003ad5 2c9f
003ad6 2ca0                      	.dw sound_driver_channel4_fx_0xy, sound_driver_channel4_fx_1xx, sound_driver_channel4_fx_2xx, sound_driver_channel4_fx_3xx, sound_driver_channel4_fx_4xy
003ad7 2ca1
003ad8 2ca2
003ad9 2ca3
003ada 2ca6
003adb 2ca9                      	.dw sound_driver_channel4_fx_7xy, sound_driver_channel4_fx_Axy, sound_driver_channel4_fx_Bxx, sound_driver_channel4_fx_Cxx, sound_driver_channel4_fx_Dxx
003adc 2cac
003add 2cad
003ade 2cb0
003adf 2cbd
003ae0 2cbe                      	.dw sound_driver_channel4_fx_Exx, sound_driver_channel4_fx_Fxx, sound_driver_channel4_fx_Gxx, sound_driver_channel4_fx_Hxy, sound_driver_channel4_fx_Ixy
003ae1 2cbf
003ae2 2cc0
003ae3 2cc1
003ae4 2cc2
003ae5 2cc3                      	.dw sound_driver_channel4_fx_Hxx, sound_driver_channel4_fx_Ixx, sound_driver_channel4_fx_Pxx, sound_driver_channel4_fx_Qxy, sound_driver_channel4_fx_Rxy
003ae6 2cc4
003ae7 2cd1
003ae8 2cd2
003ae9 2cd3
003aea 2cd4                      	.dw sound_driver_channel4_fx_Sxx, sound_driver_channel4_fx_Vxx, sound_driver_channel4_fx_Wxx, sound_driver_channel4_fx_Xxx, sound_driver_channel4_fx_Yxx
003aeb 2cd5                      	.dw sound_driver_channel4_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
003aec 0000
003aed 0000
003aee 0000
003aef 0000
003af0 0000
003af1 0000
003af2 0000
003af3 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
003af4 0100
003af5 0101
003af6 0101
003af7 0101
003af8 0101
003af9 0101
003afa 0101
003afb 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
003afc 0100
003afd 0101
003afe 0101
003aff 0101
003b00 0101
003b01 0101
003b02 0101
003b03 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
003b04 0100
003b05 0101
003b06 0101
003b07 0101
003b08 0101
003b09 0202
003b0a 0202
003b0b 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
003b0c 0100
003b0d 0101
003b0e 0101
003b0f 0101
003b10 0202
003b11 0202
003b12 0303
003b13 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
003b14 0100
003b15 0101
003b16 0101
003b17 0202
003b18 0302
003b19 0303
003b1a 0404
003b1b 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
003b1c 0100
003b1d 0101
003b1e 0201
003b1f 0202
003b20 0303
003b21 0404
003b22 0504
003b23 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
003b24 0100
003b25 0101
003b26 0201
003b27 0302
003b28 0403
003b29 0504
003b2a 0605
003b2b 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
003b2c 0100
003b2d 0101
003b2e 0202
003b2f 0303
003b30 0404
003b31 0505
003b32 0606
003b33 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
003b34 0100
003b35 0101
003b36 0302
003b37 0403
003b38 0504
003b39 0606
003b3a 0707
003b3b 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
003b3c 0100
003b3d 0201
003b3e 0302
003b3f 0404
003b40 0605
003b41 0706
003b42 0808
003b43 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
003b44 0100
003b45 0201
003b46 0302
003b47 0504
003b48 0605
003b49 0807
003b4a 0908
003b4b 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
003b4c 0100
003b4d 0201
003b4e 0403
003b4f 0504
003b50 0706
003b51 0808
003b52 0a09
003b53 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
003b54 0100
003b55 0201
003b56 0403
003b57 0605
003b58 0706
003b59 0908
003b5a 0b0a
003b5b 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
003b5c 0100
003b5d 0201
003b5e 0403
003b5f 0605
003b60 0807
003b61 0a09
003b62 0c0b
003b63 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
003b64 0100
003b65 0302
003b66 0504
003b67 0706
003b68 0908
003b69 0b0a
003b6a 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 258 r0 : 148 r1 : 160 r2 : 689 r3 :  25 r4 :   4 
r5 :   8 r6 :   0 r7 :   6 r8 :   4 r9 :   9 r10:   6 r11:   4 r12:   9 
r13:   5 r14:   5 r15:   4 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 138 r23: 129 r24:   5 r25:  24 r26:1017 r27:1231 r28: 664 
r29: 353 r30: 345 r31: 329 
Registers used: 32 out of 35 (91.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 135 add   : 189 adiw  : 100 and   :   2 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   6 brcs  :  13 break :   0 breq  : 175 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  77 brlt  :   0 brmi  :   0 
brne  : 133 brpl  :   0 brsh  :  38 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   5 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   7 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 129 cpc   :  16 
cpi   : 175 cpse  :  26 dec   :  25 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   5 in    :   6 inc   :  46 
jmp   :   9 ld    :   0 ldd   :   0 ldi   : 314 lds   : 696 lpm   : 284 
lsl   :  83 lsr   : 137 mov   : 138 movw  :   0 mul   :  21 muls  :   0 
mulsu :  10 neg   :   1 nop   :   0 or    :  24 ori   :  12 out   :  10 
pop   :  98 push  :  90 rcall :  56 ret   :  44 reti  :   8 rjmp  : 578 
rol   :  59 ror   : 156 sbc   :  31 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  26 sbrs  :  18 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1396 sub   :  57 subi  :  38 swap  :  47 tst   :   0 wdr   :   0 

Instructions used: 55 out of 114 (48.2%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0076d8  15786  14518  30304   49152  61.7%
[.dseg] 0x002800 0x002958      0    344    344    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 53 warnings
