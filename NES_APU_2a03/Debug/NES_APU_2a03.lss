
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Wed Jan 20 20:31:14 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           song_frames: .byte 2
002815                           song_frame_offset: .byte 2
002817                           song_size: .byte 2
002819                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281a                           song_fx_Bxx: .byte 1
00281b                           song_fx_Cxx: .byte 1
00281c                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
00281d                           pulse1_pattern: .byte 2
00281f                           pulse1_pattern_delay_rows: .byte 1
002820                           pulse1_pattern_delay_frames: .byte 1
002821                           pulse1_pattern_offset: .byte 2
                                 
002823                           pulse1_volume_macro: .byte 2
002825                           pulse1_volume_macro_offset: .byte 1
002826                           pulse1_volume_macro_loop: .byte 1
002827                           pulse1_volume_macro_release: .byte 1
                                 
002828                           pulse1_arpeggio_macro: .byte 2
00282a                           pulse1_arpeggio_macro_offset: .byte 1
00282b                           pulse1_arpeggio_macro_loop: .byte 1
00282c                           pulse1_arpeggio_macro_release: .byte 1
00282d                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00282e                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00282f                           pulse1_pitch_macro: .byte 2
002831                           pulse1_pitch_macro_offset: .byte 1
002832                           pulse1_pitch_macro_loop: .byte 1
002833                           pulse1_pitch_macro_release: .byte 1
                                 
002834                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002835                           pulse1_hi_pitch_macro: .byte 2
002837                           pulse1_hi_pitch_macro_offset: .byte 1
002838                           pulse1_hi_pitch_macro_loop: .byte 1
002839                           pulse1_hi_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_duty_macro: .byte 2
00283c                           pulse1_duty_macro_offset: .byte 1
00283d                           pulse1_duty_macro_loop: .byte 1
00283e                           pulse1_duty_macro_release: .byte 1
                                 
00283f                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002841                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002843                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002845                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002847                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002849                           pulse1_fx_3xx_start: .byte 2 //the starting note period
00284b                           pulse1_fx_3xx_target: .byte 2 //target note period
00284d                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00284f                           pulse1_fx_3xx_total_offset: .byte 2
002851                           pulse1_fx_4xy_speed: .byte 1
002852                           pulse1_fx_4xy_depth: .byte 1
002853                           pulse1_fx_4xy_phase: .byte 1
002854                           pulse1_fx_7xy_speed: .byte 1
002855                           pulse1_fx_7xy_depth: .byte 1
002856                           pulse1_fx_7xy_phase: .byte 1
002857                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002858                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002859                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00285a                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00285b                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
00285c                           pulse1_fx_Qxy_target: .byte 2 //target note period
00285e                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002860                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002862                           pulse1_fx_Rxy_target: .byte 2 //target note period
002864                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002866                           pulse1_fx_Rxy_total_offset: .byte 2
002868                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002869                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
00286a                           pulse2_pattern: .byte 2
00286c                           pulse2_pattern_delay_rows: .byte 1
00286d                           pulse2_pattern_delay_frames: .byte 1
00286e                           pulse2_pattern_offset: .byte 2
                                 
002870                           pulse2_volume_macro: .byte 2
002872                           pulse2_volume_macro_offset: .byte 1
002873                           pulse2_volume_macro_loop: .byte 1
002874                           pulse2_volume_macro_release: .byte 1
                                 
002875                           pulse2_arpeggio_macro: .byte 2
002877                           pulse2_arpeggio_macro_offset: .byte 1
002878                           pulse2_arpeggio_macro_loop: .byte 1
002879                           pulse2_arpeggio_macro_release: .byte 1
00287a                           pulse2_arpeggio_macro_mode: .byte 1
                                 
00287b                           pulse2_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00287c                           pulse2_pitch_macro: .byte 2
00287e                           pulse2_pitch_macro_offset: .byte 1
00287f                           pulse2_pitch_macro_loop: .byte 1
002880                           pulse2_pitch_macro_release: .byte 1
                                 
002881                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002882                           pulse2_hi_pitch_macro: .byte 2
002884                           pulse2_hi_pitch_macro_offset: .byte 1
002885                           pulse2_hi_pitch_macro_loop: .byte 1
002886                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002887                           pulse2_duty_macro: .byte 2
002889                           pulse2_duty_macro_offset: .byte 1
00288a                           pulse2_duty_macro_loop: .byte 1
00288b                           pulse2_duty_macro_release: .byte 1
                                 
00288c                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00288e                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002890                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002892                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002894                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002896                           pulse2_fx_3xx_start: .byte 2 //the starting note period
002898                           pulse2_fx_3xx_target: .byte 2 //target note period
00289a                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00289c                           pulse2_fx_3xx_total_offset: .byte 2
00289e                           pulse2_fx_4xy_speed: .byte 1
00289f                           pulse2_fx_4xy_depth: .byte 1
0028a0                           pulse2_fx_4xy_phase: .byte 1
0028a1                           pulse2_fx_7xy_speed: .byte 1
0028a2                           pulse2_fx_7xy_depth: .byte 1
0028a3                           pulse2_fx_7xy_phase: .byte 1
0028a4                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028a5                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028a6                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028a7                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028a8                           pulse2_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
0028a9                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028ab                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028ad                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028af                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028b1                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028b3                           pulse2_fx_Rxy_total_offset: .byte 2
0028b5                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028b6                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028b7                           triangle_pattern: .byte 2
0028b9                           triangle_pattern_delay_rows: .byte 1
0028ba                           triangle_pattern_delay_frames: .byte 1
0028bb                           triangle_pattern_offset: .byte 2
                                 
0028bd                           triangle_volume_macro: .byte 2
0028bf                           triangle_volume_macro_offset: .byte 1
0028c0                           triangle_volume_macro_loop: .byte 1
0028c1                           triangle_volume_macro_release: .byte 1
                                 
0028c2                           triangle_arpeggio_macro: .byte 2
0028c4                           triangle_arpeggio_macro_offset: .byte 1
0028c5                           triangle_arpeggio_macro_loop: .byte 1
0028c6                           triangle_arpeggio_macro_release: .byte 1
0028c7                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028c8                           triangle_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
0028c9                           triangle_pitch_macro: .byte 2
0028cb                           triangle_pitch_macro_offset: .byte 1
0028cc                           triangle_pitch_macro_loop: .byte 1
0028cd                           triangle_pitch_macro_release: .byte 1
                                 
0028ce                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028cf                           triangle_hi_pitch_macro: .byte 2
0028d1                           triangle_hi_pitch_macro_offset: .byte 1
0028d2                           triangle_hi_pitch_macro_loop: .byte 1
0028d3                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028d4                           triangle_duty_macro: .byte 2
0028d6                           triangle_duty_macro_offset: .byte 1
0028d7                           triangle_duty_macro_loop: .byte 1
0028d8                           triangle_duty_macro_release: .byte 1
                                 
0028d9                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028db                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028dd                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028df                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028e1                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028e3                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028e5                           triangle_fx_3xx_target: .byte 2 //target note period
0028e7                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028e9                           triangle_fx_3xx_total_offset: .byte 2
0028eb                           triangle_fx_4xy_speed: .byte 1
0028ec                           triangle_fx_4xy_depth: .byte 1
0028ed                           triangle_fx_4xy_phase: .byte 1
0028ee                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028ef                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028f0                           triangle_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
0028f1                           triangle_fx_Qxy_target: .byte 2 //target note period
0028f3                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028f5                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028f7                           triangle_fx_Rxy_target: .byte 2 //target note period
0028f9                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028fb                           triangle_fx_Rxy_total_offset: .byte 2
0028fd                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028fe                           triangle_fx_Sxx_post: .byte 1
                                 
                                 
0028ff                           noise_pattern_delay: .byte 1
002900                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 
                                 reset:
000000 940c 1a66                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 1e19                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1d46                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1d51                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1d46                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1d68                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 1db5                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 1e02                 	jmp triangle_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(31): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(46): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(120): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(145): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(148): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(155): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(156): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(158): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(159): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(161): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(164): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(166): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(167): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(168): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(170): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(171): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(173): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(175): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(177): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(178): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(179): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(182): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(183): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(184): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(185): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(186): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(187): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(188): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(190): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(191): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(192): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(195): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(196): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(198): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(199): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(200): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(201): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(207): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(208): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(214): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(219): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(222): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(224): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(226): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(227): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(229): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(234): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(235): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(285): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(287): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(288): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(289): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(290): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(292): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(294): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(295): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(296): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(302): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(303): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(309): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(312): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(313): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(320): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
001a66 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
001a67 93c0 0034                 	sts CPU_CCP, r28
001a69 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
001a6a 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001a6c 2422                      	clr zero
                                 
                                 	//MEMORY
001a6d e3c0                      	ldi r28, 0b00110000
001a6e 93c0 2800                 	sts pulse1_param, r28
001a70 e8c0                      	ldi r28, 0b10000000
001a71 93c0 2801                 	sts pulse1_sweep_param, r28
001a73 efcf                      	ldi r28, 0xFF
001a74 93c0 2802                 	sts pulse1_timerL, r28
001a76 93c0 2803                 	sts pulse1_timerH, r28
001a78 93c0 2804                 	sts pulse1_length, r28
                                 
001a7a e3c0                      	ldi r28, 0b00110000
001a7b 93c0 2808                 	sts pulse2_param, r28
001a7d e8c0                      	ldi r28, 0b10000000
001a7e 93c0 2809                 	sts pulse2_sweep_param, r28
001a80 efcf                      	ldi r28, 0xFF
001a81 93c0 280a                 	sts pulse2_timerL, r28
001a83 93c0 280b                 	sts pulse2_timerH, r28
001a85 93c0 280c                 	sts pulse2_length, r28
                                 
001a87 efcf                      	ldi r28, 0xFF
001a88 93c0 2810                 	sts triangle_timerL, r28
001a8a 93c0 2811                 	sts triangle_timerH, r28
                                 
001a8c e0c2                      	ldi r28, 0x02
001a8d 93c0 2815                 	sts song_frame_offset, r28
001a8f 9220 2816                 	sts song_frame_offset+1, zero
001a91 efcf                      	ldi r28, 0xFF
001a92 93c0 281a                 	sts song_fx_Bxx, r28
001a94 9220 281b                 	sts song_fx_Cxx, zero
001a96 9220 281c                 	sts song_fx_Dxx, zero
001a98 e0e2                      	ldi ZL, LOW(song0_frames << 1)
001a99 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
001a9a 93e0 2813                 	sts song_frames, ZL
001a9c 93f0 2814                 	sts song_frames+1, ZH
001a9e 91c5                      	lpm r28, Z+ //load the song size
001a9f 91d5                      	lpm r29, Z+
001aa0 93c0 2817                 	sts song_size, r28
001aa2 93d0 2818                 	sts song_size+1, r29
001aa4 9220 2819                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
001aa6 91c5                      	lpm r28, Z+
001aa7 91d5                      	lpm r29, Z+
001aa8 0fcc                      	lsl r28
001aa9 1fdd                      	rol r29
001aaa 93c0 281d                 	sts pulse1_pattern, r28
001aac 93d0 281e                 	sts pulse1_pattern+1, r29
001aae 9220 281f                 	sts pulse1_pattern_delay_rows, zero
001ab0 9220 2820                 	sts pulse1_pattern_delay_frames, zero
001ab2 9220 2821                 	sts pulse1_pattern_offset, zero
001ab4 9220 2822                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
001ab6 91c5                      	lpm r28, Z+
001ab7 91d5                      	lpm r29, Z+
001ab8 0fcc                      	lsl r28
001ab9 1fdd                      	rol r29
001aba 93c0 286a                 	sts pulse2_pattern, r28
001abc 93d0 286b                 	sts pulse2_pattern+1, r29
001abe 9220 286c                 	sts pulse2_pattern_delay_rows, zero
001ac0 9220 286d                 	sts pulse2_pattern_delay_frames, zero
001ac2 9220 286e                 	sts pulse2_pattern_offset, zero
001ac4 9220 286f                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
001ac6 91c5                      	lpm r28, Z+
001ac7 91d5                      	lpm r29, Z+
001ac8 0fcc                      	lsl r28
001ac9 1fdd                      	rol r29
001aca 93c0 28b7                 	sts triangle_pattern, r28
001acc 93d0 28b8                 	sts triangle_pattern+1, r29
001ace 9220 28b9                 	sts triangle_pattern_delay_rows, zero
001ad0 9220 28ba                 	sts triangle_pattern_delay_frames, zero
001ad2 9220 28bb                 	sts triangle_pattern_offset, zero
001ad4 9220 28bc                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
001ad6 efcf                      	ldi r28, 0xFF
001ad7 9220 2825                 	sts pulse1_volume_macro_offset, zero
001ad9 93c0 2826                 	sts pulse1_volume_macro_loop, r28
001adb 93c0 2827                 	sts pulse1_volume_macro_release, r28
001add 9220 282a                 	sts pulse1_arpeggio_macro_offset, zero
001adf 93c0 282b                 	sts pulse1_arpeggio_macro_loop, r28
001ae1 93c0 282c                 	sts pulse1_arpeggio_macro_release, r28
001ae3 93c0 282d                 	sts pulse1_arpeggio_macro_mode, r28
001ae5 9220 2831                 	sts pulse1_pitch_macro_offset, zero
001ae7 93c0 2832                 	sts pulse1_pitch_macro_loop, r28
001ae9 93c0 2833                 	sts pulse1_pitch_macro_release, r28
001aeb 9220 2837                 	sts pulse1_hi_pitch_macro_offset, zero
001aed 93c0 2838                 	sts pulse1_hi_pitch_macro_loop, r28
001aef 93c0 2839                 	sts pulse1_hi_pitch_macro_release, r28
001af1 9220 283c                 	sts pulse1_duty_macro_offset, zero
001af3 93c0 283d                 	sts pulse1_duty_macro_loop, r28
001af5 93c0 283e                 	sts pulse1_duty_macro_release, r28
                                 
001af7 9220 2823                 	sts pulse1_volume_macro, zero
001af9 9220 2824                 	sts pulse1_volume_macro+1, zero
001afb 9220 2828                 	sts pulse1_arpeggio_macro, zero
001afd 9220 2829                 	sts pulse1_arpeggio_macro+1, zero
001aff 9220 282e                 	sts pulse1_total_pitch_offset, zero
001b01 9220 282f                 	sts pulse1_pitch_macro, zero
001b03 9220 2830                 	sts pulse1_pitch_macro+1, zero
001b05 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero
001b07 9220 2835                 	sts pulse1_hi_pitch_macro, zero
001b09 9220 2836                 	sts pulse1_hi_pitch_macro+1, zero
001b0b 9220 283a                 	sts pulse1_duty_macro, zero
001b0d 9220 283b                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001b0f e00f                      	ldi pulse1_volume_divider, 0x0F
001b10 9110 2800                 	lds pulse1_volume_decay, pulse1_param
001b12 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001b13 9190 2800                 	lds pulse_channel_flags, pulse1_param
001b15 7390                      	andi pulse_channel_flags, 0b00110000
001b16 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001b17 9220 2806                 	sts pulse1_output_volume, zero
001b19 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001b1b 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001b1c e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001b1d 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001b1e 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
001b20 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
001b21 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
001b22 efcf                      	ldi r28, 0xFF
001b23 9220 283f                 	sts pulse1_fx_0xy_sequence, zero
001b25 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
001b27 9220 2841                 	sts pulse1_fx_1xx, zero
001b29 9220 2842                 	sts pulse1_fx_1xx+1, zero
001b2b 9220 2843                 	sts pulse1_fx_1xx_total, zero
001b2d 9220 2844                 	sts pulse1_fx_1xx_total+1, zero
001b2f 9220 2845                 	sts pulse1_fx_2xx, zero
001b31 9220 2846                 	sts pulse1_fx_2xx+1, zero
001b33 9220 2847                 	sts pulse1_fx_2xx_total, zero
001b35 9220 2848                 	sts pulse1_fx_2xx_total+1, zero
001b37 9220 2849                 	sts pulse1_fx_3xx_start, zero
001b39 9220 284a                 	sts pulse1_fx_3xx_start+1, zero
001b3b 9220 284b                 	sts pulse1_fx_3xx_target, zero
001b3d 9220 284c                 	sts pulse1_fx_3xx_target+1, zero
001b3f 9220 284d                 	sts pulse1_fx_3xx_speed, zero
001b41 9220 284e                 	sts pulse1_fx_3xx_speed+1, zero
001b43 9220 284f                 	sts pulse1_fx_3xx_total_offset, zero
001b45 9220 2850                 	sts pulse1_fx_3xx_total_offset+1, zero
001b47 9220 2851                 	sts pulse1_fx_4xy_speed, zero
001b49 9220 2852                 	sts pulse1_fx_4xy_depth, zero
001b4b 9220 2853                 	sts pulse1_fx_4xy_phase, zero
001b4d 9220 2854                 	sts pulse1_fx_7xy_speed, zero
001b4f 9220 2855                 	sts pulse1_fx_7xy_depth, zero
001b51 9220 2856                 	sts pulse1_fx_7xy_phase, zero
001b53 9220 2857                 	sts pulse1_fx_7xy_value, zero
001b55 9220 2858                 	sts pulse1_fx_Axy, zero
001b57 93c0 2859                 	sts pulse1_fx_Gxx_pre, r28
001b59 93c0 285a                 	sts pulse1_fx_Gxx_post, r28
001b5b 9220 285b                 	sts pulse1_fx_Pxx, zero
001b5d 9220 285c                 	sts pulse1_fx_Qxy_target, zero
001b5f 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
001b61 9220 285e                 	sts pulse1_fx_Qxy_speed, zero
001b63 9220 285f                 	sts pulse1_fx_Qxy_speed+1, zero
001b65 9220 2860                 	sts pulse1_fx_Qxy_total_offset, zero
001b67 9220 2861                 	sts pulse1_fx_Qxy_total_offset+1, zero
001b69 9220 2862                 	sts pulse1_fx_Rxy_target, zero
001b6b 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
001b6d 9220 2864                 	sts pulse1_fx_Rxy_speed, zero
001b6f 9220 2865                 	sts pulse1_fx_Rxy_speed+1, zero
001b71 9220 2866                 	sts pulse1_fx_Rxy_total_offset, zero
001b73 9220 2867                 	sts pulse1_fx_Rxy_total_offset+1, zero
001b75 93c0 2868                 	sts pulse1_fx_Sxx_pre, r28
001b77 93c0 2869                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
001b79 efcf                      	ldi r28, 0xFF
001b7a 9220 2872                 	sts pulse2_volume_macro_offset, zero
001b7c 93c0 2873                 	sts pulse2_volume_macro_loop, r28
001b7e 93c0 2874                 	sts pulse2_volume_macro_release, r28
001b80 9220 2877                 	sts pulse2_arpeggio_macro_offset, zero
001b82 93c0 2878                 	sts pulse2_arpeggio_macro_loop, r28
001b84 93c0 2879                 	sts pulse2_arpeggio_macro_release, r28
001b86 93c0 287a                 	sts pulse2_arpeggio_macro_mode, r28
001b88 9220 287e                 	sts pulse2_pitch_macro_offset, zero
001b8a 93c0 287f                 	sts pulse2_pitch_macro_loop, r28
001b8c 93c0 2880                 	sts pulse2_pitch_macro_release, r28
001b8e 9220 2884                 	sts pulse2_hi_pitch_macro_offset, zero
001b90 93c0 2885                 	sts pulse2_hi_pitch_macro_loop, r28
001b92 93c0 2886                 	sts pulse2_hi_pitch_macro_release, r28
001b94 9220 2889                 	sts pulse2_duty_macro_offset, zero
001b96 93c0 288a                 	sts pulse2_duty_macro_loop, r28
001b98 93c0 288b                 	sts pulse2_duty_macro_release, r28
                                 
001b9a 9220 2870                 	sts pulse2_volume_macro, zero
001b9c 9220 2871                 	sts pulse2_volume_macro+1, zero
001b9e 9220 2875                 	sts pulse2_arpeggio_macro, zero
001ba0 9220 2876                 	sts pulse2_arpeggio_macro+1, zero
001ba2 9220 287b                 	sts pulse2_total_pitch_offset, zero
001ba4 9220 287c                 	sts pulse2_pitch_macro, zero
001ba6 9220 287d                 	sts pulse2_pitch_macro+1, zero
001ba8 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero
001baa 9220 2882                 	sts pulse2_hi_pitch_macro, zero
001bac 9220 2883                 	sts pulse2_hi_pitch_macro+1, zero
001bae 9220 2887                 	sts pulse2_duty_macro, zero
001bb0 9220 2888                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
001bb2 e02f                      	ldi pulse2_volume_divider, 0x0F
001bb3 9130 2808                 	lds pulse2_volume_decay, pulse2_param
001bb5 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
001bb6 91d0 2808                 	lds r29, pulse2_param
001bb8 73d0                      	andi r29, 0b00110000
001bb9 62d0                      	sbr r29, 0b0100000 //set start flag
001bba 95d2                      	swap r29
001bbb 2b9d                      	or pulse_channel_flags, r29
001bbc 9220 280e                 	sts pulse2_output_volume, zero
001bbe 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
001bc0 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
001bc1 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001bc2 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
001bc3 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
001bc5 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
001bc6 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001bc7 efcf                      	ldi r28, 0xFF
001bc8 9220 288c                 	sts pulse2_fx_0xy_sequence, zero
001bca 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
001bcc 9220 288e                 	sts pulse2_fx_1xx, zero
001bce 9220 288f                 	sts pulse2_fx_1xx+1, zero
001bd0 9220 2890                 	sts pulse2_fx_1xx_total, zero
001bd2 9220 2891                 	sts pulse2_fx_1xx_total+1, zero
001bd4 9220 2892                 	sts pulse2_fx_2xx, zero
001bd6 9220 2893                 	sts pulse2_fx_2xx+1, zero
001bd8 9220 2894                 	sts pulse2_fx_2xx_total, zero
001bda 9220 2895                 	sts pulse2_fx_2xx_total+1, zero
001bdc 9220 2896                 	sts pulse2_fx_3xx_start, zero
001bde 9220 2897                 	sts pulse2_fx_3xx_start+1, zero
001be0 9220 2898                 	sts pulse2_fx_3xx_target, zero
001be2 9220 2899                 	sts pulse2_fx_3xx_target+1, zero
001be4 9220 289a                 	sts pulse2_fx_3xx_speed, zero
001be6 9220 289b                 	sts pulse2_fx_3xx_speed+1, zero
001be8 9220 289c                 	sts pulse2_fx_3xx_total_offset, zero
001bea 9220 289d                 	sts pulse2_fx_3xx_total_offset+1, zero
001bec 9220 289e                 	sts pulse2_fx_4xy_speed, zero
001bee 9220 289f                 	sts pulse2_fx_4xy_depth, zero
001bf0 9220 28a0                 	sts pulse2_fx_4xy_phase, zero
001bf2 9220 28a1                 	sts pulse2_fx_7xy_speed, zero
001bf4 9220 28a2                 	sts pulse2_fx_7xy_depth, zero
001bf6 9220 28a3                 	sts pulse2_fx_7xy_phase, zero
001bf8 9220 28a4                 	sts pulse2_fx_7xy_value, zero
001bfa 9220 28a5                 	sts pulse2_fx_Axy, zero
001bfc 93c0 28a6                 	sts pulse2_fx_Gxx_pre, r28
001bfe 93c0 28a7                 	sts pulse2_fx_Gxx_post, r28
001c00 9220 28a8                 	sts pulse2_fx_Pxx, zero
001c02 9220 28a9                 	sts pulse2_fx_Qxy_target, zero
001c04 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
001c06 9220 28ab                 	sts pulse2_fx_Qxy_speed, zero
001c08 9220 28ac                 	sts pulse2_fx_Qxy_speed+1, zero
001c0a 9220 28ad                 	sts pulse2_fx_Qxy_total_offset, zero
001c0c 9220 28ae                 	sts pulse2_fx_Qxy_total_offset+1, zero
001c0e 9220 28af                 	sts pulse2_fx_Rxy_target, zero
001c10 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
001c12 9220 28b1                 	sts pulse2_fx_Rxy_speed, zero
001c14 9220 28b2                 	sts pulse2_fx_Rxy_speed+1, zero
001c16 9220 28b3                 	sts pulse2_fx_Rxy_total_offset, zero
001c18 9220 28b4                 	sts pulse2_fx_Rxy_total_offset+1, zero
001c1a 93c0 28b5                 	sts pulse2_fx_Sxx_pre, r28
001c1c 93c0 28b6                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
001c1e efcf                      	ldi r28, 0xFF
001c1f 9220 28bf                 	sts triangle_volume_macro_offset, zero
001c21 93c0 28c0                 	sts triangle_volume_macro_loop, r28
001c23 93c0 28c1                 	sts triangle_volume_macro_release, r28
001c25 9220 28c4                 	sts triangle_arpeggio_macro_offset, zero
001c27 93c0 28c5                 	sts triangle_arpeggio_macro_loop, r28
001c29 93c0 28c6                 	sts triangle_arpeggio_macro_release, r28
001c2b 93c0 28c7                 	sts triangle_arpeggio_macro_mode, r28
001c2d 9220 28cb                 	sts triangle_pitch_macro_offset, zero
001c2f 93c0 28cc                 	sts triangle_pitch_macro_loop, r28
001c31 93c0 28cd                 	sts triangle_pitch_macro_release, r28
001c33 9220 28d1                 	sts triangle_hi_pitch_macro_offset, zero
001c35 93c0 28d2                 	sts triangle_hi_pitch_macro_loop, r28
001c37 93c0 28d3                 	sts triangle_hi_pitch_macro_release, r28
001c39 9220 28d6                 	sts triangle_duty_macro_offset, zero
001c3b 93c0 28d7                 	sts triangle_duty_macro_loop, r28
001c3d 93c0 28d8                 	sts triangle_duty_macro_release, r28
                                 
001c3f 9220 28bd                 	sts triangle_volume_macro, zero
001c41 9220 28be                 	sts triangle_volume_macro+1, zero
001c43 9220 28c2                 	sts triangle_arpeggio_macro, zero
001c45 9220 28c3                 	sts triangle_arpeggio_macro+1, zero
001c47 9220 28c8                 	sts triangle_total_pitch_offset, zero
001c49 9220 28c9                 	sts triangle_pitch_macro, zero
001c4b 9220 28ca                 	sts triangle_pitch_macro+1, zero
001c4d 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero
001c4f 9220 28cf                 	sts triangle_hi_pitch_macro, zero
001c51 9220 28d0                 	sts triangle_hi_pitch_macro+1, zero
001c53 9220 28d4                 	sts triangle_duty_macro, zero
001c55 9220 28d5                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 SEQUENCE
001c57 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
001c58 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 3 FX
001c59 efcf                      	ldi r28, 0xFF
001c5a 9220 28d9                 	sts triangle_fx_0xy_sequence, zero
001c5c 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
001c5e 9220 28db                 	sts triangle_fx_1xx, zero
001c60 9220 28dc                 	sts triangle_fx_1xx+1, zero
001c62 9220 28dd                 	sts triangle_fx_1xx_total, zero
001c64 9220 28de                 	sts triangle_fx_1xx_total+1, zero
001c66 9220 28df                 	sts triangle_fx_2xx, zero
001c68 9220 28e0                 	sts triangle_fx_2xx+1, zero
001c6a 9220 28e1                 	sts triangle_fx_2xx_total, zero
001c6c 9220 28e2                 	sts triangle_fx_2xx_total+1, zero
001c6e 9220 28e3                 	sts triangle_fx_3xx_start, zero
001c70 9220 28e4                 	sts triangle_fx_3xx_start+1, zero
001c72 9220 28e5                 	sts triangle_fx_3xx_target, zero
001c74 9220 28e6                 	sts triangle_fx_3xx_target+1, zero
001c76 9220 28e7                 	sts triangle_fx_3xx_speed, zero
001c78 9220 28e8                 	sts triangle_fx_3xx_speed+1, zero
001c7a 9220 28e9                 	sts triangle_fx_3xx_total_offset, zero
001c7c 9220 28ea                 	sts triangle_fx_3xx_total_offset+1, zero
001c7e 9220 28eb                 	sts triangle_fx_4xy_speed, zero
001c80 9220 28ec                 	sts triangle_fx_4xy_depth, zero
001c82 9220 28ed                 	sts triangle_fx_4xy_phase, zero
001c84 93c0 28ee                 	sts triangle_fx_Gxx_pre, r28
001c86 93c0 28ef                 	sts triangle_fx_Gxx_post, r28
001c88 9220 28f0                 	sts triangle_fx_Pxx, zero
001c8a 9220 28f1                 	sts triangle_fx_Qxy_target, zero
001c8c 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
001c8e 9220 28f3                 	sts triangle_fx_Qxy_speed, zero
001c90 9220 28f4                 	sts triangle_fx_Qxy_speed+1, zero
001c92 9220 28f5                 	sts triangle_fx_Qxy_total_offset, zero
001c94 9220 28f6                 	sts triangle_fx_Qxy_total_offset+1, zero
001c96 9220 28f7                 	sts triangle_fx_Rxy_target, zero
001c98 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
001c9a 9220 28f9                 	sts triangle_fx_Rxy_speed, zero
001c9c 9220 28fa                 	sts triangle_fx_Rxy_speed+1, zero
001c9e 9220 28fb                 	sts triangle_fx_Rxy_total_offset, zero
001ca0 9220 28fc                 	sts triangle_fx_Rxy_total_offset+1, zero
001ca2 93c0 28fd                 	sts triangle_fx_Sxx_pre, r28
001ca4 93c0 28fe                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//PINS
001ca6 efcf                      	ldi r28, 0xFF
001ca7 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
001ca8 e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
001ca9 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
001cab e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
001cac 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001cae e1c5                      	ldi r28, 0x15 //set the period for CMP0
001caf 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
001cb1 e0c5                      	ldi r28, 0x05
001cb2 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
001cb4 e2cb                      	ldi r28, 0x2B //set the period for CMP1
001cb5 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
001cb7 e0ca                      	ldi r28, 0x0A
001cb8 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
001cba e4c1                      	ldi r28, 0x41 //set the period for CMP2
001cbb 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
001cbd e0cf                      	ldi r28, 0x0F
001cbe 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
001cc0 e5c7                      	ldi r28, 0x57 //set the period for OVF
001cc1 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
001cc3 e1c4                      	ldi r28, 0x14
001cc4 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
001cc6 e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
001cc7 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
001cc9 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
001cca 93c0 0a81                 	sts TCB0_CTRLB, r28
001ccc e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
001ccd 93c0 0a85                 	sts TCB0_INTCTRL, r28
001ccf 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001cd1 93c0 0a8c                 	sts TCB0_CCMPL, r28
001cd3 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001cd5 93c0 0a8d                 	sts TCB0_CCMPH, r28
001cd7 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001cd8 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001cda e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001cdb 93b0 0a91                 	sts TCB1_CTRLB, r27
001cdd e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001cde 93b0 0a95                 	sts TCB1_INTCTRL, r27
001ce0 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001ce2 93b0 0a9c                 	sts TCB1_CCMPL, r27
001ce4 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001ce6 93b0 0a9d                 	sts TCB1_CCMPH, r27
001ce8 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001ce9 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001ceb e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001cec 93b0 0aa1                 	sts TCB2_CTRLB, r27
001cee e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001cef 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001cf1 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
001cf3 93b0 0aac                 	sts TCB2_CCMPL, r27
001cf5 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
001cf7 93b0 0aad                 	sts TCB2_CCMPH, r27
001cf9 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001cfa 93b0 0aa0                 	sts TCB2_CTRLA, r27
001cfc 9478                      	sei //global interrupt enable
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
001cfd 91c0 2806                 	lds r28, pulse1_output_volume
001cff 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
001d01 fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
001d02 c015                      	rjmp volume_mixer_pulse1_off
                                 
001d03 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
001d04 f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
001d05 91e0 0a8c                 	lds r30, TCB0_CCMPL
001d07 e5f9                      	ldi r31, 0x059
001d08 17ef                      	cp r30, r31
001d09 91e0 0a8d                 	lds r30, TCB0_CCMPH
001d0b e0f0                      	ldi r31, 0x00
001d0c 07ef                      	cpc r30, r31
001d0d f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
001d0e 91e0 0a8c                 	lds r30, TCB0_CCMPL
001d10 e6f6                      	ldi r31, 0x66
001d11 17ef                      	cp r30, r31
001d12 91e0 0a8d                 	lds r30, TCB0_CCMPH
001d14 e5f9                      	ldi r31, 0x59
001d15 07ef                      	cpc r30, r31
001d16 f408                      	brsh volume_mixer_pulse1_off
001d17 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
001d18 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
001d19 fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
001d1a c015                      	rjmp volume_mixer_pulse2_off
                                 
001d1b 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
001d1c f099                      	breq volume_mixer_pulse2_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
001d1d 91e0 0a9c                 	lds r30, TCB1_CCMPL
001d1f e5f9                      	ldi r31, 0x059
001d20 17ef                      	cp r30, r31
001d21 91e0 0a9d                 	lds r30, TCB1_CCMPH
001d23 e0f0                      	ldi r31, 0x00
001d24 07ef                      	cpc r30, r31
001d25 f050                      	brlo volume_mixer_pulse2_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
001d26 91e0 0a9c                 	lds r30, TCB1_CCMPL
001d28 e6f6                      	ldi r31, 0x66
001d29 17ef                      	cp r30, r31
001d2a 91e0 0a9d                 	lds r30, TCB1_CCMPH
001d2c e5f9                      	ldi r31, 0x59
001d2d 07ef                      	cpc r30, r31
001d2e f408                      	brsh volume_mixer_pulse2_off
001d2f c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001d30 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
001d31 0fcd                      	add r28, r29
001d32 e1e6                      	ldi ZL, LOW(pulse_volume_table << 1)
001d33 e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
001d34 0fec                      	add ZL, r28
001d35 1df2                      	adc ZH, zero
001d36 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001d37 2fd4                      	mov r29, triangle_sequence
001d38 fdd4                      	sbrc r29, 4 //check 5th bit
001d39 95d0                      	com r29
001d3a 70df                      	andi r29, 0x0F
001d3b 2fed                      	mov r30, r29
001d3c 0fde                      	add r29, r30 //multiply the triangle volume by 3
001d3d 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
001d3e e3e6                      	ldi ZL, LOW(tnd_volume_table << 1)
001d3f e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
001d40 0fed                      	add ZL, r29
001d41 1df2                      	adc ZH, zero
001d42 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001d43 0fcd                      	add r28, r29
001d44 b9c1                      	out VPORTA_OUT, r28
001d45 cfb7                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001d46 b7bf                      	in r27, CPU_SREG
001d47 93bf                      	push r27
001d48 94f8                      	cli
                                 
                                 	//ENVELOPE
001d49 d053                      	rcall pulse1_envelope_routine
001d4a d09f                      	rcall pulse2_envelope_routine
                                 
001d4b e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
001d4c 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001d4e 91bf                      	pop r27
001d4f bfbf                      	out CPU_SREG, r27
001d50 9518                      	reti
                                 
                                 sequence_1_3:
001d51 b7bf                      	in r27, CPU_SREG
001d52 93bf                      	push r27
001d53 94f8                      	cli
                                 
                                 	//ENVELOPE
001d54 d048                      	rcall pulse1_envelope_routine
001d55 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001d56 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001d57 d01b                      	rcall pulse1_sweep_routine
001d58 fcf3                      	sbrc pulse2_sweep, 3
001d59 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001d5a fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001d5b c002                      	rjmp sequence_1_3_pulse2_length
001d5c 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001d5d 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001d5e fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001d5f c002                      	rjmp sequence_1_3_exit
001d60 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001d61 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001d62 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
001d63 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001d65 91bf                      	pop r27
001d66 bfbf                      	out CPU_SREG, r27
001d67 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001d68 b7bf                      	in r27, CPU_SREG
001d69 93bf                      	push r27
001d6a 94f8                      	cli
                                 
001d6b 0caa                      	lsl pulse1_sequence //shifts sequence to the left
001d6c 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001d6d e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001d6e 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001d70 91bf                      	pop r27
001d71 bfbf                      	out CPU_SREG, r27
001d72 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001d73 2dbc                      	mov r27, pulse1_sweep
001d74 70b7                      	andi r27, 0x07 //mask for period divider bits
001d75 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001d76 93df                      	push r29
001d77 2ddc                      	mov r29, pulse1_sweep
001d78 95d2                      	swap r29
001d79 70d7                      	andi r29, 0x07 //mask for shift bits
001d7a f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001d7b 91df                      	pop r29
001d7c c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001d7d 91a0 0a8c                 	lds r26, TCB0_CCMPL
001d7f 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001d81 95b6                      	lsr r27
001d82 95a7                      	ror r26
001d83 95da                      	dec r29
001d84 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001d85 fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
001d86 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001d87 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001d88 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001d89 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001d8b 0fad                      	add r26, r29
001d8c 91d0 0a8d                 	lds r29, TCB0_CCMPH
001d8e 1fbd                      	adc r27, r29
                                 
001d8f 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001d91 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001d93 91df                      	pop r29
001d94 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001d95 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001d96 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
001d97 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001d98 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001d9a 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
001d9b 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
001d9c 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001d9d fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
001d9e c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001d9f 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001da0 f011                      	breq PC+3 //if the divider == 0, check loop flag
001da1 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001da2 9508                      	ret
                                 
001da3 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001da5 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001da6 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001da7 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001da8 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001da9 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001daa 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001dab f409                      	brne PC+2 //if decay != 0, go decrement
001dac 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001dad 951a                      	dec pulse1_volume_decay
001dae 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001daf 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
001db0 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001db2 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001db3 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001db4 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
001db5 b7bf                      	in r27, CPU_SREG
001db6 93bf                      	push r27
001db7 94f8                      	cli
                                 
001db8 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
001db9 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001dba e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001dbb 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001dbd 91bf                      	pop r27
001dbe bfbf                      	out CPU_SREG, r27
001dbf 9518                      	reti
                                 
                                 pulse2_sweep_routine:
001dc0 2dbf                      	mov r27, pulse2_sweep
001dc1 70b7                      	andi r27, 0x07 //mask for period divider bits
001dc2 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001dc3 93df                      	push r29
001dc4 2ddf                      	mov r29, pulse2_sweep
001dc5 95d2                      	swap r29
001dc6 70d7                      	andi r29, 0x07 //mask for shift bits
001dc7 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001dc8 91df                      	pop r29
001dc9 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001dca 91a0 0a9c                 	lds r26, TCB1_CCMPL
001dcc 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
001dce 95b6                      	lsr r27
001dcf 95a7                      	ror r26
001dd0 95da                      	dec r29
001dd1 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001dd2 fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
001dd3 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001dd4 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001dd5 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001dd6 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001dd8 0fad                      	add r26, r29
001dd9 91d0 0a9d                 	lds r29, TCB1_CCMPH
001ddb 1fbd                      	adc r27, r29
                                 
001ddc 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
001dde 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001de0 91df                      	pop r29
001de1 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
001de2 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
001de3 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
001de4 9508                      	ret
                                 
                                 pulse2_sweep_reload:
001de5 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001de7 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
001de8 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
001de9 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
001dea fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
001deb c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
001dec 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
001ded f011                      	breq PC+3 //if the divider == 0, check loop flag
001dee 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
001def 9508                      	ret
                                 
001df0 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
001df2 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001df3 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
001df4 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001df5 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001df6 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001df7 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
001df8 f409                      	brne PC+2 //if decay != 0, go decrement
001df9 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001dfa 953a                      	dec pulse2_volume_decay
001dfb 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
001dfc 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
001dfd 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
001dff 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001e00 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
001e01 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
001e02 b7bf                      	in r27, CPU_SREG
001e03 93bf                      	push r27
001e04 94f8                      	cli
                                 
001e05 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
001e06 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
001e07 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001e08 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
001e0a 91bf                      	pop r27
001e0b bfbf                      	out CPU_SREG, r27
001e0c 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001e0d e4ec                      	ldi ZL, LOW(length << 1)
001e0e e6f3                      	ldi ZH, HIGH(length << 1)
001e0f 0fed                      	add ZL, r29
001e10 1df2                      	adc ZH, zero
001e11 91d4                      	lpm r29, Z
001e12 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001e13 e6ec                      	ldi ZL, LOW(sequences << 1)
001e14 e6f3                      	ldi ZH, HIGH(sequences << 1)
001e15 0fed                      	add ZL, r29
001e16 1df2                      	adc ZH, zero
001e17 91d4                      	lpm r29, Z
001e18 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
001e19 b7bf                      	in r27, CPU_SREG
001e1a 93bf                      	push r27
001e1b 94f8                      	cli
001e1c 93cf                      	push r28
001e1d 93df                      	push r29
001e1e 93ef                      	push r30
001e1f 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001e20 91a0 281a                 	lds r26, song_fx_Bxx
001e22 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001e23 f4a9                      	brne sound_driver_fx_Bxx_routine
001e24 91a0 281b                 	lds r26, song_fx_Cxx
001e26 11a2                      	cpse r26, zero
001e27 c073                      	rjmp sound_driver_fx_Cxx_routine
001e28 91a0 281c                 	lds r26, song_fx_Dxx
001e2a 11a2                      	cpse r26, zero
001e2b c080                      	rjmp sound_driver_fx_Dxx_routine
                                 
001e2c 91a0 2815                 	lds r26, song_frame_offset
001e2e 91b0 2816                 	lds r27, song_frame_offset+1
001e30 91c0 2817                 	lds r28, song_size
001e32 91d0 2818                 	lds r29, song_size+1
001e34 17ac                      	cp r26, r28
001e35 07bd                      	cpc r27, r29
001e36 f408                      	brsh sound_driver_fx_song_loop
001e37 c0d3                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
001e38 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001e39 91e0 2813                 	lds ZL, song_frames
001e3b 91f0 2814                 	lds ZH, song_frames+1
001e3d 27cc                      	clr r28 //initialize r29:r28 to 0
001e3e 27dd                      	clr r29
001e3f 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001e40 95aa                      	dec r26
001e41 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001e42 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001e43 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
001e44 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
001e45 93c0 2815                 	sts song_frame_offset, r28
001e47 93d0 2816                 	sts song_frame_offset+1, r29
001e49 0fec                      	add ZL, r28
001e4a 1ffd                      	adc ZH, r29
                                 
001e4b 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
001e4c 91b5                      	lpm r27, Z+
001e4d 0faa                      	lsl r26
001e4e 1fbb                      	rol r27
001e4f 93a0 281d                 	sts pulse1_pattern, r26
001e51 93b0 281e                 	sts pulse1_pattern+1, r27
001e53 91a5                      	lpm r26, Z+
001e54 91b5                      	lpm r27, Z+
001e55 0faa                      	lsl r26
001e56 1fbb                      	rol r27
001e57 93a0 286a                 	sts pulse2_pattern, r26
001e59 93b0 286b                 	sts pulse2_pattern+1, r27
001e5b 91a5                      	lpm r26, Z+
001e5c 91b5                      	lpm r27, Z+
001e5d 0faa                      	lsl r26
001e5e 1fbb                      	rol r27
001e5f 93a0 28b7                 	sts triangle_pattern, r26
001e61 93b0 28b8                 	sts triangle_pattern+1, r27
                                 
001e63 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001e65 9220 2822                 	sts pulse1_pattern_offset+1, zero
001e67 9220 281f                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001e69 9220 2820                 	sts pulse1_pattern_delay_frames, zero
001e6b 9220 286e                 	sts pulse2_pattern_offset, zero
001e6d 9220 286f                 	sts pulse2_pattern_offset+1, zero
001e6f 9220 286c                 	sts pulse2_pattern_delay_rows, zero
001e71 9220 286d                 	sts pulse2_pattern_delay_frames, zero
001e73 9220 28bb                 	sts triangle_pattern_offset, zero
001e75 9220 28bc                 	sts triangle_pattern_offset+1, zero
001e77 9220 28b9                 	sts triangle_pattern_delay_rows, zero
001e79 9220 28ba                 	sts triangle_pattern_delay_frames, zero
                                 
001e7b efaf                      	ldi r26, 0xFF
001e7c 93a0 2859                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001e7e 93a0 285a                 	sts pulse1_fx_Gxx_post, r26
001e80 93a0 2868                 	sts pulse1_fx_Sxx_pre, r26
001e82 93a0 2869                 	sts pulse1_fx_Sxx_post, r26
001e84 93a0 28a6                 	sts pulse2_fx_Gxx_pre, r26
001e86 93a0 28a7                 	sts pulse2_fx_Gxx_post, r26
001e88 93a0 28b5                 	sts pulse2_fx_Sxx_pre, r26
001e8a 93a0 28b6                 	sts pulse2_fx_Sxx_post, r26
001e8c 93a0 28ee                 	sts triangle_fx_Gxx_pre, r26
001e8e 93a0 28ef                 	sts triangle_fx_Gxx_post, r26
001e90 93a0 28fd                 	sts triangle_fx_Sxx_pre, r26
001e92 93a0 28fe                 	sts triangle_fx_Sxx_post, r26
                                 
001e94 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
001e96 9220 281b                 	sts song_fx_Cxx, zero
001e98 9220 281c                 	sts song_fx_Dxx, zero
001e9a c070                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
001e9b 91ff                      	pop r31
001e9c 91ef                      	pop r30
001e9d 91df                      	pop r29
001e9e 91cf                      	pop r28
001e9f 91bf                      	pop r27
001ea0 bfbf                      	out CPU_SREG, r27
001ea1 94f8                      	cli //disable global interrupts
                                 		
001ea2 efaf                      	ldi r26, 0xFF
001ea3 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
001ea5 9220 281b                 	sts song_fx_Cxx, zero
001ea7 9220 281c                 	sts song_fx_Dxx, zero
                                 
001ea9 9220 2806                 	sts pulse1_output_volume, zero //mute all channels
001eab 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
001eac 91e0 2813                 	lds ZL, song_frames
001eae 91f0 2814                 	lds ZH, song_frames+1
001eb0 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001eb2 91b0 2816                 	lds r27, song_frame_offset+1
001eb4 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001eb5 93a0 2815                 	sts song_frame_offset, r26
001eb7 93b0 2816                 	sts song_frame_offset+1, r27
001eb9 0fea                      	add ZL, r26
001eba 1ffb                      	adc ZH, r27
                                 
001ebb 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ebc 91b5                      	lpm r27, Z+
001ebd 0faa                      	lsl r26
001ebe 1fbb                      	rol r27
001ebf 93a0 281d                 	sts pulse1_pattern, r26
001ec1 93b0 281e                 	sts pulse1_pattern+1, r27
001ec3 91a5                      	lpm r26, Z+
001ec4 91b5                      	lpm r27, Z+
001ec5 0faa                      	lsl r26
001ec6 1fbb                      	rol r27
001ec7 93a0 286a                 	sts pulse2_pattern, r26
001ec9 93b0 286b                 	sts pulse2_pattern+1, r27
001ecb 91a5                      	lpm r26, Z+
001ecc 91b5                      	lpm r27, Z+
001ecd 0faa                      	lsl r26
001ece 1fbb                      	rol r27
001ecf 93a0 28b7                 	sts triangle_pattern, r26
001ed1 93b0 28b8                 	sts triangle_pattern+1, r27
                                 
001ed3 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ed5 9220 2822                 	sts pulse1_pattern_offset+1, zero
001ed7 9220 281f                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001ed9 9220 2820                 	sts pulse1_pattern_delay_frames, zero
001edb 9220 286e                 	sts pulse2_pattern_offset, zero
001edd 9220 286f                 	sts pulse2_pattern_offset+1, zero
001edf 9220 286c                 	sts pulse2_pattern_delay_rows, zero
001ee1 9220 286d                 	sts pulse2_pattern_delay_frames, zero
001ee3 9220 28bb                 	sts triangle_pattern_offset, zero
001ee5 9220 28bc                 	sts triangle_pattern_offset+1, zero
001ee7 9220 28b9                 	sts triangle_pattern_delay_rows, zero
001ee9 9220 28ba                 	sts triangle_pattern_delay_frames, zero
                                 
001eeb efaf                      	ldi r26, 0xFF
001eec 93a0 2859                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001eee 93a0 285a                 	sts pulse1_fx_Gxx_post, r26
001ef0 93a0 2868                 	sts pulse1_fx_Sxx_pre, r26
001ef2 93a0 2869                 	sts pulse1_fx_Sxx_post, r26
001ef4 93a0 28a6                 	sts pulse2_fx_Gxx_pre, r26
001ef6 93a0 28a7                 	sts pulse2_fx_Gxx_post, r26
001ef8 93a0 28b5                 	sts pulse2_fx_Sxx_pre, r26
001efa 93a0 28b6                 	sts pulse2_fx_Sxx_post, r26
001efc 93a0 28ee                 	sts triangle_fx_Gxx_pre, r26
001efe 93a0 28ef                 	sts triangle_fx_Gxx_post, r26
001f00 93a0 28fd                 	sts triangle_fx_Sxx_pre, r26
001f02 93a0 28fe                 	sts triangle_fx_Sxx_post, r26
                                 
001f04 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
001f06 9220 281b                 	sts song_fx_Cxx, zero
001f08 9220 281c                 	sts song_fx_Dxx, zero
001f0a c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001f0b 91a0 281f                 	lds r26, pulse1_pattern_delay_rows
001f0d 91b0 2820                 	lds r27, pulse1_pattern_delay_frames
001f0f 9610                      	adiw r27:r26, 0
001f10 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
001f11 c2c2                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001f12 91e0 281d                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001f14 91f0 281e                 	lds ZH, pulse1_pattern+1
001f16 91a0 2821                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001f18 91b0 2822                 	lds r27, pulse1_pattern_offset+1
001f1a 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001f1b 1ffb                      	adc ZH, r27
001f1c 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
001f1d 35b7                      	cpi r27, 0x57
001f1e f408                      	brsh sound_driver_channel0_check_if_volume
001f1f c16b                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001f20 36b7                      	cpi r27, 0x67
001f21 f408                      	brsh sound_driver_channel0_check_if_delay
001f22 c1a3                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001f23 3eb3                      	cpi r27, 0xE3
001f24 f408                      	brsh sound_driver_channel0_check_if_instrument
001f25 c1aa                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001f26 f409                      	brne sound_driver_channel0_check_if_release
001f27 c1ad                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001f28 3eb4                      	cpi r27, 0xE4
001f29 f409                      	brne sound_driver_channel0_check_if_end
001f2a c254                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001f2b 3fbf                      	cpi r27, 0xFF
001f2c f409                      	brne sound_driver_channel0_check_if_fx
001f2d c276                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001f2e 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001f2f 91a4                      	lpm r26, Z //load the fx data into r26
001f30 d299                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001f31 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001f32 e7e0                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001f33 e6f3                      	ldi ZH, HIGH(channel0_fx << 1)
001f34 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001f35 0feb                      	add ZL, r27 //add offset
001f36 1df2                      	adc ZH, zero
001f37 91c5                      	lpm r28, Z+ //load address bytes
001f38 91d4                      	lpm r29, Z
001f39 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001f3a 2ffd                      	mov ZH, r29
001f3b 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001f3c 93a0 283f                 	sts pulse1_fx_0xy_sequence, r26
001f3e 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
001f40 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
001f41 9220 2845                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001f43 9220 2846                 	sts pulse1_fx_2xx+1, zero
001f45 9220 283f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001f47 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
001f49 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f4a 937f                      	push r23
001f4b 2f6a                      	mov r22, r26 //store the rate into r22
001f4c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f4d 9f67                      	mul r22, r23
001f4e 917f                      	pop r23
001f4f 916f                      	pop r22
                                 
001f50 9416                      	lsr r1 //shift out the fractional bits
001f51 9407                      	ror r0
001f52 9416                      	lsr r1
001f53 9407                      	ror r0
001f54 9416                      	lsr r1
001f55 9407                      	ror r0
001f56 9416                      	lsr r1
001f57 9407                      	ror r0
001f58 9200 2841                 	sts pulse1_fx_1xx, r0
001f5a 9210 2842                 	sts pulse1_fx_1xx+1, r1
001f5c cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001f5d 9220 2841                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001f5f 9220 2842                 	sts pulse1_fx_1xx+1, zero
001f61 9220 283f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001f63 9220 2840                 	sts pulse1_fx_0xy_sequence+1, zero
001f65 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f66 937f                      	push r23
001f67 2f6a                      	mov r22, r26 //store the rate into r22
001f68 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f69 9f67                      	mul r22, r23
001f6a 917f                      	pop r23
001f6b 916f                      	pop r22
                                 
001f6c 9416                      	lsr r1 //shift out the fractional bits
001f6d 9407                      	ror r0
001f6e 9416                      	lsr r1
001f6f 9407                      	ror r0
001f70 9416                      	lsr r1
001f71 9407                      	ror r0
001f72 9416                      	lsr r1
001f73 9407                      	ror r0
001f74 9200 2845                 	sts pulse1_fx_2xx, r0
001f76 9210 2846                 	sts pulse1_fx_2xx+1, r1
001f78 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
001f79 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f7a 937f                      	push r23
001f7b 2f6a                      	mov r22, r26 //store the rate into r22
001f7c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f7d 9f67                      	mul r22, r23
001f7e 917f                      	pop r23
001f7f 916f                      	pop r22
                                 
001f80 9416                      	lsr r1 //shift out the fractional bits
001f81 9407                      	ror r0
001f82 9416                      	lsr r1
001f83 9407                      	ror r0
001f84 9416                      	lsr r1
001f85 9407                      	ror r0
001f86 9416                      	lsr r1
001f87 9407                      	ror r0
001f88 9200 284d                 	sts pulse1_fx_3xx_speed, r0
001f8a 9210 284e                 	sts pulse1_fx_3xx_speed+1, r1
                                 
001f8c 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001f8d c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
001f8e cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
001f8f 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001f91 91b0 0a8d                 	lds r27, TCB0_CCMPH
001f93 93a0 2849                 	sts pulse1_fx_3xx_start, r26
001f95 93b0 284a                 	sts pulse1_fx_3xx_start+1, r27
                                 
001f97 9220 284f                 	sts pulse1_fx_3xx_total_offset, zero
001f99 9220 2850                 	sts pulse1_fx_3xx_total_offset+1, zero
001f9b cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
001f9c 2fba                      	mov r27, r26
001f9d 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001f9e 95a2                      	swap r26
001f9f 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001fa0 93a0 2851                 	sts pulse1_fx_4xy_speed, r26
001fa2 93b0 2852                 	sts pulse1_fx_4xy_depth, r27
001fa4 9220 2853                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
001fa6 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
001fa7 2fba                      	mov r27, r26
001fa8 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001fa9 95a2                      	swap r26
001faa 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001fab 93a0 2854                 	sts pulse1_fx_7xy_speed, r26
001fad 93b0 2855                 	sts pulse1_fx_7xy_depth, r27
001faf 9220 2856                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
001fb1 9220 2857                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001fb3 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001fb4 93a0 2858                 	sts pulse1_fx_Axy, r26
001fb6 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
001fb7 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001fb9 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
001fba 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001fbc cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
001fbd 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001fbf cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
001fc0 91b0 2800                 	lds r27, pulse1_param
001fc2 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001fc3 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001fc4 93b0 2800                 	sts pulse1_param, r27
001fc6 6096                      	sbr pulse_channel_flags, 6
001fc7 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
001fc8 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001fca cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
001fcb 15a2                      	cp r26, zero
001fcc f051                      	breq sound_driver_channel0_fx_Gxx_invalid
001fcd 91b0 2819                 	lds r27, song_speed
001fcf 17ab                      	cp r26, r27
001fd0 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
001fd1 93a0 2859                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001fd3 e0b1                      	ldi r27, 0x01
001fd4 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
001fd6 c200                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
001fd7 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001fd8 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
001fd9 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
001fda cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
001fdb cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
001fdc 93a0 285b                 	sts pulse1_fx_Pxx, r26
001fde cf33                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001fdf 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
001fe1 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
001fe3 9630                      	adiw Z, 0
001fe4 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001fe5 cf2c                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001fe6 91e0 282f                 	lds ZL, pulse1_pitch_macro
001fe8 91f0 2830                 	lds ZH, pulse1_pitch_macro+1
001fea 9630                      	adiw Z, 0
001feb f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001fec cf25                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001fed 91e0 2835                 	lds ZL, pulse1_hi_pitch_macro
001fef 91f0 2836                 	lds ZH, pulse1_hi_pitch_macro+1
001ff1 9630                      	adiw Z, 0
001ff2 f009                      	breq sound_driver_channel0_fx_Qxy_process
001ff3 cf1e                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001ff4 2fba                      	mov r27, r26 //copy fx parameters into r27
001ff5 70bf                      	andi r27, 0x0F //mask note index offset
001ff6 91c0 2807                 	lds r28, pulse1_note //load current note index
001ff8 0fbc                      	add r27, r28
001ff9 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001ffa f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001ffb e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001ffc e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001ffd e0f0                      	ldi ZH, HIGH(note_table << 1)
001ffe 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001fff 0feb                      	add ZL, r27 //add offset
002000 1df2                      	adc ZH, zero
002001 91c5                      	lpm r28, Z+ //load bytes
002002 91d4                      	lpm r29, Z
002003 93c0 285c                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
002005 93d0 285d                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
002007 95a2                      	swap r26
002008 70af                      	andi r26, 0x0F //mask effect speed
002009 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00200a 95a3                      	inc r26 //increment the speed by 1
                                 
00200b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00200c 937f                      	push r23
00200d 2f6a                      	mov r22, r26 //store the speed data into r27
00200e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00200f 9f67                      	mul r22, r23
002010 917f                      	pop r23
002011 916f                      	pop r22
                                 
002012 9416                      	lsr r1 //shift out the fractional bits
002013 9407                      	ror r0
002014 9416                      	lsr r1
002015 9407                      	ror r0
002016 9416                      	lsr r1
002017 9407                      	ror r0
002018 9416                      	lsr r1
002019 9407                      	ror r0
                                 
00201a 9200 285e                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
00201c 9210 285f                 	sts pulse1_fx_Qxy_speed+1, r1
00201e 9220 2860                 	sts pulse1_fx_Qxy_total_offset, zero
002020 9220 2861                 	sts pulse1_fx_Qxy_total_offset+1, zero
002022 ceef                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
002023 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
002025 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
002027 9630                      	adiw Z, 0
002028 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
002029 cee8                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
00202a 91e0 282f                 	lds ZL, pulse1_pitch_macro
00202c 91f0 2830                 	lds ZH, pulse1_pitch_macro+1
00202e 9630                      	adiw Z, 0
00202f f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
002030 cee1                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
002031 91e0 2835                 	lds ZL, pulse1_hi_pitch_macro
002033 91f0 2836                 	lds ZH, pulse1_hi_pitch_macro+1
002035 9630                      	adiw Z, 0
002036 f009                      	breq sound_driver_channel0_fx_Rxy_process
002037 ceda                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
002038 2fba                      	mov r27, r26 //copy fx parameters into r27
002039 70bf                      	andi r27, 0x0F //mask note index offset
00203a 91c0 2807                 	lds r28, pulse1_note //load current note index
00203c 1bcb                      	sub r28, r27
00203d f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
00203e e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
00203f e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
002040 e0f0                      	ldi ZH, HIGH(note_table << 1)
002041 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
002042 0fec                      	add ZL, r28 //add offset
002043 1df2                      	adc ZH, zero
002044 91c5                      	lpm r28, Z+ //load bytes
002045 91d4                      	lpm r29, Z
002046 93c0 2862                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
002048 93d0 2863                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
00204a 95a2                      	swap r26
00204b 70af                      	andi r26, 0x0F //mask effect speed
00204c 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00204d 95a3                      	inc r26 //increment the speed by 1
                                 
00204e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00204f 937f                      	push r23
002050 2f6a                      	mov r22, r26 //store the speed data into r27
002051 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002052 9f67                      	mul r22, r23
002053 917f                      	pop r23
002054 916f                      	pop r22
                                 
002055 9416                      	lsr r1 //shift out the fractional bits
002056 9407                      	ror r0
002057 9416                      	lsr r1
002058 9407                      	ror r0
002059 9416                      	lsr r1
00205a 9407                      	ror r0
00205b 9416                      	lsr r1
00205c 9407                      	ror r0
                                 
00205d 9200 2864                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
00205f 9210 2865                 	sts pulse1_fx_Rxy_speed+1, r1
002061 9220 2866                 	sts pulse1_fx_Rxy_total_offset, zero
002063 9220 2867                 	sts pulse1_fx_Rxy_total_offset+1, zero
002065 ceac                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
002066 15a2                      	cp r26, zero
002067 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
002068 91b0 2819                 	lds r27, song_speed
00206a 17ab                      	cp r26, r27
00206b f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
00206c 93a0 2868                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00206e e0b1                      	ldi r27, 0x01
00206f 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
002071 c165                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
002072 ce9f                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
002073 e6ec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002074 e6f3                      	ldi ZH, HIGH(sequences << 1)
002075 0fea                      	add ZL, r26 //offset the pointer
002076 1df2                      	adc ZH, zero
                                 
002077 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
002078 95a7                      	ror r26
002079 95a7                      	ror r26
00207a 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
00207c 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
00207d 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
00207e 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
00207f c001                      	rjmp sound_driver_channel0_fx_Vxx_store
002080 ce91                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
002081 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
002082 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002083 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002084 93c0 2800                 	sts pulse1_param, r28
002086 ce8b                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
002087 ce8a                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
002088 ce89                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
002089 ce88                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
00208a ce87                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
00208b 93b0 2807                 	sts pulse1_note, r27 //store the note index
00208d e0a3                      	ldi r26, 0x03
00208e e0b2                      	ldi r27, 0x02
00208f 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
002091 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
002093 93b0 2831                 	sts pulse1_pitch_macro_offset, r27
002095 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27
002097 93b0 283c                 	sts pulse1_duty_macro_offset, r27
002099 9220 282e                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
00209b 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero
00209d 9220 2843                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00209f 9220 2844                 	sts pulse1_fx_1xx_total+1, zero
0020a1 9220 2847                 	sts pulse1_fx_2xx_total, zero
0020a3 9220 2848                 	sts pulse1_fx_2xx_total+1, zero
0020a5 9220 284f                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
0020a7 9220 2850                 	sts pulse1_fx_3xx_total_offset+1, zero
0020a9 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0020ab 91b0 0a8d                 	lds r27, TCB0_CCMPH
0020ad 93a0 2849                 	sts pulse1_fx_3xx_start, r26
0020af 93b0 284a                 	sts pulse1_fx_3xx_start+1, r27
0020b1 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
0020b3 6097                      	sbr pulse_channel_flags, 7 //set reload flag
0020b4 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0020b6 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
0020b8 9220 2860                 	sts pulse1_fx_Qxy_total_offset, zero
0020ba 9220 2861                 	sts pulse1_fx_Qxy_total_offset+1, zero
0020bc 9220 2862                 	sts pulse1_fx_Rxy_target, zero
0020be 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
0020c0 9220 2866                 	sts pulse1_fx_Rxy_total_offset, zero
0020c2 9220 2867                 	sts pulse1_fx_Rxy_total_offset+1, zero
0020c4 d0fb                      	rcall sound_driver_channel0_increment_offset
0020c5 ce4c                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
0020c6 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0020c7 91a0 2800                 	lds r26, pulse1_param
0020c9 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0020ca 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
0020cb 93a0 2800                 	sts pulse1_param, r26
0020cd 6096                      	sbr pulse_channel_flags, 6
0020ce d0f1                      	rcall sound_driver_channel0_increment_offset
0020cf ce42                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
0020d0 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0020d1 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
0020d3 d0ec                      	rcall sound_driver_channel0_increment_offset
0020d4 c102                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
0020d5 9220 2823                 	sts pulse1_volume_macro, zero //reset all macro addresses
0020d7 9220 2824                 	sts pulse1_volume_macro+1, zero
0020d9 9220 2828                 	sts pulse1_arpeggio_macro, zero
0020db 9220 2829                 	sts pulse1_arpeggio_macro+1, zero
0020dd 9220 282f                 	sts pulse1_pitch_macro, zero
0020df 9220 2830                 	sts pulse1_pitch_macro+1, zero
0020e1 9220 2835                 	sts pulse1_hi_pitch_macro, zero
0020e3 9220 2836                 	sts pulse1_hi_pitch_macro+1, zero
0020e5 9220 283a                 	sts pulse1_duty_macro, zero
0020e7 9220 283b                 	sts pulse1_duty_macro+1, zero
0020e9 9220 282e                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
0020eb 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0020ed 9631                      	adiw Z, 1 //point to the byte next to the flag
0020ee 91b4                      	lpm r27, Z //store the instrument offset into r27
0020ef e6e2                      	ldi ZL, LOW(instruments) //point Z to instruments table
0020f0 e1f9                      	ldi ZH, HIGH(instruments)
0020f1 0feb                      	add ZL, r27 //point Z to offsetted instrument
0020f2 1df2                      	adc ZH, zero
0020f3 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0020f4 1fff                      	rol ZH
0020f5 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0020f6 91b4                      	lpm r27, Z
                                 
0020f7 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0020f8 1fbb                      	rol r27
0020f9 2fea                      	mov ZL, r26
0020fa 2ffb                      	mov ZH, r27
0020fb 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0020fc 9632                      	adiw Z, 2 //point Z to the address of the macro
0020fd e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
0020fe 95aa                      	dec r26
0020ff f019                      	breq sound_driver_channel0_instrument_change_exit
002100 95b6                      	lsr r27
002101 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
002102 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
002103 e0a3                      	ldi r26, 0x03
002104 e0b2                      	ldi r27, 0x02
002105 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
002107 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
002109 93b0 2831                 	sts pulse1_pitch_macro_offset, r27
00210b 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27
00210d 93b0 283c                 	sts pulse1_duty_macro_offset, r27
00210f d0ba                      	rcall sound_driver_channel0_increment_offset_twice
002110 ce01                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
002111 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
002112 91d5                      	lpm r29, Z+
                                 
002113 30a5                      	cpi r26, 5
002114 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
002115 30a4                      	cpi r26, 4
002116 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
002117 30a3                      	cpi r26, 3
002118 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
002119 30a2                      	cpi r26, 2
00211a f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
00211b c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
00211c 93c0 2823                 	sts pulse1_volume_macro, r28
00211e 93d0 2824                 	sts pulse1_volume_macro+1, r29
002120 d041                      	rcall sound_driver_channel0_instrument_change_read_header
002121 93c0 2827                 	sts pulse1_volume_macro_release, r28
002123 93d0 2826                 	sts pulse1_volume_macro_loop, r29
002125 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
002126 93c0 2828                 	sts pulse1_arpeggio_macro, r28
002128 93d0 2829                 	sts pulse1_arpeggio_macro+1, r29
00212a 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00212c 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
00212e 9220 2862                 	sts pulse1_fx_Rxy_target, zero
002130 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
002132 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
002133 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
002134 93c0 282f                 	sts pulse1_pitch_macro, r28
002136 93d0 2830                 	sts pulse1_pitch_macro+1, r29
002138 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00213a 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
00213c 9220 2862                 	sts pulse1_fx_Rxy_target, zero
00213e 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
002140 d021                      	rcall sound_driver_channel0_instrument_change_read_header
002141 93c0 2833                 	sts pulse1_pitch_macro_release, r28
002143 93d0 2832                 	sts pulse1_pitch_macro_loop, r29
002145 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
002146 93c0 2835                 	sts pulse1_hi_pitch_macro, r28
002148 93d0 2836                 	sts pulse1_hi_pitch_macro+1, r29
00214a 9220 285c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00214c 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
00214e 9220 2862                 	sts pulse1_fx_Rxy_target, zero
002150 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
002152 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
002153 93c0 2839                 	sts pulse1_hi_pitch_macro_release, r28
002155 93d0 2838                 	sts pulse1_hi_pitch_macro_loop, r29
002157 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
002158 93c0 283a                 	sts pulse1_duty_macro, r28
00215a 93d0 283b                 	sts pulse1_duty_macro+1, r29
00215c d005                      	rcall sound_driver_channel0_instrument_change_read_header
00215d 93c0 283e                 	sts pulse1_duty_macro_release, r28
00215f 93d0 283d                 	sts pulse1_duty_macro_loop, r29
002161 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
002162 93ef                      	push ZL
002163 93ff                      	push ZH
002164 2fec                      	mov ZL, r28
002165 2ffd                      	mov ZH, r29
002166 0fee                      	lsl ZL
002167 1fff                      	rol ZH
002168 91c5                      	lpm r28, Z+
002169 91d4                      	lpm r29, Z
00216a 91ff                      	pop ZH
00216b 91ef                      	pop ZL
00216c 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
00216d 93ef                      	push ZL
00216e 93ff                      	push ZH
00216f 2fec                      	mov ZL, r28
002170 2ffd                      	mov ZH, r29
002171 0fee                      	lsl ZL
002172 1fff                      	rol ZH
002173 91c5                      	lpm r28, Z+
002174 91d5                      	lpm r29, Z+
002175 93c0 282c                 	sts pulse1_arpeggio_macro_release, r28
002177 93d0 282b                 	sts pulse1_arpeggio_macro_loop, r29
002179 91c4                      	lpm r28, Z
00217a 93c0 282d                 	sts pulse1_arpeggio_macro_mode, r28
00217c 91ff                      	pop ZH
00217d 91ef                      	pop ZL
00217e 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
00217f 91b0 2827                 	lds r27, pulse1_volume_macro_release
002181 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002182 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
002183 95b3                      	inc r27
002184 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
002186 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
002188 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002189 f019                      	breq sound_driver_channel0_release_pitch
00218a 95b3                      	inc r27
00218b 93b0 282a                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
00218d 91b0 2833                 	lds r27, pulse1_pitch_macro_release
00218f 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002190 f019                      	breq sound_driver_channel0_release_hi_pitch
002191 95b3                      	inc r27
002192 93b0 2831                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
002194 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_release
002196 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002197 f019                      	breq sound_driver_channel0_release_duty
002198 95b3                      	inc r27
002199 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
00219b 91b0 283e                 	lds r27, pulse1_duty_macro_release
00219d 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00219e f019                      	breq sound_driver_channel0_release_exit
00219f 95b3                      	inc r27
0021a0 93b0 283c                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
0021a2 d01d                      	rcall sound_driver_channel0_increment_offset
0021a3 cd6e                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
0021a4 91e0 2813                 	lds ZL, song_frames
0021a6 91f0 2814                 	lds ZH, song_frames+1
0021a8 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0021aa 91b0 2816                 	lds r27, song_frame_offset+1
0021ac 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0021ad 93a0 2815                 	sts song_frame_offset, r26
0021af 93b0 2816                 	sts song_frame_offset+1, r27
0021b1 0fea                      	add ZL, r26
0021b2 1ffb                      	adc ZH, r27
                                 
0021b3 91a5                      	lpm r26, Z+ //load the address of the next pattern
0021b4 91b4                      	lpm r27, Z
0021b5 0faa                      	lsl r26
0021b6 1fbb                      	rol r27
0021b7 93a0 281d                 	sts pulse1_pattern, r26
0021b9 93b0 281e                 	sts pulse1_pattern+1, r27
                                 
0021bb 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0021bd 9220 2822                 	sts pulse1_pattern_offset+1, zero
0021bf cd52                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
0021c0 91e0 2821                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0021c2 91f0 2822                 	lds ZH, pulse1_pattern_offset+1
0021c4 9631                      	adiw Z, 1
0021c5 93e0 2821                 	sts pulse1_pattern_offset, ZL
0021c7 93f0 2822                 	sts pulse1_pattern_offset+1, ZH
0021c9 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0021ca 91e0 2821                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0021cc 91f0 2822                 	lds ZH, pulse1_pattern_offset+1
0021ce 9632                      	adiw Z, 2 //increment the pointer twice
0021cf 93e0 2821                 	sts pulse1_pattern_offset, ZL
0021d1 93f0 2822                 	sts pulse1_pattern_offset+1, ZH
0021d3 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
0021d4 95ba                      	dec r27
0021d5 93b0 2820                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
0021d7 91a0 286c                 	lds r26, pulse2_pattern_delay_rows
0021d9 91b0 286d                 	lds r27, pulse2_pattern_delay_frames
0021db 9610                      	adiw r27:r26, 0
0021dc f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
0021dd c2be                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
0021de 91e0 286a                 	lds ZL, pulse2_pattern //current pattern for pulse 2
0021e0 91f0 286b                 	lds ZH, pulse2_pattern+1
0021e2 91a0 286e                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
0021e4 91b0 286f                 	lds r27, pulse2_pattern_offset+1
0021e6 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0021e7 1ffb                      	adc ZH, r27
0021e8 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
0021e9 35b7                      	cpi r27, 0x57
0021ea f408                      	brsh sound_driver_channel1_check_if_volume
0021eb c16b                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
0021ec 36b7                      	cpi r27, 0x67
0021ed f408                      	brsh sound_driver_channel1_check_if_delay
0021ee c1a3                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0021ef 3eb3                      	cpi r27, 0xE3
0021f0 f408                      	brsh sound_driver_channel1_check_if_instrument
0021f1 c1aa                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
0021f2 f409                      	brne sound_driver_channel1_check_if_release
0021f3 c1ad                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
0021f4 3eb4                      	cpi r27, 0xE4
0021f5 f409                      	brne sound_driver_channel1_check_if_end
0021f6 c254                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
0021f7 3fbf                      	cpi r27, 0xFF
0021f8 f409                      	brne sound_driver_channel1_check_if_fx
0021f9 c276                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
0021fa 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0021fb 91a4                      	lpm r26, Z //load the fx data into r26
0021fc d295                      	rcall sound_driver_channel1_increment_offset_twice
                                 
0021fd 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0021fe eae4                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
0021ff e6f3                      	ldi ZH, HIGH(channel1_fx << 1)
002200 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
002201 0feb                      	add ZL, r27 //add offset
002202 1df2                      	adc ZH, zero
002203 91c5                      	lpm r28, Z+ //load address bytes
002204 91d4                      	lpm r29, Z
002205 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002206 2ffd                      	mov ZH, r29
002207 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
002208 93a0 288c                 	sts pulse2_fx_0xy_sequence, r26
00220a 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
00220c cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
00220d 9220 2892                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
00220f 9220 2893                 	sts pulse2_fx_2xx+1, zero
002211 9220 288c                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
002213 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
002215 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002216 937f                      	push r23
002217 2f6a                      	mov r22, r26 //store the rate into r22
002218 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002219 9f67                      	mul r22, r23
00221a 917f                      	pop r23
00221b 916f                      	pop r22
                                 
00221c 9416                      	lsr r1 //shift out the fractional bits
00221d 9407                      	ror r0
00221e 9416                      	lsr r1
00221f 9407                      	ror r0
002220 9416                      	lsr r1
002221 9407                      	ror r0
002222 9416                      	lsr r1
002223 9407                      	ror r0
002224 9200 288e                 	sts pulse2_fx_1xx, r0
002226 9210 288f                 	sts pulse2_fx_1xx+1, r1
002228 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
002229 9220 288e                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
00222b 9220 288f                 	sts pulse2_fx_1xx+1, zero
00222d 9220 288c                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
00222f 9220 288d                 	sts pulse2_fx_0xy_sequence+1, zero
002231 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002232 937f                      	push r23
002233 2f6a                      	mov r22, r26 //store the rate into r22
002234 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002235 9f67                      	mul r22, r23
002236 917f                      	pop r23
002237 916f                      	pop r22
                                 
002238 9416                      	lsr r1 //shift out the fractional bits
002239 9407                      	ror r0
00223a 9416                      	lsr r1
00223b 9407                      	ror r0
00223c 9416                      	lsr r1
00223d 9407                      	ror r0
00223e 9416                      	lsr r1
00223f 9407                      	ror r0
002240 9200 2892                 	sts pulse2_fx_2xx, r0
002242 9210 2893                 	sts pulse2_fx_2xx+1, r1
002244 cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
002245 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002246 937f                      	push r23
002247 2f6a                      	mov r22, r26 //store the rate into r22
002248 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002249 9f67                      	mul r22, r23
00224a 917f                      	pop r23
00224b 916f                      	pop r22
                                 
00224c 9416                      	lsr r1 //shift out the fractional bits
00224d 9407                      	ror r0
00224e 9416                      	lsr r1
00224f 9407                      	ror r0
002250 9416                      	lsr r1
002251 9407                      	ror r0
002252 9416                      	lsr r1
002253 9407                      	ror r0
002254 9200 289a                 	sts pulse2_fx_3xx_speed, r0
002256 9210 289b                 	sts pulse2_fx_3xx_speed+1, r1
                                 
002258 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
002259 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
00225a cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
00225b 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00225d 91b0 0a9d                 	lds r27, TCB1_CCMPH
00225f 93a0 2896                 	sts pulse2_fx_3xx_start, r26
002261 93b0 2897                 	sts pulse2_fx_3xx_start+1, r27
                                 
002263 9220 289c                 	sts pulse2_fx_3xx_total_offset, zero
002265 9220 289d                 	sts pulse2_fx_3xx_total_offset+1, zero
002267 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
002268 2fba                      	mov r27, r26
002269 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00226a 95a2                      	swap r26
00226b 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00226c 93a0 289e                 	sts pulse2_fx_4xy_speed, r26
00226e 93b0 289f                 	sts pulse2_fx_4xy_depth, r27
002270 9220 28a0                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
002272 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
002273 2fba                      	mov r27, r26
002274 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002275 95a2                      	swap r26
002276 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002277 93a0 28a1                 	sts pulse2_fx_7xy_speed, r26
002279 93b0 28a2                 	sts pulse2_fx_7xy_depth, r27
00227b 9220 28a3                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
00227d 9220 28a4                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
00227f cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
002280 93a0 28a5                 	sts pulse2_fx_Axy, r26
002282 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
002283 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002285 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
002286 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002288 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
002289 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00228b cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
00228c 91b0 2808                 	lds r27, pulse2_param
00228e 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
00228f 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
002290 93b0 2808                 	sts pulse2_param, r27
002292 6092                      	sbr pulse_channel_flags, 2
002293 cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
002294 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002296 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
002297 15a2                      	cp r26, zero
002298 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
002299 91b0 2819                 	lds r27, song_speed
00229b 17ab                      	cp r26, r27
00229c f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
00229d 93a0 28a6                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00229f e0b1                      	ldi r27, 0x01
0022a0 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
0022a2 c1fc                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
0022a3 cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
0022a4 cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
0022a5 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
0022a6 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
0022a7 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
0022a8 93a0 28a8                 	sts pulse2_fx_Pxx, r26
0022aa cf33                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
0022ab 91e0 2875                 	lds ZL, pulse2_arpeggio_macro
0022ad 91f0 2876                 	lds ZH, pulse2_arpeggio_macro+1
0022af 9630                      	adiw Z, 0
0022b0 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
0022b1 cf2c                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
0022b2 91e0 287c                 	lds ZL, pulse2_pitch_macro
0022b4 91f0 287d                 	lds ZH, pulse2_pitch_macro+1
0022b6 9630                      	adiw Z, 0
0022b7 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
0022b8 cf25                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
0022b9 91e0 2882                 	lds ZL, pulse2_hi_pitch_macro
0022bb 91f0 2883                 	lds ZH, pulse2_hi_pitch_macro+1
0022bd 9630                      	adiw Z, 0
0022be f009                      	breq sound_driver_channel1_fx_Qxy_process
0022bf cf1e                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
0022c0 2fba                      	mov r27, r26 //copy fx parameters into r27
0022c1 70bf                      	andi r27, 0x0F //mask note index offset
0022c2 91c0 280f                 	lds r28, pulse2_note //load current note index
0022c4 0fbc                      	add r27, r28
0022c5 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0022c6 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
0022c7 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
0022c8 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
0022c9 e0f0                      	ldi ZH, HIGH(note_table << 1)
0022ca 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0022cb 0feb                      	add ZL, r27 //add offset
0022cc 1df2                      	adc ZH, zero
0022cd 91c5                      	lpm r28, Z+ //load bytes
0022ce 91d4                      	lpm r29, Z
0022cf 93c0 28a9                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
0022d1 93d0 28aa                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
0022d3 95a2                      	swap r26
0022d4 70af                      	andi r26, 0x0F //mask effect speed
0022d5 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0022d6 95a3                      	inc r26 //increment the speed by 1
                                 
0022d7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022d8 937f                      	push r23
0022d9 2f6a                      	mov r22, r26 //store the speed data into r27
0022da eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022db 9f67                      	mul r22, r23
0022dc 917f                      	pop r23
0022dd 916f                      	pop r22
                                 
0022de 9416                      	lsr r1 //shift out the fractional bits
0022df 9407                      	ror r0
0022e0 9416                      	lsr r1
0022e1 9407                      	ror r0
0022e2 9416                      	lsr r1
0022e3 9407                      	ror r0
0022e4 9416                      	lsr r1
0022e5 9407                      	ror r0
                                 
0022e6 9200 28ab                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
0022e8 9210 28ac                 	sts pulse2_fx_Qxy_speed+1, r1
0022ea 9220 28ad                 	sts pulse2_fx_Qxy_total_offset, zero
0022ec 9220 28ae                 	sts pulse2_fx_Qxy_total_offset+1, zero
0022ee ceef                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
0022ef 91e0 2875                 	lds ZL, pulse2_arpeggio_macro
0022f1 91f0 2876                 	lds ZH, pulse2_arpeggio_macro+1
0022f3 9630                      	adiw Z, 0
0022f4 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
0022f5 cee8                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
0022f6 91e0 287c                 	lds ZL, pulse2_pitch_macro
0022f8 91f0 287d                 	lds ZH, pulse2_pitch_macro+1
0022fa 9630                      	adiw Z, 0
0022fb f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
0022fc cee1                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
0022fd 91e0 2882                 	lds ZL, pulse2_hi_pitch_macro
0022ff 91f0 2883                 	lds ZH, pulse2_hi_pitch_macro+1
002301 9630                      	adiw Z, 0
002302 f009                      	breq sound_driver_channel1_fx_Rxy_process
002303 ceda                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
002304 2fba                      	mov r27, r26 //copy fx parameters into r27
002305 70bf                      	andi r27, 0x0F //mask note index offset
002306 91c0 280f                 	lds r28, pulse2_note //load current note index
002308 1bcb                      	sub r28, r27
002309 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
00230a e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
00230b e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
00230c e0f0                      	ldi ZH, HIGH(note_table << 1)
00230d 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00230e 0fec                      	add ZL, r28 //add offset
00230f 1df2                      	adc ZH, zero
002310 91c5                      	lpm r28, Z+ //load bytes
002311 91d4                      	lpm r29, Z
002312 93c0 28af                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
002314 93d0 28b0                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
002316 95a2                      	swap r26
002317 70af                      	andi r26, 0x0F //mask effect speed
002318 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
002319 95a3                      	inc r26 //increment the speed by 1
                                 
00231a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00231b 937f                      	push r23
00231c 2f6a                      	mov r22, r26 //store the speed data into r27
00231d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00231e 9f67                      	mul r22, r23
00231f 917f                      	pop r23
002320 916f                      	pop r22
                                 
002321 9416                      	lsr r1 //shift out the fractional bits
002322 9407                      	ror r0
002323 9416                      	lsr r1
002324 9407                      	ror r0
002325 9416                      	lsr r1
002326 9407                      	ror r0
002327 9416                      	lsr r1
002328 9407                      	ror r0
                                 
002329 9200 28b1                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
00232b 9210 28b2                 	sts pulse2_fx_Rxy_speed+1, r1
00232d 9220 28b3                 	sts pulse2_fx_Rxy_total_offset, zero
00232f 9220 28b4                 	sts pulse2_fx_Rxy_total_offset+1, zero
002331 ceac                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
002332 15a2                      	cp r26, zero
002333 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
002334 91b0 2819                 	lds r27, song_speed
002336 17ab                      	cp r26, r27
002337 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
002338 93a0 28b5                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00233a e0b1                      	ldi r27, 0x01
00233b 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
00233d c161                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
00233e ce9f                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
00233f e6ec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002340 e6f3                      	ldi ZH, HIGH(sequences << 1)
002341 0fea                      	add ZL, r26 //offset the pointer
002342 1df2                      	adc ZH, zero
                                 
002343 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002344 95a7                      	ror r26
002345 95a7                      	ror r26
002346 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
002348 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
002349 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
00234a 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
00234b c001                      	rjmp sound_driver_channel1_fx_Vxx_store
00234c ce91                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
00234d 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
00234e 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00234f 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002350 93c0 2808                 	sts pulse2_param, r28
002352 ce8b                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
002353 ce8a                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
002354 ce89                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
002355 ce88                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
002356 ce87                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
002357 93b0 280f                 	sts pulse2_note, r27 //store the note index
002359 e0a3                      	ldi r26, 0x03
00235a e0b2                      	ldi r27, 0x02
00235b 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
00235d 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
00235f 93b0 287e                 	sts pulse2_pitch_macro_offset, r27
002361 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27
002363 93b0 2889                 	sts pulse2_duty_macro_offset, r27
002365 9220 287b                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
002367 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero
002369 9220 2890                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00236b 9220 2891                 	sts pulse2_fx_1xx_total+1, zero
00236d 9220 2894                 	sts pulse2_fx_2xx_total, zero
00236f 9220 2895                 	sts pulse2_fx_2xx_total+1, zero
002371 9220 289c                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
002373 9220 289d                 	sts pulse2_fx_3xx_total_offset+1, zero
002375 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002377 91b0 0a9d                 	lds r27, TCB1_CCMPH
002379 93a0 2896                 	sts pulse2_fx_3xx_start, r26
00237b 93b0 2897                 	sts pulse2_fx_3xx_start+1, r27
00237d 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
00237f 6093                      	sbr pulse_channel_flags, 3 //set reload flag
002380 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002382 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
002384 9220 28ad                 	sts pulse2_fx_Qxy_total_offset, zero
002386 9220 28ae                 	sts pulse2_fx_Qxy_total_offset+1, zero
002388 9220 28af                 	sts pulse2_fx_Rxy_target, zero
00238a 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
00238c 9220 28b3                 	sts pulse2_fx_Rxy_total_offset, zero
00238e 9220 28b4                 	sts pulse2_fx_Rxy_total_offset+1, zero
002390 d0f7                      	rcall sound_driver_channel1_increment_offset
002391 ce4c                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
002392 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
002393 91a0 2808                 	lds r26, pulse2_param
002395 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
002396 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
002397 93a0 2808                 	sts pulse2_param, r26
002399 6092                      	sbr pulse_channel_flags, 2
00239a d0ed                      	rcall sound_driver_channel1_increment_offset
00239b ce42                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
00239c 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00239d 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
00239f d0e8                      	rcall sound_driver_channel1_increment_offset
0023a0 c0fe                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
0023a1 9220 2870                 	sts pulse2_volume_macro, zero //reset all macro addresses
0023a3 9220 2871                 	sts pulse2_volume_macro+1, zero
0023a5 9220 2875                 	sts pulse2_arpeggio_macro, zero
0023a7 9220 2876                 	sts pulse2_arpeggio_macro+1, zero
0023a9 9220 287c                 	sts pulse2_pitch_macro, zero
0023ab 9220 287d                 	sts pulse2_pitch_macro+1, zero
0023ad 9220 2882                 	sts pulse2_hi_pitch_macro, zero
0023af 9220 2883                 	sts pulse2_hi_pitch_macro+1, zero
0023b1 9220 2887                 	sts pulse2_duty_macro, zero
0023b3 9220 2888                 	sts pulse2_duty_macro+1, zero
0023b5 9220 287b                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
0023b7 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0023b9 9631                      	adiw Z, 1 //point to the byte next to the flag
0023ba 91b4                      	lpm r27, Z //store the instrument offset into r27
0023bb e6e2                      	ldi ZL, LOW(instruments) //point Z to instruments table
0023bc e1f9                      	ldi ZH, HIGH(instruments)
0023bd 0feb                      	add ZL, r27 //point Z to offsetted instrument
0023be 1df2                      	adc ZH, zero
0023bf 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0023c0 1fff                      	rol ZH
0023c1 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0023c2 91b4                      	lpm r27, Z
                                 
0023c3 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0023c4 1fbb                      	rol r27
0023c5 2fea                      	mov ZL, r26
0023c6 2ffb                      	mov ZH, r27
0023c7 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0023c8 9632                      	adiw Z, 2 //point Z to the address of the macro
0023c9 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
0023ca 95aa                      	dec r26
0023cb f019                      	breq sound_driver_channel1_instrument_change_exit
0023cc 95b6                      	lsr r27
0023cd f078                      	brcs sound_driver_channel1_instrument_change_load_macro
0023ce cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
0023cf e0a3                      	ldi r26, 0x03
0023d0 e0b2                      	ldi r27, 0x02
0023d1 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
0023d3 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
0023d5 93b0 287e                 	sts pulse2_pitch_macro_offset, r27
0023d7 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27
0023d9 93b0 2889                 	sts pulse2_duty_macro_offset, r27
0023db d0b6                      	rcall sound_driver_channel1_increment_offset_twice
0023dc ce01                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
0023dd 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0023de 91d5                      	lpm r29, Z+
                                 
0023df 30a5                      	cpi r26, 5
0023e0 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
0023e1 30a4                      	cpi r26, 4
0023e2 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
0023e3 30a3                      	cpi r26, 3
0023e4 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
0023e5 30a2                      	cpi r26, 2
0023e6 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
0023e7 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
0023e8 93c0 2870                 	sts pulse2_volume_macro, r28
0023ea 93d0 2871                 	sts pulse2_volume_macro+1, r29
0023ec d041                      	rcall sound_driver_channel1_instrument_change_read_header
0023ed 93c0 2874                 	sts pulse2_volume_macro_release, r28
0023ef 93d0 2873                 	sts pulse2_volume_macro_loop, r29
0023f1 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
0023f2 93c0 2875                 	sts pulse2_arpeggio_macro, r28
0023f4 93d0 2876                 	sts pulse2_arpeggio_macro+1, r29
0023f6 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0023f8 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
0023fa 9220 28af                 	sts pulse2_fx_Rxy_target, zero
0023fc 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
0023fe d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
0023ff cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
002400 93c0 287c                 	sts pulse2_pitch_macro, r28
002402 93d0 287d                 	sts pulse2_pitch_macro+1, r29
002404 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002406 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
002408 9220 28af                 	sts pulse2_fx_Rxy_target, zero
00240a 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
00240c d021                      	rcall sound_driver_channel1_instrument_change_read_header
00240d 93c0 2880                 	sts pulse2_pitch_macro_release, r28
00240f 93d0 287f                 	sts pulse2_pitch_macro_loop, r29
002411 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
002412 93c0 2882                 	sts pulse2_hi_pitch_macro, r28
002414 93d0 2883                 	sts pulse2_hi_pitch_macro+1, r29
002416 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002418 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
00241a 9220 28af                 	sts pulse2_fx_Rxy_target, zero
00241c 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
00241e d00f                      	rcall sound_driver_channel1_instrument_change_read_header
00241f 93c0 2886                 	sts pulse2_hi_pitch_macro_release, r28
002421 93d0 2885                 	sts pulse2_hi_pitch_macro_loop, r29
002423 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
002424 93c0 2887                 	sts pulse2_duty_macro, r28
002426 93d0 2888                 	sts pulse2_duty_macro+1, r29
002428 d005                      	rcall sound_driver_channel1_instrument_change_read_header
002429 93c0 288b                 	sts pulse2_duty_macro_release, r28
00242b 93d0 288a                 	sts pulse2_duty_macro_loop, r29
00242d cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
00242e 93ef                      	push ZL
00242f 93ff                      	push ZH
002430 2fec                      	mov ZL, r28
002431 2ffd                      	mov ZH, r29
002432 0fee                      	lsl ZL
002433 1fff                      	rol ZH
002434 91c5                      	lpm r28, Z+
002435 91d4                      	lpm r29, Z
002436 91ff                      	pop ZH
002437 91ef                      	pop ZL
002438 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
002439 93ef                      	push ZL
00243a 93ff                      	push ZH
00243b 2fec                      	mov ZL, r28
00243c 2ffd                      	mov ZH, r29
00243d 0fee                      	lsl ZL
00243e 1fff                      	rol ZH
00243f 91c5                      	lpm r28, Z+
002440 91d5                      	lpm r29, Z+
002441 93c0 2879                 	sts pulse2_arpeggio_macro_release, r28
002443 93d0 2878                 	sts pulse2_arpeggio_macro_loop, r29
002445 91c4                      	lpm r28, Z
002446 93c0 287a                 	sts pulse2_arpeggio_macro_mode, r28
002448 91ff                      	pop ZH
002449 91ef                      	pop ZL
00244a 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
00244b 91b0 2874                 	lds r27, pulse2_volume_macro_release
00244d 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
00244e f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
00244f 95b3                      	inc r27
002450 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
002452 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
002454 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002455 f019                      	breq sound_driver_channel1_release_pitch
002456 95b3                      	inc r27
002457 93b0 2877                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
002459 91b0 2880                 	lds r27, pulse2_pitch_macro_release
00245b 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00245c f019                      	breq sound_driver_channel1_release_hi_pitch
00245d 95b3                      	inc r27
00245e 93b0 287e                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
002460 91b0 2886                 	lds r27, pulse2_hi_pitch_macro_release
002462 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002463 f019                      	breq sound_driver_channel1_release_duty
002464 95b3                      	inc r27
002465 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
002467 91b0 288b                 	lds r27, pulse2_duty_macro_release
002469 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00246a f019                      	breq sound_driver_channel1_release_exit
00246b 95b3                      	inc r27
00246c 93b0 2889                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
00246e d019                      	rcall sound_driver_channel1_increment_offset
00246f cd6e                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
002470 91e0 2813                 	lds ZL, song_frames
002472 91f0 2814                 	lds ZH, song_frames+1
002474 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002476 91b0 2816                 	lds r27, song_frame_offset+1
002478 9612                      	adiw r27:r26, 2 //offset for channel 1
002479 0fea                      	add ZL, r26
00247a 1ffb                      	adc ZH, r27
                                 
00247b 91a5                      	lpm r26, Z+ //load the address of the next pattern
00247c 91b4                      	lpm r27, Z
00247d 0faa                      	lsl r26
00247e 1fbb                      	rol r27
00247f 93a0 286a                 	sts pulse2_pattern, r26
002481 93b0 286b                 	sts pulse2_pattern+1, r27
                                 
002483 9220 286e                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002485 9220 286f                 	sts pulse2_pattern_offset+1, zero
002487 cd56                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
002488 91e0 286e                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
00248a 91f0 286f                 	lds ZH, pulse2_pattern_offset+1
00248c 9631                      	adiw Z, 1
00248d 93e0 286e                 	sts pulse2_pattern_offset, ZL
00248f 93f0 286f                 	sts pulse2_pattern_offset+1, ZH
002491 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002492 91e0 286e                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
002494 91f0 286f                 	lds ZH, pulse2_pattern_offset+1
002496 9632                      	adiw Z, 2 //increment the pointer twice
002497 93e0 286e                 	sts pulse2_pattern_offset, ZL
002499 93f0 286f                 	sts pulse2_pattern_offset+1, ZH
00249b 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
00249c 95ba                      	dec r27
00249d 93b0 286d                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
00249f 91a0 28b9                 	lds r26, triangle_pattern_delay_rows
0024a1 91b0 28ba                 	lds r27, triangle_pattern_delay_frames
0024a3 9610                      	adiw r27:r26, 0
0024a4 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
0024a5 c2a3                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
0024a6 91e0 28b7                 	lds ZL, triangle_pattern //current pattern for triangle
0024a8 91f0 28b8                 	lds ZH, triangle_pattern+1
0024aa 91a0 28bb                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
0024ac 91b0 28bc                 	lds r27, triangle_pattern_offset+1
0024ae 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0024af 1ffb                      	adc ZH, r27
0024b0 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
0024b1 35b7                      	cpi r27, 0x57
0024b2 f408                      	brsh sound_driver_channel2_check_if_volume
0024b3 c14f                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
0024b4 36b7                      	cpi r27, 0x67
0024b5 f408                      	brsh sound_driver_channel2_check_if_delay
0024b6 c184                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0024b7 3eb3                      	cpi r27, 0xE3
0024b8 f408                      	brsh sound_driver_channel2_check_if_instrument
0024b9 c18f                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
0024ba f409                      	brne sound_driver_channel2_check_if_release
0024bb c192                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
0024bc 3eb4                      	cpi r27, 0xE4
0024bd f409                      	brne sound_driver_channel2_check_if_end
0024be c239                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
0024bf 3fbf                      	cpi r27, 0xFF
0024c0 f409                      	brne sound_driver_channel2_check_if_fx
0024c1 c25b                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
0024c2 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0024c3 91a4                      	lpm r26, Z //load the fx data into r26
0024c4 d27a                      	rcall sound_driver_channel2_increment_offset_twice
                                 
0024c5 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0024c6 ede8                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
0024c7 e6f3                      	ldi ZH, HIGH(channel2_fx << 1)
0024c8 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0024c9 0feb                      	add ZL, r27 //add offset
0024ca 1df2                      	adc ZH, zero
0024cb 91c5                      	lpm r28, Z+ //load address bytes
0024cc 91d4                      	lpm r29, Z
0024cd 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0024ce 2ffd                      	mov ZH, r29
0024cf 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
0024d0 93a0 28d9                 	sts triangle_fx_0xy_sequence, r26
0024d2 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
0024d4 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
0024d5 9220 28df                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
0024d7 9220 28e0                 	sts triangle_fx_2xx+1, zero
0024d9 9220 28d9                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
0024db 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
0024dd 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0024de 937f                      	push r23
0024df 2f6a                      	mov r22, r26 //store the rate into r22
0024e0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0024e1 9f67                      	mul r22, r23
0024e2 917f                      	pop r23
0024e3 916f                      	pop r22
                                 
0024e4 9416                      	lsr r1 //shift out the fractional bits
0024e5 9407                      	ror r0
0024e6 9416                      	lsr r1
0024e7 9407                      	ror r0
0024e8 9416                      	lsr r1
0024e9 9407                      	ror r0
0024ea 9416                      	lsr r1
0024eb 9407                      	ror r0
0024ec 9200 28db                 	sts triangle_fx_1xx, r0
0024ee 9210 28dc                 	sts triangle_fx_1xx+1, r1
0024f0 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
0024f1 9220 28db                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
0024f3 9220 28dc                 	sts triangle_fx_1xx+1, zero
0024f5 9220 28d9                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
0024f7 9220 28da                 	sts triangle_fx_0xy_sequence+1, zero
0024f9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0024fa 937f                      	push r23
0024fb 2f6a                      	mov r22, r26 //store the rate into r22
0024fc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0024fd 9f67                      	mul r22, r23
0024fe 917f                      	pop r23
0024ff 916f                      	pop r22
                                 
002500 9416                      	lsr r1 //shift out the fractional bits
002501 9407                      	ror r0
002502 9416                      	lsr r1
002503 9407                      	ror r0
002504 9416                      	lsr r1
002505 9407                      	ror r0
002506 9416                      	lsr r1
002507 9407                      	ror r0
002508 9200 28df                 	sts triangle_fx_2xx, r0
00250a 9210 28e0                 	sts triangle_fx_2xx+1, r1
00250c cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
00250d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00250e 937f                      	push r23
00250f 2f6a                      	mov r22, r26 //store the rate into r22
002510 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002511 9f67                      	mul r22, r23
002512 917f                      	pop r23
002513 916f                      	pop r22
                                 
002514 9416                      	lsr r1 //shift out the fractional bits
002515 9407                      	ror r0
002516 9416                      	lsr r1
002517 9407                      	ror r0
002518 9416                      	lsr r1
002519 9407                      	ror r0
00251a 9416                      	lsr r1
00251b 9407                      	ror r0
00251c 9200 28e7                 	sts triangle_fx_3xx_speed, r0
00251e 9210 28e8                 	sts triangle_fx_3xx_speed+1, r1
                                 
002520 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
002521 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
002522 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
002523 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002525 91b0 0aad                 	lds r27, TCB2_CCMPH
002527 93a0 28e3                 	sts triangle_fx_3xx_start, r26
002529 93b0 28e4                 	sts triangle_fx_3xx_start+1, r27
                                 
00252b 9220 28e9                 	sts triangle_fx_3xx_total_offset, zero
00252d 9220 28ea                 	sts triangle_fx_3xx_total_offset+1, zero
00252f cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
002530 2fba                      	mov r27, r26
002531 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002532 95a2                      	swap r26
002533 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002534 93a0 28eb                 	sts triangle_fx_4xy_speed, r26
002536 93b0 28ec                 	sts triangle_fx_4xy_depth, r27
002538 9220 28ed                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
00253a cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
00253b cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
00253c cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
00253d 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00253f cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
002540 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002542 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
002543 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002545 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
002546 15a2                      	cp r26, zero
002547 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
002548 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002549 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00254b cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
00254c 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
00254e 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002550 9220 0aad                 	sts TCB2_CCMPH, zero
002552 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
002553 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002555 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
002556 15a2                      	cp r26, zero
002557 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
002558 91b0 2819                 	lds r27, song_speed
00255a 17ab                      	cp r26, r27
00255b f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
00255c 93a0 28ee                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00255e e0b1                      	ldi r27, 0x01
00255f 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
002561 c1ea                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel2_fx_Gxx_invalid:
002562 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
002563 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
002564 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
002565 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
002566 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
002567 93a0 28f0                 	sts triangle_fx_Pxx, r26
002569 cf3c                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
00256a 91e0 28c2                 	lds ZL, triangle_arpeggio_macro
00256c 91f0 28c3                 	lds ZH, triangle_arpeggio_macro+1
00256e 9630                      	adiw Z, 0
00256f f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
002570 cf35                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
002571 91e0 28c9                 	lds ZL, triangle_pitch_macro
002573 91f0 28ca                 	lds ZH, triangle_pitch_macro+1
002575 9630                      	adiw Z, 0
002576 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
002577 cf2e                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
002578 91e0 28cf                 	lds ZL, triangle_hi_pitch_macro
00257a 91f0 28d0                 	lds ZH, triangle_hi_pitch_macro+1
00257c 9630                      	adiw Z, 0
00257d f009                      	breq sound_driver_channel2_fx_Qxy_process
00257e cf27                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
00257f 2fba                      	mov r27, r26 //copy fx parameters into r27
002580 70bf                      	andi r27, 0x0F //mask note index offset
002581 91c0 2812                 	lds r28, triangle_note //load current note index
002583 0fbc                      	add r27, r28
002584 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
002585 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
002586 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
002587 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
002588 e0f0                      	ldi ZH, HIGH(note_table << 1)
002589 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
00258a 0feb                      	add ZL, r27 //add offset
00258b 1df2                      	adc ZH, zero
00258c 91c5                      	lpm r28, Z+ //load bytes
00258d 91d4                      	lpm r29, Z
00258e 93c0 28f1                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
002590 93d0 28f2                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
002592 95a2                      	swap r26
002593 70af                      	andi r26, 0x0F //mask effect speed
002594 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
002595 95a3                      	inc r26 //increment the speed by 1
                                 
002596 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002597 937f                      	push r23
002598 2f6a                      	mov r22, r26 //store the speed data into r27
002599 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00259a 9f67                      	mul r22, r23
00259b 917f                      	pop r23
00259c 916f                      	pop r22
                                 
00259d 9416                      	lsr r1 //shift out the fractional bits
00259e 9407                      	ror r0
00259f 9416                      	lsr r1
0025a0 9407                      	ror r0
0025a1 9416                      	lsr r1
0025a2 9407                      	ror r0
0025a3 9416                      	lsr r1
0025a4 9407                      	ror r0
                                 
0025a5 9200 28f3                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
0025a7 9210 28f4                 	sts triangle_fx_Qxy_speed+1, r1
0025a9 9220 28f5                 	sts triangle_fx_Qxy_total_offset, zero
0025ab 9220 28f6                 	sts triangle_fx_Qxy_total_offset+1, zero
0025ad cef8                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
0025ae 91e0 28c2                 	lds ZL, triangle_arpeggio_macro
0025b0 91f0 28c3                 	lds ZH, triangle_arpeggio_macro+1
0025b2 9630                      	adiw Z, 0
0025b3 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
0025b4 cef1                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
0025b5 91e0 28c9                 	lds ZL, triangle_pitch_macro
0025b7 91f0 28ca                 	lds ZH, triangle_pitch_macro+1
0025b9 9630                      	adiw Z, 0
0025ba f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
0025bb ceea                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
0025bc 91e0 28cf                 	lds ZL, triangle_hi_pitch_macro
0025be 91f0 28d0                 	lds ZH, triangle_hi_pitch_macro+1
0025c0 9630                      	adiw Z, 0
0025c1 f009                      	breq sound_driver_channel2_fx_Rxy_process
0025c2 cee3                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
0025c3 2fba                      	mov r27, r26 //copy fx parameters into r27
0025c4 70bf                      	andi r27, 0x0F //mask note index offset
0025c5 91c0 2812                 	lds r28, triangle_note //load current note index
0025c7 1bcb                      	sub r28, r27
0025c8 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
0025c9 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
0025ca e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
0025cb e0f0                      	ldi ZH, HIGH(note_table << 1)
0025cc 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0025cd 0fec                      	add ZL, r28 //add offset
0025ce 1df2                      	adc ZH, zero
0025cf 91c5                      	lpm r28, Z+ //load bytes
0025d0 91d4                      	lpm r29, Z
0025d1 93c0 28f7                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
0025d3 93d0 28f8                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0025d5 95a2                      	swap r26
0025d6 70af                      	andi r26, 0x0F //mask effect speed
0025d7 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0025d8 95a3                      	inc r26 //increment the speed by 1
                                 
0025d9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025da 937f                      	push r23
0025db 2f6a                      	mov r22, r26 //store the speed data into r27
0025dc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025dd 9f67                      	mul r22, r23
0025de 917f                      	pop r23
0025df 916f                      	pop r22
                                 
0025e0 9416                      	lsr r1 //shift out the fractional bits
0025e1 9407                      	ror r0
0025e2 9416                      	lsr r1
0025e3 9407                      	ror r0
0025e4 9416                      	lsr r1
0025e5 9407                      	ror r0
0025e6 9416                      	lsr r1
0025e7 9407                      	ror r0
                                 
0025e8 9200 28f9                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
0025ea 9210 28fa                 	sts triangle_fx_Rxy_speed+1, r1
0025ec 9220 28fb                 	sts triangle_fx_Rxy_total_offset, zero
0025ee 9220 28fc                 	sts triangle_fx_Rxy_total_offset+1, zero
0025f0 ceb5                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
0025f1 15a2                      	cp r26, zero
0025f2 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
0025f3 91b0 2819                 	lds r27, song_speed
0025f5 17ab                      	cp r26, r27
0025f6 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
0025f7 93a0 28fd                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0025f9 e0b1                      	ldi r27, 0x01
0025fa 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
0025fc c14f                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel2_fx_Sxx_invalid:
0025fd cea8                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
0025fe cea7                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
0025ff cea6                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
002600 cea5                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
002601 cea4                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
002602 cea3                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
002603 93b0 2812                 	sts triangle_note, r27 //store the note index
002605 e0a3                      	ldi r26, 0x03
002606 e0b2                      	ldi r27, 0x02
002607 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
002609 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
00260b 93b0 28cb                 	sts triangle_pitch_macro_offset, r27
00260d 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27
00260f 93b0 28d6                 	sts triangle_duty_macro_offset, r27
002611 9220 28c8                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
002613 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero
002615 9220 28dd                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002617 9220 28de                 	sts triangle_fx_1xx_total+1, zero
002619 9220 28e1                 	sts triangle_fx_2xx_total, zero
00261b 9220 28e2                 	sts triangle_fx_2xx_total+1, zero
00261d 9220 28e9                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
00261f 9220 28ea                 	sts triangle_fx_3xx_total_offset+1, zero
002621 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002623 91b0 0aad                 	lds r27, TCB2_CCMPH
002625 93a0 28e3                 	sts triangle_fx_3xx_start, r26
002627 93b0 28e4                 	sts triangle_fx_3xx_start+1, r27
002629 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00262b 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
00262d 9220 28f5                 	sts triangle_fx_Qxy_total_offset, zero
00262f 9220 28f6                 	sts triangle_fx_Qxy_total_offset+1, zero
002631 9220 28f7                 	sts triangle_fx_Rxy_target, zero
002633 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
002635 9220 28fb                 	sts triangle_fx_Rxy_total_offset, zero
002637 9220 28fc                 	sts triangle_fx_Rxy_total_offset+1, zero
002639 d0fb                      	rcall sound_driver_channel2_increment_offset
00263a ce6b                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
00263b d0f9                      	rcall sound_driver_channel2_increment_offset
00263c 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00263d f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
00263e e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00263f 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002641 ce64                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
002642 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
002644 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002646 9220 0aad                 	sts TCB2_CCMPH, zero
002648 ce5d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
002649 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00264a 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
00264c d0e8                      	rcall sound_driver_channel2_increment_offset
00264d c0fe                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
00264e 9220 28bd                 	sts triangle_volume_macro, zero //reset all macro addresses
002650 9220 28be                 	sts triangle_volume_macro+1, zero
002652 9220 28c2                 	sts triangle_arpeggio_macro, zero
002654 9220 28c3                 	sts triangle_arpeggio_macro+1, zero
002656 9220 28c9                 	sts triangle_pitch_macro, zero
002658 9220 28ca                 	sts triangle_pitch_macro+1, zero
00265a 9220 28cf                 	sts triangle_hi_pitch_macro, zero
00265c 9220 28d0                 	sts triangle_hi_pitch_macro+1, zero
00265e 9220 28d4                 	sts triangle_duty_macro, zero
002660 9220 28d5                 	sts triangle_duty_macro+1, zero
002662 9220 28c8                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
002664 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
002666 9631                      	adiw Z, 1 //point to the byte next to the flag
002667 91b4                      	lpm r27, Z //store the instrument offset into r27
002668 e6e2                      	ldi ZL, LOW(instruments) //point Z to instruments table
002669 e1f9                      	ldi ZH, HIGH(instruments)
00266a 0feb                      	add ZL, r27 //point Z to offsetted instrument
00266b 1df2                      	adc ZH, zero
00266c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00266d 1fff                      	rol ZH
00266e 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00266f 91b4                      	lpm r27, Z
                                 
002670 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
002671 1fbb                      	rol r27
002672 2fea                      	mov ZL, r26
002673 2ffb                      	mov ZH, r27
002674 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
002675 9632                      	adiw Z, 2 //point Z to the address of the macro
002676 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
002677 95aa                      	dec r26
002678 f019                      	breq sound_driver_channel2_instrument_change_exit
002679 95b6                      	lsr r27
00267a f078                      	brcs sound_driver_channel2_instrument_change_load_macro
00267b cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
00267c e0a3                      	ldi r26, 0x03
00267d e0b2                      	ldi r27, 0x02
00267e 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
002680 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
002682 93b0 28cb                 	sts triangle_pitch_macro_offset, r27
002684 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27
002686 93b0 28d6                 	sts triangle_duty_macro_offset, r27
002688 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
002689 ce1c                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
00268a 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
00268b 91d5                      	lpm r29, Z+
                                 
00268c 30a5                      	cpi r26, 5
00268d f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
00268e 30a4                      	cpi r26, 4
00268f f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
002690 30a3                      	cpi r26, 3
002691 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
002692 30a2                      	cpi r26, 2
002693 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
002694 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
002695 93c0 28bd                 	sts triangle_volume_macro, r28
002697 93d0 28be                 	sts triangle_volume_macro+1, r29
002699 d041                      	rcall sound_driver_channel2_instrument_change_read_header
00269a 93c0 28c1                 	sts triangle_volume_macro_release, r28
00269c 93d0 28c0                 	sts triangle_volume_macro_loop, r29
00269e cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
00269f 93c0 28c2                 	sts triangle_arpeggio_macro, r28
0026a1 93d0 28c3                 	sts triangle_arpeggio_macro+1, r29
0026a3 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0026a5 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
0026a7 9220 28f7                 	sts triangle_fx_Rxy_target, zero
0026a9 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
0026ab d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
0026ac cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
0026ad 93c0 28c9                 	sts triangle_pitch_macro, r28
0026af 93d0 28ca                 	sts triangle_pitch_macro+1, r29
0026b1 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0026b3 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
0026b5 9220 28f7                 	sts triangle_fx_Rxy_target, zero
0026b7 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
0026b9 d021                      	rcall sound_driver_channel2_instrument_change_read_header
0026ba 93c0 28cd                 	sts triangle_pitch_macro_release, r28
0026bc 93d0 28cc                 	sts triangle_pitch_macro_loop, r29
0026be cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
0026bf 93c0 28cf                 	sts triangle_hi_pitch_macro, r28
0026c1 93d0 28d0                 	sts triangle_hi_pitch_macro+1, r29
0026c3 9220 28f1                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0026c5 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
0026c7 9220 28f7                 	sts triangle_fx_Rxy_target, zero
0026c9 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
0026cb d00f                      	rcall sound_driver_channel2_instrument_change_read_header
0026cc 93c0 28d3                 	sts triangle_hi_pitch_macro_release, r28
0026ce 93d0 28d2                 	sts triangle_hi_pitch_macro_loop, r29
0026d0 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
0026d1 93c0 28d4                 	sts triangle_duty_macro, r28
0026d3 93d0 28d5                 	sts triangle_duty_macro+1, r29
0026d5 d005                      	rcall sound_driver_channel2_instrument_change_read_header
0026d6 93c0 28d8                 	sts triangle_duty_macro_release, r28
0026d8 93d0 28d7                 	sts triangle_duty_macro_loop, r29
0026da cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
0026db 93ef                      	push ZL
0026dc 93ff                      	push ZH
0026dd 2fec                      	mov ZL, r28
0026de 2ffd                      	mov ZH, r29
0026df 0fee                      	lsl ZL
0026e0 1fff                      	rol ZH
0026e1 91c5                      	lpm r28, Z+
0026e2 91d4                      	lpm r29, Z
0026e3 91ff                      	pop ZH
0026e4 91ef                      	pop ZL
0026e5 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
0026e6 93ef                      	push ZL
0026e7 93ff                      	push ZH
0026e8 2fec                      	mov ZL, r28
0026e9 2ffd                      	mov ZH, r29
0026ea 0fee                      	lsl ZL
0026eb 1fff                      	rol ZH
0026ec 91c5                      	lpm r28, Z+
0026ed 91d5                      	lpm r29, Z+
0026ee 93c0 28c6                 	sts triangle_arpeggio_macro_release, r28
0026f0 93d0 28c5                 	sts triangle_arpeggio_macro_loop, r29
0026f2 91c4                      	lpm r28, Z
0026f3 93c0 28c7                 	sts triangle_arpeggio_macro_mode, r28
0026f5 91ff                      	pop ZH
0026f6 91ef                      	pop ZL
0026f7 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
0026f8 91b0 28c1                 	lds r27, triangle_volume_macro_release
0026fa 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0026fb f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
0026fc 95b3                      	inc r27
0026fd 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
0026ff 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
002701 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002702 f019                      	breq sound_driver_channel2_release_pitch
002703 95b3                      	inc r27
002704 93b0 28c4                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
002706 91b0 28cd                 	lds r27, triangle_pitch_macro_release
002708 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002709 f019                      	breq sound_driver_channel2_release_hi_pitch
00270a 95b3                      	inc r27
00270b 93b0 28cb                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
00270d 91b0 28d3                 	lds r27, triangle_hi_pitch_macro_release
00270f 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002710 f019                      	breq sound_driver_channel2_release_duty
002711 95b3                      	inc r27
002712 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
002714 91b0 28d8                 	lds r27, triangle_duty_macro_release
002716 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002717 f019                      	breq sound_driver_channel2_release_exit
002718 95b3                      	inc r27
002719 93b0 28d6                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
00271b d019                      	rcall sound_driver_channel2_increment_offset
00271c cd89                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
00271d 91e0 2813                 	lds ZL, song_frames
00271f 91f0 2814                 	lds ZH, song_frames+1
002721 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002723 91b0 2816                 	lds r27, song_frame_offset+1
002725 9614                      	adiw r27:r26, 4 //offset for channel 2
002726 0fea                      	add ZL, r26
002727 1ffb                      	adc ZH, r27
                                 
002728 91a5                      	lpm r26, Z+ //load the address of the next pattern
002729 91b4                      	lpm r27, Z
00272a 0faa                      	lsl r26
00272b 1fbb                      	rol r27
00272c 93a0 28b7                 	sts triangle_pattern, r26
00272e 93b0 28b8                 	sts triangle_pattern+1, r27
                                 
002730 9220 28bb                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002732 9220 28bc                 	sts triangle_pattern_offset+1, zero
002734 cd71                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
002735 91e0 28bb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
002737 91f0 28bc                 	lds ZH, triangle_pattern_offset+1
002739 9631                      	adiw Z, 1
00273a 93e0 28bb                 	sts triangle_pattern_offset, ZL
00273c 93f0 28bc                 	sts triangle_pattern_offset+1, ZH
00273e 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00273f 91e0 28bb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
002741 91f0 28bc                 	lds ZH, triangle_pattern_offset+1
002743 9632                      	adiw Z, 2 //increment the pointer twice
002744 93e0 28bb                 	sts triangle_pattern_offset, ZL
002746 93f0 28bc                 	sts triangle_pattern_offset+1, ZH
002748 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
002749 95ba                      	dec r27
00274a 93b0 28ba                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
00274c 91f0 2819                 	lds r31, song_speed
00274e 2fef                      	mov r30, r31
00274f 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
002750 91a0 2820                 	lds r26, pulse1_pattern_delay_frames
002752 11a2                      	cpse r26, zero
002753 c042                      	rjmp sound_driver_calculate_delays_pulse2
002754 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002755 2faf                      	mov r26, r31 //move the speed to r26
002756 91b0 281f                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002758 15b2                      	cp r27, zero
002759 f409                      	brne PC+2
00275a c03b                      	rjmp sound_driver_calculate_delays_pulse2
00275b 95ba                      	dec r27
00275c 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
00275e 11b2                      	cpse r27, zero
00275f c034                      	rjmp sound_driver_calculate_delays_pulse1_store
002760 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002761 efbf                      	ldi r27, 0xFF
002762 91c0 2868                 	lds r28, pulse1_fx_Sxx_pre
002764 91d0 2869                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002766 17cb                      	cp r28, r27
002767 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002768 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
002769 17db                      	cp r29, r27
00276a f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
00276b c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
00276c 91c0 2859                 	lds r28, pulse1_fx_Gxx_pre
00276e 91d0 285a                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
002770 17cb                      	cp r28, r27
002771 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
002772 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
002773 17db                      	cp r29, r27
002774 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
002775 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
002776 93b0 2868                 	sts pulse1_fx_Sxx_pre, r27
002778 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002779 93e0 2869                 	sts pulse1_fx_Sxx_post, r30
00277b 95ca                      	dec r28
00277c 93c0 2820                 	sts pulse1_pattern_delay_frames, r28
00277e 2fef                      	mov r30, r31
00277f 50e1                      	subi r30, 1
002780 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
002781 93b0 2869                 	sts pulse1_fx_Sxx_post, r27
002783 2fad                      	mov r26, r29
002784 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
002785 93b0 2859                 	sts pulse1_fx_Gxx_pre, r27
002787 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002788 93e0 285a                 	sts pulse1_fx_Gxx_post, r30
00278a 95ca                      	dec r28
00278b 93c0 2820                 	sts pulse1_pattern_delay_frames, r28
00278d 2fef                      	mov r30, r31
00278e 50e1                      	subi r30, 1
00278f c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
002790 93b0 285a                 	sts pulse1_fx_Gxx_post, r27
002792 2fad                      	mov r26, r29
002793 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
002794 93a0 2820                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
002796 91a0 286d                 	lds r26, pulse2_pattern_delay_frames
002798 11a2                      	cpse r26, zero
002799 c042                      	rjmp sound_driver_calculate_delays_triangle
00279a c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
00279b 2faf                      	mov r26, r31 //move the speed to r26
00279c 91b0 286c                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
00279e 15b2                      	cp r27, zero
00279f f409                      	brne PC+2
0027a0 c03b                      	rjmp sound_driver_calculate_delays_triangle
0027a1 95ba                      	dec r27
0027a2 93b0 286c                 	sts pulse2_pattern_delay_rows, r27
0027a4 11b2                      	cpse r27, zero
0027a5 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
0027a6 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
0027a7 efbf                      	ldi r27, 0xFF
0027a8 91c0 28b5                 	lds r28, pulse2_fx_Sxx_pre
0027aa 91d0 28b6                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
0027ac 17cb                      	cp r28, r27
0027ad f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
0027ae c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
0027af 17db                      	cp r29, r27
0027b0 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
0027b1 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
0027b2 91c0 28a6                 	lds r28, pulse2_fx_Gxx_pre
0027b4 91d0 28a7                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
0027b6 17cb                      	cp r28, r27
0027b7 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
0027b8 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
0027b9 17db                      	cp r29, r27
0027ba f0f9                      	breq sound_driver_calculate_delays_pulse2_store
0027bb c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
0027bc 93b0 28b5                 	sts pulse2_fx_Sxx_pre, r27
0027be 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0027bf 93e0 28b6                 	sts pulse2_fx_Sxx_post, r30
0027c1 95ca                      	dec r28
0027c2 93c0 286d                 	sts pulse2_pattern_delay_frames, r28
0027c4 2fef                      	mov r30, r31
0027c5 50e1                      	subi r30, 1
0027c6 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
0027c7 93b0 28b6                 	sts pulse2_fx_Sxx_post, r27
0027c9 2fad                      	mov r26, r29
0027ca c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
0027cb 93b0 28a6                 	sts pulse2_fx_Gxx_pre, r27
0027cd 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0027ce 93e0 28a7                 	sts pulse2_fx_Gxx_post, r30
0027d0 95ca                      	dec r28
0027d1 93c0 286d                 	sts pulse2_pattern_delay_frames, r28
0027d3 2fef                      	mov r30, r31
0027d4 50e1                      	subi r30, 1
0027d5 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
0027d6 93b0 28a7                 	sts pulse2_fx_Gxx_post, r27
0027d8 2fad                      	mov r26, r29
0027d9 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
0027da 93a0 286d                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
0027dc 91a0 28ba                 	lds r26, triangle_pattern_delay_frames
0027de 11a2                      	cpse r26, zero
0027df c042                      	rjmp sound_driver_calculate_delays_noise
0027e0 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
0027e1 2faf                      	mov r26, r31 //move the speed to r26
0027e2 91b0 28b9                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
0027e4 15b2                      	cp r27, zero
0027e5 f409                      	brne PC+2
0027e6 c03b                      	rjmp sound_driver_calculate_delays_noise
0027e7 95ba                      	dec r27
0027e8 93b0 28b9                 	sts triangle_pattern_delay_rows, r27
0027ea 11b2                      	cpse r27, zero
0027eb c034                      	rjmp sound_driver_calculate_delays_triangle_store
0027ec 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
0027ed efbf                      	ldi r27, 0xFF
0027ee 91c0 28fd                 	lds r28, triangle_fx_Sxx_pre
0027f0 91d0 28fe                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
0027f2 17cb                      	cp r28, r27
0027f3 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
0027f4 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
0027f5 17db                      	cp r29, r27
0027f6 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
0027f7 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
0027f8 91c0 28ee                 	lds r28, triangle_fx_Gxx_pre
0027fa 91d0 28ef                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
0027fc 17cb                      	cp r28, r27
0027fd f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
0027fe c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
0027ff 17db                      	cp r29, r27
002800 f0f9                      	breq sound_driver_calculate_delays_triangle_store
002801 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
002802 93b0 28fd                 	sts triangle_fx_Sxx_pre, r27
002804 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002805 93e0 28fe                 	sts triangle_fx_Sxx_post, r30
002807 95ca                      	dec r28
002808 93c0 28ba                 	sts triangle_pattern_delay_frames, r28
00280a 2fef                      	mov r30, r31
00280b 50e1                      	subi r30, 1
00280c c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
00280d 93b0 28fe                 	sts triangle_fx_Sxx_post, r27
00280f 2fad                      	mov r26, r29
002810 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002811 93b0 28ee                 	sts triangle_fx_Gxx_pre, r27
002813 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002814 93e0 28ef                 	sts triangle_fx_Gxx_post, r30
002816 95ca                      	dec r28
002817 93c0 28ba                 	sts triangle_pattern_delay_frames, r28
002819 2fef                      	mov r30, r31
00281a 50e1                      	subi r30, 1
00281b c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
00281c 93b0 28ef                 	sts triangle_fx_Gxx_post, r27
00281e 2fad                      	mov r26, r29
00281f c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
002820 93a0 28ba                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002822 91e0 2823                 	lds ZL, pulse1_volume_macro
002824 91f0 2824                 	lds ZH, pulse1_volume_macro+1
002826 9630                      	adiw Z, 0
002827 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
002828 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002829 1fff                      	rol ZH
00282a 91a0 2825                 	lds r26, pulse1_volume_macro_offset
00282c 0fea                      	add ZL, r26
00282d 1df2                      	adc ZH, zero
                                 
00282e 91b0 2827                 	lds r27, pulse1_volume_macro_release
002830 17ba                      	cp r27, r26
002831 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
002832 91a0 2826                 	lds r26, pulse1_volume_macro_loop
002834 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002835 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002836 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
002837 95a3                      	inc r26 //increment the macro offset
002838 93a0 2825                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
00283a 91b4                      	lpm r27, Z //load volume data into r27
00283b 3fbf                      	cpi r27, 0xFF //check for macro end flag
00283c f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
00283d 91b0 2827                 	lds r27, pulse1_volume_macro_release
00283f 3fbf                      	cpi r27, 0xFF
002840 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
002841 91b0 2826                 	lds r27, pulse1_volume_macro_loop //load the loop index
002843 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
002845 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
002846 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002847 93a0 2825                 	sts pulse1_volume_macro_offset, r26
002849 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
00284a e0ec                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
00284b e6f4                      	ldi ZH, HIGH(volumes << 1)
00284c 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
00284d 0feb                      	add ZL, r27 //add offset to the table
00284e 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
00284f 91b0 2800                 	lds r27, pulse1_param //load main volume
002851 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002852 91a0 2857                 	lds r26, pulse1_fx_7xy_value
002854 30a0                      	cpi r26, 0x00
002855 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
002856 0feb                      	add ZL, r27 //offset the volume table by the main volume
002857 1df2                      	adc ZH, zero
002858 91b4                      	lpm r27, Z
002859 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00285b c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
00285c 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
00285e 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00285f 91a0 2857                 	lds r26, pulse1_fx_7xy_value
002861 30a0                      	cpi r26, 0x00
002862 f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
002863 93b0 2806                 	sts pulse1_output_volume, r27
002865 c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
002866 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002867 f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
002868 f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
002869 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
00286a 0feb                      	add ZL, r27 //offset the volume table by the main volume
00286b 1df2                      	adc ZH, zero
00286c 91b4                      	lpm r27, Z
00286d 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00286f c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002870 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002871 0feb                      	add ZL, r27 //offset the volume table by the main volume
002872 1df2                      	adc ZH, zero
002873 91b4                      	lpm r27, Z
002874 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002876 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
002877 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002878 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002879 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
00287a 93b0 2806                 	sts pulse1_output_volume, r27
00287c c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
00287d e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00287e 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002880 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
002882 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
002884 9630                      	adiw Z, 0
002885 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002886 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002887 1fff                      	rol ZH
002888 91a0 282a                 	lds r26, pulse1_arpeggio_macro_offset
00288a 0fea                      	add ZL, r26
00288b 1df2                      	adc ZH, zero
                                 
00288c 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
00288e 17ba                      	cp r27, r26
00288f f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002890 91a0 282b                 	lds r26, pulse1_arpeggio_macro_loop
002892 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002893 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002894 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
002895 95a3                      	inc r26 //increment the macro offset
002896 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
002898 91b4                      	lpm r27, Z //load arpeggio data into r27
002899 38b0                      	cpi r27, 0x80 //check for macro end flag
00289a f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
00289b c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
00289c 50a1                      	subi r26, 1 //keep the offset at the end flag
00289d 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
00289f 91b0 282d                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0028a1 30b1                      	cpi r27, 0x01
0028a2 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0028a3 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
0028a5 3fbf                      	cpi r27, 0xFF
0028a6 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0028a7 91b0 282b                 	lds r27, pulse1_arpeggio_macro_loop
0028a9 3fbf                      	cpi r27, 0xFF
0028aa f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0028ab c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0028ac 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
0028ae 3fbf                      	cpi r27, 0xFF
0028af f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0028b0 91b0 282b                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0028b2 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0028b3 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0028b4 91c0 283f                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0028b6 91d0 2840                 	lds r29, pulse1_fx_0xy_sequence+1
0028b8 9620                      	adiw r29:r28, 0
0028b9 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0028ba 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0028bb 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0028bd cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0028be 93b0 282a                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0028c0 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0028c1 91c0 283f                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0028c3 91d0 2840                 	lds r29, pulse1_fx_0xy_sequence+1
0028c5 9620                      	adiw r29:r28, 0 //check for 0xy effect
0028c6 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
0028c7 95d6                      	lsr r29
0028c8 95c7                      	ror r28
0028c9 95d7                      	ror r29
0028ca 95c7                      	ror r28
0028cb 95d7                      	ror r29
0028cc 95c7                      	ror r28
0028cd 95d7                      	ror r29
0028ce 95c7                      	ror r28
0028cf 95d7                      	ror r29
0028d0 95d2                      	swap r29
                                 
0028d1 93c0 283f                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0028d3 93d0 2840                 	sts pulse1_fx_0xy_sequence+1, r29
0028d5 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0028d6 91a0 2807                 	lds r26, pulse1_note //load the current note index
0028d8 0fac                      	add r26, r28 //add the note offset
0028d9 c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0028da 91a0 2807                 	lds r26, pulse1_note //load the current note index
0028dc c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0028dd 9220 282e                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0028df 9220 2834                 	sts pulse1_total_hi_pitch_offset, zero
0028e1 91a0 282d                 	lds r26, pulse1_arpeggio_macro_mode
0028e3 30a1                      	cpi r26, 0x01 //absolute mode
0028e4 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0028e5 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0028e6 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0028e7 91a0 2807                 	lds r26, pulse1_note //load the current note index
0028e9 0fab                      	add r26, r27 //offset the note with the arpeggio data
0028ea fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0028eb c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0028ec 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0028ed f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0028ee e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0028ef c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0028f0 fda7                      	sbrc r26, 7 //check if result is negative
0028f1 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0028f2 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0028f3 2fab                      	mov r26, r27 //move the arpeggio data into r26
0028f4 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0028f5 91a0 2807                 	lds r26, pulse1_note //load the current note index
0028f7 0fab                      	add r26, r27 //offset the note with the arpeggio data
0028f8 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0028f9 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0028fa 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0028fc 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0028fd f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0028fe e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0028ff 93a0 2807                 	sts pulse1_note, r26
002901 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
002902 fda7                      	sbrc r26, 7 //check if result is negative
002903 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002904 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
002906 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
002907 e0f0                      	ldi ZH, HIGH(note_table << 1)
002908 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002909 0fea                      	add ZL, r26 //add offset
00290a 1df2                      	adc ZH, zero
00290b 91a5                      	lpm r26, Z+ //load bytes
00290c 91b4                      	lpm r27, Z
00290d 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
00290f 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002911 93a0 284b                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002913 93b0 284c                 	sts pulse1_fx_3xx_target+1, r27
002915 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
002916 91e0 282f                 	lds ZL, pulse1_pitch_macro
002918 91f0 2830                 	lds ZH, pulse1_pitch_macro+1
00291a 9630                      	adiw Z, 0
00291b f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
00291c c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
00291d 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00291e 1fff                      	rol ZH
00291f 91a0 2831                 	lds r26, pulse1_pitch_macro_offset
002921 0fea                      	add ZL, r26
002922 1df2                      	adc ZH, zero
                                 
002923 91b0 2833                 	lds r27, pulse1_pitch_macro_release
002925 17ba                      	cp r27, r26
002926 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
002927 91a0 2832                 	lds r26, pulse1_pitch_macro_loop
002929 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00292a f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00292b c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
00292c 95a3                      	inc r26 //increment the macro offset
00292d 93a0 2831                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
00292f 91b4                      	lpm r27, Z //load pitch data into r27
002930 38b0                      	cpi r27, 0x80 //check for macro end flag
002931 f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
002932 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002933 93a0 2831                 	sts pulse1_pitch_macro_offset, r26
002935 91b0 2833                 	lds r27, pulse1_pitch_macro_release
002937 3fbf                      	cpi r27, 0xFF
002938 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
002939 91b0 2832                 	lds r27, pulse1_pitch_macro_loop //load the loop index
00293b 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00293c f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00293d 93b0 2831                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
00293f cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002940 91b0 282e                 	lds r27, pulse1_total_pitch_offset
002942 c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002943 91a0 282e                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
002945 0fba                      	add r27, r26
002946 93b0 282e                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
002948 91a0 285b                 	lds r26, pulse1_fx_Pxx
00294a 0fba                      	add r27, r26
                                 
00294b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00294c 937f                      	push r23
00294d 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00294e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00294f 0367                      	mulsu r22, r23
002950 917f                      	pop r23
002951 916f                      	pop r22
                                 
002952 9416                      	lsr r1 //shift out the fractional bits
002953 9407                      	ror r0
002954 9416                      	lsr r1
002955 9407                      	ror r0
002956 9416                      	lsr r1
002957 9407                      	ror r0
002958 9416                      	lsr r1
002959 9407                      	ror r0
00295a fe13                      	sbrs r1, 3 //check if result was a negative number
00295b c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
00295c efb0                      	ldi r27, 0xF0
00295d 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
00295e 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002960 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002962 0da0                      	add r26, r0 //offset the timer values
002963 1db1                      	adc r27, r1
                                 	
002964 91c0 2843                 	lds r28, pulse1_fx_1xx_total
002966 91d0 2844                 	lds r29, pulse1_fx_1xx_total+1
002968 1bac                      	sub r26, r28
002969 0bbd                      	sbc r27, r29
00296a 91c0 2847                 	lds r28, pulse1_fx_2xx_total
00296c 91d0 2848                 	lds r29, pulse1_fx_2xx_total+1
00296e 0fac                      	add r26, r28
00296f 1fbd                      	adc r27, r29
002970 91c0 2860                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002972 91d0 2861                 	lds r29, pulse1_fx_Qxy_total_offset+1
002974 1bac                      	sub r26, r28
002975 0bbd                      	sbc r27, r29
002976 91c0 2866                 	lds r28, pulse1_fx_Rxy_total_offset
002978 91d0 2867                 	lds r29, pulse1_fx_Rxy_total_offset+1
00297a 0fac                      	add r26, r28
00297b 1fbd                      	adc r27, r29
                                 
00297c 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00297e 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
002980 91e0 2835                 	lds ZL, pulse1_hi_pitch_macro
002982 91f0 2836                 	lds ZH, pulse1_hi_pitch_macro+1
002984 9630                      	adiw Z, 0
002985 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
002986 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
002987 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002988 1fff                      	rol ZH
002989 91a0 2837                 	lds r26, pulse1_hi_pitch_macro_offset
00298b 0fea                      	add ZL, r26
00298c 1df2                      	adc ZH, zero
                                 
00298d 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_release
00298f 17ba                      	cp r27, r26
002990 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002991 91a0 2838                 	lds r26, pulse1_hi_pitch_macro_loop
002993 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002994 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002995 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
002996 95a3                      	inc r26 //increment the macro offset
002997 93a0 2837                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
002999 91b4                      	lpm r27, Z //load hi pitch data into r27
00299a 38b0                      	cpi r27, 0x80 //check for macro end flag
00299b f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
00299c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00299d 93a0 2837                 	sts pulse1_hi_pitch_macro_offset, r26
00299f 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_release
0029a1 3fbf                      	cpi r27, 0xFF
0029a2 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0029a3 91b0 2838                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0029a5 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0029a6 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0029a7 93b0 2837                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0029a9 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0029aa 91b0 2834                 	lds r27, pulse1_total_hi_pitch_offset
0029ac c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0029ad 91a0 2834                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0029af 0fba                      	add r27, r26
0029b0 93b0 2834                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0029b2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0029b3 937f                      	push r23
0029b4 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0029b5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0029b6 0367                      	mulsu r22, r23
0029b7 917f                      	pop r23
0029b8 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0029b9 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0029bb 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0029bd 0da0                      	add r26, r0 //offset the timer values
0029be 1db1                      	adc r27, r1
0029bf 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0029c1 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0029c3 91e0 283a                 	lds ZL, pulse1_duty_macro
0029c5 91f0 283b                 	lds ZH, pulse1_duty_macro+1
0029c7 9630                      	adiw Z, 0
0029c8 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0029c9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0029ca 1fff                      	rol ZH
0029cb 91a0 283c                 	lds r26, pulse1_duty_macro_offset
0029cd 0fea                      	add ZL, r26
0029ce 1df2                      	adc ZH, zero
                                 
0029cf 91b0 283e                 	lds r27, pulse1_duty_macro_release
0029d1 17ba                      	cp r27, r26
0029d2 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0029d3 91a0 283d                 	lds r26, pulse1_duty_macro_loop
0029d5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0029d6 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0029d7 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0029d8 95a3                      	inc r26 //increment the macro offset
0029d9 93a0 283c                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0029db 91b4                      	lpm r27, Z //load pitch data into r27
0029dc 3fbf                      	cpi r27, 0xFF //check for macro end flag
0029dd f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0029de 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0029df 93a0 283c                 	sts pulse1_duty_macro_offset, r26
0029e1 91b0 283e                 	lds r27, pulse1_duty_macro_release
0029e3 3fbf                      	cpi r27, 0xFF
0029e4 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0029e5 91b0 283d                 	lds r27, pulse1_duty_macro_loop //load the loop index
0029e7 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0029e8 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0029e9 93b0 283c                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0029eb cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0029ec e6ec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0029ed e6f3                      	ldi ZH, HIGH(sequences << 1)
0029ee 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0029ef 1df2                      	adc ZH, zero
                                 
0029f0 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0029f1 95b7                      	ror r27
0029f2 95b7                      	ror r27
0029f3 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0029f5 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0029f6 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0029f7 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0029f8 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0029f9 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0029fa 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0029fb 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0029fc 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0029fd 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0029ff 91e0 2841                 	lds ZL, pulse1_fx_1xx
002a01 91f0 2842                 	lds ZH, pulse1_fx_1xx+1
002a03 9630                      	adiw Z, 0
002a04 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
002a05 91a0 2843                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
002a07 91b0 2844                 	lds r27, pulse1_fx_1xx_total+1
002a09 0fae                      	add r26, ZL //increase the total offset by the rate
002a0a 1fbf                      	adc r27, ZH
002a0b 93a0 2843                 	sts pulse1_fx_1xx_total, r26
002a0d 93b0 2844                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
002a0f 91e0 2845                 	lds ZL, pulse1_fx_2xx
002a11 91f0 2846                 	lds ZH, pulse1_fx_2xx+1
002a13 9630                      	adiw Z, 0
002a14 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
002a15 91a0 2847                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
002a17 91b0 2848                 	lds r27, pulse1_fx_2xx_total+1
002a19 0fae                      	add r26, ZL //increase the total offset by the rate
002a1a 1fbf                      	adc r27, ZH
002a1b 93a0 2847                 	sts pulse1_fx_2xx_total, r26
002a1d 93b0 2848                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
002a1f 91e0 284d                 	lds ZL, pulse1_fx_3xx_speed
002a21 91f0 284e                 	lds ZH, pulse1_fx_3xx_speed+1
002a23 9630                      	adiw Z, 0
002a24 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
002a25 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
002a26 91a0 2849                 	lds r26, pulse1_fx_3xx_start
002a28 91b0 284a                 	lds r27, pulse1_fx_3xx_start+1
002a2a 9610                      	adiw r26:r27, 0
002a2b f409                      	brne sound_driver_channel0_fx_3xx_routine_main
002a2c c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
002a2d 91c0 284b                 	lds r28, pulse1_fx_3xx_target
002a2f 91d0 284c                 	lds r29, pulse1_fx_3xx_target+1
                                 
002a31 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002a32 07bd                      	cpc r27, r29
002a33 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
002a34 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002a35 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
002a36 9220 2849                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002a38 9220 284a                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002a3a c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
002a3b 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002a3c 0bdb                      	sbc r29, r27
002a3d 91a0 284f                 	lds r26, pulse1_fx_3xx_total_offset
002a3f 91b0 2850                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
002a41 0fae                      	add r26, ZL //add the speed to the total offset
002a42 1fbf                      	adc r27, ZH
002a43 1bca                      	sub r28, r26 //invert the total difference with the total offset
002a44 0bdb                      	sbc r29, r27
002a45 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002a46 93a0 284f                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
002a48 93b0 2850                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
002a4a 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
002a4c 91b0 0a8d                 	lds r27, TCB0_CCMPH
002a4e 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002a4f 0bbd                      	sbc r27, r29
002a50 93a0 0a8c                 	sts TCB0_CCMPL, r26
002a52 93b0 0a8d                 	sts TCB0_CCMPH, r27
002a54 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002a55 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002a56 0bbd                      	sbc r27, r29
002a57 91c0 284f                 	lds r28, pulse1_fx_3xx_total_offset
002a59 91d0 2850                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
002a5b 0fce                      	add r28, ZL //add the speed to the total offset
002a5c 1fdf                      	adc r29, ZH
002a5d 1bac                      	sub r26, r28 //invert the total difference with the total offset
002a5e 0bbd                      	sbc r27, r29
002a5f f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002a60 93c0 284f                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
002a62 93d0 2850                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
002a64 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
002a66 91d0 0a8d                 	lds r29, TCB0_CCMPH
002a68 0fca                      	add r28, r26 //offset the current timer period with the total offset
002a69 1fdb                      	adc r29, r27
002a6a 93c0 0a8c                 	sts TCB0_CCMPL, r28
002a6c 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002a6e 91a0 2851                 	lds r26, pulse1_fx_4xy_speed
002a70 15a2                      	cp r26, zero
002a71 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
002a72 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
002a73 91b0 2852                 	lds r27, pulse1_fx_4xy_depth
002a75 91c0 2853                 	lds r28, pulse1_fx_4xy_phase
002a77 0fca                      	add r28, r26 //increase the phase by the speed
002a78 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002a79 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002a7a 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
002a7b 93c0 2853                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002a7d 31c0                      	cpi r28, 16
002a7e f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
002a7f 32c0                      	cpi r28, 32
002a80 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
002a81 33c0                      	cpi r28, 48
002a82 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
002a83 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
002a84 70cf                      	andi r28, 0x0F //mask for values 0-15
002a85 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
002a86 6fc0                      	ori r28, 0xF0
002a87 95c0                      	com r28 //invert values 0-15
002a88 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
002a89 70cf                      	andi r28, 0x0F //mask for values 0-15
002a8a c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
002a8b 6fc0                      	ori r28, 0xF0
002a8c 95c0                      	com r28 //invert values 0-15
002a8d c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
002a8e 95b2                      	swap r27 //multiply depth by 16
002a8f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002a90 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002a91 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002a92 0fec                      	add ZL, r28 //offset the table by the depth+phase
002a93 1df2                      	adc ZH, zero
002a94 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002a95 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a96 937f                      	push r23
002a97 2f6c                      	mov r22, r28 //store the vibrato value into r22
002a98 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a99 9f67                      	mul r22, r23
002a9a 917f                      	pop r23
002a9b 916f                      	pop r22
                                 
002a9c 9416                      	lsr r1 //shift out the fractional bits
002a9d 9407                      	ror r0
002a9e 9416                      	lsr r1
002a9f 9407                      	ror r0
002aa0 9416                      	lsr r1
002aa1 9407                      	ror r0
002aa2 9416                      	lsr r1
002aa3 9407                      	ror r0
                                 	
002aa4 91a0 0a8c                 	lds r26, TCB0_CCMPL
002aa6 91b0 0a8d                 	lds r27, TCB0_CCMPH
002aa8 0da0                      	add r26, r0
002aa9 1db1                      	adc r27, r1
002aaa 93a0 0a8c                 	sts TCB0_CCMPL, r26
002aac 93b0 0a8d                 	sts TCB0_CCMPH, r27
002aae c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
002aaf 95b2                      	swap r27 //multiply depth by 16
002ab0 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002ab1 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002ab2 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002ab3 0fec                      	add ZL, r28 //offset the table by the depth+phase
002ab4 1df2                      	adc ZH, zero
002ab5 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002ab6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ab7 937f                      	push r23
002ab8 2f6c                      	mov r22, r28 //store the vibrato value into r22
002ab9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002aba 9f67                      	mul r22, r23
002abb 917f                      	pop r23
002abc 916f                      	pop r22
                                 
002abd 9416                      	lsr r1 //shift out the fractional bits
002abe 9407                      	ror r0
002abf 9416                      	lsr r1
002ac0 9407                      	ror r0
002ac1 9416                      	lsr r1
002ac2 9407                      	ror r0
002ac3 9416                      	lsr r1
002ac4 9407                      	ror r0
                                 
002ac5 91a0 0a8c                 	lds r26, TCB0_CCMPL
002ac7 91b0 0a8d                 	lds r27, TCB0_CCMPH
002ac9 19a0                      	sub r26, r0
002aca 09b1                      	sbc r27, r1
002acb 93a0 0a8c                 	sts TCB0_CCMPL, r26
002acd 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
002acf 91a0 2854                 	lds r26, pulse1_fx_7xy_speed
002ad1 15a2                      	cp r26, zero
002ad2 f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002ad3 91b0 2855                 	lds r27, pulse1_fx_7xy_depth
002ad5 91c0 2856                 	lds r28, pulse1_fx_7xy_phase
002ad7 0fca                      	add r28, r26 //increase the phase by the speed
002ad8 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002ad9 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002ada e0c0                      	ldi r28, 0x00
002adb 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
002adc 93c0 2856                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
002ade 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002adf ffc4                      	sbrs r28, 4
002ae0 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
002ae1 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
002ae2 70cf                      	andi r28, 0x0F //mask for values 0-15
002ae3 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
002ae4 6fc0                      	ori r28, 0xF0
002ae5 95c0                      	com r28 //invert values 0-15
002ae6 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002ae7 95b2                      	swap r27 //multiply depth by 16
002ae8 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002ae9 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002aea e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002aeb 0fec                      	add ZL, r28 //offset the table by the depth+phase
002aec 1df2                      	adc ZH, zero
002aed 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002aee 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002aef 93c0 2857                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
002af1 91b0 2858                 	lds r27, pulse1_fx_Axy
002af3 15b2                      	cp r27, zero
002af4 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002af5 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
002af7 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
002af9 2fda                      	mov r29, r26 //copy fractional volume into r29
002afa 2fec                      	mov r30, r28 //copy the pulse1_param into r30
002afb 95e2                      	swap r30
002afc 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002afd 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002afe 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002aff f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
002b00 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
002b01 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002b02 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
002b03 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002b04 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002b05 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002b06 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
002b07 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002b08 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002b09 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
002b0a 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
002b0c 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002b0d 95a2                      	swap r26
002b0e 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002b0f 2bca                      	or r28, r26 //store the new volume back into pulse1_param
002b10 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
002b12 91e0 285c                 	lds ZL, pulse1_fx_Qxy_target
002b14 91f0 285d                 	lds ZH, pulse1_fx_Qxy_target+1
002b16 9630                      	adiw Z, 0
002b17 f199                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002b18 91a0 2860                 	lds r26, pulse1_fx_Qxy_total_offset
002b1a 91b0 2861                 	lds r27, pulse1_fx_Qxy_total_offset+1
002b1c 91c0 0a8c                 	lds r28, TCB0_CCMPL
002b1e 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002b20 1bec                      	sub ZL, r28 //calculate the difference to the target
002b21 0bfd                      	sbc ZH, r29
002b22 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
002b23 f0e8                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
002b24 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002b25 0bbf                      	sbc r27, ZH
                                 
002b26 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b27 937f                      	push r23
002b28 9160 285b                 	lds r22, pulse1_fx_Pxx
002b2a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b2b 9f67                      	mul r22, r23
002b2c 917f                      	pop r23
002b2d 916f                      	pop r22
002b2e 9416                      	lsr r1 //shift out the fractional bits
002b2f 9407                      	ror r0
002b30 9416                      	lsr r1
002b31 9407                      	ror r0
002b32 9416                      	lsr r1
002b33 9407                      	ror r0
002b34 9416                      	lsr r1
002b35 9407                      	ror r0
                                 
002b36 0da0                      	add r26, r0
002b37 1db2                      	adc r27, zero
                                 
002b38 93a0 2860                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
002b3a 93b0 2861                 	sts pulse1_fx_Qxy_total_offset+1, r27
002b3c 9220 285c                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002b3e 9220 285d                 	sts pulse1_fx_Qxy_target+1, zero
002b40 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
002b41 91c0 285e                 	lds r28, pulse1_fx_Qxy_speed
002b43 91d0 285f                 	lds r29, pulse1_fx_Qxy_speed+1
002b45 0fac                      	add r26, r28 //increase the total offset by the speed
002b46 1fbd                      	adc r27, r29
002b47 93a0 2860                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
002b49 93b0 2861                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
002b4b 91e0 2862                 	lds ZL, pulse1_fx_Rxy_target
002b4d 91f0 2863                 	lds ZH, pulse1_fx_Rxy_target+1
002b4f 9630                      	adiw Z, 0
002b50 f199                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
002b51 91a0 2866                 	lds r26, pulse1_fx_Rxy_total_offset
002b53 91b0 2867                 	lds r27, pulse1_fx_Rxy_total_offset+1
002b55 91c0 0a8c                 	lds r28, TCB0_CCMPL
002b57 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002b59 1bce                      	sub r28, ZL //calculate the difference to the target
002b5a 0bdf                      	sbc r29, ZH
002b5b f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
002b5c f0e8                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
002b5d 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002b5e 0bbd                      	sbc r27, r29
                                 
002b5f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b60 937f                      	push r23
002b61 9160 285b                 	lds r22, pulse1_fx_Pxx
002b63 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b64 9f67                      	mul r22, r23
002b65 917f                      	pop r23
002b66 916f                      	pop r22
002b67 9416                      	lsr r1 //shift out the fractional bits
002b68 9407                      	ror r0
002b69 9416                      	lsr r1
002b6a 9407                      	ror r0
002b6b 9416                      	lsr r1
002b6c 9407                      	ror r0
002b6d 9416                      	lsr r1
002b6e 9407                      	ror r0
                                 
002b6f 0da0                      	add r26, r0
002b70 1db2                      	adc r27, zero
                                 
002b71 93a0 2866                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002b73 93b0 2867                 	sts pulse1_fx_Rxy_total_offset+1, r27
002b75 9220 2862                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002b77 9220 2863                 	sts pulse1_fx_Rxy_target+1, zero
002b79 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
002b7a 91c0 2864                 	lds r28, pulse1_fx_Rxy_speed
002b7c 91d0 2865                 	lds r29, pulse1_fx_Rxy_speed+1
002b7e 0fac                      	add r26, r28 //increase the total offset by the speed
002b7f 1fbd                      	adc r27, r29
002b80 93a0 2866                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002b82 93b0 2867                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
002b84 91e0 2870                 	lds ZL, pulse2_volume_macro
002b86 91f0 2871                 	lds ZH, pulse2_volume_macro+1
002b88 9630                      	adiw Z, 0
002b89 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
002b8a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002b8b 1fff                      	rol ZH
002b8c 91a0 2872                 	lds r26, pulse2_volume_macro_offset
002b8e 0fea                      	add ZL, r26
002b8f 1df2                      	adc ZH, zero
                                 
002b90 91b0 2874                 	lds r27, pulse2_volume_macro_release
002b92 17ba                      	cp r27, r26
002b93 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
002b94 91a0 2873                 	lds r26, pulse2_volume_macro_loop
002b96 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002b97 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002b98 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
002b99 95a3                      	inc r26 //increment the macro offset
002b9a 93a0 2872                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002b9c 91b4                      	lpm r27, Z //load volume data into r27
002b9d 3fbf                      	cpi r27, 0xFF //check for macro end flag
002b9e f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002b9f 91b0 2874                 	lds r27, pulse2_volume_macro_release
002ba1 3fbf                      	cpi r27, 0xFF
002ba2 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
002ba3 91b0 2873                 	lds r27, pulse2_volume_macro_loop //load the loop index
002ba5 93b0 2872                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
002ba7 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
002ba8 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002ba9 93a0 2872                 	sts pulse2_volume_macro_offset, r26
002bab cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
002bac e0ec                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002bad e6f4                      	ldi ZH, HIGH(volumes << 1)
002bae 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002baf 0feb                      	add ZL, r27 //add offset to the table
002bb0 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
002bb1 91b0 2808                 	lds r27, pulse2_param //load main volume
002bb3 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002bb4 91a0 28a4                 	lds r26, pulse2_fx_7xy_value
002bb6 30a0                      	cpi r26, 0x00
002bb7 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
002bb8 0feb                      	add ZL, r27 //offset the volume table by the main volume
002bb9 1df2                      	adc ZH, zero
002bba 91b4                      	lpm r27, Z
002bbb 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002bbd c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
002bbe 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002bc0 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002bc1 91a0 28a4                 	lds r26, pulse2_fx_7xy_value
002bc3 30a0                      	cpi r26, 0x00
002bc4 f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
002bc5 93b0 280e                 	sts pulse2_output_volume, r27
002bc7 c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
002bc8 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002bc9 f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002bca f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
002bcb e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002bcc 0feb                      	add ZL, r27 //offset the volume table by the main volume
002bcd 1df2                      	adc ZH, zero
002bce 91b4                      	lpm r27, Z
002bcf 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002bd1 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
002bd2 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002bd3 0feb                      	add ZL, r27 //offset the volume table by the main volume
002bd4 1df2                      	adc ZH, zero
002bd5 91b4                      	lpm r27, Z
002bd6 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002bd8 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
002bd9 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002bda f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002bdb f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002bdc 93b0 280e                 	sts pulse2_output_volume, r27
002bde c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002bdf e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002be0 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002be2 91e0 2875                 	lds ZL, pulse2_arpeggio_macro
002be4 91f0 2876                 	lds ZH, pulse2_arpeggio_macro+1
002be6 9630                      	adiw Z, 0
002be7 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002be8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002be9 1fff                      	rol ZH
002bea 91a0 2877                 	lds r26, pulse2_arpeggio_macro_offset
002bec 0fea                      	add ZL, r26
002bed 1df2                      	adc ZH, zero
                                 
002bee 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
002bf0 17ba                      	cp r27, r26
002bf1 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002bf2 91a0 2878                 	lds r26, pulse2_arpeggio_macro_loop
002bf4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002bf5 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002bf6 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
002bf7 95a3                      	inc r26 //increment the macro offset
002bf8 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
002bfa 91b4                      	lpm r27, Z //load arpeggio data into r27
002bfb 38b0                      	cpi r27, 0x80 //check for macro end flag
002bfc f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
002bfd c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
002bfe 50a1                      	subi r26, 1 //keep the offset at the end flag
002bff 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26
002c01 91b0 287a                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002c03 30b1                      	cpi r27, 0x01
002c04 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
002c05 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
002c07 3fbf                      	cpi r27, 0xFF
002c08 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
002c09 91b0 2878                 	lds r27, pulse2_arpeggio_macro_loop
002c0b 3fbf                      	cpi r27, 0xFF
002c0c f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002c0d c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002c0e 91b0 2879                 	lds r27, pulse2_arpeggio_macro_release
002c10 3fbf                      	cpi r27, 0xFF
002c11 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
002c12 91b0 2878                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
002c14 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002c15 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
002c16 91c0 288c                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002c18 91d0 288d                 	lds r29, pulse2_fx_0xy_sequence+1
002c1a 9620                      	adiw r29:r28, 0
002c1b f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002c1c 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002c1d 93a0 2877                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002c1f cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002c20 93b0 2877                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
002c22 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
002c23 91c0 288c                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
002c25 91d0 288d                 	lds r29, pulse2_fx_0xy_sequence+1
002c27 9620                      	adiw r29:r28, 0 //check for 0xy effect
002c28 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
002c29 95d6                      	lsr r29
002c2a 95c7                      	ror r28
002c2b 95d7                      	ror r29
002c2c 95c7                      	ror r28
002c2d 95d7                      	ror r29
002c2e 95c7                      	ror r28
002c2f 95d7                      	ror r29
002c30 95c7                      	ror r28
002c31 95d7                      	ror r29
002c32 95d2                      	swap r29
                                 
002c33 93c0 288c                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
002c35 93d0 288d                 	sts pulse2_fx_0xy_sequence+1, r29
002c37 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002c38 91a0 280f                 	lds r26, pulse2_note //load the current note index
002c3a 0fac                      	add r26, r28 //add the note offset
002c3b c02c                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002c3c 91a0 280f                 	lds r26, pulse2_note //load the current note index
002c3e c029                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
002c3f 9220 287b                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002c41 9220 2881                 	sts pulse2_total_hi_pitch_offset, zero
002c43 91a0 287a                 	lds r26, pulse2_arpeggio_macro_mode
002c45 30a1                      	cpi r26, 0x01 //absolute mode
002c46 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
002c47 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
002c48 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
002c49 91a0 280f                 	lds r26, pulse2_note //load the current note index
002c4b 0fab                      	add r26, r27 //offset the note with the arpeggio data
002c4c fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002c4d c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
002c4e 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002c4f f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002c50 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002c51 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
002c52 fda7                      	sbrc r26, 7 //check if result is negative
002c53 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002c54 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
002c55 2fab                      	mov r26, r27 //move the arpeggio data into r26
002c56 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
002c57 91a0 280f                 	lds r26, pulse2_note //load the current note index
002c59 0fab                      	add r26, r27 //offset the note with the arpeggio data
002c5a fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002c5b c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
002c5c 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
002c5e 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002c5f f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002c60 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002c61 93a0 280f                 	sts pulse2_note, r26
002c63 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
002c64 fda7                      	sbrc r26, 7 //check if result is negative
002c65 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002c66 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
002c68 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
002c69 e0f0                      	ldi ZH, HIGH(note_table << 1)
002c6a 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002c6b 0fea                      	add ZL, r26 //add offset
002c6c 1df2                      	adc ZH, zero
002c6d 91a5                      	lpm r26, Z+ //load bytes
002c6e 91b4                      	lpm r27, Z
002c6f 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
002c71 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
002c73 93a0 2898                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002c75 93b0 2899                 	sts pulse2_fx_3xx_target+1, r27
002c77 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel1_pitch:
002c78 91e0 287c                 	lds ZL, pulse2_pitch_macro
002c7a 91f0 287d                 	lds ZH, pulse2_pitch_macro+1
002c7c 9630                      	adiw Z, 0
002c7d f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002c7e c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002c7f 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002c80 1fff                      	rol ZH
002c81 91a0 287e                 	lds r26, pulse2_pitch_macro_offset
002c83 0fea                      	add ZL, r26
002c84 1df2                      	adc ZH, zero
                                 
002c85 91b0 2880                 	lds r27, pulse2_pitch_macro_release
002c87 17ba                      	cp r27, r26
002c88 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
002c89 91a0 287f                 	lds r26, pulse2_pitch_macro_loop
002c8b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c8c f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c8d c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002c8e 95a3                      	inc r26 //increment the macro offset
002c8f 93a0 287e                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002c91 91b4                      	lpm r27, Z //load pitch data into r27
002c92 38b0                      	cpi r27, 0x80 //check for macro end flag
002c93 f489                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002c94 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002c95 93a0 287e                 	sts pulse2_pitch_macro_offset, r26
002c97 91b0 2880                 	lds r27, pulse2_pitch_macro_release
002c99 3fbf                      	cpi r27, 0xFF
002c9a f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002c9b 91b0 287f                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002c9d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002c9e f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002c9f 93b0 287e                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002ca1 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002ca2 91b0 287b                 	lds r27, pulse2_total_pitch_offset
002ca4 c005                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002ca5 91a0 287b                 	lds r26, pulse2_total_pitch_offset //load the total pitch offset to change
002ca7 0fba                      	add r27, r26
002ca8 93b0 287b                 	sts pulse2_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
002caa 91a0 28a8                 	lds r26, pulse2_fx_Pxx
002cac 0fba                      	add r27, r26
                                 
002cad 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002cae 937f                      	push r23
002caf 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002cb0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002cb1 0367                      	mulsu r22, r23
002cb2 917f                      	pop r23
002cb3 916f                      	pop r22
                                 
002cb4 9416                      	lsr r1 //shift out the fractional bits
002cb5 9407                      	ror r0
002cb6 9416                      	lsr r1
002cb7 9407                      	ror r0
002cb8 9416                      	lsr r1
002cb9 9407                      	ror r0
002cba 9416                      	lsr r1
002cbb 9407                      	ror r0
002cbc fe13                      	sbrs r1, 3 //check if result was a negative number
002cbd c002                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002cbe efb0                      	ldi r27, 0xF0
002cbf 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002cc0 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002cc2 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002cc4 0da0                      	add r26, r0 //offset the timer values
002cc5 1db1                      	adc r27, r1
                                 	
002cc6 91c0 2890                 	lds r28, pulse2_fx_1xx_total
002cc8 91d0 2891                 	lds r29, pulse2_fx_1xx_total+1
002cca 1bac                      	sub r26, r28
002ccb 0bbd                      	sbc r27, r29
002ccc 91c0 2894                 	lds r28, pulse2_fx_2xx_total
002cce 91d0 2895                 	lds r29, pulse2_fx_2xx_total+1
002cd0 0fac                      	add r26, r28
002cd1 1fbd                      	adc r27, r29
002cd2 91c0 28ad                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002cd4 91d0 28ae                 	lds r29, pulse2_fx_Qxy_total_offset+1
002cd6 1bac                      	sub r26, r28
002cd7 0bbd                      	sbc r27, r29
002cd8 91c0 28b3                 	lds r28, pulse2_fx_Rxy_total_offset
002cda 91d0 28b4                 	lds r29, pulse2_fx_Rxy_total_offset+1
002cdc 0fac                      	add r26, r28
002cdd 1fbd                      	adc r27, r29
                                 
002cde 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002ce0 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002ce2 91e0 2882                 	lds ZL, pulse2_hi_pitch_macro
002ce4 91f0 2883                 	lds ZH, pulse2_hi_pitch_macro+1
002ce6 9630                      	adiw Z, 0
002ce7 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002ce8 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002ce9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002cea 1fff                      	rol ZH
002ceb 91a0 2884                 	lds r26, pulse2_hi_pitch_macro_offset
002ced 0fea                      	add ZL, r26
002cee 1df2                      	adc ZH, zero
                                 
002cef 91b0 2886                 	lds r27, pulse2_hi_pitch_macro_release
002cf1 17ba                      	cp r27, r26
002cf2 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002cf3 91a0 2885                 	lds r26, pulse2_hi_pitch_macro_loop
002cf5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002cf6 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002cf7 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002cf8 95a3                      	inc r26 //increment the macro offset
002cf9 93a0 2884                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002cfb 91b4                      	lpm r27, Z //load hi pitch data into r27
002cfc 38b0                      	cpi r27, 0x80 //check for macro end flag
002cfd f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002cfe 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002cff 93a0 2884                 	sts pulse2_hi_pitch_macro_offset, r26
002d01 91b0 2886                 	lds r27, pulse2_hi_pitch_macro_release
002d03 3fbf                      	cpi r27, 0xFF
002d04 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002d05 91b0 2885                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002d07 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d08 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002d09 93b0 2884                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002d0b cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002d0c 91b0 2881                 	lds r27, pulse2_total_hi_pitch_offset
002d0e c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002d0f 91a0 2881                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002d11 0fba                      	add r27, r26
002d12 93b0 2881                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002d14 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d15 937f                      	push r23
002d16 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002d17 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d18 0367                      	mulsu r22, r23
002d19 917f                      	pop r23
002d1a 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002d1b 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002d1d 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002d1f 0da0                      	add r26, r0 //offset the timer values
002d20 1db1                      	adc r27, r1
002d21 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002d23 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002d25 91e0 2887                 	lds ZL, pulse2_duty_macro
002d27 91f0 2888                 	lds ZH, pulse2_duty_macro+1
002d29 9630                      	adiw Z, 0
002d2a f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002d2b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d2c 1fff                      	rol ZH
002d2d 91a0 2889                 	lds r26, pulse2_duty_macro_offset
002d2f 0fea                      	add ZL, r26
002d30 1df2                      	adc ZH, zero
                                 
002d31 91b0 288b                 	lds r27, pulse2_duty_macro_release
002d33 17ba                      	cp r27, r26
002d34 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002d35 91a0 288a                 	lds r26, pulse2_duty_macro_loop
002d37 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d38 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d39 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002d3a 95a3                      	inc r26 //increment the macro offset
002d3b 93a0 2889                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002d3d 91b4                      	lpm r27, Z //load pitch data into r27
002d3e 3fbf                      	cpi r27, 0xFF //check for macro end flag
002d3f f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002d40 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d41 93a0 2889                 	sts pulse2_duty_macro_offset, r26
002d43 91b0 288b                 	lds r27, pulse2_duty_macro_release
002d45 3fbf                      	cpi r27, 0xFF
002d46 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002d47 91b0 288a                 	lds r27, pulse2_duty_macro_loop //load the loop index
002d49 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d4a f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002d4b 93b0 2889                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002d4d cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002d4e e6ec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002d4f e6f3                      	ldi ZH, HIGH(sequences << 1)
002d50 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002d51 1df2                      	adc ZH, zero
                                 
002d52 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002d53 95b7                      	ror r27
002d54 95b7                      	ror r27
002d55 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002d57 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002d58 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002d59 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002d5a c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002d5b c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002d5c 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002d5d 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002d5e 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002d5f 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002d61 91e0 288e                 	lds ZL, pulse2_fx_1xx
002d63 91f0 288f                 	lds ZH, pulse2_fx_1xx+1
002d65 9630                      	adiw Z, 0
002d66 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002d67 91a0 2890                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002d69 91b0 2891                 	lds r27, pulse2_fx_1xx_total+1
002d6b 0fae                      	add r26, ZL //increase the total offset by the rate
002d6c 1fbf                      	adc r27, ZH
002d6d 93a0 2890                 	sts pulse2_fx_1xx_total, r26
002d6f 93b0 2891                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002d71 91e0 2892                 	lds ZL, pulse2_fx_2xx
002d73 91f0 2893                 	lds ZH, pulse2_fx_2xx+1
002d75 9630                      	adiw Z, 0
002d76 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002d77 91a0 2894                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002d79 91b0 2895                 	lds r27, pulse2_fx_2xx_total+1
002d7b 0fae                      	add r26, ZL //increase the total offset by the rate
002d7c 1fbf                      	adc r27, ZH
002d7d 93a0 2894                 	sts pulse2_fx_2xx_total, r26
002d7f 93b0 2895                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002d81 91e0 289a                 	lds ZL, pulse2_fx_3xx_speed
002d83 91f0 289b                 	lds ZH, pulse2_fx_3xx_speed+1
002d85 9630                      	adiw Z, 0
002d86 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002d87 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002d88 91a0 2896                 	lds r26, pulse2_fx_3xx_start
002d8a 91b0 2897                 	lds r27, pulse2_fx_3xx_start+1
002d8c 9610                      	adiw r26:r27, 0
002d8d f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002d8e c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002d8f 91c0 2898                 	lds r28, pulse2_fx_3xx_target
002d91 91d0 2899                 	lds r29, pulse2_fx_3xx_target+1
                                 
002d93 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002d94 07bd                      	cpc r27, r29
002d95 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002d96 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002d97 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002d98 9220 2896                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002d9a 9220 2897                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002d9c c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002d9d 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002d9e 0bdb                      	sbc r29, r27
002d9f 91a0 289c                 	lds r26, pulse2_fx_3xx_total_offset
002da1 91b0 289d                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002da3 0fae                      	add r26, ZL //add the speed to the total offset
002da4 1fbf                      	adc r27, ZH
002da5 1bca                      	sub r28, r26 //invert the total difference with the total offset
002da6 0bdb                      	sbc r29, r27
002da7 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002da8 93a0 289c                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002daa 93b0 289d                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002dac 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002dae 91b0 0a9d                 	lds r27, TCB1_CCMPH
002db0 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002db1 0bbd                      	sbc r27, r29
002db2 93a0 0a9c                 	sts TCB1_CCMPL, r26
002db4 93b0 0a9d                 	sts TCB1_CCMPH, r27
002db6 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002db7 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002db8 0bbd                      	sbc r27, r29
002db9 91c0 289c                 	lds r28, pulse2_fx_3xx_total_offset
002dbb 91d0 289d                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002dbd 0fce                      	add r28, ZL //add the speed to the total offset
002dbe 1fdf                      	adc r29, ZH
002dbf 1bac                      	sub r26, r28 //invert the total difference with the total offset
002dc0 0bbd                      	sbc r27, r29
002dc1 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002dc2 93c0 289c                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002dc4 93d0 289d                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002dc6 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002dc8 91d0 0a9d                 	lds r29, TCB1_CCMPH
002dca 0fca                      	add r28, r26 //offset the current timer period with the total offset
002dcb 1fdb                      	adc r29, r27
002dcc 93c0 0a9c                 	sts TCB1_CCMPL, r28
002dce 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002dd0 91a0 289e                 	lds r26, pulse2_fx_4xy_speed
002dd2 15a2                      	cp r26, zero
002dd3 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002dd4 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002dd5 91b0 289f                 	lds r27, pulse2_fx_4xy_depth
002dd7 91c0 28a0                 	lds r28, pulse2_fx_4xy_phase
002dd9 0fca                      	add r28, r26 //increase the phase by the speed
002dda 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002ddb f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002ddc 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002ddd 93c0 28a0                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002ddf 31c0                      	cpi r28, 16
002de0 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002de1 32c0                      	cpi r28, 32
002de2 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002de3 33c0                      	cpi r28, 48
002de4 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002de5 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002de6 70cf                      	andi r28, 0x0F //mask for values 0-15
002de7 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002de8 6fc0                      	ori r28, 0xF0
002de9 95c0                      	com r28 //invert values 0-15
002dea c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002deb 70cf                      	andi r28, 0x0F //mask for values 0-15
002dec c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002ded 6fc0                      	ori r28, 0xF0
002dee 95c0                      	com r28 //invert values 0-15
002def c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002df0 95b2                      	swap r27 //multiply depth by 16
002df1 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002df2 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002df3 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002df4 0fec                      	add ZL, r28 //offset the table by the depth+phase
002df5 1df2                      	adc ZH, zero
002df6 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002df7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002df8 937f                      	push r23
002df9 2f6c                      	mov r22, r28 //store the vibrato value into r22
002dfa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002dfb 9f67                      	mul r22, r23
002dfc 917f                      	pop r23
002dfd 916f                      	pop r22
                                 
002dfe 9416                      	lsr r1 //shift out the fractional bits
002dff 9407                      	ror r0
002e00 9416                      	lsr r1
002e01 9407                      	ror r0
002e02 9416                      	lsr r1
002e03 9407                      	ror r0
002e04 9416                      	lsr r1
002e05 9407                      	ror r0
                                 	
002e06 91a0 0a9c                 	lds r26, TCB1_CCMPL
002e08 91b0 0a9d                 	lds r27, TCB1_CCMPH
002e0a 0da0                      	add r26, r0
002e0b 1db1                      	adc r27, r1
002e0c 93a0 0a9c                 	sts TCB1_CCMPL, r26
002e0e 93b0 0a9d                 	sts TCB1_CCMPH, r27
002e10 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002e11 95b2                      	swap r27 //multiply depth by 16
002e12 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002e13 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e14 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e15 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e16 1df2                      	adc ZH, zero
002e17 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002e18 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e19 937f                      	push r23
002e1a 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e1b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e1c 9f67                      	mul r22, r23
002e1d 917f                      	pop r23
002e1e 916f                      	pop r22
                                 
002e1f 9416                      	lsr r1 //shift out the fractional bits
002e20 9407                      	ror r0
002e21 9416                      	lsr r1
002e22 9407                      	ror r0
002e23 9416                      	lsr r1
002e24 9407                      	ror r0
002e25 9416                      	lsr r1
002e26 9407                      	ror r0
                                 
002e27 91a0 0a9c                 	lds r26, TCB1_CCMPL
002e29 91b0 0a9d                 	lds r27, TCB1_CCMPH
002e2b 19a0                      	sub r26, r0
002e2c 09b1                      	sbc r27, r1
002e2d 93a0 0a9c                 	sts TCB1_CCMPL, r26
002e2f 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002e31 91a0 28a1                 	lds r26, pulse2_fx_7xy_speed
002e33 15a2                      	cp r26, zero
002e34 f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002e35 91b0 28a2                 	lds r27, pulse2_fx_7xy_depth
002e37 91c0 28a3                 	lds r28, pulse2_fx_7xy_phase
002e39 0fca                      	add r28, r26 //increase the phase by the speed
002e3a 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002e3b f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002e3c e0c0                      	ldi r28, 0x00
002e3d 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002e3e 93c0 28a3                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002e40 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002e41 ffc4                      	sbrs r28, 4
002e42 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002e43 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002e44 70cf                      	andi r28, 0x0F //mask for values 0-15
002e45 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002e46 6fc0                      	ori r28, 0xF0
002e47 95c0                      	com r28 //invert values 0-15
002e48 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002e49 95b2                      	swap r27 //multiply depth by 16
002e4a 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002e4b e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e4c e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e4d 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e4e 1df2                      	adc ZH, zero
002e4f 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002e50 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002e51 93c0 28a4                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002e53 91b0 28a5                 	lds r27, pulse2_fx_Axy
002e55 15b2                      	cp r27, zero
002e56 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002e57 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002e59 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002e5b 2fda                      	mov r29, r26 //copy fractional volume into r29
002e5c 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002e5d 95e2                      	swap r30
002e5e 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002e5f 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002e60 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002e61 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002e62 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002e63 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002e64 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002e65 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002e66 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002e67 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002e68 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002e69 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002e6a f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002e6b e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002e6c 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002e6e 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002e6f 95a2                      	swap r26
002e70 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002e71 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002e72 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002e74 91e0 28a9                 	lds ZL, pulse2_fx_Qxy_target
002e76 91f0 28aa                 	lds ZH, pulse2_fx_Qxy_target+1
002e78 9630                      	adiw Z, 0
002e79 f199                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002e7a 91a0 28ad                 	lds r26, pulse2_fx_Qxy_total_offset
002e7c 91b0 28ae                 	lds r27, pulse2_fx_Qxy_total_offset+1
002e7e 91c0 0a9c                 	lds r28, TCB1_CCMPL
002e80 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002e82 1bec                      	sub ZL, r28 //calculate the difference to the target
002e83 0bfd                      	sbc ZH, r29
002e84 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002e85 f0e8                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002e86 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002e87 0bbf                      	sbc r27, ZH
                                 
002e88 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e89 937f                      	push r23
002e8a 9160 28a8                 	lds r22, pulse2_fx_Pxx
002e8c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e8d 9f67                      	mul r22, r23
002e8e 917f                      	pop r23
002e8f 916f                      	pop r22
002e90 9416                      	lsr r1 //shift out the fractional bits
002e91 9407                      	ror r0
002e92 9416                      	lsr r1
002e93 9407                      	ror r0
002e94 9416                      	lsr r1
002e95 9407                      	ror r0
002e96 9416                      	lsr r1
002e97 9407                      	ror r0
                                 
002e98 0da0                      	add r26, r0
002e99 1db2                      	adc r27, zero
                                 
002e9a 93a0 28ad                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002e9c 93b0 28ae                 	sts pulse2_fx_Qxy_total_offset+1, r27
002e9e 9220 28a9                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002ea0 9220 28aa                 	sts pulse2_fx_Qxy_target+1, zero
002ea2 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002ea3 91c0 28ab                 	lds r28, pulse2_fx_Qxy_speed
002ea5 91d0 28ac                 	lds r29, pulse2_fx_Qxy_speed+1
002ea7 0fac                      	add r26, r28 //increase the total offset by the speed
002ea8 1fbd                      	adc r27, r29
002ea9 93a0 28ad                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002eab 93b0 28ae                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002ead 91e0 28af                 	lds ZL, pulse2_fx_Rxy_target
002eaf 91f0 28b0                 	lds ZH, pulse2_fx_Rxy_target+1
002eb1 9630                      	adiw Z, 0
002eb2 f199                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002eb3 91a0 28b3                 	lds r26, pulse2_fx_Rxy_total_offset
002eb5 91b0 28b4                 	lds r27, pulse2_fx_Rxy_total_offset+1
002eb7 91c0 0a9c                 	lds r28, TCB1_CCMPL
002eb9 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002ebb 1bce                      	sub r28, ZL //calculate the difference to the target
002ebc 0bdf                      	sbc r29, ZH
002ebd f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002ebe f0e8                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002ebf 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002ec0 0bbd                      	sbc r27, r29
                                 
002ec1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ec2 937f                      	push r23
002ec3 9160 28a8                 	lds r22, pulse2_fx_Pxx
002ec5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ec6 9f67                      	mul r22, r23
002ec7 917f                      	pop r23
002ec8 916f                      	pop r22
002ec9 9416                      	lsr r1 //shift out the fractional bits
002eca 9407                      	ror r0
002ecb 9416                      	lsr r1
002ecc 9407                      	ror r0
002ecd 9416                      	lsr r1
002ece 9407                      	ror r0
002ecf 9416                      	lsr r1
002ed0 9407                      	ror r0
                                 
002ed1 0da0                      	add r26, r0
002ed2 1db2                      	adc r27, zero
                                 
002ed3 93a0 28b3                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002ed5 93b0 28b4                 	sts pulse2_fx_Rxy_total_offset+1, r27
002ed7 9220 28af                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002ed9 9220 28b0                 	sts pulse2_fx_Rxy_target+1, zero
002edb c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002edc 91c0 28b1                 	lds r28, pulse2_fx_Rxy_speed
002ede 91d0 28b2                 	lds r29, pulse2_fx_Rxy_speed+1
002ee0 0fac                      	add r26, r28 //increase the total offset by the speed
002ee1 1fbd                      	adc r27, r29
002ee2 93a0 28b3                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002ee4 93b0 28b4                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002ee6 91e0 28bd                 	lds ZL, triangle_volume_macro
002ee8 91f0 28be                 	lds ZH, triangle_volume_macro+1
002eea 9630                      	adiw Z, 0
002eeb f179                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002eec 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002eed 1fff                      	rol ZH
002eee 91a0 28bf                 	lds r26, triangle_volume_macro_offset
002ef0 0fea                      	add ZL, r26
002ef1 1df2                      	adc ZH, zero
                                 
002ef2 91b0 28c1                 	lds r27, triangle_volume_macro_release
002ef4 17ba                      	cp r27, r26
002ef5 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002ef6 91a0 28c0                 	lds r26, triangle_volume_macro_loop
002ef8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ef9 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002efa c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002efb 95a3                      	inc r26 //increment the macro offset
002efc 93a0 28bf                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002efe 91b4                      	lpm r27, Z //load volume data into r27
002eff 3fbf                      	cpi r27, 0xFF //check for macro end flag
002f00 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002f01 91b0 28c1                 	lds r27, triangle_volume_macro_release
002f03 3fbf                      	cpi r27, 0xFF
002f04 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002f05 91b0 28c0                 	lds r27, triangle_volume_macro_loop //load the loop index
002f07 93b0 28bf                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002f09 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002f0a 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002f0b 93a0 28bf                 	sts triangle_volume_macro_offset, r26
002f0d cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002f0e 15b2                      	cp r27, zero
002f0f f021                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002f10 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002f11 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002f13 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002f14 9220 0aa5                 	sts TCB2_INTCTRL, zero
002f16 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002f18 9220 0aad                 	sts TCB2_CCMPH, zero
002f1a c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002f1b 91e0 28c2                 	lds ZL, triangle_arpeggio_macro
002f1d 91f0 28c3                 	lds ZH, triangle_arpeggio_macro+1
002f1f 9630                      	adiw Z, 0
002f20 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002f21 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f22 1fff                      	rol ZH
002f23 91a0 28c4                 	lds r26, triangle_arpeggio_macro_offset
002f25 0fea                      	add ZL, r26
002f26 1df2                      	adc ZH, zero
                                 
002f27 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
002f29 17ba                      	cp r27, r26
002f2a f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002f2b 91a0 28c5                 	lds r26, triangle_arpeggio_macro_loop
002f2d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f2e f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002f2f c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002f30 95a3                      	inc r26 //increment the macro offset
002f31 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002f33 91b4                      	lpm r27, Z //load arpeggio data into r27
002f34 38b0                      	cpi r27, 0x80 //check for macro end flag
002f35 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002f36 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002f37 50a1                      	subi r26, 1 //keep the offset at the end flag
002f38 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26
002f3a 91b0 28c7                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002f3c 30b1                      	cpi r27, 0x01
002f3d f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002f3e 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
002f40 3fbf                      	cpi r27, 0xFF
002f41 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002f42 91b0 28c5                 	lds r27, triangle_arpeggio_macro_loop
002f44 3fbf                      	cpi r27, 0xFF
002f45 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002f46 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002f47 91b0 28c6                 	lds r27, triangle_arpeggio_macro_release
002f49 3fbf                      	cpi r27, 0xFF
002f4a f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002f4b 91b0 28c5                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002f4d 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002f4e f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002f4f 91c0 28d9                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002f51 91d0 28da                 	lds r29, triangle_fx_0xy_sequence+1
002f53 9620                      	adiw r29:r28, 0
002f54 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002f55 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002f56 93a0 28c4                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002f58 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002f59 93b0 28c4                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002f5b cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002f5c 91c0 28d9                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002f5e 91d0 28da                 	lds r29, triangle_fx_0xy_sequence+1
002f60 9620                      	adiw r29:r28, 0 //check for 0xy effect
002f61 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
002f62 95d6                      	lsr r29
002f63 95c7                      	ror r28
002f64 95d7                      	ror r29
002f65 95c7                      	ror r28
002f66 95d7                      	ror r29
002f67 95c7                      	ror r28
002f68 95d7                      	ror r29
002f69 95c7                      	ror r28
002f6a 95d7                      	ror r29
002f6b 95d2                      	swap r29
                                 
002f6c 93c0 28d9                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002f6e 93d0 28da                 	sts triangle_fx_0xy_sequence+1, r29
002f70 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002f71 91a0 2812                 	lds r26, triangle_note //load the current note index
002f73 0fac                      	add r26, r28 //add the note offset
002f74 c02c                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002f75 91a0 2812                 	lds r26, triangle_note //load the current note index
002f77 c029                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002f78 9220 28c8                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002f7a 9220 28ce                 	sts triangle_total_hi_pitch_offset, zero
002f7c 91a0 28c7                 	lds r26, triangle_arpeggio_macro_mode
002f7e 30a1                      	cpi r26, 0x01 //absolute mode
002f7f f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002f80 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002f81 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002f82 91a0 2812                 	lds r26, triangle_note //load the current note index
002f84 0fab                      	add r26, r27 //offset the note with the arpeggio data
002f85 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002f86 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002f87 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002f88 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002f89 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002f8a c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002f8b fda7                      	sbrc r26, 7 //check if result is negative
002f8c e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002f8d c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002f8e 2fab                      	mov r26, r27 //move the arpeggio data into r26
002f8f c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002f90 91a0 2812                 	lds r26, triangle_note //load the current note index
002f92 0fab                      	add r26, r27 //offset the note with the arpeggio data
002f93 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002f94 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002f95 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002f97 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002f98 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002f99 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002f9a 93a0 2812                 	sts triangle_note, r26
002f9c c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002f9d fda7                      	sbrc r26, 7 //check if result is negative
002f9e e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002f9f 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002fa1 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
002fa2 e0f0                      	ldi ZH, HIGH(note_table << 1)
002fa3 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002fa4 0fea                      	add ZL, r26 //add offset
002fa5 1df2                      	adc ZH, zero
002fa6 91a5                      	lpm r26, Z+ //load bytes
002fa7 91b4                      	lpm r27, Z
002fa8 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002faa 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002fac 93a0 28e5                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002fae 93b0 28e6                 	sts triangle_fx_3xx_target+1, r27
002fb0 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel2_pitch:
002fb1 91e0 28c9                 	lds ZL, triangle_pitch_macro
002fb3 91f0 28ca                 	lds ZH, triangle_pitch_macro+1
002fb5 9630                      	adiw Z, 0
002fb6 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002fb7 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002fb8 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002fb9 1fff                      	rol ZH
002fba 91a0 28cb                 	lds r26, triangle_pitch_macro_offset
002fbc 0fea                      	add ZL, r26
002fbd 1df2                      	adc ZH, zero
                                 
002fbe 91b0 28cd                 	lds r27, triangle_pitch_macro_release
002fc0 17ba                      	cp r27, r26
002fc1 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002fc2 91a0 28cc                 	lds r26, triangle_pitch_macro_loop
002fc4 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002fc5 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002fc6 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002fc7 95a3                      	inc r26 //increment the macro offset
002fc8 93a0 28cb                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002fca 91b4                      	lpm r27, Z //load pitch data into r27
002fcb 38b0                      	cpi r27, 0x80 //check for macro end flag
002fcc f489                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002fcd 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002fce 93a0 28cb                 	sts triangle_pitch_macro_offset, r26
002fd0 91b0 28cd                 	lds r27, triangle_pitch_macro_release
002fd2 3fbf                      	cpi r27, 0xFF
002fd3 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002fd4 91b0 28cc                 	lds r27, triangle_pitch_macro_loop //load the loop index
002fd6 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002fd7 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002fd8 93b0 28cb                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002fda cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002fdb 91b0 28c8                 	lds r27, triangle_total_pitch_offset
002fdd c005                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002fde 91a0 28c8                 	lds r26, triangle_total_pitch_offset //load the total pitch offset to change
002fe0 0fba                      	add r27, r26
002fe1 93b0 28c8                 	sts triangle_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
002fe3 91a0 28f0                 	lds r26, triangle_fx_Pxx
002fe5 0fba                      	add r27, r26
                                 
002fe6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002fe7 937f                      	push r23
002fe8 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002fe9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002fea 0367                      	mulsu r22, r23
002feb 917f                      	pop r23
002fec 916f                      	pop r22
                                 
002fed 9416                      	lsr r1 //shift out the fractional bits
002fee 9407                      	ror r0
002fef 9416                      	lsr r1
002ff0 9407                      	ror r0
002ff1 9416                      	lsr r1
002ff2 9407                      	ror r0
002ff3 9416                      	lsr r1
002ff4 9407                      	ror r0
002ff5 fe13                      	sbrs r1, 3 //check if result was a negative number
002ff6 c002                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002ff7 efb0                      	ldi r27, 0xF0
002ff8 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002ff9 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002ffb 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002ffd 0da0                      	add r26, r0 //offset the timer values
002ffe 1db1                      	adc r27, r1
                                 	
002fff 91c0 28dd                 	lds r28, triangle_fx_1xx_total
003001 91d0 28de                 	lds r29, triangle_fx_1xx_total+1
003003 1bac                      	sub r26, r28
003004 0bbd                      	sbc r27, r29
003005 91c0 28e1                 	lds r28, triangle_fx_2xx_total
003007 91d0 28e2                 	lds r29, triangle_fx_2xx_total+1
003009 0fac                      	add r26, r28
00300a 1fbd                      	adc r27, r29
00300b 91c0 28f5                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00300d 91d0 28f6                 	lds r29, triangle_fx_Qxy_total_offset+1
00300f 1bac                      	sub r26, r28
003010 0bbd                      	sbc r27, r29
003011 91c0 28fb                 	lds r28, triangle_fx_Rxy_total_offset
003013 91d0 28fc                 	lds r29, triangle_fx_Rxy_total_offset+1
003015 0fac                      	add r26, r28
003016 1fbd                      	adc r27, r29
                                 
003017 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
003019 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
00301b 91e0 28cf                 	lds ZL, triangle_hi_pitch_macro
00301d 91f0 28d0                 	lds ZH, triangle_hi_pitch_macro+1
00301f 9630                      	adiw Z, 0
003020 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
003021 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
003022 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003023 1fff                      	rol ZH
003024 91a0 28d1                 	lds r26, triangle_hi_pitch_macro_offset
003026 0fea                      	add ZL, r26
003027 1df2                      	adc ZH, zero
                                 
003028 91b0 28d3                 	lds r27, triangle_hi_pitch_macro_release
00302a 17ba                      	cp r27, r26
00302b f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00302c 91a0 28d2                 	lds r26, triangle_hi_pitch_macro_loop
00302e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00302f f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003030 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
003031 95a3                      	inc r26 //increment the macro offset
003032 93a0 28d1                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
003034 91b4                      	lpm r27, Z //load hi pitch data into r27
003035 38b0                      	cpi r27, 0x80 //check for macro end flag
003036 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
003037 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003038 93a0 28d1                 	sts triangle_hi_pitch_macro_offset, r26
00303a 91b0 28d3                 	lds r27, triangle_hi_pitch_macro_release
00303c 3fbf                      	cpi r27, 0xFF
00303d f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
00303e 91b0 28d2                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
003040 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003041 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
003042 93b0 28d1                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
003044 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
003045 91b0 28ce                 	lds r27, triangle_total_hi_pitch_offset
003047 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
003048 91a0 28ce                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
00304a 0fba                      	add r27, r26
00304b 93b0 28ce                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
00304d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00304e 937f                      	push r23
00304f 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
003050 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003051 0367                      	mulsu r22, r23
003052 917f                      	pop r23
003053 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
003054 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
003056 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
003058 0da0                      	add r26, r0 //offset the timer values
003059 1db1                      	adc r27, r1
00305a 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
00305c 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
00305e 91e0 28db                 	lds ZL, triangle_fx_1xx
003060 91f0 28dc                 	lds ZH, triangle_fx_1xx+1
003062 9630                      	adiw Z, 0
003063 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
003064 91a0 28dd                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
003066 91b0 28de                 	lds r27, triangle_fx_1xx_total+1
003068 0fae                      	add r26, ZL //increase the total offset by the rate
003069 1fbf                      	adc r27, ZH
00306a 93a0 28dd                 	sts triangle_fx_1xx_total, r26
00306c 93b0 28de                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
00306e 91e0 28df                 	lds ZL, triangle_fx_2xx
003070 91f0 28e0                 	lds ZH, triangle_fx_2xx+1
003072 9630                      	adiw Z, 0
003073 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
003074 91a0 28e1                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
003076 91b0 28e2                 	lds r27, triangle_fx_2xx_total+1
003078 0fae                      	add r26, ZL //increase the total offset by the rate
003079 1fbf                      	adc r27, ZH
00307a 93a0 28e1                 	sts triangle_fx_2xx_total, r26
00307c 93b0 28e2                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
00307e 91e0 28e7                 	lds ZL, triangle_fx_3xx_speed
003080 91f0 28e8                 	lds ZH, triangle_fx_3xx_speed+1
003082 9630                      	adiw Z, 0
003083 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
003084 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
003085 91a0 28e3                 	lds r26, triangle_fx_3xx_start
003087 91b0 28e4                 	lds r27, triangle_fx_3xx_start+1
003089 9610                      	adiw r26:r27, 0
00308a f409                      	brne sound_driver_channel2_fx_3xx_routine_main
00308b c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
00308c 91c0 28e5                 	lds r28, triangle_fx_3xx_target
00308e 91d0 28e6                 	lds r29, triangle_fx_3xx_target+1
                                 
003090 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
003091 07bd                      	cpc r27, r29
003092 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
003093 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
003094 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
003095 9220 28e3                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
003097 9220 28e4                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
003099 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
00309a 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
00309b 0bdb                      	sbc r29, r27
00309c 91a0 28e9                 	lds r26, triangle_fx_3xx_total_offset
00309e 91b0 28ea                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
0030a0 0fae                      	add r26, ZL //add the speed to the total offset
0030a1 1fbf                      	adc r27, ZH
0030a2 1bca                      	sub r28, r26 //invert the total difference with the total offset
0030a3 0bdb                      	sbc r29, r27
0030a4 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0030a5 93a0 28e9                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
0030a7 93b0 28ea                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
0030a9 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
0030ab 91b0 0aad                 	lds r27, TCB2_CCMPH
0030ad 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0030ae 0bbd                      	sbc r27, r29
0030af 93a0 0aac                 	sts TCB2_CCMPL, r26
0030b1 93b0 0aad                 	sts TCB2_CCMPH, r27
0030b3 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
0030b4 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0030b5 0bbd                      	sbc r27, r29
0030b6 91c0 28e9                 	lds r28, triangle_fx_3xx_total_offset
0030b8 91d0 28ea                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
0030ba 0fce                      	add r28, ZL //add the speed to the total offset
0030bb 1fdf                      	adc r29, ZH
0030bc 1bac                      	sub r26, r28 //invert the total difference with the total offset
0030bd 0bbd                      	sbc r27, r29
0030be f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0030bf 93c0 28e9                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
0030c1 93d0 28ea                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
0030c3 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
0030c5 91d0 0aad                 	lds r29, TCB2_CCMPH
0030c7 0fca                      	add r28, r26 //offset the current timer period with the total offset
0030c8 1fdb                      	adc r29, r27
0030c9 93c0 0aac                 	sts TCB2_CCMPL, r28
0030cb 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
0030cd 91a0 28eb                 	lds r26, triangle_fx_4xy_speed
0030cf 15a2                      	cp r26, zero
0030d0 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
0030d1 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
0030d2 91b0 28ec                 	lds r27, triangle_fx_4xy_depth
0030d4 91c0 28ed                 	lds r28, triangle_fx_4xy_phase
0030d6 0fca                      	add r28, r26 //increase the phase by the speed
0030d7 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0030d8 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0030d9 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
0030da 93c0 28ed                 	sts triangle_fx_4xy_phase, r28 //store the new phase
0030dc 31c0                      	cpi r28, 16
0030dd f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
0030de 32c0                      	cpi r28, 32
0030df f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
0030e0 33c0                      	cpi r28, 48
0030e1 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
0030e2 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
0030e3 70cf                      	andi r28, 0x0F //mask for values 0-15
0030e4 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
0030e5 6fc0                      	ori r28, 0xF0
0030e6 95c0                      	com r28 //invert values 0-15
0030e7 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
0030e8 70cf                      	andi r28, 0x0F //mask for values 0-15
0030e9 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
0030ea 6fc0                      	ori r28, 0xF0
0030eb 95c0                      	com r28 //invert values 0-15
0030ec c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
0030ed 95b2                      	swap r27 //multiply depth by 16
0030ee 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0030ef e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0030f0 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0030f1 0fec                      	add ZL, r28 //offset the table by the depth+phase
0030f2 1df2                      	adc ZH, zero
0030f3 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0030f4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0030f5 937f                      	push r23
0030f6 2f6c                      	mov r22, r28 //store the vibrato value into r22
0030f7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0030f8 9f67                      	mul r22, r23
0030f9 917f                      	pop r23
0030fa 916f                      	pop r22
                                 
0030fb 9416                      	lsr r1 //shift out the fractional bits
0030fc 9407                      	ror r0
0030fd 9416                      	lsr r1
0030fe 9407                      	ror r0
0030ff 9416                      	lsr r1
003100 9407                      	ror r0
003101 9416                      	lsr r1
003102 9407                      	ror r0
                                 	
003103 91a0 0aac                 	lds r26, TCB2_CCMPL
003105 91b0 0aad                 	lds r27, TCB2_CCMPH
003107 0da0                      	add r26, r0
003108 1db1                      	adc r27, r1
003109 93a0 0aac                 	sts TCB2_CCMPL, r26
00310b 93b0 0aad                 	sts TCB2_CCMPH, r27
00310d c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
00310e 95b2                      	swap r27 //multiply depth by 16
00310f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
003110 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003111 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003112 0fec                      	add ZL, r28 //offset the table by the depth+phase
003113 1df2                      	adc ZH, zero
003114 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003115 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003116 937f                      	push r23
003117 2f6c                      	mov r22, r28 //store the vibrato value into r22
003118 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003119 9f67                      	mul r22, r23
00311a 917f                      	pop r23
00311b 916f                      	pop r22
                                 
00311c 9416                      	lsr r1 //shift out the fractional bits
00311d 9407                      	ror r0
00311e 9416                      	lsr r1
00311f 9407                      	ror r0
003120 9416                      	lsr r1
003121 9407                      	ror r0
003122 9416                      	lsr r1
003123 9407                      	ror r0
                                 
003124 91a0 0aac                 	lds r26, TCB2_CCMPL
003126 91b0 0aad                 	lds r27, TCB2_CCMPH
003128 19a0                      	sub r26, r0
003129 09b1                      	sbc r27, r1
00312a 93a0 0aac                 	sts TCB2_CCMPL, r26
00312c 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
00312e 91e0 28f1                 	lds ZL, triangle_fx_Qxy_target
003130 91f0 28f2                 	lds ZH, triangle_fx_Qxy_target+1
003132 9630                      	adiw Z, 0
003133 f199                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
003134 91a0 28f5                 	lds r26, triangle_fx_Qxy_total_offset
003136 91b0 28f6                 	lds r27, triangle_fx_Qxy_total_offset+1
003138 91c0 0aac                 	lds r28, TCB2_CCMPL
00313a 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
00313c 1bec                      	sub ZL, r28 //calculate the difference to the target
00313d 0bfd                      	sbc ZH, r29
00313e f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
00313f f0e8                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
003140 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
003141 0bbf                      	sbc r27, ZH
                                 
003142 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003143 937f                      	push r23
003144 9160 28f0                 	lds r22, triangle_fx_Pxx
003146 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003147 9f67                      	mul r22, r23
003148 917f                      	pop r23
003149 916f                      	pop r22
00314a 9416                      	lsr r1 //shift out the fractional bits
00314b 9407                      	ror r0
00314c 9416                      	lsr r1
00314d 9407                      	ror r0
00314e 9416                      	lsr r1
00314f 9407                      	ror r0
003150 9416                      	lsr r1
003151 9407                      	ror r0
                                 
003152 0da0                      	add r26, r0
003153 1db2                      	adc r27, zero
                                 
003154 93a0 28f5                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
003156 93b0 28f6                 	sts triangle_fx_Qxy_total_offset+1, r27
003158 9220 28f1                 	sts triangle_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
00315a 9220 28f2                 	sts triangle_fx_Qxy_target+1, zero
00315c c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
00315d 91c0 28f3                 	lds r28, triangle_fx_Qxy_speed
00315f 91d0 28f4                 	lds r29, triangle_fx_Qxy_speed+1
003161 0fac                      	add r26, r28 //increase the total offset by the speed
003162 1fbd                      	adc r27, r29
003163 93a0 28f5                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
003165 93b0 28f6                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
003167 91e0 28f7                 	lds ZL, triangle_fx_Rxy_target
003169 91f0 28f8                 	lds ZH, triangle_fx_Rxy_target+1
00316b 9630                      	adiw Z, 0
00316c f199                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
00316d 91a0 28fb                 	lds r26, triangle_fx_Rxy_total_offset
00316f 91b0 28fc                 	lds r27, triangle_fx_Rxy_total_offset+1
003171 91c0 0aac                 	lds r28, TCB2_CCMPL
003173 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
003175 1bce                      	sub r28, ZL //calculate the difference to the target
003176 0bdf                      	sbc r29, ZH
003177 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
003178 f0e8                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
003179 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
00317a 0bbd                      	sbc r27, r29
                                 
00317b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00317c 937f                      	push r23
00317d 9160 28f0                 	lds r22, triangle_fx_Pxx
00317f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003180 9f67                      	mul r22, r23
003181 917f                      	pop r23
003182 916f                      	pop r22
003183 9416                      	lsr r1 //shift out the fractional bits
003184 9407                      	ror r0
003185 9416                      	lsr r1
003186 9407                      	ror r0
003187 9416                      	lsr r1
003188 9407                      	ror r0
003189 9416                      	lsr r1
00318a 9407                      	ror r0
                                 
00318b 0da0                      	add r26, r0
00318c 1db2                      	adc r27, zero
                                 
00318d 93a0 28fb                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
00318f 93b0 28fc                 	sts triangle_fx_Rxy_total_offset+1, r27
003191 9220 28f7                 	sts triangle_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
003193 9220 28f8                 	sts triangle_fx_Rxy_target+1, zero
003195 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
003196 91c0 28f9                 	lds r28, triangle_fx_Rxy_speed
003198 91d0 28fa                 	lds r29, triangle_fx_Rxy_speed+1
00319a 0fac                      	add r26, r28 //increase the total offset by the speed
00319b 1fbd                      	adc r27, r29
00319c 93a0 28fb                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
00319e 93b0 28fc                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
                                 
                                 sound_driver_exit:
0031a0 91ff                      	pop r31
0031a1 91ef                      	pop r30
0031a2 91df                      	pop r29
0031a3 91cf                      	pop r28
0031a4 940c 1d54                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
0031a6 7f05
0031a7 010a
0031a8 0214
0031a9 0328
0031aa 0450
0031ab 051e
0031ac 0607
0031ad 070d
0031ae 0806
0031af 090c
0031b0 0a18
0031b1 0b30
0031b2 0c60
0031b3 0d24
0031b4 0e08
0031b5 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
0031b6 0301
0031b7 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
0031b8 1f3c
0031b9 1f41
0031ba 1f5d
0031bb 1f79
0031bc 1f9c                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
0031bd 1fa7
0031be 1fb4
0031bf 1fb7
0031c0 1fba
0031c1 1fbd                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
0031c2 1fc0
0031c3 1fc8
0031c4 1fcb
0031c5 1fd8
0031c6 1fd9                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
0031c7 1fda
0031c8 1fdb
0031c9 1fdc
0031ca 1fdf
0031cb 2023                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
0031cc 2066
0031cd 2073
0031ce 2087
0031cf 2088
0031d0 2089                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
0031d1 208a                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
0031d2 2208
0031d3 220d
0031d4 2229
0031d5 2245
0031d6 2268                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
0031d7 2273
0031d8 2280
0031d9 2283
0031da 2286
0031db 2289                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
0031dc 228c
0031dd 2294
0031de 2297
0031df 22a4
0031e0 22a5                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
0031e1 22a6
0031e2 22a7
0031e3 22a8
0031e4 22ab
0031e5 22ef                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
0031e6 2332
0031e7 233f
0031e8 2353
0031e9 2354
0031ea 2355                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
0031eb 2356                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
0031ec 24d0
0031ed 24d5
0031ee 24f1
0031ef 250d
0031f0 2530                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
0031f1 253b
0031f2 253c
0031f3 253d
0031f4 2540
0031f5 2543                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
0031f6 2546
0031f7 2553
0031f8 2556
0031f9 2563
0031fa 2564                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
0031fb 2565
0031fc 2566
0031fd 2567
0031fe 256a
0031ff 25ae                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
003200 25f1
003201 25fe
003202 25ff
003203 2600
003204 2601                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
003205 2602                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
003206 0000
003207 0000
003208 0000
003209 0000
00320a 0000
00320b 0000
00320c 0000
00320d 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
00320e 0100
00320f 0101
003210 0101
003211 0101
003212 0101
003213 0101
003214 0101
003215 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
003216 0100
003217 0101
003218 0101
003219 0101
00321a 0101
00321b 0101
00321c 0101
00321d 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
00321e 0100
00321f 0101
003220 0101
003221 0101
003222 0101
003223 0202
003224 0202
003225 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
003226 0100
003227 0101
003228 0101
003229 0101
00322a 0202
00322b 0202
00322c 0303
00322d 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
00322e 0100
00322f 0101
003230 0101
003231 0202
003232 0302
003233 0303
003234 0404
003235 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
003236 0100
003237 0101
003238 0201
003239 0202
00323a 0303
00323b 0404
00323c 0504
00323d 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
00323e 0100
00323f 0101
003240 0201
003241 0302
003242 0403
003243 0504
003244 0605
003245 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
003246 0100
003247 0101
003248 0202
003249 0303
00324a 0404
00324b 0505
00324c 0606
00324d 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
00324e 0100
00324f 0101
003250 0302
003251 0403
003252 0504
003253 0606
003254 0707
003255 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
003256 0100
003257 0201
003258 0302
003259 0404
00325a 0605
00325b 0706
00325c 0808
00325d 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
00325e 0100
00325f 0201
003260 0302
003261 0504
003262 0605
003263 0807
003264 0908
003265 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
003266 0100
003267 0201
003268 0403
003269 0504
00326a 0706
00326b 0808
00326c 0a09
00326d 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
00326e 0100
00326f 0201
003270 0403
003271 0605
003272 0706
003273 0908
003274 0b0a
003275 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
003276 0100
003277 0201
003278 0403
003279 0605
00327a 0807
00327b 0a09
00327c 0c0b
00327d 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
00327e 0100
00327f 0302
003280 0504
003281 0706
003282 0908
003283 0b0a
003284 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 187 r0 : 153 r1 : 153 r2 : 520 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   0 r22: 132 r23: 132 r24:   0 r25:  24 r26: 729 r27: 880 r28: 517 
r29: 275 r30: 289 r31: 261 
Registers used: 24 out of 35 (68.6%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 107 add   : 147 adiw  :  80 and   :   0 
andi  :  71 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   5 brcs  :   9 break :   0 breq  : 127 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  60 brlt  :   0 brmi  :   0 
brne  :  91 brpl  :   0 brsh  :  24 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   4 
clc   :   0 clh   :   0 cli   :   7 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  13 cp    :  76 cpc   :   8 
cpi   : 125 cpse  :  17 dec   :  29 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   3 in    :   6 inc   :  36 
jmp   :   9 ld    :   0 ldd   :   0 ldi   : 225 lds   : 539 lpm   : 197 
lsl   :  58 lsr   : 136 mov   : 102 movw  :   0 mul   :  27 muls  :   0 
mulsu :   6 neg   :   0 nop   :   0 or    :  14 ori   :   8 out   :   8 
pop   :  96 push  :  90 rcall :  39 ret   :  28 reti  :   6 rjmp  : 388 
rol   :  38 ror   : 154 sbc   :  36 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  10 sbrc  :  21 sbrs  :  13 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1035 sub   :  49 subi  :  39 swap  :  35 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00650c  11936  13860  25796   49152  52.5%
[.dseg] 0x002800 0x002901      0    257    257    6144   4.2%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 87 warnings
