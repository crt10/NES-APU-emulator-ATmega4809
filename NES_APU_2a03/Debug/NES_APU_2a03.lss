
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Sat Jan 23 21:02:47 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
                                 
002818                           song_frames: .byte 2
00281a                           song_frame_offset: .byte 2
00281c                           song_size: .byte 2
00281e                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281f                           song_fx_Bxx: .byte 1
002820                           song_fx_Cxx: .byte 1
002821                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002822                           pulse1_pattern: .byte 2
002824                           pulse1_pattern_delay_rows: .byte 1
002825                           pulse1_pattern_delay_frames: .byte 1
002826                           pulse1_pattern_offset: .byte 2
                                 
002828                           pulse1_volume_macro: .byte 2
00282a                           pulse1_volume_macro_offset: .byte 1
00282b                           pulse1_volume_macro_loop: .byte 1
00282c                           pulse1_volume_macro_release: .byte 1
                                 
00282d                           pulse1_arpeggio_macro: .byte 2
00282f                           pulse1_arpeggio_macro_offset: .byte 1
002830                           pulse1_arpeggio_macro_loop: .byte 1
002831                           pulse1_arpeggio_macro_release: .byte 1
002832                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002833                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002835                           pulse1_pitch_macro: .byte 2
002837                           pulse1_pitch_macro_offset: .byte 1
002838                           pulse1_pitch_macro_loop: .byte 1
002839                           pulse1_pitch_macro_release: .byte 1
                                 
00283a                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283b                           pulse1_hi_pitch_macro: .byte 2
00283d                           pulse1_hi_pitch_macro_offset: .byte 1
00283e                           pulse1_hi_pitch_macro_loop: .byte 1
00283f                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002840                           pulse1_duty_macro: .byte 2
002842                           pulse1_duty_macro_offset: .byte 1
002843                           pulse1_duty_macro_loop: .byte 1
002844                           pulse1_duty_macro_release: .byte 1
                                 
002845                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002847                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002849                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284b                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284d                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00284f                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002851                           pulse1_fx_3xx_target: .byte 2 //target note period
002853                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002855                           pulse1_fx_3xx_total_offset: .byte 2
002857                           pulse1_fx_4xy_speed: .byte 1
002858                           pulse1_fx_4xy_depth: .byte 1
002859                           pulse1_fx_4xy_phase: .byte 1
00285a                           pulse1_fx_7xy_speed: .byte 1
00285b                           pulse1_fx_7xy_depth: .byte 1
00285c                           pulse1_fx_7xy_phase: .byte 1
00285d                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285e                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00285f                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002860                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002861                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002863                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002864                           pulse1_fx_Qxy_target: .byte 2 //target note period
002866                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002868                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286a                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286b                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286d                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00286f                           pulse1_fx_Rxy_total_offset: .byte 2
002871                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002872                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002873                           pulse2_pattern: .byte 2
002875                           pulse2_pattern_delay_rows: .byte 1
002876                           pulse2_pattern_delay_frames: .byte 1
002877                           pulse2_pattern_offset: .byte 2
                                 
002879                           pulse2_volume_macro: .byte 2
00287b                           pulse2_volume_macro_offset: .byte 1
00287c                           pulse2_volume_macro_loop: .byte 1
00287d                           pulse2_volume_macro_release: .byte 1
                                 
00287e                           pulse2_arpeggio_macro: .byte 2
002880                           pulse2_arpeggio_macro_offset: .byte 1
002881                           pulse2_arpeggio_macro_loop: .byte 1
002882                           pulse2_arpeggio_macro_release: .byte 1
002883                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002884                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002886                           pulse2_pitch_macro: .byte 2
002888                           pulse2_pitch_macro_offset: .byte 1
002889                           pulse2_pitch_macro_loop: .byte 1
00288a                           pulse2_pitch_macro_release: .byte 1
                                 
00288b                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288c                           pulse2_hi_pitch_macro: .byte 2
00288e                           pulse2_hi_pitch_macro_offset: .byte 1
00288f                           pulse2_hi_pitch_macro_loop: .byte 1
002890                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002891                           pulse2_duty_macro: .byte 2
002893                           pulse2_duty_macro_offset: .byte 1
002894                           pulse2_duty_macro_loop: .byte 1
002895                           pulse2_duty_macro_release: .byte 1
                                 
002896                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002898                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289a                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289c                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289e                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a0                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a2                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a4                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a6                           pulse2_fx_3xx_total_offset: .byte 2
0028a8                           pulse2_fx_4xy_speed: .byte 1
0028a9                           pulse2_fx_4xy_depth: .byte 1
0028aa                           pulse2_fx_4xy_phase: .byte 1
0028ab                           pulse2_fx_7xy_speed: .byte 1
0028ac                           pulse2_fx_7xy_depth: .byte 1
0028ad                           pulse2_fx_7xy_phase: .byte 1
0028ae                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028af                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b0                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b1                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b2                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b4                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b5                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b7                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028b9                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028bb                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bc                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028be                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c0                           pulse2_fx_Rxy_total_offset: .byte 2
0028c2                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c3                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c4                           triangle_pattern: .byte 2
0028c6                           triangle_pattern_delay_rows: .byte 1
0028c7                           triangle_pattern_delay_frames: .byte 1
0028c8                           triangle_pattern_offset: .byte 2
                                 
0028ca                           triangle_volume_macro: .byte 2
0028cc                           triangle_volume_macro_offset: .byte 1
0028cd                           triangle_volume_macro_loop: .byte 1
0028ce                           triangle_volume_macro_release: .byte 1
                                 
0028cf                           triangle_arpeggio_macro: .byte 2
0028d1                           triangle_arpeggio_macro_offset: .byte 1
0028d2                           triangle_arpeggio_macro_loop: .byte 1
0028d3                           triangle_arpeggio_macro_release: .byte 1
0028d4                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d5                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d7                           triangle_pitch_macro: .byte 2
0028d9                           triangle_pitch_macro_offset: .byte 1
0028da                           triangle_pitch_macro_loop: .byte 1
0028db                           triangle_pitch_macro_release: .byte 1
                                 
0028dc                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028dd                           triangle_hi_pitch_macro: .byte 2
0028df                           triangle_hi_pitch_macro_offset: .byte 1
0028e0                           triangle_hi_pitch_macro_loop: .byte 1
0028e1                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e2                           triangle_duty_macro: .byte 2
0028e4                           triangle_duty_macro_offset: .byte 1
0028e5                           triangle_duty_macro_loop: .byte 1
0028e6                           triangle_duty_macro_release: .byte 1
                                 
0028e7                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028e9                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028eb                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028ed                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028ef                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f1                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f3                           triangle_fx_3xx_target: .byte 2 //target note period
0028f5                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f7                           triangle_fx_3xx_total_offset: .byte 2
0028f9                           triangle_fx_4xy_speed: .byte 1
0028fa                           triangle_fx_4xy_depth: .byte 1
0028fb                           triangle_fx_4xy_phase: .byte 1
0028fc                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028fd                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028fe                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002900                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002901                           triangle_fx_Qxy_target: .byte 2 //target note period
002903                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002905                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002907                           triangle_fx_Rxy_target_note: .byte 1 //target note index
002908                           triangle_fx_Rxy_target: .byte 2 //target note period
00290a                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290c                           triangle_fx_Rxy_total_offset: .byte 2
00290e                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
00290f                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002910                           noise_pattern: .byte 2
002912                           noise_pattern_delay_rows: .byte 1
002913                           noise_pattern_delay_frames: .byte 1
002914                           noise_pattern_offset: .byte 2
                                 
002916                           noise_volume_macro: .byte 2
002918                           noise_volume_macro_offset: .byte 1
002919                           noise_volume_macro_loop: .byte 1
00291a                           noise_volume_macro_release: .byte 1
                                 
00291b                           noise_arpeggio_macro: .byte 2
00291d                           noise_arpeggio_macro_offset: .byte 1
00291e                           noise_arpeggio_macro_loop: .byte 1
00291f                           noise_arpeggio_macro_release: .byte 1
002920                           noise_arpeggio_macro_mode: .byte 1
                                 
002921                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002923                           noise_pitch_macro: .byte 2
002925                           noise_pitch_macro_offset: .byte 1
002926                           noise_pitch_macro_loop: .byte 1
002927                           noise_pitch_macro_release: .byte 1
                                 
002928                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002929                           noise_hi_pitch_macro: .byte 2
00292b                           noise_hi_pitch_macro_offset: .byte 1
00292c                           noise_hi_pitch_macro_loop: .byte 1
00292d                           noise_hi_pitch_macro_release: .byte 1
                                 
00292e                           noise_duty_macro: .byte 2
002930                           noise_duty_macro_offset: .byte 1
002931                           noise_duty_macro_loop: .byte 1
002932                           noise_duty_macro_release: .byte 1
                                 
002933                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002935                           noise_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002937                           noise_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002939                           noise_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00293b                           noise_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00293d                           noise_fx_3xx_start: .byte 2 //the starting note period
00293f                           noise_fx_3xx_target: .byte 2 //target note period
002941                           noise_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002943                           noise_fx_3xx_total_offset: .byte 2
002945                           noise_fx_4xy_speed: .byte 1
002946                           noise_fx_4xy_depth: .byte 1
002947                           noise_fx_4xy_phase: .byte 1
002948                           noise_fx_7xy_speed: .byte 1
002949                           noise_fx_7xy_depth: .byte 1
00294a                           noise_fx_7xy_phase: .byte 1
00294b                           noise_fx_7xy_value: .byte 1 //value to offset the volume
00294c                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00294d                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00294e                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00294f                           noise_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002951                           noise_fx_Qxy_target_note: .byte 1 //target note index
002952                           noise_fx_Qxy_target: .byte 2 //target note period
002954                           noise_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002956                           noise_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002958                           noise_fx_Rxy_target_note: .byte 1 //target note index
002959                           noise_fx_Rxy_target: .byte 2 //target note period
00295b                           noise_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00295d                           noise_fx_Rxy_total_offset: .byte 2
00295f                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002960                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002961                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 0ec3                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 137e                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1285                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1290                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1285                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 12a7                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 12f4                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 1341                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 134c                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(216): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(218): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(219): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(220): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(221): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(223): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(226): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(227): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(231): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(233): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(234): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(235): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(237): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(240): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(246): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(247): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(249): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(250): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(251): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(258): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(259): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(269): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(270): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(356): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
000ec3 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
000ec4 93c0 0034                 	sts CPU_CCP, r28
000ec6 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
000ec7 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
000ec9 2422                      	clr zero
                                 
                                 	//MEMORY
000eca e3c0                      	ldi r28, 0b00110000
000ecb 93c0 2800                 	sts pulse1_param, r28
000ecd e8c0                      	ldi r28, 0b10000000
000ece 93c0 2801                 	sts pulse1_sweep_param, r28
000ed0 efcf                      	ldi r28, 0xFF
000ed1 93c0 2802                 	sts pulse1_timerL, r28
000ed3 93c0 2803                 	sts pulse1_timerH, r28
000ed5 93c0 2804                 	sts pulse1_length, r28
                                 
000ed7 e3c0                      	ldi r28, 0b00110000
000ed8 93c0 2808                 	sts pulse2_param, r28
000eda e8c0                      	ldi r28, 0b10000000
000edb 93c0 2809                 	sts pulse2_sweep_param, r28
000edd efcf                      	ldi r28, 0xFF
000ede 93c0 280a                 	sts pulse2_timerL, r28
000ee0 93c0 280b                 	sts pulse2_timerH, r28
000ee2 93c0 280c                 	sts pulse2_length, r28
                                 
000ee4 efcf                      	ldi r28, 0xFF
000ee5 93c0 2810                 	sts triangle_timerL, r28
000ee7 93c0 2811                 	sts triangle_timerH, r28
                                 
000ee9 e3c0                      	ldi r28, 0b00110000
000eea 93c0 2813                 	sts noise_param, r28
000eec e0cf                      	ldi r28, 0b00001111
000eed 93c0 2814                 	sts noise_period, r28
                                 
000eef e0c2                      	ldi r28, 0x02
000ef0 93c0 281a                 	sts song_frame_offset, r28
000ef2 9220 281b                 	sts song_frame_offset+1, zero
000ef4 efcf                      	ldi r28, 0xFF
000ef5 93c0 281f                 	sts song_fx_Bxx, r28
000ef7 9220 2820                 	sts song_fx_Cxx, zero
000ef9 9220 2821                 	sts song_fx_Dxx, zero
000efb e4ee                      	ldi ZL, LOW(song0_frames << 1)
000efc e0f3                      	ldi ZH, HIGH(song0_frames << 1)
000efd 93e0 2818                 	sts song_frames, ZL
000eff 93f0 2819                 	sts song_frames+1, ZH
000f01 91c5                      	lpm r28, Z+ //load the song size
000f02 91d5                      	lpm r29, Z+
000f03 93c0 281c                 	sts song_size, r28
000f05 93d0 281d                 	sts song_size+1, r29
000f07 9220 281e                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
000f09 91c5                      	lpm r28, Z+
000f0a 91d5                      	lpm r29, Z+
000f0b 0fcc                      	lsl r28
000f0c 1fdd                      	rol r29
000f0d 93c0 2822                 	sts pulse1_pattern, r28
000f0f 93d0 2823                 	sts pulse1_pattern+1, r29
000f11 9220 2824                 	sts pulse1_pattern_delay_rows, zero
000f13 9220 2825                 	sts pulse1_pattern_delay_frames, zero
000f15 9220 2826                 	sts pulse1_pattern_offset, zero
000f17 9220 2827                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
000f19 91c5                      	lpm r28, Z+
000f1a 91d5                      	lpm r29, Z+
000f1b 0fcc                      	lsl r28
000f1c 1fdd                      	rol r29
000f1d 93c0 2873                 	sts pulse2_pattern, r28
000f1f 93d0 2874                 	sts pulse2_pattern+1, r29
000f21 9220 2875                 	sts pulse2_pattern_delay_rows, zero
000f23 9220 2876                 	sts pulse2_pattern_delay_frames, zero
000f25 9220 2877                 	sts pulse2_pattern_offset, zero
000f27 9220 2878                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
000f29 91c5                      	lpm r28, Z+
000f2a 91d5                      	lpm r29, Z+
000f2b 0fcc                      	lsl r28
000f2c 1fdd                      	rol r29
000f2d 93c0 28c4                 	sts triangle_pattern, r28
000f2f 93d0 28c5                 	sts triangle_pattern+1, r29
000f31 9220 28c6                 	sts triangle_pattern_delay_rows, zero
000f33 9220 28c7                 	sts triangle_pattern_delay_frames, zero
000f35 9220 28c8                 	sts triangle_pattern_offset, zero
000f37 9220 28c9                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
000f39 91c5                      	lpm r28, Z+
000f3a 91d5                      	lpm r29, Z+
000f3b 0fcc                      	lsl r28
000f3c 1fdd                      	rol r29
000f3d 93c0 2910                 	sts noise_pattern, r28
000f3f 93d0 2911                 	sts noise_pattern+1, r29
000f41 9220 2912                 	sts noise_pattern_delay_rows, zero
000f43 9220 2913                 	sts noise_pattern_delay_frames, zero
000f45 9220 2914                 	sts noise_pattern_offset, zero
000f47 9220 2915                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
000f49 efcf                      	ldi r28, 0xFF
000f4a 9220 282a                 	sts pulse1_volume_macro_offset, zero
000f4c 93c0 282b                 	sts pulse1_volume_macro_loop, r28
000f4e 93c0 282c                 	sts pulse1_volume_macro_release, r28
000f50 9220 282f                 	sts pulse1_arpeggio_macro_offset, zero
000f52 93c0 2830                 	sts pulse1_arpeggio_macro_loop, r28
000f54 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
000f56 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
000f58 9220 2837                 	sts pulse1_pitch_macro_offset, zero
000f5a 93c0 2838                 	sts pulse1_pitch_macro_loop, r28
000f5c 93c0 2839                 	sts pulse1_pitch_macro_release, r28
000f5e 9220 283d                 	sts pulse1_hi_pitch_macro_offset, zero
000f60 93c0 283e                 	sts pulse1_hi_pitch_macro_loop, r28
000f62 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
000f64 9220 2842                 	sts pulse1_duty_macro_offset, zero
000f66 93c0 2843                 	sts pulse1_duty_macro_loop, r28
000f68 93c0 2844                 	sts pulse1_duty_macro_release, r28
                                 
000f6a 9220 2828                 	sts pulse1_volume_macro, zero
000f6c 9220 2829                 	sts pulse1_volume_macro+1, zero
000f6e 9220 282d                 	sts pulse1_arpeggio_macro, zero
000f70 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
000f72 9220 2833                 	sts pulse1_total_pitch_offset, zero
000f74 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
000f76 9220 2835                 	sts pulse1_pitch_macro, zero
000f78 9220 2836                 	sts pulse1_pitch_macro+1, zero
000f7a 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
000f7c 9220 283b                 	sts pulse1_hi_pitch_macro, zero
000f7e 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
000f80 9220 2840                 	sts pulse1_duty_macro, zero
000f82 9220 2841                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
000f84 e00f                      	ldi pulse1_volume_divider, 0x0F
000f85 9110 2800                 	lds pulse1_volume_decay, pulse1_param
000f87 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
000f88 9190 2800                 	lds pulse_channel_flags, pulse1_param
000f8a 7390                      	andi pulse_channel_flags, 0b00110000
000f8b 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
000f8c 9220 2806                 	sts pulse1_output_volume, zero
000f8e 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
000f90 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
000f91 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
000f92 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
000f93 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
000f95 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
000f96 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
000f97 efcf                      	ldi r28, 0xFF
000f98 9220 2845                 	sts pulse1_fx_0xy_sequence, zero
000f9a 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
000f9c 9220 2847                 	sts pulse1_fx_1xx, zero
000f9e 9220 2848                 	sts pulse1_fx_1xx+1, zero
000fa0 9220 2849                 	sts pulse1_fx_1xx_total, zero
000fa2 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
000fa4 9220 284b                 	sts pulse1_fx_2xx, zero
000fa6 9220 284c                 	sts pulse1_fx_2xx+1, zero
000fa8 9220 284d                 	sts pulse1_fx_2xx_total, zero
000faa 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
000fac 9220 284f                 	sts pulse1_fx_3xx_start, zero
000fae 9220 2850                 	sts pulse1_fx_3xx_start+1, zero
000fb0 9220 2851                 	sts pulse1_fx_3xx_target, zero
000fb2 9220 2852                 	sts pulse1_fx_3xx_target+1, zero
000fb4 9220 2853                 	sts pulse1_fx_3xx_speed, zero
000fb6 9220 2854                 	sts pulse1_fx_3xx_speed+1, zero
000fb8 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
000fba 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
000fbc 9220 2857                 	sts pulse1_fx_4xy_speed, zero
000fbe 9220 2858                 	sts pulse1_fx_4xy_depth, zero
000fc0 9220 2859                 	sts pulse1_fx_4xy_phase, zero
000fc2 9220 285a                 	sts pulse1_fx_7xy_speed, zero
000fc4 9220 285b                 	sts pulse1_fx_7xy_depth, zero
000fc6 9220 285c                 	sts pulse1_fx_7xy_phase, zero
000fc8 9220 285d                 	sts pulse1_fx_7xy_value, zero
000fca 9220 285e                 	sts pulse1_fx_Axy, zero
000fcc 93c0 285f                 	sts pulse1_fx_Gxx_pre, r28
000fce 93c0 2860                 	sts pulse1_fx_Gxx_post, r28
000fd0 9220 2861                 	sts pulse1_fx_Pxx_total, zero
000fd2 9220 2862                 	sts pulse1_fx_Pxx_total+1, zero
000fd4 9220 2863                 	sts pulse1_fx_Qxy_target_note, zero
000fd6 9220 2864                 	sts pulse1_fx_Qxy_target, zero
000fd8 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
000fda 9220 2866                 	sts pulse1_fx_Qxy_speed, zero
000fdc 9220 2867                 	sts pulse1_fx_Qxy_speed+1, zero
000fde 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero
000fe0 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
000fe2 9220 286a                 	sts pulse1_fx_Rxy_target_note, zero
000fe4 9220 286b                 	sts pulse1_fx_Rxy_target, zero
000fe6 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
000fe8 9220 286d                 	sts pulse1_fx_Rxy_speed, zero
000fea 9220 286e                 	sts pulse1_fx_Rxy_speed+1, zero
000fec 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero
000fee 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
000ff0 93c0 2871                 	sts pulse1_fx_Sxx_pre, r28
000ff2 93c0 2872                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
000ff4 efcf                      	ldi r28, 0xFF
000ff5 9220 287b                 	sts pulse2_volume_macro_offset, zero
000ff7 93c0 287c                 	sts pulse2_volume_macro_loop, r28
000ff9 93c0 287d                 	sts pulse2_volume_macro_release, r28
000ffb 9220 2880                 	sts pulse2_arpeggio_macro_offset, zero
000ffd 93c0 2881                 	sts pulse2_arpeggio_macro_loop, r28
000fff 93c0 2882                 	sts pulse2_arpeggio_macro_release, r28
001001 93c0 2883                 	sts pulse2_arpeggio_macro_mode, r28
001003 9220 2888                 	sts pulse2_pitch_macro_offset, zero
001005 93c0 2889                 	sts pulse2_pitch_macro_loop, r28
001007 93c0 288a                 	sts pulse2_pitch_macro_release, r28
001009 9220 288e                 	sts pulse2_hi_pitch_macro_offset, zero
00100b 93c0 288f                 	sts pulse2_hi_pitch_macro_loop, r28
00100d 93c0 2890                 	sts pulse2_hi_pitch_macro_release, r28
00100f 9220 2893                 	sts pulse2_duty_macro_offset, zero
001011 93c0 2894                 	sts pulse2_duty_macro_loop, r28
001013 93c0 2895                 	sts pulse2_duty_macro_release, r28
                                 
001015 9220 2879                 	sts pulse2_volume_macro, zero
001017 9220 287a                 	sts pulse2_volume_macro+1, zero
001019 9220 287e                 	sts pulse2_arpeggio_macro, zero
00101b 9220 287f                 	sts pulse2_arpeggio_macro+1, zero
00101d 9220 2884                 	sts pulse2_total_pitch_offset, zero
00101f 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
001021 9220 2886                 	sts pulse2_pitch_macro, zero
001023 9220 2887                 	sts pulse2_pitch_macro+1, zero
001025 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero
001027 9220 288c                 	sts pulse2_hi_pitch_macro, zero
001029 9220 288d                 	sts pulse2_hi_pitch_macro+1, zero
00102b 9220 2891                 	sts pulse2_duty_macro, zero
00102d 9220 2892                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
00102f e02f                      	ldi pulse2_volume_divider, 0x0F
001030 9130 2808                 	lds pulse2_volume_decay, pulse2_param
001032 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
001033 91d0 2808                 	lds r29, pulse2_param
001035 73d0                      	andi r29, 0b00110000
001036 62d0                      	sbr r29, 0b0100000 //set start flag
001037 95d2                      	swap r29
001038 2b9d                      	or pulse_channel_flags, r29
001039 9220 280e                 	sts pulse2_output_volume, zero
00103b 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
00103d 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
00103e e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00103f 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
001040 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
001042 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
001043 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001044 efcf                      	ldi r28, 0xFF
001045 9220 2896                 	sts pulse2_fx_0xy_sequence, zero
001047 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
001049 9220 2898                 	sts pulse2_fx_1xx, zero
00104b 9220 2899                 	sts pulse2_fx_1xx+1, zero
00104d 9220 289a                 	sts pulse2_fx_1xx_total, zero
00104f 9220 289b                 	sts pulse2_fx_1xx_total+1, zero
001051 9220 289c                 	sts pulse2_fx_2xx, zero
001053 9220 289d                 	sts pulse2_fx_2xx+1, zero
001055 9220 289e                 	sts pulse2_fx_2xx_total, zero
001057 9220 289f                 	sts pulse2_fx_2xx_total+1, zero
001059 9220 28a0                 	sts pulse2_fx_3xx_start, zero
00105b 9220 28a1                 	sts pulse2_fx_3xx_start+1, zero
00105d 9220 28a2                 	sts pulse2_fx_3xx_target, zero
00105f 9220 28a3                 	sts pulse2_fx_3xx_target+1, zero
001061 9220 28a4                 	sts pulse2_fx_3xx_speed, zero
001063 9220 28a5                 	sts pulse2_fx_3xx_speed+1, zero
001065 9220 28a6                 	sts pulse2_fx_3xx_total_offset, zero
001067 9220 28a7                 	sts pulse2_fx_3xx_total_offset+1, zero
001069 9220 28a8                 	sts pulse2_fx_4xy_speed, zero
00106b 9220 28a9                 	sts pulse2_fx_4xy_depth, zero
00106d 9220 28aa                 	sts pulse2_fx_4xy_phase, zero
00106f 9220 28ab                 	sts pulse2_fx_7xy_speed, zero
001071 9220 28ac                 	sts pulse2_fx_7xy_depth, zero
001073 9220 28ad                 	sts pulse2_fx_7xy_phase, zero
001075 9220 28ae                 	sts pulse2_fx_7xy_value, zero
001077 9220 28af                 	sts pulse2_fx_Axy, zero
001079 93c0 28b0                 	sts pulse2_fx_Gxx_pre, r28
00107b 93c0 28b1                 	sts pulse2_fx_Gxx_post, r28
00107d 9220 28b2                 	sts pulse2_fx_Pxx_total, zero
00107f 9220 28b3                 	sts pulse2_fx_Pxx_total+1, zero
001081 9220 28b4                 	sts pulse2_fx_Qxy_target_note, zero
001083 9220 28b5                 	sts pulse2_fx_Qxy_target, zero
001085 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
001087 9220 28b7                 	sts pulse2_fx_Qxy_speed, zero
001089 9220 28b8                 	sts pulse2_fx_Qxy_speed+1, zero
00108b 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero
00108d 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
00108f 9220 28bb                 	sts pulse2_fx_Rxy_target_note, zero
001091 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
001093 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
001095 9220 28be                 	sts pulse2_fx_Rxy_speed, zero
001097 9220 28bf                 	sts pulse2_fx_Rxy_speed+1, zero
001099 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero
00109b 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
00109d 93c0 28c2                 	sts pulse2_fx_Sxx_pre, r28
00109f 93c0 28c3                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
0010a1 efcf                      	ldi r28, 0xFF
0010a2 9220 28cc                 	sts triangle_volume_macro_offset, zero
0010a4 93c0 28cd                 	sts triangle_volume_macro_loop, r28
0010a6 93c0 28ce                 	sts triangle_volume_macro_release, r28
0010a8 9220 28d1                 	sts triangle_arpeggio_macro_offset, zero
0010aa 93c0 28d2                 	sts triangle_arpeggio_macro_loop, r28
0010ac 93c0 28d3                 	sts triangle_arpeggio_macro_release, r28
0010ae 93c0 28d4                 	sts triangle_arpeggio_macro_mode, r28
0010b0 9220 28d9                 	sts triangle_pitch_macro_offset, zero
0010b2 93c0 28da                 	sts triangle_pitch_macro_loop, r28
0010b4 93c0 28db                 	sts triangle_pitch_macro_release, r28
0010b6 9220 28df                 	sts triangle_hi_pitch_macro_offset, zero
0010b8 93c0 28e0                 	sts triangle_hi_pitch_macro_loop, r28
0010ba 93c0 28e1                 	sts triangle_hi_pitch_macro_release, r28
0010bc 9220 28e4                 	sts triangle_duty_macro_offset, zero
0010be 93c0 28e5                 	sts triangle_duty_macro_loop, r28
0010c0 93c0 28e6                 	sts triangle_duty_macro_release, r28
                                 
0010c2 9220 28ca                 	sts triangle_volume_macro, zero
0010c4 9220 28cb                 	sts triangle_volume_macro+1, zero
0010c6 9220 28cf                 	sts triangle_arpeggio_macro, zero
0010c8 9220 28d0                 	sts triangle_arpeggio_macro+1, zero
0010ca 9220 28d5                 	sts triangle_total_pitch_offset, zero
0010cc 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
0010ce 9220 28d7                 	sts triangle_pitch_macro, zero
0010d0 9220 28d8                 	sts triangle_pitch_macro+1, zero
0010d2 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero
0010d4 9220 28dd                 	sts triangle_hi_pitch_macro, zero
0010d6 9220 28de                 	sts triangle_hi_pitch_macro+1, zero
0010d8 9220 28e2                 	sts triangle_duty_macro, zero
0010da 9220 28e3                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
0010dc e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
0010dd 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
0010de efcf                      	ldi r28, 0xFF
0010df 9220 28e7                 	sts triangle_fx_0xy_sequence, zero
0010e1 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
0010e3 9220 28e9                 	sts triangle_fx_1xx, zero
0010e5 9220 28ea                 	sts triangle_fx_1xx+1, zero
0010e7 9220 28eb                 	sts triangle_fx_1xx_total, zero
0010e9 9220 28ec                 	sts triangle_fx_1xx_total+1, zero
0010eb 9220 28ed                 	sts triangle_fx_2xx, zero
0010ed 9220 28ee                 	sts triangle_fx_2xx+1, zero
0010ef 9220 28ef                 	sts triangle_fx_2xx_total, zero
0010f1 9220 28f0                 	sts triangle_fx_2xx_total+1, zero
0010f3 9220 28f1                 	sts triangle_fx_3xx_start, zero
0010f5 9220 28f2                 	sts triangle_fx_3xx_start+1, zero
0010f7 9220 28f3                 	sts triangle_fx_3xx_target, zero
0010f9 9220 28f4                 	sts triangle_fx_3xx_target+1, zero
0010fb 9220 28f5                 	sts triangle_fx_3xx_speed, zero
0010fd 9220 28f6                 	sts triangle_fx_3xx_speed+1, zero
0010ff 9220 28f7                 	sts triangle_fx_3xx_total_offset, zero
001101 9220 28f8                 	sts triangle_fx_3xx_total_offset+1, zero
001103 9220 28f9                 	sts triangle_fx_4xy_speed, zero
001105 9220 28fa                 	sts triangle_fx_4xy_depth, zero
001107 9220 28fb                 	sts triangle_fx_4xy_phase, zero
001109 93c0 28fc                 	sts triangle_fx_Gxx_pre, r28
00110b 93c0 28fd                 	sts triangle_fx_Gxx_post, r28
00110d 9220 28fe                 	sts triangle_fx_Pxx_total, zero
00110f 9220 28ff                 	sts triangle_fx_Pxx_total+1, zero
001111 9220 2900                 	sts triangle_fx_Qxy_target_note, zero
001113 9220 2901                 	sts triangle_fx_Qxy_target, zero
001115 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001117 9220 2903                 	sts triangle_fx_Qxy_speed, zero
001119 9220 2904                 	sts triangle_fx_Qxy_speed+1, zero
00111b 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero
00111d 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
00111f 9220 2907                 	sts triangle_fx_Rxy_target_note, zero
001121 9220 2908                 	sts triangle_fx_Rxy_target, zero
001123 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001125 9220 290a                 	sts triangle_fx_Rxy_speed, zero
001127 9220 290b                 	sts triangle_fx_Rxy_speed+1, zero
001129 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero
00112b 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
00112d 93c0 290e                 	sts triangle_fx_Sxx_pre, r28
00112f 93c0 290f                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
001131 efcf                      	ldi r28, 0xFF
001132 9220 2918                 	sts noise_volume_macro_offset, zero
001134 93c0 2919                 	sts noise_volume_macro_loop, r28
001136 93c0 291a                 	sts noise_volume_macro_release, r28
001138 9220 291d                 	sts noise_arpeggio_macro_offset, zero
00113a 93c0 291e                 	sts noise_arpeggio_macro_loop, r28
00113c 93c0 291f                 	sts noise_arpeggio_macro_release, r28
00113e 93c0 2920                 	sts noise_arpeggio_macro_mode, r28
001140 9220 2925                 	sts noise_pitch_macro_offset, zero
001142 93c0 2926                 	sts noise_pitch_macro_loop, r28
001144 93c0 2927                 	sts noise_pitch_macro_release, r28
001146 9220 292b                 	sts noise_hi_pitch_macro_offset, zero
001148 93c0 292c                 	sts noise_hi_pitch_macro_loop, r28
00114a 93c0 292d                 	sts noise_hi_pitch_macro_release, r28
00114c 9220 2930                 	sts noise_duty_macro_offset, zero
00114e 93c0 2931                 	sts noise_duty_macro_loop, r28
001150 93c0 2932                 	sts noise_duty_macro_release, r28
                                 
001152 9220 2916                 	sts noise_volume_macro, zero
001154 9220 2917                 	sts noise_volume_macro+1, zero
001156 9220 291b                 	sts noise_arpeggio_macro, zero
001158 9220 291c                 	sts noise_arpeggio_macro+1, zero
00115a 9220 2921                 	sts noise_total_pitch_offset, zero
00115c 9220 2922                 	sts noise_total_pitch_offset+1, zero
00115e 9220 2923                 	sts noise_pitch_macro, zero
001160 9220 2924                 	sts noise_pitch_macro+1, zero
001162 9220 2928                 	sts noise_total_hi_pitch_offset, zero
001164 9220 2929                 	sts noise_hi_pitch_macro, zero
001166 9220 292a                 	sts noise_hi_pitch_macro+1, zero
001168 9220 292e                 	sts noise_duty_macro, zero
00116a 9220 292f                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
00116c 9220 2816                 	sts noise_output_volume, zero
00116e 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001170 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001171 2f5c                      	mov noise_sequence_LOW, r28
001172 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
001173 efcf                      	ldi r28, 0xFF
001174 9220 2933                 	sts noise_fx_0xy_sequence, zero
001176 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001178 9220 2935                 	sts noise_fx_1xx, zero
00117a 9220 2936                 	sts noise_fx_1xx+1, zero
00117c 9220 2937                 	sts noise_fx_1xx_total, zero
00117e 9220 2938                 	sts noise_fx_1xx_total+1, zero
001180 9220 2939                 	sts noise_fx_2xx, zero
001182 9220 293a                 	sts noise_fx_2xx+1, zero
001184 9220 293b                 	sts noise_fx_2xx_total, zero
001186 9220 293c                 	sts noise_fx_2xx_total+1, zero
001188 9220 293d                 	sts noise_fx_3xx_start, zero
00118a 9220 293e                 	sts noise_fx_3xx_start+1, zero
00118c 9220 293f                 	sts noise_fx_3xx_target, zero
00118e 9220 2940                 	sts noise_fx_3xx_target+1, zero
001190 9220 2941                 	sts noise_fx_3xx_speed, zero
001192 9220 2942                 	sts noise_fx_3xx_speed+1, zero
001194 9220 2943                 	sts noise_fx_3xx_total_offset, zero
001196 9220 2944                 	sts noise_fx_3xx_total_offset+1, zero
001198 9220 2945                 	sts noise_fx_4xy_speed, zero
00119a 9220 2946                 	sts noise_fx_4xy_depth, zero
00119c 9220 2947                 	sts noise_fx_4xy_phase, zero
00119e 9220 2948                 	sts noise_fx_7xy_speed, zero
0011a0 9220 2949                 	sts noise_fx_7xy_depth, zero
0011a2 9220 294a                 	sts noise_fx_7xy_phase, zero
0011a4 9220 294b                 	sts noise_fx_7xy_value, zero
0011a6 9220 294c                 	sts noise_fx_Axy, zero
0011a8 93c0 294d                 	sts noise_fx_Gxx_pre, r28
0011aa 93c0 294e                 	sts noise_fx_Gxx_post, r28
0011ac 9220 294f                 	sts noise_fx_Pxx_total, zero
0011ae 9220 2950                 	sts noise_fx_Pxx_total+1, zero
0011b0 9220 2951                 	sts noise_fx_Qxy_target_note, zero
0011b2 9220 2952                 	sts noise_fx_Qxy_target, zero
0011b4 9220 2953                 	sts noise_fx_Qxy_target+1, zero
0011b6 9220 2954                 	sts noise_fx_Qxy_speed, zero
0011b8 9220 2955                 	sts noise_fx_Qxy_speed+1, zero
0011ba 9220 2956                 	sts noise_fx_Qxy_total_offset, zero
0011bc 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
0011be 9220 2958                 	sts noise_fx_Rxy_target_note, zero
0011c0 9220 2959                 	sts noise_fx_Rxy_target, zero
0011c2 9220 295a                 	sts noise_fx_Rxy_target+1, zero
0011c4 9220 295b                 	sts noise_fx_Rxy_speed, zero
0011c6 9220 295c                 	sts noise_fx_Rxy_speed+1, zero
0011c8 9220 295d                 	sts noise_fx_Rxy_total_offset, zero
0011ca 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
0011cc 93c0 295f                 	sts noise_fx_Sxx_pre, r28
0011ce 93c0 2960                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
0011d0 efcf                      	ldi r28, 0xFF
0011d1 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0011d2 e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0011d3 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
0011d5 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0011d6 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
0011d8 e1c5                      	ldi r28, 0x15 //set the period for CMP0
0011d9 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
0011db e0c5                      	ldi r28, 0x05
0011dc 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
0011de e2cb                      	ldi r28, 0x2B //set the period for CMP1
0011df 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
0011e1 e0ca                      	ldi r28, 0x0A
0011e2 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
0011e4 e4c1                      	ldi r28, 0x41 //set the period for CMP2
0011e5 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
0011e7 e0cf                      	ldi r28, 0x0F
0011e8 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
0011ea e5c7                      	ldi r28, 0x57 //set the period for OVF
0011eb 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
0011ed e1c4                      	ldi r28, 0x14
0011ee 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
0011f0 e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0011f1 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0011f3 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
0011f4 93c0 0a81                 	sts TCB0_CTRLB, r28
0011f6 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
0011f7 93c0 0a85                 	sts TCB0_INTCTRL, r28
0011f9 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
0011fb 93c0 0a8c                 	sts TCB0_CCMPL, r28
0011fd 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
0011ff 93c0 0a8d                 	sts TCB0_CCMPH, r28
001201 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001202 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001204 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001205 93b0 0a91                 	sts TCB1_CTRLB, r27
001207 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001208 93b0 0a95                 	sts TCB1_INTCTRL, r27
00120a 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00120c 93b0 0a9c                 	sts TCB1_CCMPL, r27
00120e 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001210 93b0 0a9d                 	sts TCB1_CCMPH, r27
001212 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001213 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001215 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001216 93b0 0aa1                 	sts TCB2_CTRLB, r27
001218 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
001219 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
00121b 93b0 0aac                 	sts TCB2_CCMPL, r27
00121d 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
00121f 93b0 0aad                 	sts TCB2_CCMPH, r27
001221 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001222 93b0 0aa0                 	sts TCB2_CTRLA, r27
001224 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
001225 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001226 93b0 0ab1                 	sts TCB3_CTRLB, r27
001228 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001229 93b0 0ab5                 	sts TCB3_INTCTRL, r27
00122b 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00122d 93b0 0abc                 	sts TCB3_CCMPL, r27
00122f 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001231 93b0 0abd                 	sts TCB3_CCMPH, r27
001233 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001234 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
001236 91c0 2806                 	lds r28, pulse1_output_volume
001238 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
00123a fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
00123b c015                      	rjmp volume_mixer_pulse1_off
                                 
00123c 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
00123d f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
00123e 91e0 0a8c                 	lds r30, TCB0_CCMPL
001240 e5f9                      	ldi r31, 0x059
001241 17ef                      	cp r30, r31
001242 91e0 0a8d                 	lds r30, TCB0_CCMPH
001244 e0f0                      	ldi r31, 0x00
001245 07ef                      	cpc r30, r31
001246 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
001247 91e0 0a8c                 	lds r30, TCB0_CCMPL
001249 e6f6                      	ldi r31, 0x66
00124a 17ef                      	cp r30, r31
00124b 91e0 0a8d                 	lds r30, TCB0_CCMPH
00124d e5f9                      	ldi r31, 0x59
00124e 07ef                      	cpc r30, r31
00124f f408                      	brsh volume_mixer_pulse1_off
001250 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
001251 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
001252 fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
001253 c015                      	rjmp volume_mixer_pulse2_off
                                 
001254 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
001255 f099                      	breq volume_mixer_pulse2_off
                                 
001256 91e0 0a9c                 	lds r30, TCB1_CCMPL
001258 e5f9                      	ldi r31, 0x059
001259 17ef                      	cp r30, r31
00125a 91e0 0a9d                 	lds r30, TCB1_CCMPH
00125c e0f0                      	ldi r31, 0x00
00125d 07ef                      	cpc r30, r31
00125e f050                      	brlo volume_mixer_pulse2_off
                                 
00125f 91e0 0a9c                 	lds r30, TCB1_CCMPL
001261 e6f6                      	ldi r31, 0x66
001262 17ef                      	cp r30, r31
001263 91e0 0a9d                 	lds r30, TCB1_CCMPH
001265 e5f9                      	ldi r31, 0x59
001266 07ef                      	cpc r30, r31
001267 f408                      	brsh volume_mixer_pulse2_off
001268 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001269 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
00126a 0fcd                      	add r28, r29
00126b e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
00126c e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
00126d 0fec                      	add ZL, r28
00126e 1df2                      	adc ZH, zero
00126f 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001270 2fd4                      	mov r29, triangle_sequence
001271 fdd4                      	sbrc r29, 4 //check 5th bit
001272 95d0                      	com r29
001273 70df                      	andi r29, 0x0F
001274 2fed                      	mov r30, r29
001275 0fde                      	add r29, r30 //multiply the triangle volume by 3
001276 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
001277 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
001278 c004                      	rjmp volume_mixer_tnd_out
001279 91e0 2816                 	lds r30, noise_output_volume
00127b 0fee                      	lsl r30 //multiply noise volume by 2
00127c 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
00127d e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
00127e e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
00127f 0fed                      	add ZL, r29
001280 1df2                      	adc ZH, zero
001281 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001282 0fcd                      	add r28, r29
001283 b9c1                      	out VPORTA_OUT, r28
001284 cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001285 b7bf                      	in r27, CPU_SREG
001286 93bf                      	push r27
001287 94f8                      	cli
                                 
                                 	//ENVELOPE
001288 d053                      	rcall pulse1_envelope_routine
001289 d09f                      	rcall pulse2_envelope_routine
                                 
00128a e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
00128b 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00128d 91bf                      	pop r27
00128e bfbf                      	out CPU_SREG, r27
00128f 9518                      	reti
                                 
                                 sequence_1_3:
001290 b7bf                      	in r27, CPU_SREG
001291 93bf                      	push r27
001292 94f8                      	cli
                                 
                                 	//ENVELOPE
001293 d048                      	rcall pulse1_envelope_routine
001294 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001295 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001296 d01b                      	rcall pulse1_sweep_routine
001297 fcf3                      	sbrc pulse2_sweep, 3
001298 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001299 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
00129a c002                      	rjmp sequence_1_3_pulse2_length
00129b 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
00129c 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
00129d fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
00129e c002                      	rjmp sequence_1_3_exit
00129f 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
0012a0 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
0012a1 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
0012a2 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0012a4 91bf                      	pop r27
0012a5 bfbf                      	out CPU_SREG, r27
0012a6 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
0012a7 b7bf                      	in r27, CPU_SREG
0012a8 93bf                      	push r27
0012a9 94f8                      	cli
                                 
0012aa 0caa                      	lsl pulse1_sequence //shifts sequence to the left
0012ab 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0012ac e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0012ad 93b0 0a86                 	sts TCB0_INTFLAGS, r27
0012af 91bf                      	pop r27
0012b0 bfbf                      	out CPU_SREG, r27
0012b1 9518                      	reti
                                 
                                 pulse1_sweep_routine:
0012b2 2dbc                      	mov r27, pulse1_sweep
0012b3 70b7                      	andi r27, 0x07 //mask for period divider bits
0012b4 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0012b5 93df                      	push r29
0012b6 2ddc                      	mov r29, pulse1_sweep
0012b7 95d2                      	swap r29
0012b8 70d7                      	andi r29, 0x07 //mask for shift bits
0012b9 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
0012ba 91df                      	pop r29
0012bb c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
0012bc 91a0 0a8c                 	lds r26, TCB0_CCMPL
0012be 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
0012c0 95b6                      	lsr r27
0012c1 95a7                      	ror r26
0012c2 95da                      	dec r29
0012c3 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0012c4 fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
0012c5 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0012c6 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
0012c7 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
0012c8 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
0012ca 0fad                      	add r26, r29
0012cb 91d0 0a8d                 	lds r29, TCB0_CCMPH
0012cd 1fbd                      	adc r27, r29
                                 
0012ce 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
0012d0 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0012d2 91df                      	pop r29
0012d3 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
0012d4 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
0012d5 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
0012d6 9508                      	ret
                                 
                                 pulse1_sweep_reload:
0012d7 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0012d9 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
0012da 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
0012db 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
0012dc fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
0012dd c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
0012de 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0012df f011                      	breq PC+3 //if the divider == 0, check loop flag
0012e0 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0012e1 9508                      	ret
                                 
0012e2 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0012e4 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0012e5 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
0012e6 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0012e7 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0012e8 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
0012e9 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0012ea f409                      	brne PC+2 //if decay != 0, go decrement
0012eb 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0012ec 951a                      	dec pulse1_volume_decay
0012ed 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0012ee 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
0012ef 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0012f1 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0012f2 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0012f3 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
0012f4 b7bf                      	in r27, CPU_SREG
0012f5 93bf                      	push r27
0012f6 94f8                      	cli
                                 
0012f7 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
0012f8 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0012f9 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0012fa 93b0 0a96                 	sts TCB1_INTFLAGS, r27
0012fc 91bf                      	pop r27
0012fd bfbf                      	out CPU_SREG, r27
0012fe 9518                      	reti
                                 
                                 pulse2_sweep_routine:
0012ff 2dbf                      	mov r27, pulse2_sweep
001300 70b7                      	andi r27, 0x07 //mask for period divider bits
001301 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001302 93df                      	push r29
001303 2ddf                      	mov r29, pulse2_sweep
001304 95d2                      	swap r29
001305 70d7                      	andi r29, 0x07 //mask for shift bits
001306 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001307 91df                      	pop r29
001308 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001309 91a0 0a9c                 	lds r26, TCB1_CCMPL
00130b 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
00130d 95b6                      	lsr r27
00130e 95a7                      	ror r26
00130f 95da                      	dec r29
001310 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001311 fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
001312 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001313 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001314 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001315 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001317 0fad                      	add r26, r29
001318 91d0 0a9d                 	lds r29, TCB1_CCMPH
00131a 1fbd                      	adc r27, r29
                                 
00131b 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
00131d 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00131f 91df                      	pop r29
001320 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
001321 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
001322 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
001323 9508                      	ret
                                 
                                 pulse2_sweep_reload:
001324 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001326 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
001327 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
001328 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
001329 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
00132a c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
00132b 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
00132c f011                      	breq PC+3 //if the divider == 0, check loop flag
00132d 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
00132e 9508                      	ret
                                 
00132f 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
001331 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001332 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
001333 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001334 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001335 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001336 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
001337 f409                      	brne PC+2 //if decay != 0, go decrement
001338 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001339 953a                      	dec pulse2_volume_decay
00133a 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
00133b 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
00133c 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
00133e 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
00133f e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
001340 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
001341 b7bf                      	in r27, CPU_SREG
001342 93bf                      	push r27
001343 94f8                      	cli
                                 
001344 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
001345 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
001346 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001347 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
001349 91bf                      	pop r27
00134a bfbf                      	out CPU_SREG, r27
00134b 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
00134c b7bf                      	in r27, CPU_SREG
00134d 93bf                      	push r27
00134e 94f8                      	cli
                                 
00134f 2fa5                      	mov r26, noise_sequence_LOW
001350 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
001351 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
001352 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
001353 27a5                      	eor r26, noise_sequence_LOW
001354 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001355 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
001356 9566                      	lsr noise_sequence_HIGH
001357 9557                      	ror noise_sequence_LOW
001358 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
001359 9566                      	lsr noise_sequence_HIGH
00135a 9557                      	ror noise_sequence_LOW
00135b 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
00135c c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
00135d 0faa                      	lsl r26
00135e 1faa                      	rol r26
00135f 1faa                      	rol r26 //move the 6th bit to the 0th bit place
001360 27a5                      	eor r26, noise_sequence_LOW
001361 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
001362 c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
001363 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
001364 9566                      	lsr noise_sequence_HIGH
001365 9557                      	ror noise_sequence_LOW
001366 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
001367 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
001368 9566                      	lsr noise_sequence_HIGH
001369 9557                      	ror noise_sequence_LOW
00136a 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
00136b c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
00136c e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00136d 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
00136f 91bf                      	pop r27
001370 bfbf                      	out CPU_SREG, r27
001371 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
001372 e8e0                      	ldi ZL, LOW(length << 1)
001373 e5fb                      	ldi ZH, HIGH(length << 1)
001374 0fed                      	add ZL, r29
001375 1df2                      	adc ZH, zero
001376 91d4                      	lpm r29, Z
001377 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001378 eae0                      	ldi ZL, LOW(sequences << 1)
001379 e5fb                      	ldi ZH, HIGH(sequences << 1)
00137a 0fed                      	add ZL, r29
00137b 1df2                      	adc ZH, zero
00137c 91d4                      	lpm r29, Z
00137d 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
00137e b7bf                      	in r27, CPU_SREG
00137f 93bf                      	push r27
001380 94f8                      	cli
001381 93cf                      	push r28
001382 93df                      	push r29
001383 93ef                      	push r30
001384 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001385 91a0 281f                 	lds r26, song_fx_Bxx
001387 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001388 f4a9                      	brne sound_driver_fx_Bxx_routine
001389 91a0 2820                 	lds r26, song_fx_Cxx
00138b 11a2                      	cpse r26, zero
00138c c08b                      	rjmp sound_driver_fx_Cxx_routine
00138d 91a0 2821                 	lds r26, song_fx_Dxx
00138f 11a2                      	cpse r26, zero
001390 c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
001391 91a0 281a                 	lds r26, song_frame_offset
001393 91b0 281b                 	lds r27, song_frame_offset+1
001395 91c0 281c                 	lds r28, song_size
001397 91d0 281d                 	lds r29, song_size+1
001399 17ac                      	cp r26, r28
00139a 07bd                      	cpc r27, r29
00139b f408                      	brsh sound_driver_fx_song_loop
00139c c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
00139d e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
00139e 91e0 2818                 	lds ZL, song_frames
0013a0 91f0 2819                 	lds ZH, song_frames+1
0013a2 27cc                      	clr r28 //initialize r29:r28 to 0
0013a3 27dd                      	clr r29
0013a4 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
0013a5 95aa                      	dec r26
0013a6 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
0013a7 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
0013a8 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
0013a9 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
0013aa 93c0 281a                 	sts song_frame_offset, r28
0013ac 93d0 281b                 	sts song_frame_offset+1, r29
0013ae 0fec                      	add ZL, r28
0013af 1ffd                      	adc ZH, r29
                                 
0013b0 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
0013b1 91b5                      	lpm r27, Z+
0013b2 0faa                      	lsl r26
0013b3 1fbb                      	rol r27
0013b4 93a0 2822                 	sts pulse1_pattern, r26
0013b6 93b0 2823                 	sts pulse1_pattern+1, r27
0013b8 91a5                      	lpm r26, Z+
0013b9 91b5                      	lpm r27, Z+
0013ba 0faa                      	lsl r26
0013bb 1fbb                      	rol r27
0013bc 93a0 2873                 	sts pulse2_pattern, r26
0013be 93b0 2874                 	sts pulse2_pattern+1, r27
0013c0 91a5                      	lpm r26, Z+
0013c1 91b5                      	lpm r27, Z+
0013c2 0faa                      	lsl r26
0013c3 1fbb                      	rol r27
0013c4 93a0 28c4                 	sts triangle_pattern, r26
0013c6 93b0 28c5                 	sts triangle_pattern+1, r27
0013c8 91a5                      	lpm r26, Z+
0013c9 91b5                      	lpm r27, Z+
0013ca 0faa                      	lsl r26
0013cb 1fbb                      	rol r27
0013cc 93a0 2910                 	sts noise_pattern, r26
0013ce 93b0 2911                 	sts noise_pattern+1, r27
                                 
0013d0 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0013d2 9220 2827                 	sts pulse1_pattern_offset+1, zero
0013d4 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0013d6 9220 2825                 	sts pulse1_pattern_delay_frames, zero
0013d8 9220 2877                 	sts pulse2_pattern_offset, zero
0013da 9220 2878                 	sts pulse2_pattern_offset+1, zero
0013dc 9220 2875                 	sts pulse2_pattern_delay_rows, zero
0013de 9220 2876                 	sts pulse2_pattern_delay_frames, zero
0013e0 9220 28c8                 	sts triangle_pattern_offset, zero
0013e2 9220 28c9                 	sts triangle_pattern_offset+1, zero
0013e4 9220 28c6                 	sts triangle_pattern_delay_rows, zero
0013e6 9220 28c7                 	sts triangle_pattern_delay_frames, zero
0013e8 9220 2914                 	sts noise_pattern_offset, zero
0013ea 9220 2915                 	sts noise_pattern_offset+1, zero
0013ec 9220 2912                 	sts noise_pattern_delay_rows, zero
0013ee 9220 2913                 	sts noise_pattern_delay_frames, zero
                                 
0013f0 efaf                      	ldi r26, 0xFF
0013f1 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0013f3 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
0013f5 93a0 2871                 	sts pulse1_fx_Sxx_pre, r26
0013f7 93a0 2872                 	sts pulse1_fx_Sxx_post, r26
0013f9 93a0 28b0                 	sts pulse2_fx_Gxx_pre, r26
0013fb 93a0 28b1                 	sts pulse2_fx_Gxx_post, r26
0013fd 93a0 28c2                 	sts pulse2_fx_Sxx_pre, r26
0013ff 93a0 28c3                 	sts pulse2_fx_Sxx_post, r26
001401 93a0 28fc                 	sts triangle_fx_Gxx_pre, r26
001403 93a0 28fd                 	sts triangle_fx_Gxx_post, r26
001405 93a0 290e                 	sts triangle_fx_Sxx_pre, r26
001407 93a0 290f                 	sts triangle_fx_Sxx_post, r26
001409 93a0 294d                 	sts noise_fx_Gxx_pre, r26
00140b 93a0 294e                 	sts noise_fx_Gxx_post, r26
00140d 93a0 295f                 	sts noise_fx_Sxx_pre, r26
00140f 93a0 2960                 	sts noise_fx_Sxx_post, r26
                                 
001411 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001413 9220 2820                 	sts song_fx_Cxx, zero
001415 9220 2821                 	sts song_fx_Dxx, zero
001417 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
001418 91ff                      	pop r31
001419 91ef                      	pop r30
00141a 91df                      	pop r29
00141b 91cf                      	pop r28
00141c 91bf                      	pop r27
00141d bfbf                      	out CPU_SREG, r27
00141e 94f8                      	cli //disable global interrupts
                                 		
00141f efaf                      	ldi r26, 0xFF
001420 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001422 9220 2820                 	sts song_fx_Cxx, zero
001424 9220 2821                 	sts song_fx_Dxx, zero
001426 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
001427 91e0 2818                 	lds ZL, song_frames
001429 91f0 2819                 	lds ZH, song_frames+1
00142b 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00142d 91b0 281b                 	lds r27, song_frame_offset+1
00142f 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001430 93a0 281a                 	sts song_frame_offset, r26
001432 93b0 281b                 	sts song_frame_offset+1, r27
001434 0fea                      	add ZL, r26
001435 1ffb                      	adc ZH, r27
                                 
001436 91a5                      	lpm r26, Z+ //load the address of the next pattern
001437 91b5                      	lpm r27, Z+
001438 0faa                      	lsl r26
001439 1fbb                      	rol r27
00143a 93a0 2822                 	sts pulse1_pattern, r26
00143c 93b0 2823                 	sts pulse1_pattern+1, r27
00143e 91a5                      	lpm r26, Z+
00143f 91b5                      	lpm r27, Z+
001440 0faa                      	lsl r26
001441 1fbb                      	rol r27
001442 93a0 2873                 	sts pulse2_pattern, r26
001444 93b0 2874                 	sts pulse2_pattern+1, r27
001446 91a5                      	lpm r26, Z+
001447 91b5                      	lpm r27, Z+
001448 0faa                      	lsl r26
001449 1fbb                      	rol r27
00144a 93a0 28c4                 	sts triangle_pattern, r26
00144c 93b0 28c5                 	sts triangle_pattern+1, r27
00144e 91a5                      	lpm r26, Z+
00144f 91b5                      	lpm r27, Z+
001450 0faa                      	lsl r26
001451 1fbb                      	rol r27
001452 93a0 2910                 	sts noise_pattern, r26
001454 93b0 2911                 	sts noise_pattern+1, r27
                                 
001456 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001458 9220 2827                 	sts pulse1_pattern_offset+1, zero
00145a 9220 2824                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00145c 9220 2825                 	sts pulse1_pattern_delay_frames, zero
00145e 9220 2877                 	sts pulse2_pattern_offset, zero
001460 9220 2878                 	sts pulse2_pattern_offset+1, zero
001462 9220 2875                 	sts pulse2_pattern_delay_rows, zero
001464 9220 2876                 	sts pulse2_pattern_delay_frames, zero
001466 9220 28c8                 	sts triangle_pattern_offset, zero
001468 9220 28c9                 	sts triangle_pattern_offset+1, zero
00146a 9220 28c6                 	sts triangle_pattern_delay_rows, zero
00146c 9220 28c7                 	sts triangle_pattern_delay_frames, zero
00146e 9220 2914                 	sts noise_pattern_offset, zero
001470 9220 2915                 	sts noise_pattern_offset+1, zero
001472 9220 2912                 	sts noise_pattern_delay_rows, zero
001474 9220 2913                 	sts noise_pattern_delay_frames, zero
                                 
001476 efaf                      	ldi r26, 0xFF
001477 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001479 93a0 2860                 	sts pulse1_fx_Gxx_post, r26
00147b 93a0 2871                 	sts pulse1_fx_Sxx_pre, r26
00147d 93a0 2872                 	sts pulse1_fx_Sxx_post, r26
00147f 93a0 28b0                 	sts pulse2_fx_Gxx_pre, r26
001481 93a0 28b1                 	sts pulse2_fx_Gxx_post, r26
001483 93a0 28c2                 	sts pulse2_fx_Sxx_pre, r26
001485 93a0 28c3                 	sts pulse2_fx_Sxx_post, r26
001487 93a0 28fc                 	sts triangle_fx_Gxx_pre, r26
001489 93a0 28fd                 	sts triangle_fx_Gxx_post, r26
00148b 93a0 290e                 	sts triangle_fx_Sxx_pre, r26
00148d 93a0 290f                 	sts triangle_fx_Sxx_post, r26
00148f 93a0 294d                 	sts noise_fx_Gxx_pre, r26
001491 93a0 294e                 	sts noise_fx_Gxx_post, r26
001493 93a0 295f                 	sts noise_fx_Sxx_pre, r26
001495 93a0 2960                 	sts noise_fx_Sxx_post, r26
                                 
001497 93a0 281f                 	sts song_fx_Bxx, r26 //reset all song effects
001499 9220 2820                 	sts song_fx_Cxx, zero
00149b 9220 2821                 	sts song_fx_Dxx, zero
00149d c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
00149e 91a0 2824                 	lds r26, pulse1_pattern_delay_rows
0014a0 91b0 2825                 	lds r27, pulse1_pattern_delay_frames
0014a2 9610                      	adiw r27:r26, 0
0014a3 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
0014a4 c2e6                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
0014a5 91e0 2822                 	lds ZL, pulse1_pattern //current pattern for pulse 1
0014a7 91f0 2823                 	lds ZH, pulse1_pattern+1
0014a9 91a0 2826                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
0014ab 91b0 2827                 	lds r27, pulse1_pattern_offset+1
0014ad 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0014ae 1ffb                      	adc ZH, r27
0014af 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0014b0 35b7                      	cpi r27, 0x57
0014b1 f408                      	brsh sound_driver_channel0_check_if_volume
0014b2 c182                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
0014b3 36b7                      	cpi r27, 0x67
0014b4 f408                      	brsh sound_driver_channel0_check_if_delay
0014b5 c1bc                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0014b6 3eb3                      	cpi r27, 0xE3
0014b7 f408                      	brsh sound_driver_channel0_check_if_instrument
0014b8 c1c3                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
0014b9 f409                      	brne sound_driver_channel0_check_if_release
0014ba c1c6                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
0014bb 3eb4                      	cpi r27, 0xE4
0014bc f409                      	brne sound_driver_channel0_check_if_end
0014bd c26f                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
0014be 3fbf                      	cpi r27, 0xFF
0014bf f409                      	brne sound_driver_channel0_check_if_fx
0014c0 c291                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
0014c1 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0014c2 91a4                      	lpm r26, Z //load the fx data into r26
0014c3 d2bd                      	rcall sound_driver_channel0_increment_offset_twice
                                 
0014c4 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0014c5 eae4                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
0014c6 e5fb                      	ldi ZH, HIGH(channel0_fx << 1)
0014c7 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0014c8 0feb                      	add ZL, r27 //add offset
0014c9 1df2                      	adc ZH, zero
0014ca 91c5                      	lpm r28, Z+ //load address bytes
0014cb 91d4                      	lpm r29, Z
0014cc 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0014cd 2ffd                      	mov ZH, r29
0014ce 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
0014cf 93a0 2845                 	sts pulse1_fx_0xy_sequence, r26
0014d1 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014d3 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
0014d4 9220 284b                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
0014d6 9220 284c                 	sts pulse1_fx_2xx+1, zero
0014d8 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0014da 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014dc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014dd 937f                      	push r23
0014de 2f6a                      	mov r22, r26 //store the rate into r22
0014df eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014e0 9f67                      	mul r22, r23
0014e1 917f                      	pop r23
0014e2 916f                      	pop r22
                                 
0014e3 9416                      	lsr r1 //shift out the fractional bits
0014e4 9407                      	ror r0
0014e5 9416                      	lsr r1
0014e6 9407                      	ror r0
0014e7 9416                      	lsr r1
0014e8 9407                      	ror r0
0014e9 9416                      	lsr r1
0014ea 9407                      	ror r0
0014eb 9200 2847                 	sts pulse1_fx_1xx, r0
0014ed 9210 2848                 	sts pulse1_fx_1xx+1, r1
0014ef cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0014f0 9220 2847                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0014f2 9220 2848                 	sts pulse1_fx_1xx+1, zero
0014f4 9220 2845                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0014f6 9220 2846                 	sts pulse1_fx_0xy_sequence+1, zero
0014f8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0014f9 937f                      	push r23
0014fa 2f6a                      	mov r22, r26 //store the rate into r22
0014fb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0014fc 9f67                      	mul r22, r23
0014fd 917f                      	pop r23
0014fe 916f                      	pop r22
                                 
0014ff 9416                      	lsr r1 //shift out the fractional bits
001500 9407                      	ror r0
001501 9416                      	lsr r1
001502 9407                      	ror r0
001503 9416                      	lsr r1
001504 9407                      	ror r0
001505 9416                      	lsr r1
001506 9407                      	ror r0
001507 9200 284b                 	sts pulse1_fx_2xx, r0
001509 9210 284c                 	sts pulse1_fx_2xx+1, r1
00150b cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00150c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00150d 937f                      	push r23
00150e 2f6a                      	mov r22, r26 //store the rate into r22
00150f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001510 9f67                      	mul r22, r23
001511 917f                      	pop r23
001512 916f                      	pop r22
                                 
001513 9416                      	lsr r1 //shift out the fractional bits
001514 9407                      	ror r0
001515 9416                      	lsr r1
001516 9407                      	ror r0
001517 9416                      	lsr r1
001518 9407                      	ror r0
001519 9416                      	lsr r1
00151a 9407                      	ror r0
00151b 9200 2853                 	sts pulse1_fx_3xx_speed, r0
00151d 9210 2854                 	sts pulse1_fx_3xx_speed+1, r1
                                 
00151f 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001520 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
001521 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
001522 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001524 91b0 0a8d                 	lds r27, TCB0_CCMPH
001526 93a0 284f                 	sts pulse1_fx_3xx_start, r26
001528 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
                                 
00152a 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero
00152c 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
00152e cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
00152f 2fba                      	mov r27, r26
001530 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001531 95a2                      	swap r26
001532 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001533 93a0 2857                 	sts pulse1_fx_4xy_speed, r26
001535 93b0 2858                 	sts pulse1_fx_4xy_depth, r27
001537 9220 2859                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
001539 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
00153a 2fba                      	mov r27, r26
00153b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00153c 95a2                      	swap r26
00153d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00153e 93a0 285a                 	sts pulse1_fx_7xy_speed, r26
001540 93b0 285b                 	sts pulse1_fx_7xy_depth, r27
001542 9220 285c                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
001544 9220 285d                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001546 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001547 93a0 285e                 	sts pulse1_fx_Axy, r26
001549 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
00154a 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00154c cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
00154d 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00154f cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
001550 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001552 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
001553 91b0 2800                 	lds r27, pulse1_param
001555 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001556 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001557 93b0 2800                 	sts pulse1_param, r27
001559 6096                      	sbr pulse_channel_flags, 6
00155a cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
00155b 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00155d cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
00155e 15a2                      	cp r26, zero
00155f f051                      	breq sound_driver_channel0_fx_Gxx_invalid
001560 91b0 281e                 	lds r27, song_speed
001562 17ab                      	cp r26, r27
001563 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
001564 93a0 285f                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001566 e0b1                      	ldi r27, 0x01
001567 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
001569 c224                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
00156a cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
00156b cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
00156c cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
00156d cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
00156e cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
00156f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001570 937f                      	push r23
001571 2f6a                      	mov r22, r26
001572 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001573 0367                      	mulsu r22, r23
001574 917f                      	pop r23
001575 916f                      	pop r22
001576 9416                      	lsr r1 //shift out the fractional bits
001577 9407                      	ror r0
001578 9416                      	lsr r1
001579 9407                      	ror r0
00157a 9416                      	lsr r1
00157b 9407                      	ror r0
00157c 9416                      	lsr r1
00157d 9407                      	ror r0
00157e fe13                      	sbrs r1, 3 //check if result was a negative number
00157f c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
001580 efb0                      	ldi r27, 0xF0
001581 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
001582 9200 2861                 	sts pulse1_fx_Pxx_total, r0
001584 9210 2862                 	sts pulse1_fx_Pxx_total+1, r1
001586 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001587 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
001589 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
00158b 9630                      	adiw Z, 0
00158c f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
00158d cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
00158e 91e0 2835                 	lds ZL, pulse1_pitch_macro
001590 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
001592 9630                      	adiw Z, 0
001593 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001594 cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001595 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
001597 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
001599 9630                      	adiw Z, 0
00159a f009                      	breq sound_driver_channel0_fx_Qxy_process
00159b cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
00159c 2fba                      	mov r27, r26 //copy fx parameters into r27
00159d 70bf                      	andi r27, 0x0F //mask note index offset
                                 
00159e 11b2                      	cpse r27, zero
00159f c001                      	rjmp sound_driver_channel0_fx_Qxy_process_refresh
0015a0 c013                      	rjmp sound_driver_channel0_fx_Qxy_process_speed //if there is no given target note, we only adjust the speed
                                 
                                 sound_driver_channel0_fx_Qxy_process_refresh:
0015a1 91c0 2807                 	lds r28, pulse1_note //load current note index
0015a3 0fbc                      	add r27, r28
0015a4 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0015a5 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
0015a6 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
0015a7 93b0 2863                 	sts pulse1_fx_Qxy_target_note, r27
0015a9 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0015aa e0f0                      	ldi ZH, HIGH(note_table << 1)
0015ab 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0015ac 0feb                      	add ZL, r27 //add offset
0015ad 1df2                      	adc ZH, zero
0015ae 91c5                      	lpm r28, Z+ //load bytes
0015af 91d4                      	lpm r29, Z
0015b0 93c0 2864                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
0015b2 93d0 2865                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
0015b4 95a2                      	swap r26
0015b5 70af                      	andi r26, 0x0F //mask effect speed
0015b6 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0015b7 95a3                      	inc r26 //increment the speed by 1
                                 
0015b8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015b9 937f                      	push r23
0015ba 2f6a                      	mov r22, r26 //store the speed data into r27
0015bb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015bc 9f67                      	mul r22, r23
0015bd 917f                      	pop r23
0015be 916f                      	pop r22
                                 
0015bf 9416                      	lsr r1 //shift out the fractional bits
0015c0 9407                      	ror r0
0015c1 9416                      	lsr r1
0015c2 9407                      	ror r0
0015c3 9416                      	lsr r1
0015c4 9407                      	ror r0
0015c5 9416                      	lsr r1
0015c6 9407                      	ror r0
                                 
0015c7 9200 2866                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0015c9 9210 2867                 	sts pulse1_fx_Qxy_speed+1, r1
0015cb ced9                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0015cc 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
0015ce 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
0015d0 9630                      	adiw Z, 0
0015d1 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
0015d2 ced2                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
0015d3 91e0 2835                 	lds ZL, pulse1_pitch_macro
0015d5 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
0015d7 9630                      	adiw Z, 0
0015d8 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0015d9 cecb                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0015da 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
0015dc 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
0015de 9630                      	adiw Z, 0
0015df f009                      	breq sound_driver_channel0_fx_Rxy_process
0015e0 cec4                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0015e1 2fba                      	mov r27, r26 //copy fx parameters into r27
0015e2 70bf                      	andi r27, 0x0F //mask note index offset
                                 
0015e3 11b2                      	cpse r27, zero
0015e4 c001                      	rjmp sound_driver_channel0_fx_Rxy_process_refresh
0015e5 c012                      	rjmp sound_driver_channel0_fx_Rxy_process_speed //if there is no given target note, we only adjust the speed
                                 
                                 sound_driver_channel0_fx_Rxy_process_refresh:
0015e6 91c0 2807                 	lds r28, pulse1_note //load current note index
0015e8 1bcb                      	sub r28, r27
0015e9 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0015ea e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0015eb 93c0 286a                 	sts pulse1_fx_Rxy_target_note, r28
0015ed e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0015ee e0f0                      	ldi ZH, HIGH(note_table << 1)
0015ef 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0015f0 0fec                      	add ZL, r28 //add offset
0015f1 1df2                      	adc ZH, zero
0015f2 91c5                      	lpm r28, Z+ //load bytes
0015f3 91d4                      	lpm r29, Z
0015f4 93c0 286b                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0015f6 93d0 286c                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
0015f8 95a2                      	swap r26
0015f9 70af                      	andi r26, 0x0F //mask effect speed
0015fa 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0015fb 95a3                      	inc r26 //increment the speed by 1
                                 
0015fc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015fd 937f                      	push r23
0015fe 2f6a                      	mov r22, r26 //store the speed data into r27
0015ff eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001600 9f67                      	mul r22, r23
001601 917f                      	pop r23
001602 916f                      	pop r22
                                 
001603 9416                      	lsr r1 //shift out the fractional bits
001604 9407                      	ror r0
001605 9416                      	lsr r1
001606 9407                      	ror r0
001607 9416                      	lsr r1
001608 9407                      	ror r0
001609 9416                      	lsr r1
00160a 9407                      	ror r0
                                 
00160b 9200 286d                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
00160d 9210 286e                 	sts pulse1_fx_Rxy_speed+1, r1
00160f ce95                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
001610 15a2                      	cp r26, zero
001611 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
001612 91b0 281e                 	lds r27, song_speed
001614 17ab                      	cp r26, r27
001615 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001616 93a0 2871                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001618 e0b1                      	ldi r27, 0x01
001619 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00161b c172                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
00161c ce88                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
00161d eae0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00161e e5fb                      	ldi ZH, HIGH(sequences << 1)
00161f 0fea                      	add ZL, r26 //offset the pointer
001620 1df2                      	adc ZH, zero
                                 
001621 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001622 95a7                      	ror r26
001623 95a7                      	ror r26
001624 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001626 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001627 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001628 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001629 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
00162a ce7a                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
00162b 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00162c 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00162d 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00162e 93c0 2800                 	sts pulse1_param, r28
001630 ce74                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001631 ce73                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001632 ce72                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001633 ce71                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001634 ce70                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001635 93b0 2807                 	sts pulse1_note, r27 //store the note index
001637 e0a3                      	ldi r26, 0x03
001638 e0b2                      	ldi r27, 0x02
001639 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00163b 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
00163d 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
00163f 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
001641 93b0 2842                 	sts pulse1_duty_macro_offset, r27
001643 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001645 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001647 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
001649 9220 2849                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00164b 9220 284a                 	sts pulse1_fx_1xx_total+1, zero
00164d 9220 284d                 	sts pulse1_fx_2xx_total, zero
00164f 9220 284e                 	sts pulse1_fx_2xx_total+1, zero
001651 9220 2855                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001653 9220 2856                 	sts pulse1_fx_3xx_total_offset+1, zero
001655 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001657 91b0 0a8d                 	lds r27, TCB0_CCMPH
001659 93a0 284f                 	sts pulse1_fx_3xx_start, r26
00165b 93b0 2850                 	sts pulse1_fx_3xx_start+1, r27
00165d 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
00165f 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001660 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001662 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
001664 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero
001666 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
001668 9220 286b                 	sts pulse1_fx_Rxy_target, zero
00166a 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
00166c 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero
00166e 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
001670 d106                      	rcall sound_driver_channel0_increment_offset
001671 ce33                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001672 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001673 91a0 2800                 	lds r26, pulse1_param
001675 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001676 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001677 93a0 2800                 	sts pulse1_param, r26
001679 6096                      	sbr pulse_channel_flags, 6
00167a d0fc                      	rcall sound_driver_channel0_increment_offset
00167b ce29                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
00167c 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00167d 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
00167f d0f7                      	rcall sound_driver_channel0_increment_offset
001680 c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001681 9220 2828                 	sts pulse1_volume_macro, zero //reset all macro addresses
001683 9220 2829                 	sts pulse1_volume_macro+1, zero
001685 9220 282d                 	sts pulse1_arpeggio_macro, zero
001687 9220 282e                 	sts pulse1_arpeggio_macro+1, zero
001689 9220 2835                 	sts pulse1_pitch_macro, zero
00168b 9220 2836                 	sts pulse1_pitch_macro+1, zero
00168d 9220 283b                 	sts pulse1_hi_pitch_macro, zero
00168f 9220 283c                 	sts pulse1_hi_pitch_macro+1, zero
001691 9220 2840                 	sts pulse1_duty_macro, zero
001693 9220 2841                 	sts pulse1_duty_macro+1, zero
001695 9220 2833                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001697 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
001699 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
00169b 9631                      	adiw Z, 1 //point to the byte next to the flag
00169c 91b4                      	lpm r27, Z //store the instrument offset into r27
00169d e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
00169e e0fd                      	ldi ZH, HIGH(instruments)
00169f 0feb                      	add ZL, r27 //point Z to offsetted instrument
0016a0 1df2                      	adc ZH, zero
0016a1 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0016a2 1fff                      	rol ZH
0016a3 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0016a4 91b4                      	lpm r27, Z
                                 
0016a5 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0016a6 1fbb                      	rol r27
0016a7 2fea                      	mov ZL, r26
0016a8 2ffb                      	mov ZH, r27
0016a9 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0016aa 9632                      	adiw Z, 2 //point Z to the address of the macro
0016ab e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
0016ac 95aa                      	dec r26
0016ad f019                      	breq sound_driver_channel0_instrument_change_exit
0016ae 95b6                      	lsr r27
0016af f078                      	brcs sound_driver_channel0_instrument_change_load_macro
0016b0 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
0016b1 e0a3                      	ldi r26, 0x03
0016b2 e0b2                      	ldi r27, 0x02
0016b3 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0016b5 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
0016b7 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
0016b9 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
0016bb 93b0 2842                 	sts pulse1_duty_macro_offset, r27
0016bd d0c3                      	rcall sound_driver_channel0_increment_offset_twice
0016be cde6                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
0016bf 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0016c0 91d5                      	lpm r29, Z+
                                 
0016c1 30a5                      	cpi r26, 5
0016c2 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
0016c3 30a4                      	cpi r26, 4
0016c4 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
0016c5 30a3                      	cpi r26, 3
0016c6 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
0016c7 30a2                      	cpi r26, 2
0016c8 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
0016c9 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
0016ca 93c0 2828                 	sts pulse1_volume_macro, r28
0016cc 93d0 2829                 	sts pulse1_volume_macro+1, r29
0016ce d041                      	rcall sound_driver_channel0_instrument_change_read_header
0016cf 93c0 282c                 	sts pulse1_volume_macro_release, r28
0016d1 93d0 282b                 	sts pulse1_volume_macro_loop, r29
0016d3 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
0016d4 93c0 282d                 	sts pulse1_arpeggio_macro, r28
0016d6 93d0 282e                 	sts pulse1_arpeggio_macro+1, r29
0016d8 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016da 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
0016dc 9220 286b                 	sts pulse1_fx_Rxy_target, zero
0016de 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
0016e0 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0016e1 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0016e2 93c0 2835                 	sts pulse1_pitch_macro, r28
0016e4 93d0 2836                 	sts pulse1_pitch_macro+1, r29
0016e6 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016e8 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
0016ea 9220 286b                 	sts pulse1_fx_Rxy_target, zero
0016ec 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
0016ee d021                      	rcall sound_driver_channel0_instrument_change_read_header
0016ef 93c0 2839                 	sts pulse1_pitch_macro_release, r28
0016f1 93d0 2838                 	sts pulse1_pitch_macro_loop, r29
0016f3 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0016f4 93c0 283b                 	sts pulse1_hi_pitch_macro, r28
0016f6 93d0 283c                 	sts pulse1_hi_pitch_macro+1, r29
0016f8 9220 2864                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0016fa 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
0016fc 9220 286b                 	sts pulse1_fx_Rxy_target, zero
0016fe 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
001700 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001701 93c0 283f                 	sts pulse1_hi_pitch_macro_release, r28
001703 93d0 283e                 	sts pulse1_hi_pitch_macro_loop, r29
001705 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001706 93c0 2840                 	sts pulse1_duty_macro, r28
001708 93d0 2841                 	sts pulse1_duty_macro+1, r29
00170a d005                      	rcall sound_driver_channel0_instrument_change_read_header
00170b 93c0 2844                 	sts pulse1_duty_macro_release, r28
00170d 93d0 2843                 	sts pulse1_duty_macro_loop, r29
00170f cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001710 93ef                      	push ZL
001711 93ff                      	push ZH
001712 2fec                      	mov ZL, r28
001713 2ffd                      	mov ZH, r29
001714 0fee                      	lsl ZL
001715 1fff                      	rol ZH
001716 91c5                      	lpm r28, Z+
001717 91d4                      	lpm r29, Z
001718 91ff                      	pop ZH
001719 91ef                      	pop ZL
00171a 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
00171b 93ef                      	push ZL
00171c 93ff                      	push ZH
00171d 2fec                      	mov ZL, r28
00171e 2ffd                      	mov ZH, r29
00171f 0fee                      	lsl ZL
001720 1fff                      	rol ZH
001721 91c5                      	lpm r28, Z+
001722 91d5                      	lpm r29, Z+
001723 93c0 2831                 	sts pulse1_arpeggio_macro_release, r28
001725 93d0 2830                 	sts pulse1_arpeggio_macro_loop, r29
001727 91c4                      	lpm r28, Z
001728 93c0 2832                 	sts pulse1_arpeggio_macro_mode, r28
00172a 91ff                      	pop ZH
00172b 91ef                      	pop ZL
00172c 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
00172d 91b0 282c                 	lds r27, pulse1_volume_macro_release
00172f 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001730 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001731 95b3                      	inc r27
001732 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001734 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
001736 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001737 f019                      	breq sound_driver_channel0_release_pitch
001738 95b3                      	inc r27
001739 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
00173b 91b0 2839                 	lds r27, pulse1_pitch_macro_release
00173d 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00173e f019                      	breq sound_driver_channel0_release_hi_pitch
00173f 95b3                      	inc r27
001740 93b0 2837                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001742 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
001744 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001745 f019                      	breq sound_driver_channel0_release_duty
001746 95b3                      	inc r27
001747 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001749 91b0 2844                 	lds r27, pulse1_duty_macro_release
00174b 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00174c f019                      	breq sound_driver_channel0_release_exit
00174d 95b3                      	inc r27
00174e 93b0 2842                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001750 d026                      	rcall sound_driver_channel0_increment_offset
001751 cd53                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001752 91e0 2818                 	lds ZL, song_frames
001754 91f0 2819                 	lds ZH, song_frames+1
001756 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001758 91b0 281b                 	lds r27, song_frame_offset+1
00175a 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
00175b 93a0 281a                 	sts song_frame_offset, r26
00175d 93b0 281b                 	sts song_frame_offset+1, r27
                                 
00175f 91c0 281c                 	lds r28, song_size
001761 91d0 281d                 	lds r29, song_size+1
001763 17ac                      	cp r26, r28
001764 07bd                      	cpc r27, r29
001765 f010                      	brlo sound_driver_channel0_next_pattern_exists
001766 940c 2dba                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001768 0fea                      	add ZL, r26
001769 1ffb                      	adc ZH, r27
                                 
00176a 91a5                      	lpm r26, Z+ //load the address of the next pattern
00176b 91b4                      	lpm r27, Z
00176c 0faa                      	lsl r26
00176d 1fbb                      	rol r27
00176e 93a0 2822                 	sts pulse1_pattern, r26
001770 93b0 2823                 	sts pulse1_pattern+1, r27
                                 
001772 9220 2826                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001774 9220 2827                 	sts pulse1_pattern_offset+1, zero
001776 cd2e                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001777 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001779 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
00177b 9631                      	adiw Z, 1
00177c 93e0 2826                 	sts pulse1_pattern_offset, ZL
00177e 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
001780 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001781 91e0 2826                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001783 91f0 2827                 	lds ZH, pulse1_pattern_offset+1
001785 9632                      	adiw Z, 2 //increment the pointer twice
001786 93e0 2826                 	sts pulse1_pattern_offset, ZL
001788 93f0 2827                 	sts pulse1_pattern_offset+1, ZH
00178a 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
00178b 95ba                      	dec r27
00178c 93b0 2825                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
00178e 91a0 2875                 	lds r26, pulse2_pattern_delay_rows
001790 91b0 2876                 	lds r27, pulse2_pattern_delay_frames
001792 9610                      	adiw r27:r26, 0
001793 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001794 c2d9                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001795 91e0 2873                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001797 91f0 2874                 	lds ZH, pulse2_pattern+1
001799 91a0 2877                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
00179b 91b0 2878                 	lds r27, pulse2_pattern_offset+1
00179d 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00179e 1ffb                      	adc ZH, r27
00179f 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
0017a0 35b7                      	cpi r27, 0x57
0017a1 f408                      	brsh sound_driver_channel1_check_if_volume
0017a2 c182                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
0017a3 36b7                      	cpi r27, 0x67
0017a4 f408                      	brsh sound_driver_channel1_check_if_delay
0017a5 c1bc                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0017a6 3eb3                      	cpi r27, 0xE3
0017a7 f408                      	brsh sound_driver_channel1_check_if_instrument
0017a8 c1c3                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
0017a9 f409                      	brne sound_driver_channel1_check_if_release
0017aa c1c6                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
0017ab 3eb4                      	cpi r27, 0xE4
0017ac f409                      	brne sound_driver_channel1_check_if_end
0017ad c26f                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
0017ae 3fbf                      	cpi r27, 0xFF
0017af f409                      	brne sound_driver_channel1_check_if_fx
0017b0 c291                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
0017b1 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0017b2 91a4                      	lpm r26, Z //load the fx data into r26
0017b3 d2b0                      	rcall sound_driver_channel1_increment_offset_twice
                                 
0017b4 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0017b5 ede8                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
0017b6 e5fb                      	ldi ZH, HIGH(channel1_fx << 1)
0017b7 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0017b8 0feb                      	add ZL, r27 //add offset
0017b9 1df2                      	adc ZH, zero
0017ba 91c5                      	lpm r28, Z+ //load address bytes
0017bb 91d4                      	lpm r29, Z
0017bc 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0017bd 2ffd                      	mov ZH, r29
0017be 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
0017bf 93a0 2896                 	sts pulse2_fx_0xy_sequence, r26
0017c1 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
0017c3 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
0017c4 9220 289c                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
0017c6 9220 289d                 	sts pulse2_fx_2xx+1, zero
0017c8 9220 2896                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
0017ca 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
0017cc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017cd 937f                      	push r23
0017ce 2f6a                      	mov r22, r26 //store the rate into r22
0017cf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017d0 9f67                      	mul r22, r23
0017d1 917f                      	pop r23
0017d2 916f                      	pop r22
                                 
0017d3 9416                      	lsr r1 //shift out the fractional bits
0017d4 9407                      	ror r0
0017d5 9416                      	lsr r1
0017d6 9407                      	ror r0
0017d7 9416                      	lsr r1
0017d8 9407                      	ror r0
0017d9 9416                      	lsr r1
0017da 9407                      	ror r0
0017db 9200 2898                 	sts pulse2_fx_1xx, r0
0017dd 9210 2899                 	sts pulse2_fx_1xx+1, r1
0017df cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
0017e0 9220 2898                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
0017e2 9220 2899                 	sts pulse2_fx_1xx+1, zero
0017e4 9220 2896                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
0017e6 9220 2897                 	sts pulse2_fx_0xy_sequence+1, zero
0017e8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017e9 937f                      	push r23
0017ea 2f6a                      	mov r22, r26 //store the rate into r22
0017eb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017ec 9f67                      	mul r22, r23
0017ed 917f                      	pop r23
0017ee 916f                      	pop r22
                                 
0017ef 9416                      	lsr r1 //shift out the fractional bits
0017f0 9407                      	ror r0
0017f1 9416                      	lsr r1
0017f2 9407                      	ror r0
0017f3 9416                      	lsr r1
0017f4 9407                      	ror r0
0017f5 9416                      	lsr r1
0017f6 9407                      	ror r0
0017f7 9200 289c                 	sts pulse2_fx_2xx, r0
0017f9 9210 289d                 	sts pulse2_fx_2xx+1, r1
0017fb cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
0017fc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017fd 937f                      	push r23
0017fe 2f6a                      	mov r22, r26 //store the rate into r22
0017ff eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001800 9f67                      	mul r22, r23
001801 917f                      	pop r23
001802 916f                      	pop r22
                                 
001803 9416                      	lsr r1 //shift out the fractional bits
001804 9407                      	ror r0
001805 9416                      	lsr r1
001806 9407                      	ror r0
001807 9416                      	lsr r1
001808 9407                      	ror r0
001809 9416                      	lsr r1
00180a 9407                      	ror r0
00180b 9200 28a4                 	sts pulse2_fx_3xx_speed, r0
00180d 9210 28a5                 	sts pulse2_fx_3xx_speed+1, r1
                                 
00180f 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001810 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001811 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001812 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001814 91b0 0a9d                 	lds r27, TCB1_CCMPH
001816 93a0 28a0                 	sts pulse2_fx_3xx_start, r26
001818 93b0 28a1                 	sts pulse2_fx_3xx_start+1, r27
                                 
00181a 9220 28a6                 	sts pulse2_fx_3xx_total_offset, zero
00181c 9220 28a7                 	sts pulse2_fx_3xx_total_offset+1, zero
00181e cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
00181f 2fba                      	mov r27, r26
001820 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001821 95a2                      	swap r26
001822 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001823 93a0 28a8                 	sts pulse2_fx_4xy_speed, r26
001825 93b0 28a9                 	sts pulse2_fx_4xy_depth, r27
001827 9220 28aa                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001829 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
00182a 2fba                      	mov r27, r26
00182b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00182c 95a2                      	swap r26
00182d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00182e 93a0 28ab                 	sts pulse2_fx_7xy_speed, r26
001830 93b0 28ac                 	sts pulse2_fx_7xy_depth, r27
001832 9220 28ad                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001834 9220 28ae                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001836 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001837 93a0 28af                 	sts pulse2_fx_Axy, r26
001839 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
00183a 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00183c cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
00183d 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00183f cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001840 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001842 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001843 91b0 2808                 	lds r27, pulse2_param
001845 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001846 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001847 93b0 2808                 	sts pulse2_param, r27
001849 6092                      	sbr pulse_channel_flags, 2
00184a cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
00184b 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00184d cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
00184e 15a2                      	cp r26, zero
00184f f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001850 91b0 281e                 	lds r27, song_speed
001852 17ab                      	cp r26, r27
001853 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001854 93a0 28b0                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001856 e0b1                      	ldi r27, 0x01
001857 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
001859 c217                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
00185a cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
00185b cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
00185c cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
00185d cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
00185e cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
00185f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001860 937f                      	push r23
001861 2f6a                      	mov r22, r26
001862 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001863 0367                      	mulsu r22, r23
001864 917f                      	pop r23
001865 916f                      	pop r22
001866 9416                      	lsr r1 //shift out the fractional bits
001867 9407                      	ror r0
001868 9416                      	lsr r1
001869 9407                      	ror r0
00186a 9416                      	lsr r1
00186b 9407                      	ror r0
00186c 9416                      	lsr r1
00186d 9407                      	ror r0
00186e fe13                      	sbrs r1, 3 //check if result was a negative number
00186f c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
001870 efb0                      	ldi r27, 0xF0
001871 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001872 9200 28b2                 	sts pulse2_fx_Pxx_total, r0
001874 9210 28b3                 	sts pulse2_fx_Pxx_total+1, r1
001876 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001877 91e0 287e                 	lds ZL, pulse2_arpeggio_macro
001879 91f0 287f                 	lds ZH, pulse2_arpeggio_macro+1
00187b 9630                      	adiw Z, 0
00187c f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
00187d cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
00187e 91e0 2886                 	lds ZL, pulse2_pitch_macro
001880 91f0 2887                 	lds ZH, pulse2_pitch_macro+1
001882 9630                      	adiw Z, 0
001883 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001884 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001885 91e0 288c                 	lds ZL, pulse2_hi_pitch_macro
001887 91f0 288d                 	lds ZH, pulse2_hi_pitch_macro+1
001889 9630                      	adiw Z, 0
00188a f009                      	breq sound_driver_channel1_fx_Qxy_process
00188b cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
00188c 2fba                      	mov r27, r26 //copy fx parameters into r27
00188d 70bf                      	andi r27, 0x0F //mask note index offset
                                 
00188e 11b2                      	cpse r27, zero
00188f c001                      	rjmp sound_driver_channel1_fx_Qxy_process_refresh
001890 c013                      	rjmp sound_driver_channel1_fx_Qxy_process_speed //if there is no given target note, we only adjust the speed
                                 
                                 sound_driver_channel1_fx_Qxy_process_refresh:
001891 91c0 280f                 	lds r28, pulse2_note //load current note index
001893 0fbc                      	add r27, r28
001894 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001895 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001896 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001897 93b0 28b4                 	sts pulse2_fx_Qxy_target_note, r27
001899 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00189a e0f0                      	ldi ZH, HIGH(note_table << 1)
00189b 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
00189c 0feb                      	add ZL, r27 //add offset
00189d 1df2                      	adc ZH, zero
00189e 91c5                      	lpm r28, Z+ //load bytes
00189f 91d4                      	lpm r29, Z
0018a0 93c0 28b5                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
0018a2 93d0 28b6                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
0018a4 95a2                      	swap r26
0018a5 70af                      	andi r26, 0x0F //mask effect speed
0018a6 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0018a7 95a3                      	inc r26 //increment the speed by 1
                                 
0018a8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018a9 937f                      	push r23
0018aa 2f6a                      	mov r22, r26 //store the speed data into r27
0018ab eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018ac 9f67                      	mul r22, r23
0018ad 917f                      	pop r23
0018ae 916f                      	pop r22
                                 
0018af 9416                      	lsr r1 //shift out the fractional bits
0018b0 9407                      	ror r0
0018b1 9416                      	lsr r1
0018b2 9407                      	ror r0
0018b3 9416                      	lsr r1
0018b4 9407                      	ror r0
0018b5 9416                      	lsr r1
0018b6 9407                      	ror r0
                                 
0018b7 9200 28b7                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
0018b9 9210 28b8                 	sts pulse2_fx_Qxy_speed+1, r1
0018bb ced9                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
0018bc 91e0 287e                 	lds ZL, pulse2_arpeggio_macro
0018be 91f0 287f                 	lds ZH, pulse2_arpeggio_macro+1
0018c0 9630                      	adiw Z, 0
0018c1 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
0018c2 ced2                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
0018c3 91e0 2886                 	lds ZL, pulse2_pitch_macro
0018c5 91f0 2887                 	lds ZH, pulse2_pitch_macro+1
0018c7 9630                      	adiw Z, 0
0018c8 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
0018c9 cecb                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
0018ca 91e0 288c                 	lds ZL, pulse2_hi_pitch_macro
0018cc 91f0 288d                 	lds ZH, pulse2_hi_pitch_macro+1
0018ce 9630                      	adiw Z, 0
0018cf f009                      	breq sound_driver_channel1_fx_Rxy_process
0018d0 cec4                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
0018d1 2fba                      	mov r27, r26 //copy fx parameters into r27
0018d2 70bf                      	andi r27, 0x0F //mask note index offset
                                 
0018d3 11b2                      	cpse r27, zero
0018d4 c001                      	rjmp sound_driver_channel1_fx_Rxy_process_refresh
0018d5 c012                      	rjmp sound_driver_channel1_fx_Rxy_process_speed //if there is no given target note, we only adjust the speed
                                 
                                 sound_driver_channel1_fx_Rxy_process_refresh:
0018d6 91c0 280f                 	lds r28, pulse2_note //load current note index
0018d8 1bcb                      	sub r28, r27
0018d9 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
0018da e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
0018db 93c0 28bb                 	sts pulse2_fx_Rxy_target_note, r28
0018dd e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0018de e0f0                      	ldi ZH, HIGH(note_table << 1)
0018df 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0018e0 0fec                      	add ZL, r28 //add offset
0018e1 1df2                      	adc ZH, zero
0018e2 91c5                      	lpm r28, Z+ //load bytes
0018e3 91d4                      	lpm r29, Z
0018e4 93c0 28bc                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
0018e6 93d0 28bd                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
0018e8 95a2                      	swap r26
0018e9 70af                      	andi r26, 0x0F //mask effect speed
0018ea 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0018eb 95a3                      	inc r26 //increment the speed by 1
                                 
0018ec 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018ed 937f                      	push r23
0018ee 2f6a                      	mov r22, r26 //store the speed data into r27
0018ef eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018f0 9f67                      	mul r22, r23
0018f1 917f                      	pop r23
0018f2 916f                      	pop r22
                                 
0018f3 9416                      	lsr r1 //shift out the fractional bits
0018f4 9407                      	ror r0
0018f5 9416                      	lsr r1
0018f6 9407                      	ror r0
0018f7 9416                      	lsr r1
0018f8 9407                      	ror r0
0018f9 9416                      	lsr r1
0018fa 9407                      	ror r0
                                 
0018fb 9200 28be                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
0018fd 9210 28bf                 	sts pulse2_fx_Rxy_speed+1, r1
0018ff ce95                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001900 15a2                      	cp r26, zero
001901 f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001902 91b0 281e                 	lds r27, song_speed
001904 17ab                      	cp r26, r27
001905 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001906 93a0 28c2                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001908 e0b1                      	ldi r27, 0x01
001909 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
00190b c165                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
00190c ce88                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
00190d eae0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00190e e5fb                      	ldi ZH, HIGH(sequences << 1)
00190f 0fea                      	add ZL, r26 //offset the pointer
001910 1df2                      	adc ZH, zero
                                 
001911 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001912 95a7                      	ror r26
001913 95a7                      	ror r26
001914 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001916 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001917 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001918 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001919 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
00191a ce7a                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
00191b 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
00191c 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00191d 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00191e 93c0 2808                 	sts pulse2_param, r28
001920 ce74                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001921 ce73                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001922 ce72                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001923 ce71                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001924 ce70                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001925 93b0 280f                 	sts pulse2_note, r27 //store the note index
001927 e0a3                      	ldi r26, 0x03
001928 e0b2                      	ldi r27, 0x02
001929 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
00192b 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
00192d 93b0 2888                 	sts pulse2_pitch_macro_offset, r27
00192f 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27
001931 93b0 2893                 	sts pulse2_duty_macro_offset, r27
001933 9220 2884                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001935 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
001937 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero
001939 9220 289a                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00193b 9220 289b                 	sts pulse2_fx_1xx_total+1, zero
00193d 9220 289e                 	sts pulse2_fx_2xx_total, zero
00193f 9220 289f                 	sts pulse2_fx_2xx_total+1, zero
001941 9220 28a6                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001943 9220 28a7                 	sts pulse2_fx_3xx_total_offset+1, zero
001945 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001947 91b0 0a9d                 	lds r27, TCB1_CCMPH
001949 93a0 28a0                 	sts pulse2_fx_3xx_start, r26
00194b 93b0 28a1                 	sts pulse2_fx_3xx_start+1, r27
00194d 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
00194f 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001950 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001952 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
001954 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero
001956 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
001958 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
00195a 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
00195c 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero
00195e 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
001960 d0f9                      	rcall sound_driver_channel1_increment_offset
001961 ce33                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001962 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001963 91a0 2808                 	lds r26, pulse2_param
001965 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001966 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001967 93a0 2808                 	sts pulse2_param, r26
001969 6092                      	sbr pulse_channel_flags, 2
00196a d0ef                      	rcall sound_driver_channel1_increment_offset
00196b ce29                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
00196c 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00196d 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
00196f d0ea                      	rcall sound_driver_channel1_increment_offset
001970 c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001971 9220 2879                 	sts pulse2_volume_macro, zero //reset all macro addresses
001973 9220 287a                 	sts pulse2_volume_macro+1, zero
001975 9220 287e                 	sts pulse2_arpeggio_macro, zero
001977 9220 287f                 	sts pulse2_arpeggio_macro+1, zero
001979 9220 2886                 	sts pulse2_pitch_macro, zero
00197b 9220 2887                 	sts pulse2_pitch_macro+1, zero
00197d 9220 288c                 	sts pulse2_hi_pitch_macro, zero
00197f 9220 288d                 	sts pulse2_hi_pitch_macro+1, zero
001981 9220 2891                 	sts pulse2_duty_macro, zero
001983 9220 2892                 	sts pulse2_duty_macro+1, zero
001985 9220 2884                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001987 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
001989 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
00198b 9631                      	adiw Z, 1 //point to the byte next to the flag
00198c 91b4                      	lpm r27, Z //store the instrument offset into r27
00198d e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
00198e e0fd                      	ldi ZH, HIGH(instruments)
00198f 0feb                      	add ZL, r27 //point Z to offsetted instrument
001990 1df2                      	adc ZH, zero
001991 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001992 1fff                      	rol ZH
001993 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001994 91b4                      	lpm r27, Z
                                 
001995 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001996 1fbb                      	rol r27
001997 2fea                      	mov ZL, r26
001998 2ffb                      	mov ZH, r27
001999 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
00199a 9632                      	adiw Z, 2 //point Z to the address of the macro
00199b e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
00199c 95aa                      	dec r26
00199d f019                      	breq sound_driver_channel1_instrument_change_exit
00199e 95b6                      	lsr r27
00199f f078                      	brcs sound_driver_channel1_instrument_change_load_macro
0019a0 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
0019a1 e0a3                      	ldi r26, 0x03
0019a2 e0b2                      	ldi r27, 0x02
0019a3 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
0019a5 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
0019a7 93b0 2888                 	sts pulse2_pitch_macro_offset, r27
0019a9 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27
0019ab 93b0 2893                 	sts pulse2_duty_macro_offset, r27
0019ad d0b6                      	rcall sound_driver_channel1_increment_offset_twice
0019ae cde6                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
0019af 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0019b0 91d5                      	lpm r29, Z+
                                 
0019b1 30a5                      	cpi r26, 5
0019b2 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
0019b3 30a4                      	cpi r26, 4
0019b4 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
0019b5 30a3                      	cpi r26, 3
0019b6 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
0019b7 30a2                      	cpi r26, 2
0019b8 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
0019b9 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
0019ba 93c0 2879                 	sts pulse2_volume_macro, r28
0019bc 93d0 287a                 	sts pulse2_volume_macro+1, r29
0019be d041                      	rcall sound_driver_channel1_instrument_change_read_header
0019bf 93c0 287d                 	sts pulse2_volume_macro_release, r28
0019c1 93d0 287c                 	sts pulse2_volume_macro_loop, r29
0019c3 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
0019c4 93c0 287e                 	sts pulse2_arpeggio_macro, r28
0019c6 93d0 287f                 	sts pulse2_arpeggio_macro+1, r29
0019c8 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019ca 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0019cc 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0019ce 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0019d0 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
0019d1 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
0019d2 93c0 2886                 	sts pulse2_pitch_macro, r28
0019d4 93d0 2887                 	sts pulse2_pitch_macro+1, r29
0019d6 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019d8 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0019da 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0019dc 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0019de d021                      	rcall sound_driver_channel1_instrument_change_read_header
0019df 93c0 288a                 	sts pulse2_pitch_macro_release, r28
0019e1 93d0 2889                 	sts pulse2_pitch_macro_loop, r29
0019e3 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
0019e4 93c0 288c                 	sts pulse2_hi_pitch_macro, r28
0019e6 93d0 288d                 	sts pulse2_hi_pitch_macro+1, r29
0019e8 9220 28b5                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019ea 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
0019ec 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0019ee 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0019f0 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
0019f1 93c0 2890                 	sts pulse2_hi_pitch_macro_release, r28
0019f3 93d0 288f                 	sts pulse2_hi_pitch_macro_loop, r29
0019f5 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
0019f6 93c0 2891                 	sts pulse2_duty_macro, r28
0019f8 93d0 2892                 	sts pulse2_duty_macro+1, r29
0019fa d005                      	rcall sound_driver_channel1_instrument_change_read_header
0019fb 93c0 2895                 	sts pulse2_duty_macro_release, r28
0019fd 93d0 2894                 	sts pulse2_duty_macro_loop, r29
0019ff cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001a00 93ef                      	push ZL
001a01 93ff                      	push ZH
001a02 2fec                      	mov ZL, r28
001a03 2ffd                      	mov ZH, r29
001a04 0fee                      	lsl ZL
001a05 1fff                      	rol ZH
001a06 91c5                      	lpm r28, Z+
001a07 91d4                      	lpm r29, Z
001a08 91ff                      	pop ZH
001a09 91ef                      	pop ZL
001a0a 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001a0b 93ef                      	push ZL
001a0c 93ff                      	push ZH
001a0d 2fec                      	mov ZL, r28
001a0e 2ffd                      	mov ZH, r29
001a0f 0fee                      	lsl ZL
001a10 1fff                      	rol ZH
001a11 91c5                      	lpm r28, Z+
001a12 91d5                      	lpm r29, Z+
001a13 93c0 2882                 	sts pulse2_arpeggio_macro_release, r28
001a15 93d0 2881                 	sts pulse2_arpeggio_macro_loop, r29
001a17 91c4                      	lpm r28, Z
001a18 93c0 2883                 	sts pulse2_arpeggio_macro_mode, r28
001a1a 91ff                      	pop ZH
001a1b 91ef                      	pop ZL
001a1c 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001a1d 91b0 287d                 	lds r27, pulse2_volume_macro_release
001a1f 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001a20 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001a21 95b3                      	inc r27
001a22 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001a24 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
001a26 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001a27 f019                      	breq sound_driver_channel1_release_pitch
001a28 95b3                      	inc r27
001a29 93b0 2880                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001a2b 91b0 288a                 	lds r27, pulse2_pitch_macro_release
001a2d 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001a2e f019                      	breq sound_driver_channel1_release_hi_pitch
001a2f 95b3                      	inc r27
001a30 93b0 2888                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001a32 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_release
001a34 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001a35 f019                      	breq sound_driver_channel1_release_duty
001a36 95b3                      	inc r27
001a37 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001a39 91b0 2895                 	lds r27, pulse2_duty_macro_release
001a3b 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001a3c f019                      	breq sound_driver_channel1_release_exit
001a3d 95b3                      	inc r27
001a3e 93b0 2893                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001a40 d019                      	rcall sound_driver_channel1_increment_offset
001a41 cd53                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001a42 91e0 2818                 	lds ZL, song_frames
001a44 91f0 2819                 	lds ZH, song_frames+1
001a46 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001a48 91b0 281b                 	lds r27, song_frame_offset+1
001a4a 9612                      	adiw r27:r26, 2 //offset for channel 1
001a4b 0fea                      	add ZL, r26
001a4c 1ffb                      	adc ZH, r27
                                 
001a4d 91a5                      	lpm r26, Z+ //load the address of the next pattern
001a4e 91b4                      	lpm r27, Z
001a4f 0faa                      	lsl r26
001a50 1fbb                      	rol r27
001a51 93a0 2873                 	sts pulse2_pattern, r26
001a53 93b0 2874                 	sts pulse2_pattern+1, r27
                                 
001a55 9220 2877                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001a57 9220 2878                 	sts pulse2_pattern_offset+1, zero
001a59 cd3b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001a5a 91e0 2877                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a5c 91f0 2878                 	lds ZH, pulse2_pattern_offset+1
001a5e 9631                      	adiw Z, 1
001a5f 93e0 2877                 	sts pulse2_pattern_offset, ZL
001a61 93f0 2878                 	sts pulse2_pattern_offset+1, ZH
001a63 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001a64 91e0 2877                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a66 91f0 2878                 	lds ZH, pulse2_pattern_offset+1
001a68 9632                      	adiw Z, 2 //increment the pointer twice
001a69 93e0 2877                 	sts pulse2_pattern_offset, ZL
001a6b 93f0 2878                 	sts pulse2_pattern_offset+1, ZH
001a6d 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001a6e 95ba                      	dec r27
001a6f 93b0 2876                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001a71 91a0 28c6                 	lds r26, triangle_pattern_delay_rows
001a73 91b0 28c7                 	lds r27, triangle_pattern_delay_frames
001a75 9610                      	adiw r27:r26, 0
001a76 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001a77 c2c1                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001a78 91e0 28c4                 	lds ZL, triangle_pattern //current pattern for triangle
001a7a 91f0 28c5                 	lds ZH, triangle_pattern+1
001a7c 91a0 28c8                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001a7e 91b0 28c9                 	lds r27, triangle_pattern_offset+1
001a80 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001a81 1ffb                      	adc ZH, r27
001a82 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001a83 35b7                      	cpi r27, 0x57
001a84 f408                      	brsh sound_driver_channel2_check_if_volume
001a85 c166                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001a86 36b7                      	cpi r27, 0x67
001a87 f408                      	brsh sound_driver_channel2_check_if_delay
001a88 c1a0                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001a89 3eb3                      	cpi r27, 0xE3
001a8a f408                      	brsh sound_driver_channel2_check_if_instrument
001a8b c1ab                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001a8c f409                      	brne sound_driver_channel2_check_if_release
001a8d c1ae                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001a8e 3eb4                      	cpi r27, 0xE4
001a8f f409                      	brne sound_driver_channel2_check_if_end
001a90 c257                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001a91 3fbf                      	cpi r27, 0xFF
001a92 f409                      	brne sound_driver_channel2_check_if_fx
001a93 c279                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001a94 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001a95 91a4                      	lpm r26, Z //load the fx data into r26
001a96 d298                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001a97 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001a98 e0ec                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001a99 e5fc                      	ldi ZH, HIGH(channel2_fx << 1)
001a9a 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001a9b 0feb                      	add ZL, r27 //add offset
001a9c 1df2                      	adc ZH, zero
001a9d 91c5                      	lpm r28, Z+ //load address bytes
001a9e 91d4                      	lpm r29, Z
001a9f 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001aa0 2ffd                      	mov ZH, r29
001aa1 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001aa2 93a0 28e7                 	sts triangle_fx_0xy_sequence, r26
001aa4 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
001aa6 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001aa7 9220 28ed                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001aa9 9220 28ee                 	sts triangle_fx_2xx+1, zero
001aab 9220 28e7                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001aad 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
001aaf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ab0 937f                      	push r23
001ab1 2f6a                      	mov r22, r26 //store the rate into r22
001ab2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ab3 9f67                      	mul r22, r23
001ab4 917f                      	pop r23
001ab5 916f                      	pop r22
                                 
001ab6 9416                      	lsr r1 //shift out the fractional bits
001ab7 9407                      	ror r0
001ab8 9416                      	lsr r1
001ab9 9407                      	ror r0
001aba 9416                      	lsr r1
001abb 9407                      	ror r0
001abc 9416                      	lsr r1
001abd 9407                      	ror r0
001abe 9200 28e9                 	sts triangle_fx_1xx, r0
001ac0 9210 28ea                 	sts triangle_fx_1xx+1, r1
001ac2 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001ac3 9220 28e9                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001ac5 9220 28ea                 	sts triangle_fx_1xx+1, zero
001ac7 9220 28e7                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001ac9 9220 28e8                 	sts triangle_fx_0xy_sequence+1, zero
001acb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001acc 937f                      	push r23
001acd 2f6a                      	mov r22, r26 //store the rate into r22
001ace eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001acf 9f67                      	mul r22, r23
001ad0 917f                      	pop r23
001ad1 916f                      	pop r22
                                 
001ad2 9416                      	lsr r1 //shift out the fractional bits
001ad3 9407                      	ror r0
001ad4 9416                      	lsr r1
001ad5 9407                      	ror r0
001ad6 9416                      	lsr r1
001ad7 9407                      	ror r0
001ad8 9416                      	lsr r1
001ad9 9407                      	ror r0
001ada 9200 28ed                 	sts triangle_fx_2xx, r0
001adc 9210 28ee                 	sts triangle_fx_2xx+1, r1
001ade cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001adf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ae0 937f                      	push r23
001ae1 2f6a                      	mov r22, r26 //store the rate into r22
001ae2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ae3 9f67                      	mul r22, r23
001ae4 917f                      	pop r23
001ae5 916f                      	pop r22
                                 
001ae6 9416                      	lsr r1 //shift out the fractional bits
001ae7 9407                      	ror r0
001ae8 9416                      	lsr r1
001ae9 9407                      	ror r0
001aea 9416                      	lsr r1
001aeb 9407                      	ror r0
001aec 9416                      	lsr r1
001aed 9407                      	ror r0
001aee 9200 28f5                 	sts triangle_fx_3xx_speed, r0
001af0 9210 28f6                 	sts triangle_fx_3xx_speed+1, r1
                                 
001af2 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001af3 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001af4 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001af5 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001af7 91b0 0aad                 	lds r27, TCB2_CCMPH
001af9 93a0 28f1                 	sts triangle_fx_3xx_start, r26
001afb 93b0 28f2                 	sts triangle_fx_3xx_start+1, r27
                                 
001afd 9220 28f7                 	sts triangle_fx_3xx_total_offset, zero
001aff 9220 28f8                 	sts triangle_fx_3xx_total_offset+1, zero
001b01 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001b02 2fba                      	mov r27, r26
001b03 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001b04 95a2                      	swap r26
001b05 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001b06 93a0 28f9                 	sts triangle_fx_4xy_speed, r26
001b08 93b0 28fa                 	sts triangle_fx_4xy_depth, r27
001b0a 9220 28fb                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001b0c cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001b0d cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001b0e cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001b0f 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001b11 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001b12 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001b14 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001b15 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001b17 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001b18 15a2                      	cp r26, zero
001b19 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001b1a e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001b1b 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001b1d cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001b1e 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001b20 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001b22 9220 0aad                 	sts TCB2_CCMPH, zero
001b24 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001b25 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001b27 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001b28 15a2                      	cp r26, zero
001b29 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001b2a 91b0 281e                 	lds r27, song_speed
001b2c 17ab                      	cp r26, r27
001b2d f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001b2e 93a0 28fc                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001b30 e0b1                      	ldi r27, 0x01
001b31 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
001b33 c208                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001b34 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001b35 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001b36 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001b37 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001b38 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001b39 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b3a 937f                      	push r23
001b3b 2f6a                      	mov r22, r26
001b3c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b3d 0367                      	mulsu r22, r23
001b3e 917f                      	pop r23
001b3f 916f                      	pop r22
001b40 9416                      	lsr r1 //shift out the fractional bits
001b41 9407                      	ror r0
001b42 9416                      	lsr r1
001b43 9407                      	ror r0
001b44 9416                      	lsr r1
001b45 9407                      	ror r0
001b46 9416                      	lsr r1
001b47 9407                      	ror r0
001b48 fe13                      	sbrs r1, 3 //check if result was a negative number
001b49 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001b4a efb0                      	ldi r27, 0xF0
001b4b 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001b4c 9200 28fe                 	sts triangle_fx_Pxx_total, r0
001b4e 9210 28ff                 	sts triangle_fx_Pxx_total+1, r1
001b50 cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001b51 91e0 28cf                 	lds ZL, triangle_arpeggio_macro
001b53 91f0 28d0                 	lds ZH, triangle_arpeggio_macro+1
001b55 9630                      	adiw Z, 0
001b56 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001b57 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001b58 91e0 28d7                 	lds ZL, triangle_pitch_macro
001b5a 91f0 28d8                 	lds ZH, triangle_pitch_macro+1
001b5c 9630                      	adiw Z, 0
001b5d f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001b5e cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001b5f 91e0 28dd                 	lds ZL, triangle_hi_pitch_macro
001b61 91f0 28de                 	lds ZH, triangle_hi_pitch_macro+1
001b63 9630                      	adiw Z, 0
001b64 f009                      	breq sound_driver_channel2_fx_Qxy_process
001b65 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001b66 2fba                      	mov r27, r26 //copy fx parameters into r27
001b67 70bf                      	andi r27, 0x0F //mask note index offset
                                 
001b68 11b2                      	cpse r27, zero
001b69 c001                      	rjmp sound_driver_channel2_fx_Qxy_process_refresh
001b6a c013                      	rjmp sound_driver_channel2_fx_Qxy_process_speed //if there is no given target note, we only adjust the speed
                                 
                                 sound_driver_channel2_fx_Qxy_process_refresh:
001b6b 91c0 2812                 	lds r28, triangle_note //load current note index
001b6d 0fbc                      	add r27, r28
001b6e 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001b6f f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001b70 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001b71 93b0 2900                 	sts triangle_fx_Qxy_target_note, r27
001b73 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001b74 e0f0                      	ldi ZH, HIGH(note_table << 1)
001b75 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001b76 0feb                      	add ZL, r27 //add offset
001b77 1df2                      	adc ZH, zero
001b78 91c5                      	lpm r28, Z+ //load bytes
001b79 91d4                      	lpm r29, Z
001b7a 93c0 2901                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001b7c 93d0 2902                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
001b7e 95a2                      	swap r26
001b7f 70af                      	andi r26, 0x0F //mask effect speed
001b80 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b81 95a3                      	inc r26 //increment the speed by 1
                                 
001b82 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b83 937f                      	push r23
001b84 2f6a                      	mov r22, r26 //store the speed data into r27
001b85 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b86 9f67                      	mul r22, r23
001b87 917f                      	pop r23
001b88 916f                      	pop r22
                                 
001b89 9416                      	lsr r1 //shift out the fractional bits
001b8a 9407                      	ror r0
001b8b 9416                      	lsr r1
001b8c 9407                      	ror r0
001b8d 9416                      	lsr r1
001b8e 9407                      	ror r0
001b8f 9416                      	lsr r1
001b90 9407                      	ror r0
                                 
001b91 9200 2903                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001b93 9210 2904                 	sts triangle_fx_Qxy_speed+1, r1
001b95 cee2                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001b96 91e0 28cf                 	lds ZL, triangle_arpeggio_macro
001b98 91f0 28d0                 	lds ZH, triangle_arpeggio_macro+1
001b9a 9630                      	adiw Z, 0
001b9b f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001b9c cedb                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001b9d 91e0 28d7                 	lds ZL, triangle_pitch_macro
001b9f 91f0 28d8                 	lds ZH, triangle_pitch_macro+1
001ba1 9630                      	adiw Z, 0
001ba2 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001ba3 ced4                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001ba4 91e0 28dd                 	lds ZL, triangle_hi_pitch_macro
001ba6 91f0 28de                 	lds ZH, triangle_hi_pitch_macro+1
001ba8 9630                      	adiw Z, 0
001ba9 f009                      	breq sound_driver_channel2_fx_Rxy_process
001baa cecd                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001bab 2fba                      	mov r27, r26 //copy fx parameters into r27
001bac 70bf                      	andi r27, 0x0F //mask note index offset
                                 
001bad 11b2                      	cpse r27, zero
001bae c001                      	rjmp sound_driver_channel2_fx_Rxy_process_refresh
001baf c012                      	rjmp sound_driver_channel2_fx_Rxy_process_speed //if there is no given target note, we only adjust the speed
                                 
                                 sound_driver_channel2_fx_Rxy_process_refresh:
001bb0 91c0 2812                 	lds r28, triangle_note //load current note index
001bb2 1bcb                      	sub r28, r27
001bb3 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001bb4 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001bb5 93c0 2907                 	sts triangle_fx_Rxy_target_note, r28
001bb7 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001bb8 e0f0                      	ldi ZH, HIGH(note_table << 1)
001bb9 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001bba 0fec                      	add ZL, r28 //add offset
001bbb 1df2                      	adc ZH, zero
001bbc 91c5                      	lpm r28, Z+ //load bytes
001bbd 91d4                      	lpm r29, Z
001bbe 93c0 2908                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001bc0 93d0 2909                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
001bc2 95a2                      	swap r26
001bc3 70af                      	andi r26, 0x0F //mask effect speed
001bc4 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001bc5 95a3                      	inc r26 //increment the speed by 1
                                 
001bc6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001bc7 937f                      	push r23
001bc8 2f6a                      	mov r22, r26 //store the speed data into r27
001bc9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001bca 9f67                      	mul r22, r23
001bcb 917f                      	pop r23
001bcc 916f                      	pop r22
                                 
001bcd 9416                      	lsr r1 //shift out the fractional bits
001bce 9407                      	ror r0
001bcf 9416                      	lsr r1
001bd0 9407                      	ror r0
001bd1 9416                      	lsr r1
001bd2 9407                      	ror r0
001bd3 9416                      	lsr r1
001bd4 9407                      	ror r0
                                 
001bd5 9200 290a                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001bd7 9210 290b                 	sts triangle_fx_Rxy_speed+1, r1
001bd9 ce9e                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001bda 15a2                      	cp r26, zero
001bdb f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001bdc 91b0 281e                 	lds r27, song_speed
001bde 17ab                      	cp r26, r27
001bdf f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001be0 93a0 290e                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001be2 e0b1                      	ldi r27, 0x01
001be3 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
001be5 c156                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
001be6 ce91                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001be7 ce90                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001be8 ce8f                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001be9 ce8e                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001bea ce8d                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001beb ce8c                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001bec 93b0 2812                 	sts triangle_note, r27 //store the note index
001bee e0a3                      	ldi r26, 0x03
001bef e0b2                      	ldi r27, 0x02
001bf0 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001bf2 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
001bf4 93b0 28d9                 	sts triangle_pitch_macro_offset, r27
001bf6 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27
001bf8 93b0 28e4                 	sts triangle_duty_macro_offset, r27
001bfa 9220 28d5                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001bfc 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
001bfe 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero
001c00 9220 28eb                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001c02 9220 28ec                 	sts triangle_fx_1xx_total+1, zero
001c04 9220 28ef                 	sts triangle_fx_2xx_total, zero
001c06 9220 28f0                 	sts triangle_fx_2xx_total+1, zero
001c08 9220 28f7                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001c0a 9220 28f8                 	sts triangle_fx_3xx_total_offset+1, zero
001c0c 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001c0e 91b0 0aad                 	lds r27, TCB2_CCMPH
001c10 93a0 28f1                 	sts triangle_fx_3xx_start, r26
001c12 93b0 28f2                 	sts triangle_fx_3xx_start+1, r27
001c14 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c16 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001c18 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero
001c1a 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
001c1c 9220 2908                 	sts triangle_fx_Rxy_target, zero
001c1e 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001c20 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero
001c22 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
001c24 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001c25 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001c27 d0fd                      	rcall sound_driver_channel2_increment_offset
001c28 ce4f                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001c29 d0fb                      	rcall sound_driver_channel2_increment_offset
001c2a 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001c2b f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001c2c e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001c2d 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001c2f ce48                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001c30 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001c32 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001c34 9220 0aad                 	sts TCB2_CCMPH, zero
001c36 ce41                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001c37 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001c38 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
001c3a d0ea                      	rcall sound_driver_channel2_increment_offset
001c3b c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001c3c 9220 28ca                 	sts triangle_volume_macro, zero //reset all macro addresses
001c3e 9220 28cb                 	sts triangle_volume_macro+1, zero
001c40 9220 28cf                 	sts triangle_arpeggio_macro, zero
001c42 9220 28d0                 	sts triangle_arpeggio_macro+1, zero
001c44 9220 28d7                 	sts triangle_pitch_macro, zero
001c46 9220 28d8                 	sts triangle_pitch_macro+1, zero
001c48 9220 28dd                 	sts triangle_hi_pitch_macro, zero
001c4a 9220 28de                 	sts triangle_hi_pitch_macro+1, zero
001c4c 9220 28e2                 	sts triangle_duty_macro, zero
001c4e 9220 28e3                 	sts triangle_duty_macro+1, zero
001c50 9220 28d5                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001c52 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
001c54 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001c56 9631                      	adiw Z, 1 //point to the byte next to the flag
001c57 91b4                      	lpm r27, Z //store the instrument offset into r27
001c58 e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001c59 e0fd                      	ldi ZH, HIGH(instruments)
001c5a 0feb                      	add ZL, r27 //point Z to offsetted instrument
001c5b 1df2                      	adc ZH, zero
001c5c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001c5d 1fff                      	rol ZH
001c5e 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001c5f 91b4                      	lpm r27, Z
                                 
001c60 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001c61 1fbb                      	rol r27
001c62 2fea                      	mov ZL, r26
001c63 2ffb                      	mov ZH, r27
001c64 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001c65 9632                      	adiw Z, 2 //point Z to the address of the macro
001c66 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001c67 95aa                      	dec r26
001c68 f019                      	breq sound_driver_channel2_instrument_change_exit
001c69 95b6                      	lsr r27
001c6a f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001c6b cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001c6c e0a3                      	ldi r26, 0x03
001c6d e0b2                      	ldi r27, 0x02
001c6e 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001c70 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
001c72 93b0 28d9                 	sts triangle_pitch_macro_offset, r27
001c74 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27
001c76 93b0 28e4                 	sts triangle_duty_macro_offset, r27
001c78 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001c79 cdfe                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001c7a 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001c7b 91d5                      	lpm r29, Z+
                                 
001c7c 30a5                      	cpi r26, 5
001c7d f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
001c7e 30a4                      	cpi r26, 4
001c7f f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
001c80 30a3                      	cpi r26, 3
001c81 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
001c82 30a2                      	cpi r26, 2
001c83 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
001c84 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
001c85 93c0 28ca                 	sts triangle_volume_macro, r28
001c87 93d0 28cb                 	sts triangle_volume_macro+1, r29
001c89 d041                      	rcall sound_driver_channel2_instrument_change_read_header
001c8a 93c0 28ce                 	sts triangle_volume_macro_release, r28
001c8c 93d0 28cd                 	sts triangle_volume_macro_loop, r29
001c8e cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
001c8f 93c0 28cf                 	sts triangle_arpeggio_macro, r28
001c91 93d0 28d0                 	sts triangle_arpeggio_macro+1, r29
001c93 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c95 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001c97 9220 2908                 	sts triangle_fx_Rxy_target, zero
001c99 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001c9b d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
001c9c cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
001c9d 93c0 28d7                 	sts triangle_pitch_macro, r28
001c9f 93d0 28d8                 	sts triangle_pitch_macro+1, r29
001ca1 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ca3 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001ca5 9220 2908                 	sts triangle_fx_Rxy_target, zero
001ca7 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001ca9 d021                      	rcall sound_driver_channel2_instrument_change_read_header
001caa 93c0 28db                 	sts triangle_pitch_macro_release, r28
001cac 93d0 28da                 	sts triangle_pitch_macro_loop, r29
001cae cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001caf 93c0 28dd                 	sts triangle_hi_pitch_macro, r28
001cb1 93d0 28de                 	sts triangle_hi_pitch_macro+1, r29
001cb3 9220 2901                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001cb5 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
001cb7 9220 2908                 	sts triangle_fx_Rxy_target, zero
001cb9 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
001cbb d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001cbc 93c0 28e1                 	sts triangle_hi_pitch_macro_release, r28
001cbe 93d0 28e0                 	sts triangle_hi_pitch_macro_loop, r29
001cc0 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
001cc1 93c0 28e2                 	sts triangle_duty_macro, r28
001cc3 93d0 28e3                 	sts triangle_duty_macro+1, r29
001cc5 d005                      	rcall sound_driver_channel2_instrument_change_read_header
001cc6 93c0 28e6                 	sts triangle_duty_macro_release, r28
001cc8 93d0 28e5                 	sts triangle_duty_macro_loop, r29
001cca cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001ccb 93ef                      	push ZL
001ccc 93ff                      	push ZH
001ccd 2fec                      	mov ZL, r28
001cce 2ffd                      	mov ZH, r29
001ccf 0fee                      	lsl ZL
001cd0 1fff                      	rol ZH
001cd1 91c5                      	lpm r28, Z+
001cd2 91d4                      	lpm r29, Z
001cd3 91ff                      	pop ZH
001cd4 91ef                      	pop ZL
001cd5 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
001cd6 93ef                      	push ZL
001cd7 93ff                      	push ZH
001cd8 2fec                      	mov ZL, r28
001cd9 2ffd                      	mov ZH, r29
001cda 0fee                      	lsl ZL
001cdb 1fff                      	rol ZH
001cdc 91c5                      	lpm r28, Z+
001cdd 91d5                      	lpm r29, Z+
001cde 93c0 28d3                 	sts triangle_arpeggio_macro_release, r28
001ce0 93d0 28d2                 	sts triangle_arpeggio_macro_loop, r29
001ce2 91c4                      	lpm r28, Z
001ce3 93c0 28d4                 	sts triangle_arpeggio_macro_mode, r28
001ce5 91ff                      	pop ZH
001ce6 91ef                      	pop ZL
001ce7 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001ce8 91b0 28ce                 	lds r27, triangle_volume_macro_release
001cea 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001ceb f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001cec 95b3                      	inc r27
001ced 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001cef 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
001cf1 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001cf2 f019                      	breq sound_driver_channel2_release_pitch
001cf3 95b3                      	inc r27
001cf4 93b0 28d1                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
001cf6 91b0 28db                 	lds r27, triangle_pitch_macro_release
001cf8 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001cf9 f019                      	breq sound_driver_channel2_release_hi_pitch
001cfa 95b3                      	inc r27
001cfb 93b0 28d9                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001cfd 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_release
001cff 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001d00 f019                      	breq sound_driver_channel2_release_duty
001d01 95b3                      	inc r27
001d02 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
001d04 91b0 28e6                 	lds r27, triangle_duty_macro_release
001d06 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001d07 f019                      	breq sound_driver_channel2_release_exit
001d08 95b3                      	inc r27
001d09 93b0 28e4                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001d0b d019                      	rcall sound_driver_channel2_increment_offset
001d0c cd6b                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001d0d 91e0 2818                 	lds ZL, song_frames
001d0f 91f0 2819                 	lds ZH, song_frames+1
001d11 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001d13 91b0 281b                 	lds r27, song_frame_offset+1
001d15 9614                      	adiw r27:r26, 4 //offset for channel 2
001d16 0fea                      	add ZL, r26
001d17 1ffb                      	adc ZH, r27
                                 
001d18 91a5                      	lpm r26, Z+ //load the address of the next pattern
001d19 91b4                      	lpm r27, Z
001d1a 0faa                      	lsl r26
001d1b 1fbb                      	rol r27
001d1c 93a0 28c4                 	sts triangle_pattern, r26
001d1e 93b0 28c5                 	sts triangle_pattern+1, r27
                                 
001d20 9220 28c8                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001d22 9220 28c9                 	sts triangle_pattern_offset+1, zero
001d24 cd53                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
001d25 91e0 28c8                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001d27 91f0 28c9                 	lds ZH, triangle_pattern_offset+1
001d29 9631                      	adiw Z, 1
001d2a 93e0 28c8                 	sts triangle_pattern_offset, ZL
001d2c 93f0 28c9                 	sts triangle_pattern_offset+1, ZH
001d2e 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001d2f 91e0 28c8                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001d31 91f0 28c9                 	lds ZH, triangle_pattern_offset+1
001d33 9632                      	adiw Z, 2 //increment the pointer twice
001d34 93e0 28c8                 	sts triangle_pattern_offset, ZL
001d36 93f0 28c9                 	sts triangle_pattern_offset+1, ZH
001d38 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001d39 95ba                      	dec r27
001d3a 93b0 28c7                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
001d3c 91a0 2912                 	lds r26, noise_pattern_delay_rows
001d3e 91b0 2913                 	lds r27, noise_pattern_delay_frames
001d40 9610                      	adiw r27:r26, 0
001d41 f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
001d42 c2cf                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
001d43 91e0 2910                 	lds ZL, noise_pattern //current pattern for noise
001d45 91f0 2911                 	lds ZH, noise_pattern+1
001d47 91a0 2914                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
001d49 91b0 2915                 	lds r27, noise_pattern_offset+1
001d4b 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001d4c 1ffb                      	adc ZH, r27
001d4d 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
001d4e 35b7                      	cpi r27, 0x57
001d4f f408                      	brsh sound_driver_channel3_check_if_volume
001d50 c178                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
001d51 36b7                      	cpi r27, 0x67
001d52 f408                      	brsh sound_driver_channel3_check_if_delay
001d53 c1af                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001d54 3eb3                      	cpi r27, 0xE3
001d55 f408                      	brsh sound_driver_channel3_check_if_instrument
001d56 c1b5                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
001d57 f409                      	brne sound_driver_channel3_check_if_release
001d58 c1b8                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
001d59 3eb4                      	cpi r27, 0xE4
001d5a f409                      	brne sound_driver_channel3_check_if_end
001d5b c261                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
001d5c 3fbf                      	cpi r27, 0xFF
001d5d f409                      	brne sound_driver_channel3_check_if_fx
001d5e c283                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
001d5f 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001d60 91a4                      	lpm r26, Z //load the fx data into r26
001d61 d2a6                      	rcall sound_driver_channel3_increment_offset_twice
                                 
001d62 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001d63 e4e0                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
001d64 e5fc                      	ldi ZH, HIGH(channel3_fx << 1)
001d65 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001d66 0feb                      	add ZL, r27 //add offset
001d67 1df2                      	adc ZH, zero
001d68 91c5                      	lpm r28, Z+ //load address bytes
001d69 91d4                      	lpm r29, Z
001d6a 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001d6b 2ffd                      	mov ZH, r29
001d6c 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
001d6d 93a0 2933                 	sts noise_fx_0xy_sequence, r26
001d6f 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001d71 cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
001d72 9220 2939                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
001d74 9220 293a                 	sts noise_fx_2xx+1, zero
001d76 9220 2933                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001d78 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001d7a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d7b 937f                      	push r23
001d7c 2f6a                      	mov r22, r26 //store the rate into r22
001d7d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d7e 9f67                      	mul r22, r23
001d7f 917f                      	pop r23
001d80 916f                      	pop r22
                                 
001d81 9416                      	lsr r1 //shift out the fractional bits
001d82 9407                      	ror r0
001d83 9416                      	lsr r1
001d84 9407                      	ror r0
001d85 9416                      	lsr r1
001d86 9407                      	ror r0
001d87 9416                      	lsr r1
001d88 9407                      	ror r0
001d89 9200 2935                 	sts noise_fx_1xx, r0
001d8b 9210 2936                 	sts noise_fx_1xx+1, r1
001d8d cfb5                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
001d8e 9220 2935                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
001d90 9220 2936                 	sts noise_fx_1xx+1, zero
001d92 9220 2933                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001d94 9220 2934                 	sts noise_fx_0xy_sequence+1, zero
001d96 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d97 937f                      	push r23
001d98 2f6a                      	mov r22, r26 //store the rate into r22
001d99 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d9a 9f67                      	mul r22, r23
001d9b 917f                      	pop r23
001d9c 916f                      	pop r22
                                 
001d9d 9416                      	lsr r1 //shift out the fractional bits
001d9e 9407                      	ror r0
001d9f 9416                      	lsr r1
001da0 9407                      	ror r0
001da1 9416                      	lsr r1
001da2 9407                      	ror r0
001da3 9416                      	lsr r1
001da4 9407                      	ror r0
001da5 9200 2939                 	sts noise_fx_2xx, r0
001da7 9210 293a                 	sts noise_fx_2xx+1, r1
001da9 cf99                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
001daa 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001dab 937f                      	push r23
001dac 2f6a                      	mov r22, r26 //store the rate into r22
001dad eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001dae 9f67                      	mul r22, r23
001daf 917f                      	pop r23
001db0 916f                      	pop r22
                                 
001db1 9416                      	lsr r1 //shift out the fractional bits
001db2 9407                      	ror r0
001db3 9416                      	lsr r1
001db4 9407                      	ror r0
001db5 9416                      	lsr r1
001db6 9407                      	ror r0
001db7 9416                      	lsr r1
001db8 9407                      	ror r0
001db9 9200 2941                 	sts noise_fx_3xx_speed, r0
001dbb 9210 2942                 	sts noise_fx_3xx_speed+1, r1
                                 
001dbd 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001dbe c001                      	rjmp sound_driver_channel3_fx_3xx_enabled
001dbf cf83                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx_enabled:
001dc0 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001dc2 91b0 0abd                 	lds r27, TCB3_CCMPH
001dc4 93a0 293d                 	sts noise_fx_3xx_start, r26
001dc6 93b0 293e                 	sts noise_fx_3xx_start+1, r27
                                 
001dc8 9220 2943                 	sts noise_fx_3xx_total_offset, zero
001dca 9220 2944                 	sts noise_fx_3xx_total_offset+1, zero
001dcc cf76                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
001dcd 2fba                      	mov r27, r26
001dce 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001dcf 95a2                      	swap r26
001dd0 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001dd1 93a0 2945                 	sts noise_fx_4xy_speed, r26
001dd3 93b0 2946                 	sts noise_fx_4xy_depth, r27
001dd5 9220 2947                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
001dd7 cf6b                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
001dd8 2fba                      	mov r27, r26
001dd9 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001dda 95a2                      	swap r26
001ddb 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001ddc 93a0 2948                 	sts noise_fx_7xy_speed, r26
001dde 93b0 2949                 	sts noise_fx_7xy_depth, r27
001de0 9220 294a                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
001de2 9220 294b                 	sts noise_fx_7xy_value, zero //reset the tremelo value
001de4 cf5e                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
001de5 93a0 294c                 	sts noise_fx_Axy, r26
001de7 cf5b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
001de8 93a0 281f                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001dea cf58                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
001deb 93b0 2820                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001ded cf55                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
001dee 93b0 2821                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001df0 cf52                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
001df1 91b0 2813                 	lds r27, noise_param
001df3 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001df4 2bba                      	or r27, r26 //move new VVVV bits into noise_param
001df5 93b0 2813                 	sts noise_param, r27
001df7 cf4b                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
001df8 93a0 281e                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001dfa cf48                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
001dfb 15a2                      	cp r26, zero
001dfc f051                      	breq sound_driver_channel3_fx_Gxx_invalid
001dfd 91b0 281e                 	lds r27, song_speed
001dff 17ab                      	cp r26, r27
001e00 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
001e01 93a0 294d                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001e03 e0b1                      	ldi r27, 0x01
001e04 93b0 2912                 	sts noise_pattern_delay_rows, r27
001e06 c20e                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
001e07 cf3b                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
001e08 cf3a                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
001e09 cf39                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
001e0a cf38                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
001e0b cf37                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
001e0c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e0d 937f                      	push r23
001e0e 2f6a                      	mov r22, r26
001e0f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e10 0367                      	mulsu r22, r23
001e11 917f                      	pop r23
001e12 916f                      	pop r22
001e13 9416                      	lsr r1 //shift out the fractional bits
001e14 9407                      	ror r0
001e15 9416                      	lsr r1
001e16 9407                      	ror r0
001e17 9416                      	lsr r1
001e18 9407                      	ror r0
001e19 9416                      	lsr r1
001e1a 9407                      	ror r0
001e1b fe13                      	sbrs r1, 3 //check if result was a negative number
001e1c c002                      	rjmp sound_driver_channel3_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel3_fx_Pxx_negative:
001e1d efb0                      	ldi r27, 0xF0
001e1e 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel3_fx_Pxx_store:
001e1f 9200 294f                 	sts noise_fx_Pxx_total, r0
001e21 9210 2950                 	sts noise_fx_Pxx_total+1, r1
001e23 cf1f                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel3_fx_Qxy:
                                 sound_driver_channel3_fx_Qxy_check_arpeggio_macro:
001e24 91e0 291b                 	lds ZL, noise_arpeggio_macro
001e26 91f0 291c                 	lds ZH, noise_arpeggio_macro+1
001e28 9630                      	adiw Z, 0
001e29 f009                      	breq sound_driver_channel3_fx_Qxy_check_pitch_macro
001e2a cf18                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_pitch_macro:
001e2b 91e0 2923                 	lds ZL, noise_pitch_macro
001e2d 91f0 2924                 	lds ZH, noise_pitch_macro+1
001e2f 9630                      	adiw Z, 0
001e30 f009                      	breq sound_driver_channel3_fx_Qxy_check_hi_pitch_macro
001e31 cf11                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_check_hi_pitch_macro:
001e32 91e0 2929                 	lds ZL, noise_hi_pitch_macro
001e34 91f0 292a                 	lds ZH, noise_hi_pitch_macro+1
001e36 9630                      	adiw Z, 0
001e37 f009                      	breq sound_driver_channel3_fx_Qxy_process
001e38 cf0a                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Qxy_process:
001e39 2fba                      	mov r27, r26 //copy fx parameters into r27
001e3a 70bf                      	andi r27, 0x0F //mask note index offset
                                 
001e3b 11b2                      	cpse r27, zero
001e3c c001                      	rjmp sound_driver_channel3_fx_Qxy_process_refresh
001e3d c013                      	rjmp sound_driver_channel3_fx_Qxy_process_speed //if there is no given target note, we only adjust the speed
                                 
                                 sound_driver_channel3_fx_Qxy_process_refresh:
001e3e 91c0 2817                 	lds r28, noise_note //load current note index
001e40 0fbc                      	add r27, r28
001e41 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001e42 f008                      	brlo sound_driver_channel3_fx_Qxy_process_continue
001e43 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel3_fx_Qxy_process_continue:
001e44 93b0 2951                 	sts noise_fx_Qxy_target_note, r27
001e46 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001e47 e0f0                      	ldi ZH, HIGH(note_table << 1)
001e48 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001e49 0feb                      	add ZL, r27 //add offset
001e4a 1df2                      	adc ZH, zero
001e4b 91c5                      	lpm r28, Z+ //load bytes
001e4c 91d4                      	lpm r29, Z
001e4d 93c0 2952                 	sts noise_fx_Qxy_target, r28 //load the LOW bits for the target period
001e4f 93d0 2953                 	sts noise_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel3_fx_Qxy_process_speed:
001e51 95a2                      	swap r26
001e52 70af                      	andi r26, 0x0F //mask effect speed
001e53 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e54 95a3                      	inc r26 //increment the speed by 1
                                 
001e55 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e56 937f                      	push r23
001e57 2f6a                      	mov r22, r26 //store the speed data into r27
001e58 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e59 9f67                      	mul r22, r23
001e5a 917f                      	pop r23
001e5b 916f                      	pop r22
                                 
001e5c 9416                      	lsr r1 //shift out the fractional bits
001e5d 9407                      	ror r0
001e5e 9416                      	lsr r1
001e5f 9407                      	ror r0
001e60 9416                      	lsr r1
001e61 9407                      	ror r0
001e62 9416                      	lsr r1
001e63 9407                      	ror r0
                                 
001e64 9200 2954                 	sts noise_fx_Qxy_speed, r0 //store the effect speed
001e66 9210 2955                 	sts noise_fx_Qxy_speed+1, r1
001e68 ceda                      	rjmp sound_driver_channel3_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel3_fx_Rxy:
                                 sound_driver_channel3_fx_Rxy_check_arpeggio_macro:
001e69 91e0 291b                 	lds ZL, noise_arpeggio_macro
001e6b 91f0 291c                 	lds ZH, noise_arpeggio_macro+1
001e6d 9630                      	adiw Z, 0
001e6e f009                      	breq sound_driver_channel3_fx_Rxy_check_pitch_macro
001e6f ced3                      	rjmp sound_driver_channel3_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_pitch_macro:
001e70 91e0 2923                 	lds ZL, noise_pitch_macro
001e72 91f0 2924                 	lds ZH, noise_pitch_macro+1
001e74 9630                      	adiw Z, 0
001e75 f009                      	breq sound_driver_channel3_fx_Rxy_check_hi_pitch_macro
001e76 cecc                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_check_hi_pitch_macro:
001e77 91e0 2929                 	lds ZL, noise_hi_pitch_macro
001e79 91f0 292a                 	lds ZH, noise_hi_pitch_macro+1
001e7b 9630                      	adiw Z, 0
001e7c f009                      	breq sound_driver_channel3_fx_Rxy_process
001e7d cec5                      	rjmp sound_driver_channel3_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel3_fx_Rxy_process:
001e7e 2fba                      	mov r27, r26 //copy fx parameters into r27
001e7f 70bf                      	andi r27, 0x0F //mask note index offset
                                 
001e80 11b2                      	cpse r27, zero
001e81 c001                      	rjmp sound_driver_channel3_fx_Rxy_process_refresh
001e82 c012                      	rjmp sound_driver_channel3_fx_Rxy_process_speed //if there is no given target note, we only adjust the speed
                                 
                                 sound_driver_channel3_fx_Rxy_process_refresh:
001e83 91c0 2817                 	lds r28, noise_note //load current note index
001e85 1bcb                      	sub r28, r27
001e86 f408                      	brcc sound_driver_channel3_fx_Rxy_process_continue
001e87 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel3_fx_Rxy_process_continue:
001e88 93c0 2958                 	sts noise_fx_Rxy_target_note, r28
001e8a e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001e8b e0f0                      	ldi ZH, HIGH(note_table << 1)
001e8c 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001e8d 0fec                      	add ZL, r28 //add offset
001e8e 1df2                      	adc ZH, zero
001e8f 91c5                      	lpm r28, Z+ //load bytes
001e90 91d4                      	lpm r29, Z
001e91 93c0 2959                 	sts noise_fx_Rxy_target, r28 //load the LOW bits for the target period
001e93 93d0 295a                 	sts noise_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel3_fx_Rxy_process_speed:
001e95 95a2                      	swap r26
001e96 70af                      	andi r26, 0x0F //mask effect speed
001e97 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e98 95a3                      	inc r26 //increment the speed by 1
                                 
001e99 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e9a 937f                      	push r23
001e9b 2f6a                      	mov r22, r26 //store the speed data into r27
001e9c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e9d 9f67                      	mul r22, r23
001e9e 917f                      	pop r23
001e9f 916f                      	pop r22
                                 
001ea0 9416                      	lsr r1 //shift out the fractional bits
001ea1 9407                      	ror r0
001ea2 9416                      	lsr r1
001ea3 9407                      	ror r0
001ea4 9416                      	lsr r1
001ea5 9407                      	ror r0
001ea6 9416                      	lsr r1
001ea7 9407                      	ror r0
                                 
001ea8 9200 295b                 	sts noise_fx_Rxy_speed, r0 //store the effect speed
001eaa 9210 295c                 	sts noise_fx_Rxy_speed+1, r1
001eac ce96                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
001ead 15a2                      	cp r26, zero
001eae f051                      	breq sound_driver_channel3_fx_Sxx_invalid
001eaf 91b0 281e                 	lds r27, song_speed
001eb1 17ab                      	cp r26, r27
001eb2 f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
001eb3 93a0 295f                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001eb5 e0b1                      	ldi r27, 0x01
001eb6 93b0 2912                 	sts noise_pattern_delay_rows, r27
001eb8 c15c                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
001eb9 ce89                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
001eba 95a6                      	lsr r26
001ebb 95a7                      	ror r26 //move mode bit to bit 7
001ebc 91b0 2814                 	lds r27, noise_period
001ebe 77bf                      	andi r27, 0b01111111
001ebf 2bba                      	or r27, r26 //store the new noise mode
001ec0 93b0 2813                 	sts noise_param, r27
                                 
001ec2 776f                      	andi noise_sequence_HIGH, 0b01111111
001ec3 2b6a                      	or noise_sequence_HIGH, r26
001ec4 ce7e                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
001ec5 ce7d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
001ec6 ce7c                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
001ec7 ce7b                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
001ec8 ce7a                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
001ec9 93b0 2817                 	sts noise_note, r27 //store the note index
001ecb e0a3                      	ldi r26, 0x03
001ecc e0b2                      	ldi r27, 0x02
001ecd 93b0 2918                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001ecf 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
001ed1 93b0 2925                 	sts noise_pitch_macro_offset, r27
001ed3 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27
001ed5 93b0 2930                 	sts noise_duty_macro_offset, r27
001ed7 9220 2921                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
001ed9 9220 2922                 	sts noise_total_pitch_offset+1, zero
001edb 9220 2928                 	sts noise_total_hi_pitch_offset, zero
001edd 9220 2937                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001edf 9220 2938                 	sts noise_fx_1xx_total+1, zero
001ee1 9220 293b                 	sts noise_fx_2xx_total, zero
001ee3 9220 293c                 	sts noise_fx_2xx_total+1, zero
001ee5 9220 2943                 	sts noise_fx_3xx_total_offset, zero //reset 3xx offset
001ee7 9220 2944                 	sts noise_fx_3xx_total_offset+1, zero
001ee9 91a0 0abc                 	lds r26, TCB3_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001eeb 91b0 0abd                 	lds r27, TCB3_CCMPH
001eed 93a0 293d                 	sts noise_fx_3xx_start, r26
001eef 93b0 293e                 	sts noise_fx_3xx_start+1, r27
001ef1 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ef3 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001ef5 9220 2956                 	sts noise_fx_Qxy_total_offset, zero
001ef7 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
001ef9 9220 2959                 	sts noise_fx_Rxy_target, zero
001efb 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001efd 9220 295d                 	sts noise_fx_Rxy_total_offset, zero
001eff 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
001f01 d0fc                      	rcall sound_driver_channel3_increment_offset
001f02 ce40                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
001f03 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001f04 91a0 2813                 	lds r26, noise_param
001f06 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001f07 2bab                      	or r26, r27 //move new VVVV bits into noise_param
001f08 93a0 2813                 	sts noise_param, r26
001f0a d0f3                      	rcall sound_driver_channel3_increment_offset
001f0b ce37                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
001f0c 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001f0d 93b0 2912                 	sts noise_pattern_delay_rows, r27
001f0f d0ee                      	rcall sound_driver_channel3_increment_offset
001f10 c104                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
001f11 9220 2916                 	sts noise_volume_macro, zero //reset all macro addresses
001f13 9220 2917                 	sts noise_volume_macro+1, zero
001f15 9220 291b                 	sts noise_arpeggio_macro, zero
001f17 9220 291c                 	sts noise_arpeggio_macro+1, zero
001f19 9220 2923                 	sts noise_pitch_macro, zero
001f1b 9220 2924                 	sts noise_pitch_macro+1, zero
001f1d 9220 2929                 	sts noise_hi_pitch_macro, zero
001f1f 9220 292a                 	sts noise_hi_pitch_macro+1, zero
001f21 9220 292e                 	sts noise_duty_macro, zero
001f23 9220 292f                 	sts noise_duty_macro+1, zero
001f25 9220 2921                 	sts noise_total_pitch_offset, zero //reset the pitch offset
001f27 9220 2922                 	sts noise_total_pitch_offset+1, zero
001f29 9220 2928                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001f2b 9631                      	adiw Z, 1 //point to the byte next to the flag
001f2c 91b4                      	lpm r27, Z //store the instrument offset into r27
001f2d e2ef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001f2e e0fd                      	ldi ZH, HIGH(instruments)
001f2f 0feb                      	add ZL, r27 //point Z to offsetted instrument
001f30 1df2                      	adc ZH, zero
001f31 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001f32 1fff                      	rol ZH
001f33 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001f34 91b4                      	lpm r27, Z
                                 
001f35 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001f36 1fbb                      	rol r27
001f37 2fea                      	mov ZL, r26
001f38 2ffb                      	mov ZH, r27
001f39 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001f3a 9632                      	adiw Z, 2 //point Z to the address of the macro
001f3b e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
001f3c 95aa                      	dec r26
001f3d f019                      	breq sound_driver_channel3_instrument_change_exit
001f3e 95b6                      	lsr r27
001f3f f078                      	brcs sound_driver_channel3_instrument_change_load_macro
001f40 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
001f41 e0a3                      	ldi r26, 0x03
001f42 e0b2                      	ldi r27, 0x02
001f43 93b0 2918                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
001f45 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
001f47 93b0 2925                 	sts noise_pitch_macro_offset, r27
001f49 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27
001f4b 93b0 2930                 	sts noise_duty_macro_offset, r27
001f4d d0ba                      	rcall sound_driver_channel3_increment_offset_twice
001f4e cdf4                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
001f4f 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001f50 91d5                      	lpm r29, Z+
                                 
001f51 30a5                      	cpi r26, 5
001f52 f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
001f53 30a4                      	cpi r26, 4
001f54 f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
001f55 30a3                      	cpi r26, 3
001f56 f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
001f57 30a2                      	cpi r26, 2
001f58 f159                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
001f59 c03c                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
001f5a 93c0 2916                 	sts noise_volume_macro, r28
001f5c 93d0 2917                 	sts noise_volume_macro+1, r29
001f5e d041                      	rcall sound_driver_channel3_instrument_change_read_header
001f5f 93c0 291a                 	sts noise_volume_macro_release, r28
001f61 93d0 2919                 	sts noise_volume_macro_loop, r29
001f63 cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
001f64 93c0 291b                 	sts noise_arpeggio_macro, r28
001f66 93d0 291c                 	sts noise_arpeggio_macro+1, r29
001f68 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f6a 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001f6c 9220 2959                 	sts noise_fx_Rxy_target, zero
001f6e 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f70 d03a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
001f71 cfca                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
001f72 93c0 2923                 	sts noise_pitch_macro, r28
001f74 93d0 2924                 	sts noise_pitch_macro+1, r29
001f76 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f78 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001f7a 9220 2959                 	sts noise_fx_Rxy_target, zero
001f7c 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f7e d021                      	rcall sound_driver_channel3_instrument_change_read_header
001f7f 93c0 2927                 	sts noise_pitch_macro_release, r28
001f81 93d0 2926                 	sts noise_pitch_macro_loop, r29
001f83 cfb8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
001f84 93c0 2929                 	sts noise_hi_pitch_macro, r28
001f86 93d0 292a                 	sts noise_hi_pitch_macro+1, r29
001f88 9220 2952                 	sts noise_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f8a 9220 2953                 	sts noise_fx_Qxy_target+1, zero
001f8c 9220 2959                 	sts noise_fx_Rxy_target, zero
001f8e 9220 295a                 	sts noise_fx_Rxy_target+1, zero
001f90 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
001f91 93c0 292d                 	sts noise_hi_pitch_macro_release, r28
001f93 93d0 292c                 	sts noise_hi_pitch_macro_loop, r29
001f95 cfa6                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
001f96 93c0 292e                 	sts noise_duty_macro, r28
001f98 93d0 292f                 	sts noise_duty_macro+1, r29
001f9a d005                      	rcall sound_driver_channel3_instrument_change_read_header
001f9b 93c0 2932                 	sts noise_duty_macro_release, r28
001f9d 93d0 2931                 	sts noise_duty_macro_loop, r29
001f9f cf9c                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
001fa0 93ef                      	push ZL
001fa1 93ff                      	push ZH
001fa2 2fec                      	mov ZL, r28
001fa3 2ffd                      	mov ZH, r29
001fa4 0fee                      	lsl ZL
001fa5 1fff                      	rol ZH
001fa6 91c5                      	lpm r28, Z+
001fa7 91d4                      	lpm r29, Z
001fa8 91ff                      	pop ZH
001fa9 91ef                      	pop ZL
001faa 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
001fab 93ef                      	push ZL
001fac 93ff                      	push ZH
001fad 2fec                      	mov ZL, r28
001fae 2ffd                      	mov ZH, r29
001faf 0fee                      	lsl ZL
001fb0 1fff                      	rol ZH
001fb1 91c5                      	lpm r28, Z+
001fb2 91d5                      	lpm r29, Z+
001fb3 93c0 291f                 	sts noise_arpeggio_macro_release, r28
001fb5 93d0 291e                 	sts noise_arpeggio_macro_loop, r29
001fb7 91c4                      	lpm r28, Z
001fb8 93c0 2920                 	sts noise_arpeggio_macro_mode, r28
001fba 91ff                      	pop ZH
001fbb 91ef                      	pop ZL
001fbc 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
001fbd 91b0 291a                 	lds r27, noise_volume_macro_release
001fbf 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001fc0 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
001fc1 95b3                      	inc r27
001fc2 93b0 2918                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
001fc4 91b0 291f                 	lds r27, noise_arpeggio_macro_release
001fc6 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001fc7 f019                      	breq sound_driver_channel3_release_pitch
001fc8 95b3                      	inc r27
001fc9 93b0 291d                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
001fcb 91b0 2927                 	lds r27, noise_pitch_macro_release
001fcd 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001fce f019                      	breq sound_driver_channel3_release_hi_pitch
001fcf 95b3                      	inc r27
001fd0 93b0 2925                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
001fd2 91b0 292d                 	lds r27, noise_hi_pitch_macro_release
001fd4 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001fd5 f019                      	breq sound_driver_channel3_release_duty
001fd6 95b3                      	inc r27
001fd7 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
001fd9 91b0 2932                 	lds r27, noise_duty_macro_release
001fdb 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001fdc f019                      	breq sound_driver_channel3_release_exit
001fdd 95b3                      	inc r27
001fde 93b0 2930                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
001fe0 d01d                      	rcall sound_driver_channel3_increment_offset
001fe1 cd61                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
001fe2 91e0 2818                 	lds ZL, song_frames
001fe4 91f0 2819                 	lds ZH, song_frames+1
001fe6 91a0 281a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001fe8 91b0 281b                 	lds r27, song_frame_offset+1
001fea 93a0 281a                 	sts song_frame_offset, r26
001fec 93b0 281b                 	sts song_frame_offset+1, r27
001fee 9616                      	adiw r27:r26, 6 //offset for channel 3
001fef 0fea                      	add ZL, r26
001ff0 1ffb                      	adc ZH, r27
                                 
001ff1 91a5                      	lpm r26, Z+ //load the address of the next pattern
001ff2 91b4                      	lpm r27, Z
001ff3 0faa                      	lsl r26
001ff4 1fbb                      	rol r27
001ff5 93a0 2910                 	sts noise_pattern, r26
001ff7 93b0 2911                 	sts noise_pattern+1, r27
                                 
001ff9 9220 2914                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001ffb 9220 2915                 	sts noise_pattern_offset+1, zero
001ffd cd45                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
001ffe 91e0 2914                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002000 91f0 2915                 	lds ZH, noise_pattern_offset+1
002002 9631                      	adiw Z, 1
002003 93e0 2914                 	sts noise_pattern_offset, ZL
002005 93f0 2915                 	sts noise_pattern_offset+1, ZH
002007 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002008 91e0 2914                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
00200a 91f0 2915                 	lds ZH, noise_pattern_offset+1
00200c 9632                      	adiw Z, 2 //increment the pointer twice
00200d 93e0 2914                 	sts noise_pattern_offset, ZL
00200f 93f0 2915                 	sts noise_pattern_offset+1, ZH
002011 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
002012 95ba                      	dec r27
002013 93b0 2913                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
002015 91f0 281e                 	lds r31, song_speed
002017 2fef                      	mov r30, r31
002018 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
002019 91a0 2825                 	lds r26, pulse1_pattern_delay_frames
00201b 11a2                      	cpse r26, zero
00201c c042                      	rjmp sound_driver_calculate_delays_pulse2
00201d c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
00201e 2faf                      	mov r26, r31 //move the speed to r26
00201f 91b0 2824                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002021 15b2                      	cp r27, zero
002022 f409                      	brne PC+2
002023 c03b                      	rjmp sound_driver_calculate_delays_pulse2
002024 95ba                      	dec r27
002025 93b0 2824                 	sts pulse1_pattern_delay_rows, r27
002027 11b2                      	cpse r27, zero
002028 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
002029 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
00202a efbf                      	ldi r27, 0xFF
00202b 91c0 2871                 	lds r28, pulse1_fx_Sxx_pre
00202d 91d0 2872                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
00202f 17cb                      	cp r28, r27
002030 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002031 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
002032 17db                      	cp r29, r27
002033 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
002034 c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
002035 91c0 285f                 	lds r28, pulse1_fx_Gxx_pre
002037 91d0 2860                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
002039 17cb                      	cp r28, r27
00203a f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
00203b c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
00203c 17db                      	cp r29, r27
00203d f0f9                      	breq sound_driver_calculate_delays_pulse1_store
00203e c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
00203f 93b0 2871                 	sts pulse1_fx_Sxx_pre, r27
002041 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002042 93e0 2872                 	sts pulse1_fx_Sxx_post, r30
002044 95ca                      	dec r28
002045 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
002047 2fef                      	mov r30, r31
002048 50e1                      	subi r30, 1
002049 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
00204a 93b0 2872                 	sts pulse1_fx_Sxx_post, r27
00204c 2fad                      	mov r26, r29
00204d c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
00204e 93b0 285f                 	sts pulse1_fx_Gxx_pre, r27
002050 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002051 93e0 2860                 	sts pulse1_fx_Gxx_post, r30
002053 95ca                      	dec r28
002054 93c0 2825                 	sts pulse1_pattern_delay_frames, r28
002056 2fef                      	mov r30, r31
002057 50e1                      	subi r30, 1
002058 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
002059 93b0 2860                 	sts pulse1_fx_Gxx_post, r27
00205b 2fad                      	mov r26, r29
00205c c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
00205d 93a0 2825                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
00205f 91a0 2876                 	lds r26, pulse2_pattern_delay_frames
002061 11a2                      	cpse r26, zero
002062 c042                      	rjmp sound_driver_calculate_delays_triangle
002063 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
002064 2faf                      	mov r26, r31 //move the speed to r26
002065 91b0 2875                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
002067 15b2                      	cp r27, zero
002068 f409                      	brne PC+2
002069 c03b                      	rjmp sound_driver_calculate_delays_triangle
00206a 95ba                      	dec r27
00206b 93b0 2875                 	sts pulse2_pattern_delay_rows, r27
00206d 11b2                      	cpse r27, zero
00206e c034                      	rjmp sound_driver_calculate_delays_pulse2_store
00206f 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
002070 efbf                      	ldi r27, 0xFF
002071 91c0 28c2                 	lds r28, pulse2_fx_Sxx_pre
002073 91d0 28c3                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
002075 17cb                      	cp r28, r27
002076 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
002077 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
002078 17db                      	cp r29, r27
002079 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
00207a c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
00207b 91c0 28b0                 	lds r28, pulse2_fx_Gxx_pre
00207d 91d0 28b1                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
00207f 17cb                      	cp r28, r27
002080 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
002081 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
002082 17db                      	cp r29, r27
002083 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
002084 c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
002085 93b0 28c2                 	sts pulse2_fx_Sxx_pre, r27
002087 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002088 93e0 28c3                 	sts pulse2_fx_Sxx_post, r30
00208a 95ca                      	dec r28
00208b 93c0 2876                 	sts pulse2_pattern_delay_frames, r28
00208d 2fef                      	mov r30, r31
00208e 50e1                      	subi r30, 1
00208f cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
002090 93b0 28c3                 	sts pulse2_fx_Sxx_post, r27
002092 2fad                      	mov r26, r29
002093 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
002094 93b0 28b0                 	sts pulse2_fx_Gxx_pre, r27
002096 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002097 93e0 28b1                 	sts pulse2_fx_Gxx_post, r30
002099 95ca                      	dec r28
00209a 93c0 2876                 	sts pulse2_pattern_delay_frames, r28
00209c 2fef                      	mov r30, r31
00209d 50e1                      	subi r30, 1
00209e cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
00209f 93b0 28b1                 	sts pulse2_fx_Gxx_post, r27
0020a1 2fad                      	mov r26, r29
0020a2 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
0020a3 93a0 2876                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
0020a5 91a0 28c7                 	lds r26, triangle_pattern_delay_frames
0020a7 11a2                      	cpse r26, zero
0020a8 c042                      	rjmp sound_driver_calculate_delays_noise
0020a9 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
0020aa 2faf                      	mov r26, r31 //move the speed to r26
0020ab 91b0 28c6                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
0020ad 15b2                      	cp r27, zero
0020ae f409                      	brne PC+2
0020af c03b                      	rjmp sound_driver_calculate_delays_noise
0020b0 95ba                      	dec r27
0020b1 93b0 28c6                 	sts triangle_pattern_delay_rows, r27
0020b3 11b2                      	cpse r27, zero
0020b4 c034                      	rjmp sound_driver_calculate_delays_triangle_store
0020b5 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
0020b6 efbf                      	ldi r27, 0xFF
0020b7 91c0 290e                 	lds r28, triangle_fx_Sxx_pre
0020b9 91d0 290f                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
0020bb 17cb                      	cp r28, r27
0020bc f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
0020bd c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
0020be 17db                      	cp r29, r27
0020bf f009                      	breq sound_driver_calculate_delays_triangle_Gxx
0020c0 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
0020c1 91c0 28fc                 	lds r28, triangle_fx_Gxx_pre
0020c3 91d0 28fd                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
0020c5 17cb                      	cp r28, r27
0020c6 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
0020c7 c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
0020c8 17db                      	cp r29, r27
0020c9 f0f9                      	breq sound_driver_calculate_delays_triangle_store
0020ca c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
0020cb 93b0 290e                 	sts triangle_fx_Sxx_pre, r27
0020cd 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020ce 93e0 290f                 	sts triangle_fx_Sxx_post, r30
0020d0 95ca                      	dec r28
0020d1 93c0 28c7                 	sts triangle_pattern_delay_frames, r28
0020d3 2fef                      	mov r30, r31
0020d4 50e1                      	subi r30, 1
0020d5 c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
0020d6 93b0 290f                 	sts triangle_fx_Sxx_post, r27
0020d8 2fad                      	mov r26, r29
0020d9 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
0020da 93b0 28fc                 	sts triangle_fx_Gxx_pre, r27
0020dc 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020dd 93e0 28fd                 	sts triangle_fx_Gxx_post, r30
0020df 95ca                      	dec r28
0020e0 93c0 28c7                 	sts triangle_pattern_delay_frames, r28
0020e2 2fef                      	mov r30, r31
0020e3 50e1                      	subi r30, 1
0020e4 c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
0020e5 93b0 28fd                 	sts triangle_fx_Gxx_post, r27
0020e7 2fad                      	mov r26, r29
0020e8 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
0020e9 93a0 28c7                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
0020eb 91a0 2913                 	lds r26, noise_pattern_delay_frames
0020ed 11a2                      	cpse r26, zero
0020ee c042                      	rjmp sound_driver_calculate_delays_dpcm
0020ef c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
0020f0 2faf                      	mov r26, r31 //move the speed to r26
0020f1 91b0 2912                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
0020f3 15b2                      	cp r27, zero
0020f4 f409                      	brne PC+2
0020f5 c03b                      	rjmp sound_driver_calculate_delays_dpcm
0020f6 95ba                      	dec r27
0020f7 93b0 2912                 	sts noise_pattern_delay_rows, r27
0020f9 11b2                      	cpse r27, zero
0020fa c034                      	rjmp sound_driver_calculate_delays_noise_store
0020fb 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
0020fc efbf                      	ldi r27, 0xFF
0020fd 91c0 295f                 	lds r28, noise_fx_Sxx_pre
0020ff 91d0 2960                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
002101 17cb                      	cp r28, r27
002102 f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
002103 c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
002104 17db                      	cp r29, r27
002105 f009                      	breq sound_driver_calculate_delays_noise_Gxx
002106 c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
002107 91c0 294d                 	lds r28, noise_fx_Gxx_pre
002109 91d0 294e                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
00210b 17cb                      	cp r28, r27
00210c f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
00210d c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
00210e 17db                      	cp r29, r27
00210f f0f9                      	breq sound_driver_calculate_delays_noise_store
002110 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
002111 93b0 295f                 	sts noise_fx_Sxx_pre, r27
002113 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002114 93e0 2960                 	sts noise_fx_Sxx_post, r30
002116 95ca                      	dec r28
002117 93c0 2913                 	sts noise_pattern_delay_frames, r28
002119 2fef                      	mov r30, r31
00211a 50e1                      	subi r30, 1
00211b c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
00211c 93b0 2960                 	sts noise_fx_Sxx_post, r27
00211e 2fad                      	mov r26, r29
00211f c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002120 93b0 294d                 	sts noise_fx_Gxx_pre, r27
002122 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002123 93e0 294e                 	sts noise_fx_Gxx_post, r30
002125 95ca                      	dec r28
002126 93c0 2913                 	sts noise_pattern_delay_frames, r28
002128 2fef                      	mov r30, r31
002129 50e1                      	subi r30, 1
00212a c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
00212b 93b0 294e                 	sts noise_fx_Gxx_post, r27
00212d 2fad                      	mov r26, r29
00212e c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
00212f 93a0 2913                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002131 91e0 2828                 	lds ZL, pulse1_volume_macro
002133 91f0 2829                 	lds ZH, pulse1_volume_macro+1
002135 9630                      	adiw Z, 0
002136 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
002137 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002138 1fff                      	rol ZH
002139 91a0 282a                 	lds r26, pulse1_volume_macro_offset
00213b 0fea                      	add ZL, r26
00213c 1df2                      	adc ZH, zero
                                 
00213d 91b0 282c                 	lds r27, pulse1_volume_macro_release
00213f 17ba                      	cp r27, r26
002140 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
002141 91a0 282b                 	lds r26, pulse1_volume_macro_loop
002143 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002144 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002145 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
002146 95a3                      	inc r26 //increment the macro offset
002147 93a0 282a                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
002149 91b4                      	lpm r27, Z //load volume data into r27
00214a 3fbf                      	cpi r27, 0xFF //check for macro end flag
00214b f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
00214c 91b0 282c                 	lds r27, pulse1_volume_macro_release
00214e 3fbf                      	cpi r27, 0xFF
00214f f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
002150 91b0 282b                 	lds r27, pulse1_volume_macro_loop //load the loop index
002152 93b0 282a                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
002154 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
002155 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002156 93a0 282a                 	sts pulse1_volume_macro_offset, r26
002158 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
002159 e7e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
00215a e5fc                      	ldi ZH, HIGH(volumes << 1)
00215b 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
00215c 0feb                      	add ZL, r27 //add offset to the table
00215d 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
00215e 91b0 2800                 	lds r27, pulse1_param //load main volume
002160 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002161 91a0 285d                 	lds r26, pulse1_fx_7xy_value
002163 30a0                      	cpi r26, 0x00
002164 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
002165 0feb                      	add ZL, r27 //offset the volume table by the main volume
002166 1df2                      	adc ZH, zero
002167 91b4                      	lpm r27, Z
002168 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00216a c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
00216b 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
00216d 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00216e 91a0 285d                 	lds r26, pulse1_fx_7xy_value
002170 30a0                      	cpi r26, 0x00
002171 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
002172 93b0 2806                 	sts pulse1_output_volume, r27
002174 c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
002175 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002176 f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
002177 f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
002178 0feb                      	add ZL, r27 //offset the volume table by the main volume
002179 1df2                      	adc ZH, zero
00217a 91b4                      	lpm r27, Z
00217b 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00217d c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
00217e e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00217f 0feb                      	add ZL, r27 //offset the volume table by the main volume
002180 1df2                      	adc ZH, zero
002181 91b4                      	lpm r27, Z
002182 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002184 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
002185 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002186 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002187 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002188 93b0 2806                 	sts pulse1_output_volume, r27
00218a c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
00218b e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00218c 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00218e 91e0 282d                 	lds ZL, pulse1_arpeggio_macro
002190 91f0 282e                 	lds ZH, pulse1_arpeggio_macro+1
002192 9630                      	adiw Z, 0
002193 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002194 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002195 1fff                      	rol ZH
002196 91a0 282f                 	lds r26, pulse1_arpeggio_macro_offset
002198 0fea                      	add ZL, r26
002199 1df2                      	adc ZH, zero
                                 
00219a 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
00219c 17ba                      	cp r27, r26
00219d f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00219e 91a0 2830                 	lds r26, pulse1_arpeggio_macro_loop
0021a0 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0021a1 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0021a2 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
0021a3 95a3                      	inc r26 //increment the macro offset
0021a4 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
0021a6 91b4                      	lpm r27, Z //load arpeggio data into r27
0021a7 38b0                      	cpi r27, 0x80 //check for macro end flag
0021a8 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
0021a9 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0021aa 50a1                      	subi r26, 1 //keep the offset at the end flag
0021ab 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26
0021ad 91b0 2832                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0021af 30b1                      	cpi r27, 0x01
0021b0 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0021b1 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
0021b3 3fbf                      	cpi r27, 0xFF
0021b4 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0021b5 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop
0021b7 3fbf                      	cpi r27, 0xFF
0021b8 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0021b9 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0021ba 91b0 2831                 	lds r27, pulse1_arpeggio_macro_release
0021bc 3fbf                      	cpi r27, 0xFF
0021bd f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0021be 91b0 2830                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0021c0 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0021c1 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0021c2 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0021c4 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
0021c6 9620                      	adiw r29:r28, 0
0021c7 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0021c8 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0021c9 93a0 282f                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0021cb cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0021cc 93b0 282f                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0021ce cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0021cf 91c0 2845                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0021d1 91d0 2846                 	lds r29, pulse1_fx_0xy_sequence+1
0021d3 9620                      	adiw r29:r28, 0 //check for 0xy effect
0021d4 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
0021d5 95d6                      	lsr r29
0021d6 95c7                      	ror r28
0021d7 95d7                      	ror r29
0021d8 95c7                      	ror r28
0021d9 95d7                      	ror r29
0021da 95c7                      	ror r28
0021db 95d7                      	ror r29
0021dc 95c7                      	ror r28
0021dd 95d7                      	ror r29
0021de 95d2                      	swap r29
                                 
0021df 93c0 2845                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0021e1 93d0 2846                 	sts pulse1_fx_0xy_sequence+1, r29
0021e3 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0021e4 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021e6 0fac                      	add r26, r28 //add the note offset
0021e7 c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0021e8 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021ea c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0021eb 9220 2833                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0021ed 9220 2834                 	sts pulse1_total_pitch_offset+1, zero
0021ef 9220 283a                 	sts pulse1_total_hi_pitch_offset, zero
0021f1 91a0 2832                 	lds r26, pulse1_arpeggio_macro_mode
0021f3 30a1                      	cpi r26, 0x01 //absolute mode
0021f4 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0021f5 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0021f6 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0021f7 91a0 2807                 	lds r26, pulse1_note //load the current note index
0021f9 0fab                      	add r26, r27 //offset the note with the arpeggio data
0021fa fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0021fb c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0021fc 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0021fd f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0021fe e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0021ff c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
002200 fda7                      	sbrc r26, 7 //check if result is negative
002201 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002202 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
002203 2fab                      	mov r26, r27 //move the arpeggio data into r26
002204 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
002205 91a0 2807                 	lds r26, pulse1_note //load the current note index
002207 0fab                      	add r26, r27 //offset the note with the arpeggio data
002208 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002209 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
00220a 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
00220c 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00220d f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
00220e e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00220f 93a0 2807                 	sts pulse1_note, r26
002211 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
002212 fda7                      	sbrc r26, 7 //check if result is negative
002213 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002214 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
002216 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002217 e0f0                      	ldi ZH, HIGH(note_table << 1)
002218 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002219 0fea                      	add ZL, r26 //add offset
00221a 1df2                      	adc ZH, zero
00221b 91a5                      	lpm r26, Z+ //load bytes
00221c 91b4                      	lpm r27, Z
00221d 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
00221f 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002221 93a0 2851                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002223 93b0 2852                 	sts pulse1_fx_3xx_target+1, r27
002225 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
002226 91e0 2835                 	lds ZL, pulse1_pitch_macro
002228 91f0 2836                 	lds ZH, pulse1_pitch_macro+1
00222a 9630                      	adiw Z, 0
00222b f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
00222c c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
00222d 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00222e 1fff                      	rol ZH
00222f 91a0 2837                 	lds r26, pulse1_pitch_macro_offset
002231 0fea                      	add ZL, r26
002232 1df2                      	adc ZH, zero
                                 
002233 91b0 2839                 	lds r27, pulse1_pitch_macro_release
002235 17ba                      	cp r27, r26
002236 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
002237 91a0 2838                 	lds r26, pulse1_pitch_macro_loop
002239 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00223a f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00223b c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
00223c 95a3                      	inc r26 //increment the macro offset
00223d 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
00223f 91b4                      	lpm r27, Z //load pitch data into r27
002240 38b0                      	cpi r27, 0x80 //check for macro end flag
002241 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
002242 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002243 93a0 2837                 	sts pulse1_pitch_macro_offset, r26
002245 91b0 2839                 	lds r27, pulse1_pitch_macro_release
002247 3fbf                      	cpi r27, 0xFF
002248 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
002249 91b0 2838                 	lds r27, pulse1_pitch_macro_loop //load the loop index
00224b 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00224c f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00224d 93b0 2837                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
00224f cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002250 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002251 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002252 937f                      	push r23
002253 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002254 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002255 0367                      	mulsu r22, r23
002256 917f                      	pop r23
002257 916f                      	pop r22
                                 
002258 9416                      	lsr r1 //shift out the fractional bits
002259 9407                      	ror r0
00225a 9416                      	lsr r1
00225b 9407                      	ror r0
00225c 9416                      	lsr r1
00225d 9407                      	ror r0
00225e 9416                      	lsr r1
00225f 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
002260 fe13                      	sbrs r1, 3 //check if result was a negative number
002261 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
002262 efc0                      	ldi r28, 0xF0
002263 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
002264 70b7                      	andi r27, 0b00000111
002265 f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
002266 e0b1                      	ldi r27, 0x01
002267 0e0b                      	add r0, r27
002268 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002269 91a0 2833                 	lds r26, pulse1_total_pitch_offset
00226b 91b0 2834                 	lds r27, pulse1_total_pitch_offset+1
00226d 0e0a                      	add r0, r26
00226e 1e1b                      	adc r1, r27
00226f 9200 2833                 	sts pulse1_total_pitch_offset, r0
002271 9210 2834                 	sts pulse1_total_pitch_offset+1, r1
002273 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002275 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002277 0da0                      	add r26, r0 //offset the timer values
002278 1db1                      	adc r27, r1
                                 	
002279 91c0 2849                 	lds r28, pulse1_fx_1xx_total
00227b 91d0 284a                 	lds r29, pulse1_fx_1xx_total+1
00227d 1bac                      	sub r26, r28
00227e 0bbd                      	sbc r27, r29
00227f 91c0 284d                 	lds r28, pulse1_fx_2xx_total
002281 91d0 284e                 	lds r29, pulse1_fx_2xx_total+1
002283 0fac                      	add r26, r28
002284 1fbd                      	adc r27, r29
002285 91c0 2861                 	lds r28, pulse1_fx_Pxx_total
002287 91d0 2862                 	lds r29, pulse1_fx_Pxx_total+1
002289 0fac                      	add r26, r28
00228a 1fbd                      	adc r27, r29
00228b 91c0 2868                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00228d 91d0 2869                 	lds r29, pulse1_fx_Qxy_total_offset+1
00228f 1bac                      	sub r26, r28
002290 0bbd                      	sbc r27, r29
002291 91c0 286f                 	lds r28, pulse1_fx_Rxy_total_offset
002293 91d0 2870                 	lds r29, pulse1_fx_Rxy_total_offset+1
002295 0fac                      	add r26, r28
002296 1fbd                      	adc r27, r29
                                 
002297 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002299 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
00229b 91e0 283b                 	lds ZL, pulse1_hi_pitch_macro
00229d 91f0 283c                 	lds ZH, pulse1_hi_pitch_macro+1
00229f 9630                      	adiw Z, 0
0022a0 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
0022a1 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
0022a2 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0022a3 1fff                      	rol ZH
0022a4 91a0 283d                 	lds r26, pulse1_hi_pitch_macro_offset
0022a6 0fea                      	add ZL, r26
0022a7 1df2                      	adc ZH, zero
                                 
0022a8 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
0022aa 17ba                      	cp r27, r26
0022ab f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0022ac 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_loop
0022ae 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0022af f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0022b0 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
0022b1 95a3                      	inc r26 //increment the macro offset
0022b2 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
0022b4 91b4                      	lpm r27, Z //load hi pitch data into r27
0022b5 38b0                      	cpi r27, 0x80 //check for macro end flag
0022b6 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
0022b7 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0022b8 93a0 283d                 	sts pulse1_hi_pitch_macro_offset, r26
0022ba 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_release
0022bc 3fbf                      	cpi r27, 0xFF
0022bd f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0022be 91b0 283e                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0022c0 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0022c1 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0022c2 93b0 283d                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0022c4 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0022c5 91b0 283a                 	lds r27, pulse1_total_hi_pitch_offset
0022c7 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0022c8 91a0 283a                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0022ca 0fba                      	add r27, r26
0022cb 93b0 283a                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0022cd 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022ce 937f                      	push r23
0022cf 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0022d0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022d1 0367                      	mulsu r22, r23
0022d2 917f                      	pop r23
0022d3 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0022d4 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0022d6 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0022d8 0da0                      	add r26, r0 //offset the timer values
0022d9 1db1                      	adc r27, r1
0022da 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0022dc 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0022de 91e0 2840                 	lds ZL, pulse1_duty_macro
0022e0 91f0 2841                 	lds ZH, pulse1_duty_macro+1
0022e2 9630                      	adiw Z, 0
0022e3 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0022e4 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0022e5 1fff                      	rol ZH
0022e6 91a0 2842                 	lds r26, pulse1_duty_macro_offset
0022e8 0fea                      	add ZL, r26
0022e9 1df2                      	adc ZH, zero
                                 
0022ea 91b0 2844                 	lds r27, pulse1_duty_macro_release
0022ec 17ba                      	cp r27, r26
0022ed f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0022ee 91a0 2843                 	lds r26, pulse1_duty_macro_loop
0022f0 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0022f1 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0022f2 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0022f3 95a3                      	inc r26 //increment the macro offset
0022f4 93a0 2842                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0022f6 91b4                      	lpm r27, Z //load pitch data into r27
0022f7 3fbf                      	cpi r27, 0xFF //check for macro end flag
0022f8 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0022f9 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0022fa 93a0 2842                 	sts pulse1_duty_macro_offset, r26
0022fc 91b0 2844                 	lds r27, pulse1_duty_macro_release
0022fe 3fbf                      	cpi r27, 0xFF
0022ff f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
002300 91b0 2843                 	lds r27, pulse1_duty_macro_loop //load the loop index
002302 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002303 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002304 93b0 2842                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
002306 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
002307 eae0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002308 e5fb                      	ldi ZH, HIGH(sequences << 1)
002309 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
00230a 1df2                      	adc ZH, zero
                                 
00230b 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00230c 95b7                      	ror r27
00230d 95b7                      	ror r27
00230e 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
002310 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
002311 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002312 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002313 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
002314 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
002315 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
002316 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002317 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002318 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
00231a 91e0 2847                 	lds ZL, pulse1_fx_1xx
00231c 91f0 2848                 	lds ZH, pulse1_fx_1xx+1
00231e 9630                      	adiw Z, 0
00231f f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
002320 91a0 2849                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
002322 91b0 284a                 	lds r27, pulse1_fx_1xx_total+1
002324 0fae                      	add r26, ZL //increase the total offset by the rate
002325 1fbf                      	adc r27, ZH
002326 93a0 2849                 	sts pulse1_fx_1xx_total, r26
002328 93b0 284a                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
00232a 91e0 284b                 	lds ZL, pulse1_fx_2xx
00232c 91f0 284c                 	lds ZH, pulse1_fx_2xx+1
00232e 9630                      	adiw Z, 0
00232f f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
002330 91a0 284d                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
002332 91b0 284e                 	lds r27, pulse1_fx_2xx_total+1
002334 0fae                      	add r26, ZL //increase the total offset by the rate
002335 1fbf                      	adc r27, ZH
002336 93a0 284d                 	sts pulse1_fx_2xx_total, r26
002338 93b0 284e                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
00233a 91e0 2853                 	lds ZL, pulse1_fx_3xx_speed
00233c 91f0 2854                 	lds ZH, pulse1_fx_3xx_speed+1
00233e 9630                      	adiw Z, 0
00233f f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
002340 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
002341 91a0 284f                 	lds r26, pulse1_fx_3xx_start
002343 91b0 2850                 	lds r27, pulse1_fx_3xx_start+1
002345 9610                      	adiw r26:r27, 0
002346 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
002347 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
002348 91c0 2851                 	lds r28, pulse1_fx_3xx_target
00234a 91d0 2852                 	lds r29, pulse1_fx_3xx_target+1
                                 
00234c 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00234d 07bd                      	cpc r27, r29
00234e f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
00234f f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002350 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
002351 9220 284f                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002353 9220 2850                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002355 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
002356 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002357 0bdb                      	sbc r29, r27
002358 91a0 2855                 	lds r26, pulse1_fx_3xx_total_offset
00235a 91b0 2856                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
00235c 0fae                      	add r26, ZL //add the speed to the total offset
00235d 1fbf                      	adc r27, ZH
00235e 1bca                      	sub r28, r26 //invert the total difference with the total offset
00235f 0bdb                      	sbc r29, r27
002360 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002361 93a0 2855                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
002363 93b0 2856                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
002365 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
002367 91b0 0a8d                 	lds r27, TCB0_CCMPH
002369 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00236a 0bbd                      	sbc r27, r29
00236b 93a0 0a8c                 	sts TCB0_CCMPL, r26
00236d 93b0 0a8d                 	sts TCB0_CCMPH, r27
00236f c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002370 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002371 0bbd                      	sbc r27, r29
002372 91c0 2855                 	lds r28, pulse1_fx_3xx_total_offset
002374 91d0 2856                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
002376 0fce                      	add r28, ZL //add the speed to the total offset
002377 1fdf                      	adc r29, ZH
002378 1bac                      	sub r26, r28 //invert the total difference with the total offset
002379 0bbd                      	sbc r27, r29
00237a f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00237b 93c0 2855                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
00237d 93d0 2856                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
00237f 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
002381 91d0 0a8d                 	lds r29, TCB0_CCMPH
002383 0fca                      	add r28, r26 //offset the current timer period with the total offset
002384 1fdb                      	adc r29, r27
002385 93c0 0a8c                 	sts TCB0_CCMPL, r28
002387 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002389 91a0 2857                 	lds r26, pulse1_fx_4xy_speed
00238b 15a2                      	cp r26, zero
00238c f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
00238d c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00238e 91b0 2858                 	lds r27, pulse1_fx_4xy_depth
002390 91c0 2859                 	lds r28, pulse1_fx_4xy_phase
002392 0fca                      	add r28, r26 //increase the phase by the speed
002393 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002394 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002395 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
002396 93c0 2859                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002398 31c0                      	cpi r28, 16
002399 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
00239a 32c0                      	cpi r28, 32
00239b f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
00239c 33c0                      	cpi r28, 48
00239d f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
00239e c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
00239f 70cf                      	andi r28, 0x0F //mask for values 0-15
0023a0 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
0023a1 6fc0                      	ori r28, 0xF0
0023a2 95c0                      	com r28 //invert values 0-15
0023a3 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
0023a4 70cf                      	andi r28, 0x0F //mask for values 0-15
0023a5 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
0023a6 6fc0                      	ori r28, 0xF0
0023a7 95c0                      	com r28 //invert values 0-15
0023a8 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
0023a9 95b2                      	swap r27 //multiply depth by 16
0023aa 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0023ab e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0023ac e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0023ad 0fec                      	add ZL, r28 //offset the table by the depth+phase
0023ae 1df2                      	adc ZH, zero
0023af 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0023b0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0023b1 937f                      	push r23
0023b2 2f6c                      	mov r22, r28 //store the vibrato value into r22
0023b3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0023b4 9f67                      	mul r22, r23
0023b5 917f                      	pop r23
0023b6 916f                      	pop r22
                                 
0023b7 9416                      	lsr r1 //shift out the fractional bits
0023b8 9407                      	ror r0
0023b9 9416                      	lsr r1
0023ba 9407                      	ror r0
0023bb 9416                      	lsr r1
0023bc 9407                      	ror r0
0023bd 9416                      	lsr r1
0023be 9407                      	ror r0
                                 	
0023bf 91a0 0a8c                 	lds r26, TCB0_CCMPL
0023c1 91b0 0a8d                 	lds r27, TCB0_CCMPH
0023c3 0da0                      	add r26, r0
0023c4 1db1                      	adc r27, r1
0023c5 93a0 0a8c                 	sts TCB0_CCMPL, r26
0023c7 93b0 0a8d                 	sts TCB0_CCMPH, r27
0023c9 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
0023ca 95b2                      	swap r27 //multiply depth by 16
0023cb 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0023cc e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0023cd e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0023ce 0fec                      	add ZL, r28 //offset the table by the depth+phase
0023cf 1df2                      	adc ZH, zero
0023d0 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0023d1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0023d2 937f                      	push r23
0023d3 2f6c                      	mov r22, r28 //store the vibrato value into r22
0023d4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0023d5 9f67                      	mul r22, r23
0023d6 917f                      	pop r23
0023d7 916f                      	pop r22
                                 
0023d8 9416                      	lsr r1 //shift out the fractional bits
0023d9 9407                      	ror r0
0023da 9416                      	lsr r1
0023db 9407                      	ror r0
0023dc 9416                      	lsr r1
0023dd 9407                      	ror r0
0023de 9416                      	lsr r1
0023df 9407                      	ror r0
                                 
0023e0 91a0 0a8c                 	lds r26, TCB0_CCMPL
0023e2 91b0 0a8d                 	lds r27, TCB0_CCMPH
0023e4 19a0                      	sub r26, r0
0023e5 09b1                      	sbc r27, r1
0023e6 93a0 0a8c                 	sts TCB0_CCMPL, r26
0023e8 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0023ea 91a0 285a                 	lds r26, pulse1_fx_7xy_speed
0023ec 15a2                      	cp r26, zero
0023ed f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0023ee 91b0 285b                 	lds r27, pulse1_fx_7xy_depth
0023f0 91c0 285c                 	lds r28, pulse1_fx_7xy_phase
0023f2 0fca                      	add r28, r26 //increase the phase by the speed
0023f3 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0023f4 f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0023f5 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0023f6 93c0 285c                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
0023f8 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0023f9 ffc4                      	sbrs r28, 4
0023fa c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
0023fb c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
0023fc 70cf                      	andi r28, 0x0F //mask for values 0-15
0023fd c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
0023fe 6fc0                      	ori r28, 0xF0
0023ff 95c0                      	com r28 //invert values 0-15
002400 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002401 95b2                      	swap r27 //multiply depth by 16
002402 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002403 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002404 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002405 0fec                      	add ZL, r28 //offset the table by the depth+phase
002406 1df2                      	adc ZH, zero
002407 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002408 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002409 93c0 285d                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
00240b 91b0 285e                 	lds r27, pulse1_fx_Axy
00240d 15b2                      	cp r27, zero
00240e f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00240f 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
002411 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
002413 2fda                      	mov r29, r26 //copy fractional volume into r29
002414 2fec                      	mov r30, r28 //copy the pulse1_param into r30
002415 95e2                      	swap r30
002416 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002417 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002418 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002419 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
00241a 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
00241b fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
00241c c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
00241d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00241e f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00241f efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002420 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
002421 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002422 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002423 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
002424 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
002426 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002427 95a2                      	swap r26
002428 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002429 2bca                      	or r28, r26 //store the new volume back into pulse1_param
00242a 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
00242c 91e0 2864                 	lds ZL, pulse1_fx_Qxy_target
00242e 91f0 2865                 	lds ZH, pulse1_fx_Qxy_target+1
002430 9630                      	adiw Z, 0
002431 f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002432 91a0 2868                 	lds r26, pulse1_fx_Qxy_total_offset
002434 91b0 2869                 	lds r27, pulse1_fx_Qxy_total_offset+1
002436 91c0 0a8c                 	lds r28, TCB0_CCMPL
002438 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
00243a 1bec                      	sub ZL, r28 //calculate the difference to the target
00243b 0bfd                      	sbc ZH, r29
00243c f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
00243d f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
00243e 9220 2868                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
002440 9220 2869                 	sts pulse1_fx_Qxy_total_offset+1, zero
002442 9220 2864                 	sts pulse1_fx_Qxy_target, zero
002444 9220 2865                 	sts pulse1_fx_Qxy_target+1, zero
002446 91b0 2863                 	lds r27, pulse1_fx_Qxy_target_note
002448 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
00244a c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
00244b 91c0 2866                 	lds r28, pulse1_fx_Qxy_speed
00244d 91d0 2867                 	lds r29, pulse1_fx_Qxy_speed+1
00244f 0fac                      	add r26, r28 //increase the total offset by the speed
002450 1fbd                      	adc r27, r29
002451 93a0 2868                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
002453 93b0 2869                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
002455 91e0 286b                 	lds ZL, pulse1_fx_Rxy_target
002457 91f0 286c                 	lds ZH, pulse1_fx_Rxy_target+1
002459 9630                      	adiw Z, 0
00245a f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
00245b 91a0 286f                 	lds r26, pulse1_fx_Rxy_total_offset
00245d 91b0 2870                 	lds r27, pulse1_fx_Rxy_total_offset+1
00245f 91c0 0a8c                 	lds r28, TCB0_CCMPL
002461 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002463 1bce                      	sub r28, ZL //calculate the difference to the target
002464 0bdf                      	sbc r29, ZH
002465 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
002466 f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
002467 9220 286f                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
002469 9220 2870                 	sts pulse1_fx_Rxy_total_offset+1, zero
00246b 9220 286b                 	sts pulse1_fx_Rxy_target, zero
00246d 9220 286c                 	sts pulse1_fx_Rxy_target+1, zero
00246f 91b0 286a                 	lds r27, pulse1_fx_Rxy_target_note
002471 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
002473 c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
002474 91c0 286d                 	lds r28, pulse1_fx_Rxy_speed
002476 91d0 286e                 	lds r29, pulse1_fx_Rxy_speed+1
002478 0fac                      	add r26, r28 //increase the total offset by the speed
002479 1fbd                      	adc r27, r29
00247a 93a0 286f                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
00247c 93b0 2870                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
00247e 91e0 2879                 	lds ZL, pulse2_volume_macro
002480 91f0 287a                 	lds ZH, pulse2_volume_macro+1
002482 9630                      	adiw Z, 0
002483 f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
002484 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002485 1fff                      	rol ZH
002486 91a0 287b                 	lds r26, pulse2_volume_macro_offset
002488 0fea                      	add ZL, r26
002489 1df2                      	adc ZH, zero
                                 
00248a 91b0 287d                 	lds r27, pulse2_volume_macro_release
00248c 17ba                      	cp r27, r26
00248d f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
00248e 91a0 287c                 	lds r26, pulse2_volume_macro_loop
002490 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002491 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002492 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
002493 95a3                      	inc r26 //increment the macro offset
002494 93a0 287b                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002496 91b4                      	lpm r27, Z //load volume data into r27
002497 3fbf                      	cpi r27, 0xFF //check for macro end flag
002498 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002499 91b0 287d                 	lds r27, pulse2_volume_macro_release
00249b 3fbf                      	cpi r27, 0xFF
00249c f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
00249d 91b0 287c                 	lds r27, pulse2_volume_macro_loop //load the loop index
00249f 93b0 287b                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
0024a1 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
0024a2 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0024a3 93a0 287b                 	sts pulse2_volume_macro_offset, r26
0024a5 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
0024a6 e7e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0024a7 e5fc                      	ldi ZH, HIGH(volumes << 1)
0024a8 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0024a9 0feb                      	add ZL, r27 //add offset to the table
0024aa 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
0024ab 91b0 2808                 	lds r27, pulse2_param //load main volume
0024ad 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0024ae 91a0 28ae                 	lds r26, pulse2_fx_7xy_value
0024b0 30a0                      	cpi r26, 0x00
0024b1 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
0024b2 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024b3 1df2                      	adc ZH, zero
0024b4 91b4                      	lpm r27, Z
0024b5 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024b7 c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
0024b8 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0024ba 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0024bb 91a0 28ae                 	lds r26, pulse2_fx_7xy_value
0024bd 30a0                      	cpi r26, 0x00
0024be f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
0024bf 93b0 280e                 	sts pulse2_output_volume, r27
0024c1 c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
0024c2 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0024c3 f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
0024c4 f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
0024c5 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024c6 1df2                      	adc ZH, zero
0024c7 91b4                      	lpm r27, Z
0024c8 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024ca c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
0024cb e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0024cc 0feb                      	add ZL, r27 //offset the volume table by the main volume
0024cd 1df2                      	adc ZH, zero
0024ce 91b4                      	lpm r27, Z
0024cf 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0024d1 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
0024d2 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0024d3 f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0024d4 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0024d5 93b0 280e                 	sts pulse2_output_volume, r27
0024d7 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
0024d8 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0024d9 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0024db 91e0 287e                 	lds ZL, pulse2_arpeggio_macro
0024dd 91f0 287f                 	lds ZH, pulse2_arpeggio_macro+1
0024df 9630                      	adiw Z, 0
0024e0 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0024e1 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0024e2 1fff                      	rol ZH
0024e3 91a0 2880                 	lds r26, pulse2_arpeggio_macro_offset
0024e5 0fea                      	add ZL, r26
0024e6 1df2                      	adc ZH, zero
                                 
0024e7 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
0024e9 17ba                      	cp r27, r26
0024ea f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0024eb 91a0 2881                 	lds r26, pulse2_arpeggio_macro_loop
0024ed 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0024ee f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0024ef c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
0024f0 95a3                      	inc r26 //increment the macro offset
0024f1 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
0024f3 91b4                      	lpm r27, Z //load arpeggio data into r27
0024f4 38b0                      	cpi r27, 0x80 //check for macro end flag
0024f5 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
0024f6 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
0024f7 50a1                      	subi r26, 1 //keep the offset at the end flag
0024f8 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26
0024fa 91b0 2883                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0024fc 30b1                      	cpi r27, 0x01
0024fd f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
0024fe 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
002500 3fbf                      	cpi r27, 0xFF
002501 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
002502 91b0 2881                 	lds r27, pulse2_arpeggio_macro_loop
002504 3fbf                      	cpi r27, 0xFF
002505 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002506 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002507 91b0 2882                 	lds r27, pulse2_arpeggio_macro_release
002509 3fbf                      	cpi r27, 0xFF
00250a f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
00250b 91b0 2881                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
00250d 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00250e f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
00250f 91c0 2896                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002511 91d0 2897                 	lds r29, pulse2_fx_0xy_sequence+1
002513 9620                      	adiw r29:r28, 0
002514 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002515 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002516 93a0 2880                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002518 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002519 93b0 2880                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
00251b cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
00251c 91c0 2896                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
00251e 91d0 2897                 	lds r29, pulse2_fx_0xy_sequence+1
002520 9620                      	adiw r29:r28, 0 //check for 0xy effect
002521 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
002522 95d6                      	lsr r29
002523 95c7                      	ror r28
002524 95d7                      	ror r29
002525 95c7                      	ror r28
002526 95d7                      	ror r29
002527 95c7                      	ror r28
002528 95d7                      	ror r29
002529 95c7                      	ror r28
00252a 95d7                      	ror r29
00252b 95d2                      	swap r29
                                 
00252c 93c0 2896                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
00252e 93d0 2897                 	sts pulse2_fx_0xy_sequence+1, r29
002530 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002531 91a0 280f                 	lds r26, pulse2_note //load the current note index
002533 0fac                      	add r26, r28 //add the note offset
002534 c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002535 91a0 280f                 	lds r26, pulse2_note //load the current note index
002537 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
002538 9220 2884                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
00253a 9220 2885                 	sts pulse2_total_pitch_offset+1, zero
00253c 9220 288b                 	sts pulse2_total_hi_pitch_offset, zero
00253e 91a0 2883                 	lds r26, pulse2_arpeggio_macro_mode
002540 30a1                      	cpi r26, 0x01 //absolute mode
002541 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
002542 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
002543 c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
002544 91a0 280f                 	lds r26, pulse2_note //load the current note index
002546 0fab                      	add r26, r27 //offset the note with the arpeggio data
002547 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002548 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
002549 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00254a f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
00254b e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00254c c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
00254d fda7                      	sbrc r26, 7 //check if result is negative
00254e e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00254f c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
002550 2fab                      	mov r26, r27 //move the arpeggio data into r26
002551 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
002552 91a0 280f                 	lds r26, pulse2_note //load the current note index
002554 0fab                      	add r26, r27 //offset the note with the arpeggio data
002555 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002556 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
002557 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
002559 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
00255a f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
00255b e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
00255c 93a0 280f                 	sts pulse2_note, r26
00255e c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
00255f fda7                      	sbrc r26, 7 //check if result is negative
002560 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002561 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
002563 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002564 e0f0                      	ldi ZH, HIGH(note_table << 1)
002565 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002566 0fea                      	add ZL, r26 //add offset
002567 1df2                      	adc ZH, zero
002568 91a5                      	lpm r26, Z+ //load bytes
002569 91b4                      	lpm r27, Z
00256a 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
00256c 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
00256e 93a0 28a2                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002570 93b0 28a3                 	sts pulse2_fx_3xx_target+1, r27
002572 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
002573 91e0 2886                 	lds ZL, pulse2_pitch_macro
002575 91f0 2887                 	lds ZH, pulse2_pitch_macro+1
002577 9630                      	adiw Z, 0
002578 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002579 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
00257a 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00257b 1fff                      	rol ZH
00257c 91a0 2888                 	lds r26, pulse2_pitch_macro_offset
00257e 0fea                      	add ZL, r26
00257f 1df2                      	adc ZH, zero
                                 
002580 91b0 288a                 	lds r27, pulse2_pitch_macro_release
002582 17ba                      	cp r27, r26
002583 f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
002584 91a0 2889                 	lds r26, pulse2_pitch_macro_loop
002586 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002587 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002588 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002589 95a3                      	inc r26 //increment the macro offset
00258a 93a0 2888                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
00258c 91b4                      	lpm r27, Z //load pitch data into r27
00258d 38b0                      	cpi r27, 0x80 //check for macro end flag
00258e f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
00258f 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002590 93a0 2888                 	sts pulse2_pitch_macro_offset, r26
002592 91b0 288a                 	lds r27, pulse2_pitch_macro_release
002594 3fbf                      	cpi r27, 0xFF
002595 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002596 91b0 2889                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002598 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002599 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
00259a 93b0 2888                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
00259c cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
00259d e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
00259e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00259f 937f                      	push r23
0025a0 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0025a1 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025a2 0367                      	mulsu r22, r23
0025a3 917f                      	pop r23
0025a4 916f                      	pop r22
                                 
0025a5 9416                      	lsr r1 //shift out the fractional bits
0025a6 9407                      	ror r0
0025a7 9416                      	lsr r1
0025a8 9407                      	ror r0
0025a9 9416                      	lsr r1
0025aa 9407                      	ror r0
0025ab 9416                      	lsr r1
0025ac 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
0025ad fe13                      	sbrs r1, 3 //check if result was a negative number
0025ae c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
0025af efc0                      	ldi r28, 0xF0
0025b0 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
0025b1 70b7                      	andi r27, 0b00000111
0025b2 f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
0025b3 e0b1                      	ldi r27, 0x01
0025b4 0e0b                      	add r0, r27
0025b5 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
0025b6 91a0 2884                 	lds r26, pulse2_total_pitch_offset
0025b8 91b0 2885                 	lds r27, pulse2_total_pitch_offset+1
0025ba 0e0a                      	add r0, r26
0025bb 1e1b                      	adc r1, r27
0025bc 9200 2884                 	sts pulse2_total_pitch_offset, r0
0025be 9210 2885                 	sts pulse2_total_pitch_offset+1, r1
0025c0 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0025c2 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0025c4 0da0                      	add r26, r0 //offset the timer values
0025c5 1db1                      	adc r27, r1
                                 	
0025c6 91c0 289a                 	lds r28, pulse2_fx_1xx_total
0025c8 91d0 289b                 	lds r29, pulse2_fx_1xx_total+1
0025ca 1bac                      	sub r26, r28
0025cb 0bbd                      	sbc r27, r29
0025cc 91c0 289e                 	lds r28, pulse2_fx_2xx_total
0025ce 91d0 289f                 	lds r29, pulse2_fx_2xx_total+1
0025d0 0fac                      	add r26, r28
0025d1 1fbd                      	adc r27, r29
0025d2 91c0 28b2                 	lds r28, pulse2_fx_Pxx_total
0025d4 91d0 28b3                 	lds r29, pulse2_fx_Pxx_total+1
0025d6 0fac                      	add r26, r28
0025d7 1fbd                      	adc r27, r29
0025d8 91c0 28b9                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0025da 91d0 28ba                 	lds r29, pulse2_fx_Qxy_total_offset+1
0025dc 1bac                      	sub r26, r28
0025dd 0bbd                      	sbc r27, r29
0025de 91c0 28c0                 	lds r28, pulse2_fx_Rxy_total_offset
0025e0 91d0 28c1                 	lds r29, pulse2_fx_Rxy_total_offset+1
0025e2 0fac                      	add r26, r28
0025e3 1fbd                      	adc r27, r29
                                 
0025e4 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0025e6 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
0025e8 91e0 288c                 	lds ZL, pulse2_hi_pitch_macro
0025ea 91f0 288d                 	lds ZH, pulse2_hi_pitch_macro+1
0025ec 9630                      	adiw Z, 0
0025ed f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
0025ee c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
0025ef 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0025f0 1fff                      	rol ZH
0025f1 91a0 288e                 	lds r26, pulse2_hi_pitch_macro_offset
0025f3 0fea                      	add ZL, r26
0025f4 1df2                      	adc ZH, zero
                                 
0025f5 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_release
0025f7 17ba                      	cp r27, r26
0025f8 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0025f9 91a0 288f                 	lds r26, pulse2_hi_pitch_macro_loop
0025fb 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025fc f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025fd c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
0025fe 95a3                      	inc r26 //increment the macro offset
0025ff 93a0 288e                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002601 91b4                      	lpm r27, Z //load hi pitch data into r27
002602 38b0                      	cpi r27, 0x80 //check for macro end flag
002603 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002604 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002605 93a0 288e                 	sts pulse2_hi_pitch_macro_offset, r26
002607 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_release
002609 3fbf                      	cpi r27, 0xFF
00260a f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
00260b 91b0 288f                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
00260d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00260e f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00260f 93b0 288e                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002611 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002612 91b0 288b                 	lds r27, pulse2_total_hi_pitch_offset
002614 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002615 91a0 288b                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002617 0fba                      	add r27, r26
002618 93b0 288b                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
00261a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00261b 937f                      	push r23
00261c 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00261d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00261e 0367                      	mulsu r22, r23
00261f 917f                      	pop r23
002620 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002621 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002623 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002625 0da0                      	add r26, r0 //offset the timer values
002626 1db1                      	adc r27, r1
002627 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002629 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
00262b 91e0 2891                 	lds ZL, pulse2_duty_macro
00262d 91f0 2892                 	lds ZH, pulse2_duty_macro+1
00262f 9630                      	adiw Z, 0
002630 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002631 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002632 1fff                      	rol ZH
002633 91a0 2893                 	lds r26, pulse2_duty_macro_offset
002635 0fea                      	add ZL, r26
002636 1df2                      	adc ZH, zero
                                 
002637 91b0 2895                 	lds r27, pulse2_duty_macro_release
002639 17ba                      	cp r27, r26
00263a f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
00263b 91a0 2894                 	lds r26, pulse2_duty_macro_loop
00263d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00263e f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00263f c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002640 95a3                      	inc r26 //increment the macro offset
002641 93a0 2893                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002643 91b4                      	lpm r27, Z //load pitch data into r27
002644 3fbf                      	cpi r27, 0xFF //check for macro end flag
002645 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002646 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002647 93a0 2893                 	sts pulse2_duty_macro_offset, r26
002649 91b0 2895                 	lds r27, pulse2_duty_macro_release
00264b 3fbf                      	cpi r27, 0xFF
00264c f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
00264d 91b0 2894                 	lds r27, pulse2_duty_macro_loop //load the loop index
00264f 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002650 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002651 93b0 2893                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002653 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002654 eae0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002655 e5fb                      	ldi ZH, HIGH(sequences << 1)
002656 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002657 1df2                      	adc ZH, zero
                                 
002658 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002659 95b7                      	ror r27
00265a 95b7                      	ror r27
00265b 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
00265d 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
00265e 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00265f 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002660 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002661 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002662 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002663 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002664 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002665 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002667 91e0 2898                 	lds ZL, pulse2_fx_1xx
002669 91f0 2899                 	lds ZH, pulse2_fx_1xx+1
00266b 9630                      	adiw Z, 0
00266c f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
00266d 91a0 289a                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
00266f 91b0 289b                 	lds r27, pulse2_fx_1xx_total+1
002671 0fae                      	add r26, ZL //increase the total offset by the rate
002672 1fbf                      	adc r27, ZH
002673 93a0 289a                 	sts pulse2_fx_1xx_total, r26
002675 93b0 289b                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002677 91e0 289c                 	lds ZL, pulse2_fx_2xx
002679 91f0 289d                 	lds ZH, pulse2_fx_2xx+1
00267b 9630                      	adiw Z, 0
00267c f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
00267d 91a0 289e                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
00267f 91b0 289f                 	lds r27, pulse2_fx_2xx_total+1
002681 0fae                      	add r26, ZL //increase the total offset by the rate
002682 1fbf                      	adc r27, ZH
002683 93a0 289e                 	sts pulse2_fx_2xx_total, r26
002685 93b0 289f                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002687 91e0 28a4                 	lds ZL, pulse2_fx_3xx_speed
002689 91f0 28a5                 	lds ZH, pulse2_fx_3xx_speed+1
00268b 9630                      	adiw Z, 0
00268c f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
00268d c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
00268e 91a0 28a0                 	lds r26, pulse2_fx_3xx_start
002690 91b0 28a1                 	lds r27, pulse2_fx_3xx_start+1
002692 9610                      	adiw r26:r27, 0
002693 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002694 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002695 91c0 28a2                 	lds r28, pulse2_fx_3xx_target
002697 91d0 28a3                 	lds r29, pulse2_fx_3xx_target+1
                                 
002699 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00269a 07bd                      	cpc r27, r29
00269b f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
00269c f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00269d c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
00269e 9220 28a0                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0026a0 9220 28a1                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0026a2 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
0026a3 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0026a4 0bdb                      	sbc r29, r27
0026a5 91a0 28a6                 	lds r26, pulse2_fx_3xx_total_offset
0026a7 91b0 28a7                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
0026a9 0fae                      	add r26, ZL //add the speed to the total offset
0026aa 1fbf                      	adc r27, ZH
0026ab 1bca                      	sub r28, r26 //invert the total difference with the total offset
0026ac 0bdb                      	sbc r29, r27
0026ad f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0026ae 93a0 28a6                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
0026b0 93b0 28a7                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
0026b2 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
0026b4 91b0 0a9d                 	lds r27, TCB1_CCMPH
0026b6 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0026b7 0bbd                      	sbc r27, r29
0026b8 93a0 0a9c                 	sts TCB1_CCMPL, r26
0026ba 93b0 0a9d                 	sts TCB1_CCMPH, r27
0026bc c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
0026bd 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0026be 0bbd                      	sbc r27, r29
0026bf 91c0 28a6                 	lds r28, pulse2_fx_3xx_total_offset
0026c1 91d0 28a7                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
0026c3 0fce                      	add r28, ZL //add the speed to the total offset
0026c4 1fdf                      	adc r29, ZH
0026c5 1bac                      	sub r26, r28 //invert the total difference with the total offset
0026c6 0bbd                      	sbc r27, r29
0026c7 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0026c8 93c0 28a6                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
0026ca 93d0 28a7                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
0026cc 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
0026ce 91d0 0a9d                 	lds r29, TCB1_CCMPH
0026d0 0fca                      	add r28, r26 //offset the current timer period with the total offset
0026d1 1fdb                      	adc r29, r27
0026d2 93c0 0a9c                 	sts TCB1_CCMPL, r28
0026d4 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
0026d6 91a0 28a8                 	lds r26, pulse2_fx_4xy_speed
0026d8 15a2                      	cp r26, zero
0026d9 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
0026da c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
0026db 91b0 28a9                 	lds r27, pulse2_fx_4xy_depth
0026dd 91c0 28aa                 	lds r28, pulse2_fx_4xy_phase
0026df 0fca                      	add r28, r26 //increase the phase by the speed
0026e0 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0026e1 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0026e2 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
0026e3 93c0 28aa                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
0026e5 31c0                      	cpi r28, 16
0026e6 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
0026e7 32c0                      	cpi r28, 32
0026e8 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
0026e9 33c0                      	cpi r28, 48
0026ea f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
0026eb c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
0026ec 70cf                      	andi r28, 0x0F //mask for values 0-15
0026ed c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
0026ee 6fc0                      	ori r28, 0xF0
0026ef 95c0                      	com r28 //invert values 0-15
0026f0 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
0026f1 70cf                      	andi r28, 0x0F //mask for values 0-15
0026f2 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
0026f3 6fc0                      	ori r28, 0xF0
0026f4 95c0                      	com r28 //invert values 0-15
0026f5 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
0026f6 95b2                      	swap r27 //multiply depth by 16
0026f7 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0026f8 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0026f9 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0026fa 0fec                      	add ZL, r28 //offset the table by the depth+phase
0026fb 1df2                      	adc ZH, zero
0026fc 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0026fd 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026fe 937f                      	push r23
0026ff 2f6c                      	mov r22, r28 //store the vibrato value into r22
002700 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002701 9f67                      	mul r22, r23
002702 917f                      	pop r23
002703 916f                      	pop r22
                                 
002704 9416                      	lsr r1 //shift out the fractional bits
002705 9407                      	ror r0
002706 9416                      	lsr r1
002707 9407                      	ror r0
002708 9416                      	lsr r1
002709 9407                      	ror r0
00270a 9416                      	lsr r1
00270b 9407                      	ror r0
                                 	
00270c 91a0 0a9c                 	lds r26, TCB1_CCMPL
00270e 91b0 0a9d                 	lds r27, TCB1_CCMPH
002710 0da0                      	add r26, r0
002711 1db1                      	adc r27, r1
002712 93a0 0a9c                 	sts TCB1_CCMPL, r26
002714 93b0 0a9d                 	sts TCB1_CCMPH, r27
002716 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002717 95b2                      	swap r27 //multiply depth by 16
002718 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002719 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00271a e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00271b 0fec                      	add ZL, r28 //offset the table by the depth+phase
00271c 1df2                      	adc ZH, zero
00271d 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00271e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00271f 937f                      	push r23
002720 2f6c                      	mov r22, r28 //store the vibrato value into r22
002721 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002722 9f67                      	mul r22, r23
002723 917f                      	pop r23
002724 916f                      	pop r22
                                 
002725 9416                      	lsr r1 //shift out the fractional bits
002726 9407                      	ror r0
002727 9416                      	lsr r1
002728 9407                      	ror r0
002729 9416                      	lsr r1
00272a 9407                      	ror r0
00272b 9416                      	lsr r1
00272c 9407                      	ror r0
                                 
00272d 91a0 0a9c                 	lds r26, TCB1_CCMPL
00272f 91b0 0a9d                 	lds r27, TCB1_CCMPH
002731 19a0                      	sub r26, r0
002732 09b1                      	sbc r27, r1
002733 93a0 0a9c                 	sts TCB1_CCMPL, r26
002735 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002737 91a0 28ab                 	lds r26, pulse2_fx_7xy_speed
002739 15a2                      	cp r26, zero
00273a f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00273b 91b0 28ac                 	lds r27, pulse2_fx_7xy_depth
00273d 91c0 28ad                 	lds r28, pulse2_fx_7xy_phase
00273f 0fca                      	add r28, r26 //increase the phase by the speed
002740 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002741 f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002742 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002743 93c0 28ad                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002745 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002746 ffc4                      	sbrs r28, 4
002747 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002748 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002749 70cf                      	andi r28, 0x0F //mask for values 0-15
00274a c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
00274b 6fc0                      	ori r28, 0xF0
00274c 95c0                      	com r28 //invert values 0-15
00274d c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
00274e 95b2                      	swap r27 //multiply depth by 16
00274f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002750 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002751 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002752 0fec                      	add ZL, r28 //offset the table by the depth+phase
002753 1df2                      	adc ZH, zero
002754 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002755 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002756 93c0 28ae                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002758 91b0 28af                 	lds r27, pulse2_fx_Axy
00275a 15b2                      	cp r27, zero
00275b f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
00275c 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
00275e 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002760 2fda                      	mov r29, r26 //copy fractional volume into r29
002761 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002762 95e2                      	swap r30
002763 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002764 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002765 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002766 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002767 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002768 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002769 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
00276a 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00276b f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00276c efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
00276d c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
00276e 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00276f f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002770 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002771 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002773 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002774 95a2                      	swap r26
002775 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002776 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002777 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002779 91e0 28b5                 	lds ZL, pulse2_fx_Qxy_target
00277b 91f0 28b6                 	lds ZH, pulse2_fx_Qxy_target+1
00277d 9630                      	adiw Z, 0
00277e f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00277f 91a0 28b9                 	lds r26, pulse2_fx_Qxy_total_offset
002781 91b0 28ba                 	lds r27, pulse2_fx_Qxy_total_offset+1
002783 91c0 0a9c                 	lds r28, TCB1_CCMPL
002785 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002787 1bec                      	sub ZL, r28 //calculate the difference to the target
002788 0bfd                      	sbc ZH, r29
002789 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
00278a f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
00278b 9220 28b9                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
00278d 9220 28ba                 	sts pulse2_fx_Qxy_total_offset+1, zero
00278f 9220 28b5                 	sts pulse2_fx_Qxy_target, zero
002791 9220 28b6                 	sts pulse2_fx_Qxy_target+1, zero
002793 91b0 28b4                 	lds r27, pulse2_fx_Qxy_target_note
002795 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002797 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002798 91c0 28b7                 	lds r28, pulse2_fx_Qxy_speed
00279a 91d0 28b8                 	lds r29, pulse2_fx_Qxy_speed+1
00279c 0fac                      	add r26, r28 //increase the total offset by the speed
00279d 1fbd                      	adc r27, r29
00279e 93a0 28b9                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
0027a0 93b0 28ba                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
0027a2 91e0 28bc                 	lds ZL, pulse2_fx_Rxy_target
0027a4 91f0 28bd                 	lds ZH, pulse2_fx_Rxy_target+1
0027a6 9630                      	adiw Z, 0
0027a7 f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
0027a8 91a0 28c0                 	lds r26, pulse2_fx_Rxy_total_offset
0027aa 91b0 28c1                 	lds r27, pulse2_fx_Rxy_total_offset+1
0027ac 91c0 0a9c                 	lds r28, TCB1_CCMPL
0027ae 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
0027b0 1bce                      	sub r28, ZL //calculate the difference to the target
0027b1 0bdf                      	sbc r29, ZH
0027b2 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
0027b3 f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
0027b4 9220 28c0                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
0027b6 9220 28c1                 	sts pulse2_fx_Rxy_total_offset+1, zero
0027b8 9220 28bc                 	sts pulse2_fx_Rxy_target, zero
0027ba 9220 28bd                 	sts pulse2_fx_Rxy_target+1, zero
0027bc 91b0 28bb                 	lds r27, pulse2_fx_Rxy_target_note
0027be 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
0027c0 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
0027c1 91c0 28be                 	lds r28, pulse2_fx_Rxy_speed
0027c3 91d0 28bf                 	lds r29, pulse2_fx_Rxy_speed+1
0027c5 0fac                      	add r26, r28 //increase the total offset by the speed
0027c6 1fbd                      	adc r27, r29
0027c7 93a0 28c0                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
0027c9 93b0 28c1                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
0027cb 91e0 28ca                 	lds ZL, triangle_volume_macro
0027cd 91f0 28cb                 	lds ZH, triangle_volume_macro+1
0027cf 9630                      	adiw Z, 0
0027d0 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
0027d1 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0027d2 1fff                      	rol ZH
0027d3 91a0 28cc                 	lds r26, triangle_volume_macro_offset
0027d5 0fea                      	add ZL, r26
0027d6 1df2                      	adc ZH, zero
                                 
0027d7 91b0 28ce                 	lds r27, triangle_volume_macro_release
0027d9 17ba                      	cp r27, r26
0027da f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
0027db 91a0 28cd                 	lds r26, triangle_volume_macro_loop
0027dd 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0027de f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0027df c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
0027e0 95a3                      	inc r26 //increment the macro offset
0027e1 93a0 28cc                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
0027e3 91b4                      	lpm r27, Z //load volume data into r27
0027e4 3fbf                      	cpi r27, 0xFF //check for macro end flag
0027e5 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
0027e6 91b0 28ce                 	lds r27, triangle_volume_macro_release
0027e8 3fbf                      	cpi r27, 0xFF
0027e9 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
0027ea 91b0 28cd                 	lds r27, triangle_volume_macro_loop //load the loop index
0027ec 93b0 28cc                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
0027ee cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
0027ef 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0027f0 93a0 28cc                 	sts triangle_volume_macro_offset, r26
0027f2 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
0027f3 15b2                      	cp r27, zero
0027f4 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
0027f5 91b0 0aa5                 	lds r27, TCB2_INTCTRL
0027f7 30b1                      	cpi r27, TCB_CAPT_bm
0027f8 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
0027f9 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0027fa 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0027fc c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
0027fd 9220 0aa5                 	sts TCB2_INTCTRL, zero
0027ff 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002801 9220 0aad                 	sts TCB2_CCMPH, zero
002803 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002804 91e0 28cf                 	lds ZL, triangle_arpeggio_macro
002806 91f0 28d0                 	lds ZH, triangle_arpeggio_macro+1
002808 9630                      	adiw Z, 0
002809 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00280a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00280b 1fff                      	rol ZH
00280c 91a0 28d1                 	lds r26, triangle_arpeggio_macro_offset
00280e 0fea                      	add ZL, r26
00280f 1df2                      	adc ZH, zero
                                 
002810 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
002812 17ba                      	cp r27, r26
002813 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002814 91a0 28d2                 	lds r26, triangle_arpeggio_macro_loop
002816 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002817 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002818 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002819 95a3                      	inc r26 //increment the macro offset
00281a 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
00281c 91b4                      	lpm r27, Z //load arpeggio data into r27
00281d 38b0                      	cpi r27, 0x80 //check for macro end flag
00281e f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
00281f c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002820 50a1                      	subi r26, 1 //keep the offset at the end flag
002821 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26
002823 91b0 28d4                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002825 30b1                      	cpi r27, 0x01
002826 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002827 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
002829 3fbf                      	cpi r27, 0xFF
00282a f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
00282b 91b0 28d2                 	lds r27, triangle_arpeggio_macro_loop
00282d 3fbf                      	cpi r27, 0xFF
00282e f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00282f c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002830 91b0 28d3                 	lds r27, triangle_arpeggio_macro_release
002832 3fbf                      	cpi r27, 0xFF
002833 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002834 91b0 28d2                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002836 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002837 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002838 91c0 28e7                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
00283a 91d0 28e8                 	lds r29, triangle_fx_0xy_sequence+1
00283c 9620                      	adiw r29:r28, 0
00283d f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00283e 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00283f 93a0 28d1                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002841 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002842 93b0 28d1                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002844 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002845 91c0 28e7                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002847 91d0 28e8                 	lds r29, triangle_fx_0xy_sequence+1
002849 9620                      	adiw r29:r28, 0 //check for 0xy effect
00284a f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
00284b 95d6                      	lsr r29
00284c 95c7                      	ror r28
00284d 95d7                      	ror r29
00284e 95c7                      	ror r28
00284f 95d7                      	ror r29
002850 95c7                      	ror r28
002851 95d7                      	ror r29
002852 95c7                      	ror r28
002853 95d7                      	ror r29
002854 95d2                      	swap r29
                                 
002855 93c0 28e7                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002857 93d0 28e8                 	sts triangle_fx_0xy_sequence+1, r29
002859 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00285a 91a0 2812                 	lds r26, triangle_note //load the current note index
00285c 0fac                      	add r26, r28 //add the note offset
00285d c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00285e 91a0 2812                 	lds r26, triangle_note //load the current note index
002860 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002861 9220 28d5                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002863 9220 28d6                 	sts triangle_total_pitch_offset+1, zero
002865 9220 28dc                 	sts triangle_total_hi_pitch_offset, zero
002867 91a0 28d4                 	lds r26, triangle_arpeggio_macro_mode
002869 30a1                      	cpi r26, 0x01 //absolute mode
00286a f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
00286b f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
00286c c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
00286d 91a0 2812                 	lds r26, triangle_note //load the current note index
00286f 0fab                      	add r26, r27 //offset the note with the arpeggio data
002870 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002871 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002872 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002873 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002874 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002875 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002876 fda7                      	sbrc r26, 7 //check if result is negative
002877 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002878 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002879 2fab                      	mov r26, r27 //move the arpeggio data into r26
00287a c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
00287b 91a0 2812                 	lds r26, triangle_note //load the current note index
00287d 0fab                      	add r26, r27 //offset the note with the arpeggio data
00287e fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00287f c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002880 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002882 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002883 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002884 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002885 93a0 2812                 	sts triangle_note, r26
002887 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002888 fda7                      	sbrc r26, 7 //check if result is negative
002889 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00288a 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
00288c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00288d e0f0                      	ldi ZH, HIGH(note_table << 1)
00288e 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00288f 0fea                      	add ZL, r26 //add offset
002890 1df2                      	adc ZH, zero
002891 91a5                      	lpm r26, Z+ //load bytes
002892 91b4                      	lpm r27, Z
002893 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002895 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002897 93a0 28f3                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002899 93b0 28f4                 	sts triangle_fx_3xx_target+1, r27
00289b c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
00289c 91e0 28d7                 	lds ZL, triangle_pitch_macro
00289e 91f0 28d8                 	lds ZH, triangle_pitch_macro+1
0028a0 9630                      	adiw Z, 0
0028a1 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
0028a2 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
0028a3 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0028a4 1fff                      	rol ZH
0028a5 91a0 28d9                 	lds r26, triangle_pitch_macro_offset
0028a7 0fea                      	add ZL, r26
0028a8 1df2                      	adc ZH, zero
                                 
0028a9 91b0 28db                 	lds r27, triangle_pitch_macro_release
0028ab 17ba                      	cp r27, r26
0028ac f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
0028ad 91a0 28da                 	lds r26, triangle_pitch_macro_loop
0028af 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0028b0 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0028b1 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
0028b2 95a3                      	inc r26 //increment the macro offset
0028b3 93a0 28d9                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
0028b5 91b4                      	lpm r27, Z //load pitch data into r27
0028b6 38b0                      	cpi r27, 0x80 //check for macro end flag
0028b7 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
0028b8 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0028b9 93a0 28d9                 	sts triangle_pitch_macro_offset, r26
0028bb 91b0 28db                 	lds r27, triangle_pitch_macro_release
0028bd 3fbf                      	cpi r27, 0xFF
0028be f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
0028bf 91b0 28da                 	lds r27, triangle_pitch_macro_loop //load the loop index
0028c1 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0028c2 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0028c3 93b0 28d9                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
0028c5 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
0028c6 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
0028c7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028c8 937f                      	push r23
0028c9 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0028ca eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028cb 0367                      	mulsu r22, r23
0028cc 917f                      	pop r23
0028cd 916f                      	pop r22
                                 
0028ce 9416                      	lsr r1 //shift out the fractional bits
0028cf 9407                      	ror r0
0028d0 9416                      	lsr r1
0028d1 9407                      	ror r0
0028d2 9416                      	lsr r1
0028d3 9407                      	ror r0
0028d4 9416                      	lsr r1
0028d5 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
0028d6 fe13                      	sbrs r1, 3 //check if result was a negative number
0028d7 c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
0028d8 efc0                      	ldi r28, 0xF0
0028d9 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
0028da 70b7                      	andi r27, 0b00000111
0028db f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
0028dc e0b1                      	ldi r27, 0x01
0028dd 0e0b                      	add r0, r27
0028de 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
0028df 91a0 28d5                 	lds r26, triangle_total_pitch_offset
0028e1 91b0 28d6                 	lds r27, triangle_total_pitch_offset+1
0028e3 0e0a                      	add r0, r26
0028e4 1e1b                      	adc r1, r27
0028e5 9200 28d5                 	sts triangle_total_pitch_offset, r0
0028e7 9210 28d6                 	sts triangle_total_pitch_offset+1, r1
0028e9 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
0028eb 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
0028ed 0da0                      	add r26, r0 //offset the timer values
0028ee 1db1                      	adc r27, r1
                                 	
0028ef 91c0 28eb                 	lds r28, triangle_fx_1xx_total
0028f1 91d0 28ec                 	lds r29, triangle_fx_1xx_total+1
0028f3 1bac                      	sub r26, r28
0028f4 0bbd                      	sbc r27, r29
0028f5 91c0 28ef                 	lds r28, triangle_fx_2xx_total
0028f7 91d0 28f0                 	lds r29, triangle_fx_2xx_total+1
0028f9 0fac                      	add r26, r28
0028fa 1fbd                      	adc r27, r29
0028fb 91c0 28fe                 	lds r28, triangle_fx_Pxx_total
0028fd 91d0 28ff                 	lds r29, triangle_fx_Pxx_total+1
0028ff 0fac                      	add r26, r28
002900 1fbd                      	adc r27, r29
002901 91c0 2905                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002903 91d0 2906                 	lds r29, triangle_fx_Qxy_total_offset+1
002905 1bac                      	sub r26, r28
002906 0bbd                      	sbc r27, r29
002907 91c0 290c                 	lds r28, triangle_fx_Rxy_total_offset
002909 91d0 290d                 	lds r29, triangle_fx_Rxy_total_offset+1
00290b 0fac                      	add r26, r28
00290c 1fbd                      	adc r27, r29
                                 
00290d 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
00290f 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002911 91e0 28dd                 	lds ZL, triangle_hi_pitch_macro
002913 91f0 28de                 	lds ZH, triangle_hi_pitch_macro+1
002915 9630                      	adiw Z, 0
002916 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002917 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002918 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002919 1fff                      	rol ZH
00291a 91a0 28df                 	lds r26, triangle_hi_pitch_macro_offset
00291c 0fea                      	add ZL, r26
00291d 1df2                      	adc ZH, zero
                                 
00291e 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_release
002920 17ba                      	cp r27, r26
002921 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002922 91a0 28e0                 	lds r26, triangle_hi_pitch_macro_loop
002924 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002925 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002926 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002927 95a3                      	inc r26 //increment the macro offset
002928 93a0 28df                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
00292a 91b4                      	lpm r27, Z //load hi pitch data into r27
00292b 38b0                      	cpi r27, 0x80 //check for macro end flag
00292c f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
00292d 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00292e 93a0 28df                 	sts triangle_hi_pitch_macro_offset, r26
002930 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_release
002932 3fbf                      	cpi r27, 0xFF
002933 f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002934 91b0 28e0                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002936 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002937 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002938 93b0 28df                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
00293a cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
00293b 91b0 28dc                 	lds r27, triangle_total_hi_pitch_offset
00293d c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
00293e 91a0 28dc                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002940 0fba                      	add r27, r26
002941 93b0 28dc                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002943 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002944 937f                      	push r23
002945 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002946 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002947 0367                      	mulsu r22, r23
002948 917f                      	pop r23
002949 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
00294a 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
00294c 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
00294e 0da0                      	add r26, r0 //offset the timer values
00294f 1db1                      	adc r27, r1
002950 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002952 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002954 91e0 28e9                 	lds ZL, triangle_fx_1xx
002956 91f0 28ea                 	lds ZH, triangle_fx_1xx+1
002958 9630                      	adiw Z, 0
002959 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
00295a 91a0 28eb                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
00295c 91b0 28ec                 	lds r27, triangle_fx_1xx_total+1
00295e 0fae                      	add r26, ZL //increase the total offset by the rate
00295f 1fbf                      	adc r27, ZH
002960 93a0 28eb                 	sts triangle_fx_1xx_total, r26
002962 93b0 28ec                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002964 91e0 28ed                 	lds ZL, triangle_fx_2xx
002966 91f0 28ee                 	lds ZH, triangle_fx_2xx+1
002968 9630                      	adiw Z, 0
002969 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
00296a 91a0 28ef                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
00296c 91b0 28f0                 	lds r27, triangle_fx_2xx_total+1
00296e 0fae                      	add r26, ZL //increase the total offset by the rate
00296f 1fbf                      	adc r27, ZH
002970 93a0 28ef                 	sts triangle_fx_2xx_total, r26
002972 93b0 28f0                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002974 91e0 28f5                 	lds ZL, triangle_fx_3xx_speed
002976 91f0 28f6                 	lds ZH, triangle_fx_3xx_speed+1
002978 9630                      	adiw Z, 0
002979 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
00297a c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
00297b 91a0 28f1                 	lds r26, triangle_fx_3xx_start
00297d 91b0 28f2                 	lds r27, triangle_fx_3xx_start+1
00297f 9610                      	adiw r26:r27, 0
002980 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002981 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002982 91c0 28f3                 	lds r28, triangle_fx_3xx_target
002984 91d0 28f4                 	lds r29, triangle_fx_3xx_target+1
                                 
002986 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002987 07bd                      	cpc r27, r29
002988 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002989 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00298a c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
00298b 9220 28f1                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00298d 9220 28f2                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
00298f c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002990 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002991 0bdb                      	sbc r29, r27
002992 91a0 28f7                 	lds r26, triangle_fx_3xx_total_offset
002994 91b0 28f8                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002996 0fae                      	add r26, ZL //add the speed to the total offset
002997 1fbf                      	adc r27, ZH
002998 1bca                      	sub r28, r26 //invert the total difference with the total offset
002999 0bdb                      	sbc r29, r27
00299a f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00299b 93a0 28f7                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
00299d 93b0 28f8                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
00299f 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
0029a1 91b0 0aad                 	lds r27, TCB2_CCMPH
0029a3 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0029a4 0bbd                      	sbc r27, r29
0029a5 93a0 0aac                 	sts TCB2_CCMPL, r26
0029a7 93b0 0aad                 	sts TCB2_CCMPH, r27
0029a9 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
0029aa 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0029ab 0bbd                      	sbc r27, r29
0029ac 91c0 28f7                 	lds r28, triangle_fx_3xx_total_offset
0029ae 91d0 28f8                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
0029b0 0fce                      	add r28, ZL //add the speed to the total offset
0029b1 1fdf                      	adc r29, ZH
0029b2 1bac                      	sub r26, r28 //invert the total difference with the total offset
0029b3 0bbd                      	sbc r27, r29
0029b4 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0029b5 93c0 28f7                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
0029b7 93d0 28f8                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
0029b9 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
0029bb 91d0 0aad                 	lds r29, TCB2_CCMPH
0029bd 0fca                      	add r28, r26 //offset the current timer period with the total offset
0029be 1fdb                      	adc r29, r27
0029bf 93c0 0aac                 	sts TCB2_CCMPL, r28
0029c1 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
0029c3 91a0 28f9                 	lds r26, triangle_fx_4xy_speed
0029c5 15a2                      	cp r26, zero
0029c6 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
0029c7 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
0029c8 91b0 28fa                 	lds r27, triangle_fx_4xy_depth
0029ca 91c0 28fb                 	lds r28, triangle_fx_4xy_phase
0029cc 0fca                      	add r28, r26 //increase the phase by the speed
0029cd 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0029ce f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0029cf e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
0029d0 93c0 28fb                 	sts triangle_fx_4xy_phase, r28 //store the new phase
0029d2 31c0                      	cpi r28, 16
0029d3 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
0029d4 32c0                      	cpi r28, 32
0029d5 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
0029d6 33c0                      	cpi r28, 48
0029d7 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
0029d8 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
0029d9 70cf                      	andi r28, 0x0F //mask for values 0-15
0029da c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
0029db 6fc0                      	ori r28, 0xF0
0029dc 95c0                      	com r28 //invert values 0-15
0029dd c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
0029de 70cf                      	andi r28, 0x0F //mask for values 0-15
0029df c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
0029e0 6fc0                      	ori r28, 0xF0
0029e1 95c0                      	com r28 //invert values 0-15
0029e2 c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
0029e3 95b2                      	swap r27 //multiply depth by 16
0029e4 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0029e5 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0029e6 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0029e7 0fec                      	add ZL, r28 //offset the table by the depth+phase
0029e8 1df2                      	adc ZH, zero
0029e9 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0029ea 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0029eb 937f                      	push r23
0029ec 2f6c                      	mov r22, r28 //store the vibrato value into r22
0029ed eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0029ee 9f67                      	mul r22, r23
0029ef 917f                      	pop r23
0029f0 916f                      	pop r22
                                 
0029f1 9416                      	lsr r1 //shift out the fractional bits
0029f2 9407                      	ror r0
0029f3 9416                      	lsr r1
0029f4 9407                      	ror r0
0029f5 9416                      	lsr r1
0029f6 9407                      	ror r0
0029f7 9416                      	lsr r1
0029f8 9407                      	ror r0
                                 	
0029f9 91a0 0aac                 	lds r26, TCB2_CCMPL
0029fb 91b0 0aad                 	lds r27, TCB2_CCMPH
0029fd 0da0                      	add r26, r0
0029fe 1db1                      	adc r27, r1
0029ff 93a0 0aac                 	sts TCB2_CCMPL, r26
002a01 93b0 0aad                 	sts TCB2_CCMPH, r27
002a03 c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002a04 95b2                      	swap r27 //multiply depth by 16
002a05 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002a06 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002a07 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002a08 0fec                      	add ZL, r28 //offset the table by the depth+phase
002a09 1df2                      	adc ZH, zero
002a0a 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002a0b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a0c 937f                      	push r23
002a0d 2f6c                      	mov r22, r28 //store the vibrato value into r22
002a0e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a0f 9f67                      	mul r22, r23
002a10 917f                      	pop r23
002a11 916f                      	pop r22
                                 
002a12 9416                      	lsr r1 //shift out the fractional bits
002a13 9407                      	ror r0
002a14 9416                      	lsr r1
002a15 9407                      	ror r0
002a16 9416                      	lsr r1
002a17 9407                      	ror r0
002a18 9416                      	lsr r1
002a19 9407                      	ror r0
                                 
002a1a 91a0 0aac                 	lds r26, TCB2_CCMPL
002a1c 91b0 0aad                 	lds r27, TCB2_CCMPH
002a1e 19a0                      	sub r26, r0
002a1f 09b1                      	sbc r27, r1
002a20 93a0 0aac                 	sts TCB2_CCMPL, r26
002a22 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002a24 91e0 2901                 	lds ZL, triangle_fx_Qxy_target
002a26 91f0 2902                 	lds ZH, triangle_fx_Qxy_target+1
002a28 9630                      	adiw Z, 0
002a29 f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002a2a 91a0 2905                 	lds r26, triangle_fx_Qxy_total_offset
002a2c 91b0 2906                 	lds r27, triangle_fx_Qxy_total_offset+1
002a2e 91c0 0aac                 	lds r28, TCB2_CCMPL
002a30 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002a32 1bec                      	sub ZL, r28 //calculate the difference to the target
002a33 0bfd                      	sbc ZH, r29
002a34 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002a35 f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002a36 9220 2905                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
002a38 9220 2906                 	sts triangle_fx_Qxy_total_offset+1, zero
002a3a 9220 2901                 	sts triangle_fx_Qxy_target, zero
002a3c 9220 2902                 	sts triangle_fx_Qxy_target+1, zero
002a3e 91b0 2900                 	lds r27, triangle_fx_Qxy_target_note
002a40 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002a42 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002a43 91c0 2903                 	lds r28, triangle_fx_Qxy_speed
002a45 91d0 2904                 	lds r29, triangle_fx_Qxy_speed+1
002a47 0fac                      	add r26, r28 //increase the total offset by the speed
002a48 1fbd                      	adc r27, r29
002a49 93a0 2905                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002a4b 93b0 2906                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002a4d 91e0 2908                 	lds ZL, triangle_fx_Rxy_target
002a4f 91f0 2909                 	lds ZH, triangle_fx_Rxy_target+1
002a51 9630                      	adiw Z, 0
002a52 f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002a53 91a0 290c                 	lds r26, triangle_fx_Rxy_total_offset
002a55 91b0 290d                 	lds r27, triangle_fx_Rxy_total_offset+1
002a57 91c0 0aac                 	lds r28, TCB2_CCMPL
002a59 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002a5b 1bce                      	sub r28, ZL //calculate the difference to the target
002a5c 0bdf                      	sbc r29, ZH
002a5d f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002a5e f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002a5f 9220 290c                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002a61 9220 290d                 	sts triangle_fx_Rxy_total_offset+1, zero
002a63 9220 2908                 	sts triangle_fx_Rxy_target, zero
002a65 9220 2909                 	sts triangle_fx_Rxy_target+1, zero
002a67 91b0 2907                 	lds r27, triangle_fx_Rxy_target_note
002a69 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002a6b c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002a6c 91c0 290a                 	lds r28, triangle_fx_Rxy_speed
002a6e 91d0 290b                 	lds r29, triangle_fx_Rxy_speed+1
002a70 0fac                      	add r26, r28 //increase the total offset by the speed
002a71 1fbd                      	adc r27, r29
002a72 93a0 290c                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002a74 93b0 290d                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002a76 91e0 2916                 	lds ZL, noise_volume_macro
002a78 91f0 2917                 	lds ZH, noise_volume_macro+1
002a7a 9630                      	adiw Z, 0
002a7b f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002a7c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002a7d 1fff                      	rol ZH
002a7e 91a0 2918                 	lds r26, noise_volume_macro_offset
002a80 0fea                      	add ZL, r26
002a81 1df2                      	adc ZH, zero
                                 
002a82 91b0 291a                 	lds r27, noise_volume_macro_release
002a84 17ba                      	cp r27, r26
002a85 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002a86 91a0 2919                 	lds r26, noise_volume_macro_loop
002a88 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a89 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a8a c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002a8b 95a3                      	inc r26 //increment the macro offset
002a8c 93a0 2918                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002a8e 91b4                      	lpm r27, Z //load volume data into r27
002a8f 3fbf                      	cpi r27, 0xFF //check for macro end flag
002a90 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002a91 91b0 291a                 	lds r27, noise_volume_macro_release
002a93 3fbf                      	cpi r27, 0xFF
002a94 f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002a95 91b0 2919                 	lds r27, noise_volume_macro_loop //load the loop index
002a97 93b0 2918                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002a99 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002a9a 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002a9b 93a0 2918                 	sts noise_volume_macro_offset, r26
002a9d cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002a9e e7e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002a9f e5fc                      	ldi ZH, HIGH(volumes << 1)
002aa0 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002aa1 0feb                      	add ZL, r27 //add offset to the table
002aa2 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002aa3 91b0 2813                 	lds r27, noise_param //load main volume
002aa5 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002aa6 91a0 294b                 	lds r26, noise_fx_7xy_value
002aa8 30a0                      	cpi r26, 0x00
002aa9 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002aaa 0feb                      	add ZL, r27 //offset the volume table by the main volume
002aab 1df2                      	adc ZH, zero
002aac 91b4                      	lpm r27, Z
002aad 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002aaf c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002ab0 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002ab2 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002ab3 91a0 294b                 	lds r26, noise_fx_7xy_value
002ab5 30a0                      	cpi r26, 0x00
002ab6 f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002ab7 93b0 2816                 	sts noise_output_volume, r27
002ab9 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002aba 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002abb f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002abc f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002abd 0feb                      	add ZL, r27 //offset the volume table by the main volume
002abe 1df2                      	adc ZH, zero
002abf 91b4                      	lpm r27, Z
002ac0 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002ac2 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002ac3 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002ac4 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ac5 1df2                      	adc ZH, zero
002ac6 91b4                      	lpm r27, Z
002ac7 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002ac9 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002aca 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002acb f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002acc f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002acd 93b0 2816                 	sts noise_output_volume, r27
002acf c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002ad0 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002ad1 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002ad3 91e0 291b                 	lds ZL, noise_arpeggio_macro
002ad5 91f0 291c                 	lds ZH, noise_arpeggio_macro+1
002ad7 9630                      	adiw Z, 0
002ad8 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002ad9 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002ada 1fff                      	rol ZH
002adb 91a0 291d                 	lds r26, noise_arpeggio_macro_offset
002add 0fea                      	add ZL, r26
002ade 1df2                      	adc ZH, zero
                                 
002adf 91b0 291f                 	lds r27, noise_arpeggio_macro_release
002ae1 17ba                      	cp r27, r26
002ae2 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002ae3 91a0 291e                 	lds r26, noise_arpeggio_macro_loop
002ae5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002ae6 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002ae7 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002ae8 95a3                      	inc r26 //increment the macro offset
002ae9 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002aeb 91b4                      	lpm r27, Z //load arpeggio data into r27
002aec 38b0                      	cpi r27, 0x80 //check for macro end flag
002aed f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002aee c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002aef 50a1                      	subi r26, 1 //keep the offset at the end flag
002af0 93a0 291d                 	sts noise_arpeggio_macro_offset, r26
002af2 91b0 2920                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002af4 30b1                      	cpi r27, 0x01
002af5 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002af6 91b0 291f                 	lds r27, noise_arpeggio_macro_release
002af8 3fbf                      	cpi r27, 0xFF
002af9 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002afa 91b0 291e                 	lds r27, noise_arpeggio_macro_loop
002afc 3fbf                      	cpi r27, 0xFF
002afd f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002afe c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002aff 91b0 291f                 	lds r27, noise_arpeggio_macro_release
002b01 3fbf                      	cpi r27, 0xFF
002b02 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002b03 91b0 291e                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002b05 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002b06 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002b07 91c0 2933                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002b09 91d0 2934                 	lds r29, noise_fx_0xy_sequence+1
002b0b 9620                      	adiw r29:r28, 0
002b0c f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002b0d 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002b0e 93a0 291d                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002b10 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002b11 93b0 291d                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002b13 cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002b14 91c0 2933                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002b16 91d0 2934                 	lds r29, noise_fx_0xy_sequence+1
002b18 9620                      	adiw r29:r28, 0 //check for 0xy effect
002b19 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_xy:
002b1a 95d6                      	lsr r29
002b1b 95c7                      	ror r28
002b1c 95d7                      	ror r29
002b1d 95c7                      	ror r28
002b1e 95d7                      	ror r29
002b1f 95c7                      	ror r28
002b20 95d7                      	ror r29
002b21 95c7                      	ror r28
002b22 95d7                      	ror r29
002b23 95d2                      	swap r29
                                 
002b24 93c0 2933                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002b26 93d0 2934                 	sts noise_fx_0xy_sequence+1, r29
002b28 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002b29 91a0 2817                 	lds r26, noise_note //load the current note index
002b2b 0fac                      	add r26, r28 //add the note offset
002b2c c02e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002b2d 91a0 2817                 	lds r26, noise_note //load the current note index
002b2f c02b                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002b30 9220 2921                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002b32 9220 2922                 	sts noise_total_pitch_offset+1, zero
002b34 9220 2928                 	sts noise_total_hi_pitch_offset, zero
002b36 91a0 2920                 	lds r26, noise_arpeggio_macro_mode
002b38 30a1                      	cpi r26, 0x01 //absolute mode
002b39 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002b3a f069                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002b3b c00e                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002b3c 91a0 2817                 	lds r26, noise_note //load the current note index
002b3e 0fab                      	add r26, r27 //offset the note with the arpeggio data
002b3f fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002b40 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_add:
002b41 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002b42 f0c0                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002b43 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002b44 c016                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute_subtract:
002b45 fda7                      	sbrc r26, 7 //check if result is negative
002b46 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002b47 c013                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002b48 2fab                      	mov r26, r27 //move the arpeggio data into r26
002b49 c011                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002b4a 91a0 2817                 	lds r26, noise_note //load the current note index
002b4c 0fab                      	add r26, r27 //offset the note with the arpeggio data
002b4d fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002b4e c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_add:
002b4f 93a0 2817                 	sts noise_note, r26 //NOTE: relative mode modifies the original note index
002b51 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002b52 f040                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_load //if the result is valid, go load the new note
002b53 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002b54 93a0 2817                 	sts noise_note, r26
002b56 c004                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative_subtract:
002b57 fda7                      	sbrc r26, 7 //check if result is negative
002b58 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002b59 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002b5b e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002b5c e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002b5d 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002b5e 0fea                      	add ZL, r26 //add offset
002b5f 1df2                      	adc ZH, zero
002b60 91a5                      	lpm r26, Z+ //load bytes
002b61 91b4                      	lpm r27, Z
002b62 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002b64 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
002b66 93a0 293f                 	sts noise_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002b68 93b0 2940                 	sts noise_fx_3xx_target+1, r27
002b6a c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002b6b 91e0 2923                 	lds ZL, noise_pitch_macro
002b6d 91f0 2924                 	lds ZH, noise_pitch_macro+1
002b6f 9630                      	adiw Z, 0
002b70 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002b71 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002b72 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002b73 1fff                      	rol ZH
002b74 91a0 2925                 	lds r26, noise_pitch_macro_offset
002b76 0fea                      	add ZL, r26
002b77 1df2                      	adc ZH, zero
                                 
002b78 91b0 2927                 	lds r27, noise_pitch_macro_release
002b7a 17ba                      	cp r27, r26
002b7b f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002b7c 91a0 2926                 	lds r26, noise_pitch_macro_loop
002b7e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002b7f f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002b80 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002b81 95a3                      	inc r26 //increment the macro offset
002b82 93a0 2925                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002b84 91b4                      	lpm r27, Z //load pitch data into r27
002b85 38b0                      	cpi r27, 0x80 //check for macro end flag
002b86 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002b87 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002b88 93a0 2925                 	sts noise_pitch_macro_offset, r26
002b8a 91b0 2927                 	lds r27, noise_pitch_macro_release
002b8c 3fbf                      	cpi r27, 0xFF
002b8d f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002b8e 91b0 2926                 	lds r27, noise_pitch_macro_loop //load the loop index
002b90 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002b91 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002b92 93b0 2925                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
002b94 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
002b95 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
002b96 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b97 937f                      	push r23
002b98 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002b99 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b9a 0367                      	mulsu r22, r23
002b9b 917f                      	pop r23
002b9c 916f                      	pop r22
                                 
002b9d 9416                      	lsr r1 //shift out the fractional bits
002b9e 9407                      	ror r0
002b9f 9416                      	lsr r1
002ba0 9407                      	ror r0
002ba1 9416                      	lsr r1
002ba2 9407                      	ror r0
002ba3 9416                      	lsr r1
002ba4 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_check_negative:
002ba5 fe13                      	sbrs r1, 3 //check if result was a negative number
002ba6 c007                      	rjmp sound_driver_instrument_routine_channel3_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_negative:
002ba7 efc0                      	ldi r28, 0xF0
002ba8 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_check_divisible_8:
002ba9 70b7                      	andi r27, 0b00000111
002baa f019                      	breq sound_driver_instrument_routine_channel3_pitch_calculate_offset
                                 
002bab e0b1                      	ldi r27, 0x01
002bac 0e0b                      	add r0, r27
002bad 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
002bae 91a0 2921                 	lds r26, noise_total_pitch_offset
002bb0 91b0 2922                 	lds r27, noise_total_pitch_offset+1
002bb2 0e0a                      	add r0, r26
002bb3 1e1b                      	adc r1, r27
002bb4 9200 2921                 	sts noise_total_pitch_offset, r0
002bb6 9210 2922                 	sts noise_total_pitch_offset+1, r1
002bb8 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002bba 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002bbc 0da0                      	add r26, r0 //offset the timer values
002bbd 1db1                      	adc r27, r1
                                 	
002bbe 91c0 2937                 	lds r28, noise_fx_1xx_total
002bc0 91d0 2938                 	lds r29, noise_fx_1xx_total+1
002bc2 1bac                      	sub r26, r28
002bc3 0bbd                      	sbc r27, r29
002bc4 91c0 293b                 	lds r28, noise_fx_2xx_total
002bc6 91d0 293c                 	lds r29, noise_fx_2xx_total+1
002bc8 0fac                      	add r26, r28
002bc9 1fbd                      	adc r27, r29
002bca 91c0 294f                 	lds r28, noise_fx_Pxx_total
002bcc 91d0 2950                 	lds r29, noise_fx_Pxx_total+1
002bce 0fac                      	add r26, r28
002bcf 1fbd                      	adc r27, r29
002bd0 91c0 2956                 	lds r28, noise_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002bd2 91d0 2957                 	lds r29, noise_fx_Qxy_total_offset+1
002bd4 1bac                      	sub r26, r28
002bd5 0bbd                      	sbc r27, r29
002bd6 91c0 295d                 	lds r28, noise_fx_Rxy_total_offset
002bd8 91d0 295e                 	lds r29, noise_fx_Rxy_total_offset+1
002bda 0fac                      	add r26, r28
002bdb 1fbd                      	adc r27, r29
                                 
002bdc 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002bde 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
002be0 91e0 2929                 	lds ZL, noise_hi_pitch_macro
002be2 91f0 292a                 	lds ZH, noise_hi_pitch_macro+1
002be4 9630                      	adiw Z, 0
002be5 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
002be6 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
002be7 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002be8 1fff                      	rol ZH
002be9 91a0 292b                 	lds r26, noise_hi_pitch_macro_offset
002beb 0fea                      	add ZL, r26
002bec 1df2                      	adc ZH, zero
                                 
002bed 91b0 292d                 	lds r27, noise_hi_pitch_macro_release
002bef 17ba                      	cp r27, r26
002bf0 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002bf1 91a0 292c                 	lds r26, noise_hi_pitch_macro_loop
002bf3 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002bf4 f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002bf5 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
002bf6 95a3                      	inc r26 //increment the macro offset
002bf7 93a0 292b                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
002bf9 91b4                      	lpm r27, Z //load hi pitch data into r27
002bfa 38b0                      	cpi r27, 0x80 //check for macro end flag
002bfb f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
002bfc 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002bfd 93a0 292b                 	sts noise_hi_pitch_macro_offset, r26
002bff 91b0 292d                 	lds r27, noise_hi_pitch_macro_release
002c01 3fbf                      	cpi r27, 0xFF
002c02 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
002c03 91b0 292c                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
002c05 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002c06 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002c07 93b0 292b                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
002c09 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
002c0a 91b0 2928                 	lds r27, noise_total_hi_pitch_offset
002c0c c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
002c0d 91a0 2928                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
002c0f 0fba                      	add r27, r26
002c10 93b0 2928                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
002c12 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002c13 937f                      	push r23
002c14 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002c15 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002c16 0367                      	mulsu r22, r23
002c17 917f                      	pop r23
002c18 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
002c19 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002c1b 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002c1d 0da0                      	add r26, r0 //offset the timer values
002c1e 1db1                      	adc r27, r1
002c1f 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002c21 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
002c23 91e0 292e                 	lds ZL, noise_duty_macro
002c25 91f0 292f                 	lds ZH, noise_duty_macro+1
002c27 9630                      	adiw Z, 0
002c28 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
002c29 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002c2a 1fff                      	rol ZH
002c2b 91a0 2930                 	lds r26, noise_duty_macro_offset
002c2d 0fea                      	add ZL, r26
002c2e 1df2                      	adc ZH, zero
                                 
002c2f 91b0 2932                 	lds r27, noise_duty_macro_release
002c31 17ba                      	cp r27, r26
002c32 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
002c33 91a0 2931                 	lds r26, noise_duty_macro_loop
002c35 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c36 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c37 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
002c38 95a3                      	inc r26 //increment the macro offset
002c39 93a0 2930                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
002c3b 91b4                      	lpm r27, Z //load pitch data into r27
002c3c 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c3d f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
002c3e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002c3f 93a0 2930                 	sts noise_duty_macro_offset, r26
002c41 91b0 2932                 	lds r27, noise_duty_macro_release
002c43 3fbf                      	cpi r27, 0xFF
002c44 f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
002c45 91b0 2931                 	lds r27, noise_duty_macro_loop //load the loop index
002c47 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002c48 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002c49 93b0 2930                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
002c4b cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
002c4c 95b6                      	lsr r27
002c4d 95b7                      	ror r27 //move mode bit to bit 7
002c4e 91c0 2814                 	lds r28, noise_period
002c50 77cf                      	andi r28, 0b01111111
002c51 2bcb                      	or r28, r27 //store the new noise mode
002c52 93c0 2813                 	sts noise_param, r28
                                 
002c54 776f                      	andi noise_sequence_HIGH, 0b01111111
002c55 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
002c56 91e0 2935                 	lds ZL, noise_fx_1xx
002c58 91f0 2936                 	lds ZH, noise_fx_1xx+1
002c5a 9630                      	adiw Z, 0
002c5b f051                      	breq sound_driver_channel3_fx_2xx_routine
                                 
002c5c 91a0 2937                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
002c5e 91b0 2938                 	lds r27, noise_fx_1xx_total+1
002c60 0fae                      	add r26, ZL //increase the total offset by the rate
002c61 1fbf                      	adc r27, ZH
002c62 93a0 2937                 	sts noise_fx_1xx_total, r26
002c64 93b0 2938                 	sts noise_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
002c66 91e0 2939                 	lds ZL, noise_fx_2xx
002c68 91f0 293a                 	lds ZH, noise_fx_2xx+1
002c6a 9630                      	adiw Z, 0
002c6b f051                      	breq sound_driver_channel3_fx_3xx_routine
                                 
002c6c 91a0 293b                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
002c6e 91b0 293c                 	lds r27, noise_fx_2xx_total+1
002c70 0fae                      	add r26, ZL //increase the total offset by the rate
002c71 1fbf                      	adc r27, ZH
002c72 93a0 293b                 	sts noise_fx_2xx_total, r26
002c74 93b0 293c                 	sts noise_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
002c76 91e0 2941                 	lds ZL, noise_fx_3xx_speed
002c78 91f0 2942                 	lds ZH, noise_fx_3xx_speed+1
002c7a 9630                      	adiw Z, 0
002c7b f409                      	brne sound_driver_channel3_fx_3xx_routine_check_start
002c7c c048                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_check_start:
002c7d 91a0 293d                 	lds r26, noise_fx_3xx_start
002c7f 91b0 293e                 	lds r27, noise_fx_3xx_start+1
002c81 9610                      	adiw r26:r27, 0
002c82 f409                      	brne sound_driver_channel3_fx_3xx_routine_main
002c83 c041                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_main:
002c84 91c0 293f                 	lds r28, noise_fx_3xx_target
002c86 91d0 2940                 	lds r29, noise_fx_3xx_target+1
                                 
002c88 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002c89 07bd                      	cpc r27, r29
002c8a f011                      	breq sound_driver_channel3_fx_3xx_routine_disable
002c8b f030                      	brlo sound_driver_channel3_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002c8c c01f                      	rjmp sound_driver_channel3_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel3_fx_3xx_routine_disable:
002c8d 9220 293d                 	sts noise_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002c8f 9220 293e                 	sts noise_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002c91 c033                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_subtract:
002c92 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002c93 0bdb                      	sbc r29, r27
002c94 91a0 2943                 	lds r26, noise_fx_3xx_total_offset
002c96 91b0 2944                 	lds r27, noise_fx_3xx_total_offset+1
                                 
002c98 0fae                      	add r26, ZL //add the speed to the total offset
002c99 1fbf                      	adc r27, ZH
002c9a 1bca                      	sub r28, r26 //invert the total difference with the total offset
002c9b 0bdb                      	sbc r29, r27
002c9c f380                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002c9d 93a0 2943                 	sts noise_fx_3xx_total_offset, r26 //store the new total offset
002c9f 93b0 2944                 	sts noise_fx_3xx_total_offset+1, r27
                                 
002ca1 91a0 0abc                 	lds r26, TCB3_CCMPL //load the current timer period
002ca3 91b0 0abd                 	lds r27, TCB3_CCMPH
002ca5 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002ca6 0bbd                      	sbc r27, r29
002ca7 93a0 0abc                 	sts TCB3_CCMPL, r26
002ca9 93b0 0abd                 	sts TCB3_CCMPH, r27
002cab c019                      	rjmp sound_driver_channel3_fx_4xy_routine
                                 
                                 sound_driver_channel3_fx_3xx_routine_add:
002cac 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002cad 0bbd                      	sbc r27, r29
002cae 91c0 2943                 	lds r28, noise_fx_3xx_total_offset
002cb0 91d0 2944                 	lds r29, noise_fx_3xx_total_offset+1
                                 
002cb2 0fce                      	add r28, ZL //add the speed to the total offset
002cb3 1fdf                      	adc r29, ZH
002cb4 1bac                      	sub r26, r28 //invert the total difference with the total offset
002cb5 0bbd                      	sbc r27, r29
002cb6 f2b0                      	brlo sound_driver_channel3_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002cb7 93c0 2943                 	sts noise_fx_3xx_total_offset, r28 //store the new total offset
002cb9 93d0 2944                 	sts noise_fx_3xx_total_offset+1, r29
                                 
002cbb 91c0 0abc                 	lds r28, TCB3_CCMPL //load the current timer period
002cbd 91d0 0abd                 	lds r29, TCB3_CCMPH
002cbf 0fca                      	add r28, r26 //offset the current timer period with the total offset
002cc0 1fdb                      	adc r29, r27
002cc1 93c0 0abc                 	sts TCB3_CCMPL, r28
002cc3 93d0 0abd                 	sts TCB3_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
002cc5 91a0 2945                 	lds r26, noise_fx_4xy_speed
002cc7 15a2                      	cp r26, zero
002cc8 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
002cc9 c05c                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
002cca 91b0 2946                 	lds r27, noise_fx_4xy_depth
002ccc 91c0 2947                 	lds r28, noise_fx_4xy_phase
002cce 0fca                      	add r28, r26 //increase the phase by the speed
002ccf 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002cd0 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002cd1 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
002cd2 93c0 2947                 	sts noise_fx_4xy_phase, r28 //store the new phase
002cd4 31c0                      	cpi r28, 16
002cd5 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
002cd6 32c0                      	cpi r28, 32
002cd7 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
002cd8 33c0                      	cpi r28, 48
002cd9 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
002cda c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
002cdb 70cf                      	andi r28, 0x0F //mask for values 0-15
002cdc c029                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
002cdd 6fc0                      	ori r28, 0xF0
002cde 95c0                      	com r28 //invert values 0-15
002cdf c026                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
002ce0 70cf                      	andi r28, 0x0F //mask for values 0-15
002ce1 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
002ce2 6fc0                      	ori r28, 0xF0
002ce3 95c0                      	com r28 //invert values 0-15
002ce4 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
002ce5 95b2                      	swap r27 //multiply depth by 16
002ce6 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002ce7 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002ce8 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002ce9 0fec                      	add ZL, r28 //offset the table by the depth+phase
002cea 1df2                      	adc ZH, zero
002ceb 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002cec 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ced 937f                      	push r23
002cee 2f6c                      	mov r22, r28 //store the vibrato value into r22
002cef eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002cf0 9f67                      	mul r22, r23
002cf1 917f                      	pop r23
002cf2 916f                      	pop r22
                                 
002cf3 9416                      	lsr r1 //shift out the fractional bits
002cf4 9407                      	ror r0
002cf5 9416                      	lsr r1
002cf6 9407                      	ror r0
002cf7 9416                      	lsr r1
002cf8 9407                      	ror r0
002cf9 9416                      	lsr r1
002cfa 9407                      	ror r0
                                 	
002cfb 91a0 0abc                 	lds r26, TCB3_CCMPL
002cfd 91b0 0abd                 	lds r27, TCB3_CCMPH
002cff 0da0                      	add r26, r0
002d00 1db1                      	adc r27, r1
002d01 93a0 0abc                 	sts TCB3_CCMPL, r26
002d03 93b0 0abd                 	sts TCB3_CCMPH, r27
002d05 c020                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
002d06 95b2                      	swap r27 //multiply depth by 16
002d07 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002d08 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002d09 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002d0a 0fec                      	add ZL, r28 //offset the table by the depth+phase
002d0b 1df2                      	adc ZH, zero
002d0c 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002d0d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d0e 937f                      	push r23
002d0f 2f6c                      	mov r22, r28 //store the vibrato value into r22
002d10 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d11 9f67                      	mul r22, r23
002d12 917f                      	pop r23
002d13 916f                      	pop r22
                                 
002d14 9416                      	lsr r1 //shift out the fractional bits
002d15 9407                      	ror r0
002d16 9416                      	lsr r1
002d17 9407                      	ror r0
002d18 9416                      	lsr r1
002d19 9407                      	ror r0
002d1a 9416                      	lsr r1
002d1b 9407                      	ror r0
                                 
002d1c 91a0 0abc                 	lds r26, TCB3_CCMPL
002d1e 91b0 0abd                 	lds r27, TCB3_CCMPH
002d20 19a0                      	sub r26, r0
002d21 09b1                      	sbc r27, r1
002d22 93a0 0abc                 	sts TCB3_CCMPL, r26
002d24 93b0 0abd                 	sts TCB3_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
002d26 91a0 2948                 	lds r26, noise_fx_7xy_speed
002d28 15a2                      	cp r26, zero
002d29 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002d2a 91b0 2949                 	lds r27, noise_fx_7xy_depth
002d2c 91c0 294a                 	lds r28, noise_fx_7xy_phase
002d2e 0fca                      	add r28, r26 //increase the phase by the speed
002d2f 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002d30 f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002d31 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
002d32 93c0 294a                 	sts noise_fx_7xy_phase, r28 //store the new phase
002d34 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002d35 ffc4                      	sbrs r28, 4
002d36 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
002d37 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
002d38 70cf                      	andi r28, 0x0F //mask for values 0-15
002d39 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
002d3a 6fc0                      	ori r28, 0xF0
002d3b 95c0                      	com r28 //invert values 0-15
002d3c c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
002d3d 95b2                      	swap r27 //multiply depth by 16
002d3e 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002d3f e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002d40 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002d41 0fec                      	add ZL, r28 //offset the table by the depth+phase
002d42 1df2                      	adc ZH, zero
002d43 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002d44 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002d45 93c0 294b                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
002d47 91b0 294c                 	lds r27, noise_fx_Axy
002d49 15b2                      	cp r27, zero
002d4a f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002d4b 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
002d4d 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
002d4f 2fda                      	mov r29, r26 //copy fractional volume into r29
002d50 2fec                      	mov r30, r28 //copy the noise_param into r30
002d51 95e2                      	swap r30
002d52 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002d53 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002d54 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002d55 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
002d56 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
002d57 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002d58 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
002d59 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002d5a f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002d5b efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002d5c c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
002d5d 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002d5e f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002d5f e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
002d60 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
002d62 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002d63 95a2                      	swap r26
002d64 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002d65 2bca                      	or r28, r26 //store the new volume back into noise_param
002d66 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel3_fx_Qxy_routine:
002d68 91e0 2952                 	lds ZL, noise_fx_Qxy_target
002d6a 91f0 2953                 	lds ZH, noise_fx_Qxy_target+1
002d6c 9630                      	adiw Z, 0
002d6d f119                      	breq sound_driver_channel3_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002d6e 91a0 2956                 	lds r26, noise_fx_Qxy_total_offset
002d70 91b0 2957                 	lds r27, noise_fx_Qxy_total_offset+1
002d72 91c0 0abc                 	lds r28, TCB3_CCMPL
002d74 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
002d76 1bec                      	sub ZL, r28 //calculate the difference to the target
002d77 0bfd                      	sbc ZH, r29
002d78 f408                      	brsh sound_driver_channel3_fx_Qxy_routine_end //if the target has been reached (or passed)
002d79 f068                      	brlo sound_driver_channel3_fx_Qxy_routine_add
                                 
                                 sound_driver_channel3_fx_Qxy_routine_end:
002d7a 9220 2956                 	sts noise_fx_Qxy_total_offset, zero //turn off the effect
002d7c 9220 2957                 	sts noise_fx_Qxy_total_offset+1, zero
002d7e 9220 2952                 	sts noise_fx_Qxy_target, zero
002d80 9220 2953                 	sts noise_fx_Qxy_target+1, zero
002d82 91b0 2951                 	lds r27, noise_fx_Qxy_target_note
002d84 93b0 2817                 	sts noise_note, r27 //replace the note with the final target note
002d86 c00a                      	rjmp sound_driver_channel3_fx_Rxy_routine
                                 
                                 sound_driver_channel3_fx_Qxy_routine_add:
002d87 91c0 2954                 	lds r28, noise_fx_Qxy_speed
002d89 91d0 2955                 	lds r29, noise_fx_Qxy_speed+1
002d8b 0fac                      	add r26, r28 //increase the total offset by the speed
002d8c 1fbd                      	adc r27, r29
002d8d 93a0 2956                 	sts noise_fx_Qxy_total_offset, r26 //store the total offset
002d8f 93b0 2957                 	sts noise_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
002d91 91e0 2959                 	lds ZL, noise_fx_Rxy_target
002d93 91f0 295a                 	lds ZH, noise_fx_Rxy_target+1
002d95 9630                      	adiw Z, 0
002d96 f119                      	breq sound_driver_instrument_routine_channel4_volume //if the effect is not enabled, skip the routine
                                 
002d97 91a0 295d                 	lds r26, noise_fx_Rxy_total_offset
002d99 91b0 295e                 	lds r27, noise_fx_Rxy_total_offset+1
002d9b 91c0 0abc                 	lds r28, TCB3_CCMPL
002d9d 91d0 0abd                 	lds r29, TCB3_CCMPH
                                 
002d9f 1bce                      	sub r28, ZL //calculate the difference to the target
002da0 0bdf                      	sbc r29, ZH
002da1 f408                      	brsh sound_driver_channel3_fx_Rxy_routine_end //if the target has been reached (or passed)
002da2 f068                      	brlo sound_driver_channel3_fx_Rxy_routine_add
                                 
                                 sound_driver_channel3_fx_Rxy_routine_end:
002da3 9220 295d                 	sts noise_fx_Rxy_total_offset, zero //disable the effect
002da5 9220 295e                 	sts noise_fx_Rxy_total_offset+1, zero
002da7 9220 2959                 	sts noise_fx_Rxy_target, zero
002da9 9220 295a                 	sts noise_fx_Rxy_target+1, zero
002dab 91b0 2958                 	lds r27, noise_fx_Rxy_target_note
002dad 93b0 2817                 	sts noise_note, r27 //replace the note with the final target note
002daf c00a                      	rjmp sound_driver_instrument_routine_channel4_volume
                                 
                                 sound_driver_channel3_fx_Rxy_routine_add:
002db0 91c0 295b                 	lds r28, noise_fx_Rxy_speed
002db2 91d0 295c                 	lds r29, noise_fx_Rxy_speed+1
002db4 0fac                      	add r26, r28 //increase the total offset by the speed
002db5 1fbd                      	adc r27, r29
002db6 93a0 295d                 	sts noise_fx_Rxy_total_offset, r26 //store the total offset
002db8 93b0 295e                 	sts noise_fx_Rxy_total_offset+1, r27
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
002dba 91ff                      	pop r31
002dbb 91ef                      	pop r30
002dbc 91df                      	pop r29
002dbd 91cf                      	pop r28
002dbe 940c 1293                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
002dc0 7f05
002dc1 010a
002dc2 0214
002dc3 0328
002dc4 0450
002dc5 051e
002dc6 0607
002dc7 070d
002dc8 0806
002dc9 090c
002dca 0a18
002dcb 0b30
002dcc 0c60
002dcd 0d24
002dce 0e08
002dcf 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
002dd0 0301
002dd1 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
002dd2 14cf
002dd3 14d4
002dd4 14f0
002dd5 150c
002dd6 152f                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
002dd7 153a
002dd8 1547
002dd9 154a
002dda 154d
002ddb 1550                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
002ddc 1553
002ddd 155b
002dde 155e
002ddf 156b
002de0 156c                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
002de1 156d
002de2 156e
002de3 156f
002de4 1587
002de5 15cc                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
002de6 1610
002de7 161d
002de8 1631
002de9 1632
002dea 1633                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
002deb 1634                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
002dec 17bf
002ded 17c4
002dee 17e0
002def 17fc
002df0 181f                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
002df1 182a
002df2 1837
002df3 183a
002df4 183d
002df5 1840                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
002df6 1843
002df7 184b
002df8 184e
002df9 185b
002dfa 185c                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
002dfb 185d
002dfc 185e
002dfd 185f
002dfe 1877
002dff 18bc                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
002e00 1900
002e01 190d
002e02 1921
002e03 1922
002e04 1923                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
002e05 1924                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
002e06 1aa2
002e07 1aa7
002e08 1ac3
002e09 1adf
002e0a 1b02                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
002e0b 1b0d
002e0c 1b0e
002e0d 1b0f
002e0e 1b12
002e0f 1b15                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
002e10 1b18
002e11 1b25
002e12 1b28
002e13 1b35
002e14 1b36                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
002e15 1b37
002e16 1b38
002e17 1b39
002e18 1b51
002e19 1b96                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
002e1a 1bda
002e1b 1be7
002e1c 1be8
002e1d 1be9
002e1e 1bea                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
002e1f 1beb                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
002e20 1d6d
002e21 1d72
002e22 1d8e
002e23 1daa
002e24 1dcd                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
002e25 1dd8
002e26 1de5
002e27 1de8
002e28 1deb
002e29 1dee                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
002e2a 1df1
002e2b 1df8
002e2c 1dfb
002e2d 1e08
002e2e 1e09                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
002e2f 1e0a
002e30 1e0b
002e31 1e0c
002e32 1e24
002e33 1e69                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
002e34 1ead
002e35 1eba
002e36 1ec5
002e37 1ec6
002e38 1ec7                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
002e39 1ec8                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
002e3a 0000
002e3b 0000
002e3c 0000
002e3d 0000
002e3e 0000
002e3f 0000
002e40 0000
002e41 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
002e42 0100
002e43 0101
002e44 0101
002e45 0101
002e46 0101
002e47 0101
002e48 0101
002e49 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
002e4a 0100
002e4b 0101
002e4c 0101
002e4d 0101
002e4e 0101
002e4f 0101
002e50 0101
002e51 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
002e52 0100
002e53 0101
002e54 0101
002e55 0101
002e56 0101
002e57 0202
002e58 0202
002e59 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
002e5a 0100
002e5b 0101
002e5c 0101
002e5d 0101
002e5e 0202
002e5f 0202
002e60 0303
002e61 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
002e62 0100
002e63 0101
002e64 0101
002e65 0202
002e66 0302
002e67 0303
002e68 0404
002e69 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
002e6a 0100
002e6b 0101
002e6c 0201
002e6d 0202
002e6e 0303
002e6f 0404
002e70 0504
002e71 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
002e72 0100
002e73 0101
002e74 0201
002e75 0302
002e76 0403
002e77 0504
002e78 0605
002e79 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
002e7a 0100
002e7b 0101
002e7c 0202
002e7d 0303
002e7e 0404
002e7f 0505
002e80 0606
002e81 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
002e82 0100
002e83 0101
002e84 0302
002e85 0403
002e86 0504
002e87 0606
002e88 0707
002e89 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
002e8a 0100
002e8b 0201
002e8c 0302
002e8d 0404
002e8e 0605
002e8f 0706
002e90 0808
002e91 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
002e92 0100
002e93 0201
002e94 0302
002e95 0504
002e96 0605
002e97 0807
002e98 0908
002e99 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
002e9a 0100
002e9b 0201
002e9c 0403
002e9d 0504
002e9e 0706
002e9f 0808
002ea0 0a09
002ea1 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
002ea2 0100
002ea3 0201
002ea4 0403
002ea5 0605
002ea6 0706
002ea7 0908
002ea8 0b0a
002ea9 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
002eaa 0100
002eab 0201
002eac 0403
002ead 0605
002eae 0807
002eaf 0a09
002eb0 0c0b
002eb1 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
002eb2 0100
002eb3 0302
002eb4 0504
002eb5 0706
002eb6 0908
002eb7 0b0a
002eb8 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 248 r0 : 196 r1 : 212 r2 : 717 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 174 r23: 160 r24:   0 r25:  24 r26: 955 r27:1197 r28: 687 
r29: 356 r30: 374 r31: 333 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 144 add   : 191 adiw  : 106 and   :   0 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   7 brcs  :  13 break :   0 breq  : 173 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  81 brlt  :   0 brmi  :   0 
brne  : 121 brpl  :   0 brsh  :  31 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 101 cpc   :  10 
cpi   : 168 cpse  :  28 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  48 
jmp   :  11 ld    :   0 ldd   :   0 ldi   : 294 lds   : 719 lpm   : 260 
lsl   :  79 lsr   : 171 mov   : 139 movw  :   0 mul   :  28 muls  :   0 
mulsu :  12 neg   :   0 nop   :   0 or    :  26 ori   :  12 out   :   9 
pop   : 115 push  : 109 rcall :  50 ret   :  32 reti  :   7 rjmp  : 534 
rol   :  53 ror   : 192 sbc   :  40 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  29 sbrs  :  20 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1405 sub   :  58 subi  :  45 swap  :  46 tst   :   0 wdr   :   0 

Instructions used: 52 out of 114 (45.6%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x005d74  15902   7910  23812   49152  48.4%
[.dseg] 0x002800 0x002962      0    354    354    6144   5.8%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 55 warnings
