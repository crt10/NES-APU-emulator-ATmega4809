
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Thu Jan 21 19:52:15 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           song_frames: .byte 2
002815                           song_frame_offset: .byte 2
002817                           song_size: .byte 2
002819                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
00281a                           song_fx_Bxx: .byte 1
00281b                           song_fx_Cxx: .byte 1
00281c                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
00281d                           pulse1_pattern: .byte 2
00281f                           pulse1_pattern_delay_rows: .byte 1
002820                           pulse1_pattern_delay_frames: .byte 1
002821                           pulse1_pattern_offset: .byte 2
                                 
002823                           pulse1_volume_macro: .byte 2
002825                           pulse1_volume_macro_offset: .byte 1
002826                           pulse1_volume_macro_loop: .byte 1
002827                           pulse1_volume_macro_release: .byte 1
                                 
002828                           pulse1_arpeggio_macro: .byte 2
00282a                           pulse1_arpeggio_macro_offset: .byte 1
00282b                           pulse1_arpeggio_macro_loop: .byte 1
00282c                           pulse1_arpeggio_macro_release: .byte 1
00282d                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00282e                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002830                           pulse1_pitch_macro: .byte 2
002832                           pulse1_pitch_macro_offset: .byte 1
002833                           pulse1_pitch_macro_loop: .byte 1
002834                           pulse1_pitch_macro_release: .byte 1
                                 
002835                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002836                           pulse1_hi_pitch_macro: .byte 2
002838                           pulse1_hi_pitch_macro_offset: .byte 1
002839                           pulse1_hi_pitch_macro_loop: .byte 1
00283a                           pulse1_hi_pitch_macro_release: .byte 1
                                 
00283b                           pulse1_duty_macro: .byte 2
00283d                           pulse1_duty_macro_offset: .byte 1
00283e                           pulse1_duty_macro_loop: .byte 1
00283f                           pulse1_duty_macro_release: .byte 1
                                 
002840                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002842                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002844                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002846                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002848                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
00284a                           pulse1_fx_3xx_start: .byte 2 //the starting note period
00284c                           pulse1_fx_3xx_target: .byte 2 //target note period
00284e                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002850                           pulse1_fx_3xx_total_offset: .byte 2
002852                           pulse1_fx_4xy_speed: .byte 1
002853                           pulse1_fx_4xy_depth: .byte 1
002854                           pulse1_fx_4xy_phase: .byte 1
002855                           pulse1_fx_7xy_speed: .byte 1
002856                           pulse1_fx_7xy_depth: .byte 1
002857                           pulse1_fx_7xy_phase: .byte 1
002858                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002859                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00285a                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00285b                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00285c                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
00285e                           pulse1_fx_Qxy_target: .byte 2 //target note period
002860                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002862                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002864                           pulse1_fx_Rxy_target: .byte 2 //target note period
002866                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002868                           pulse1_fx_Rxy_total_offset: .byte 2
00286a                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
00286b                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
00286c                           pulse2_pattern: .byte 2
00286e                           pulse2_pattern_delay_rows: .byte 1
00286f                           pulse2_pattern_delay_frames: .byte 1
002870                           pulse2_pattern_offset: .byte 2
                                 
002872                           pulse2_volume_macro: .byte 2
002874                           pulse2_volume_macro_offset: .byte 1
002875                           pulse2_volume_macro_loop: .byte 1
002876                           pulse2_volume_macro_release: .byte 1
                                 
002877                           pulse2_arpeggio_macro: .byte 2
002879                           pulse2_arpeggio_macro_offset: .byte 1
00287a                           pulse2_arpeggio_macro_loop: .byte 1
00287b                           pulse2_arpeggio_macro_release: .byte 1
00287c                           pulse2_arpeggio_macro_mode: .byte 1
                                 
00287d                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
00287f                           pulse2_pitch_macro: .byte 2
002881                           pulse2_pitch_macro_offset: .byte 1
002882                           pulse2_pitch_macro_loop: .byte 1
002883                           pulse2_pitch_macro_release: .byte 1
                                 
002884                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002885                           pulse2_hi_pitch_macro: .byte 2
002887                           pulse2_hi_pitch_macro_offset: .byte 1
002888                           pulse2_hi_pitch_macro_loop: .byte 1
002889                           pulse2_hi_pitch_macro_release: .byte 1
                                 
00288a                           pulse2_duty_macro: .byte 2
00288c                           pulse2_duty_macro_offset: .byte 1
00288d                           pulse2_duty_macro_loop: .byte 1
00288e                           pulse2_duty_macro_release: .byte 1
                                 
00288f                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002891                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002893                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002895                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002897                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002899                           pulse2_fx_3xx_start: .byte 2 //the starting note period
00289b                           pulse2_fx_3xx_target: .byte 2 //target note period
00289d                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00289f                           pulse2_fx_3xx_total_offset: .byte 2
0028a1                           pulse2_fx_4xy_speed: .byte 1
0028a2                           pulse2_fx_4xy_depth: .byte 1
0028a3                           pulse2_fx_4xy_phase: .byte 1
0028a4                           pulse2_fx_7xy_speed: .byte 1
0028a5                           pulse2_fx_7xy_depth: .byte 1
0028a6                           pulse2_fx_7xy_phase: .byte 1
0028a7                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028a8                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028a9                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028aa                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028ab                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028ad                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028af                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028b1                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028b3                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028b5                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028b7                           pulse2_fx_Rxy_total_offset: .byte 2
0028b9                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028ba                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028bb                           triangle_pattern: .byte 2
0028bd                           triangle_pattern_delay_rows: .byte 1
0028be                           triangle_pattern_delay_frames: .byte 1
0028bf                           triangle_pattern_offset: .byte 2
                                 
0028c1                           triangle_volume_macro: .byte 2
0028c3                           triangle_volume_macro_offset: .byte 1
0028c4                           triangle_volume_macro_loop: .byte 1
0028c5                           triangle_volume_macro_release: .byte 1
                                 
0028c6                           triangle_arpeggio_macro: .byte 2
0028c8                           triangle_arpeggio_macro_offset: .byte 1
0028c9                           triangle_arpeggio_macro_loop: .byte 1
0028ca                           triangle_arpeggio_macro_release: .byte 1
0028cb                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028cc                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028ce                           triangle_pitch_macro: .byte 2
0028d0                           triangle_pitch_macro_offset: .byte 1
0028d1                           triangle_pitch_macro_loop: .byte 1
0028d2                           triangle_pitch_macro_release: .byte 1
                                 
0028d3                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028d4                           triangle_hi_pitch_macro: .byte 2
0028d6                           triangle_hi_pitch_macro_offset: .byte 1
0028d7                           triangle_hi_pitch_macro_loop: .byte 1
0028d8                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028d9                           triangle_duty_macro: .byte 2
0028db                           triangle_duty_macro_offset: .byte 1
0028dc                           triangle_duty_macro_loop: .byte 1
0028dd                           triangle_duty_macro_release: .byte 1
                                 
0028de                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028e0                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028e2                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028e4                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028e6                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028e8                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028ea                           triangle_fx_3xx_target: .byte 2 //target note period
0028ec                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028ee                           triangle_fx_3xx_total_offset: .byte 2
0028f0                           triangle_fx_4xy_speed: .byte 1
0028f1                           triangle_fx_4xy_depth: .byte 1
0028f2                           triangle_fx_4xy_phase: .byte 1
0028f3                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028f4                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028f5                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028f7                           triangle_fx_Qxy_target: .byte 2 //target note period
0028f9                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028fb                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028fd                           triangle_fx_Rxy_target: .byte 2 //target note period
0028ff                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002901                           triangle_fx_Rxy_total_offset: .byte 2
002903                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002904                           triangle_fx_Sxx_post: .byte 1
                                 
                                 
002905                           noise_pattern_delay: .byte 1
002906                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 
                                 reset:
000000 940c 12bc                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 167b                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 15a8                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 15b3                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 15a8                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 15ca                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 1617                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 1664                 	jmp triangle_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(143): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(145): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(148): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(149): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(153): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(196): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(197): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(198): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(202): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(203): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(205): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(206): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(207): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(211): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(212): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(213): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(216): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(217): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(218): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(221): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(222): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(275): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
0012bc edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
0012bd 93c0 0034                 	sts CPU_CCP, r28
0012bf e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
0012c0 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
0012c2 2422                      	clr zero
                                 
                                 	//MEMORY
0012c3 e3c0                      	ldi r28, 0b00110000
0012c4 93c0 2800                 	sts pulse1_param, r28
0012c6 e8c0                      	ldi r28, 0b10000000
0012c7 93c0 2801                 	sts pulse1_sweep_param, r28
0012c9 efcf                      	ldi r28, 0xFF
0012ca 93c0 2802                 	sts pulse1_timerL, r28
0012cc 93c0 2803                 	sts pulse1_timerH, r28
0012ce 93c0 2804                 	sts pulse1_length, r28
                                 
0012d0 e3c0                      	ldi r28, 0b00110000
0012d1 93c0 2808                 	sts pulse2_param, r28
0012d3 e8c0                      	ldi r28, 0b10000000
0012d4 93c0 2809                 	sts pulse2_sweep_param, r28
0012d6 efcf                      	ldi r28, 0xFF
0012d7 93c0 280a                 	sts pulse2_timerL, r28
0012d9 93c0 280b                 	sts pulse2_timerH, r28
0012db 93c0 280c                 	sts pulse2_length, r28
                                 
0012dd efcf                      	ldi r28, 0xFF
0012de 93c0 2810                 	sts triangle_timerL, r28
0012e0 93c0 2811                 	sts triangle_timerH, r28
                                 
0012e2 e0c2                      	ldi r28, 0x02
0012e3 93c0 2815                 	sts song_frame_offset, r28
0012e5 9220 2816                 	sts song_frame_offset+1, zero
0012e7 efcf                      	ldi r28, 0xFF
0012e8 93c0 281a                 	sts song_fx_Bxx, r28
0012ea 9220 281b                 	sts song_fx_Cxx, zero
0012ec 9220 281c                 	sts song_fx_Dxx, zero
0012ee e0e2                      	ldi ZL, LOW(song0_frames << 1)
0012ef e0f3                      	ldi ZH, HIGH(song0_frames << 1)
0012f0 93e0 2813                 	sts song_frames, ZL
0012f2 93f0 2814                 	sts song_frames+1, ZH
0012f4 91c5                      	lpm r28, Z+ //load the song size
0012f5 91d5                      	lpm r29, Z+
0012f6 93c0 2817                 	sts song_size, r28
0012f8 93d0 2818                 	sts song_size+1, r29
0012fa 9220 2819                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0012fc 91c5                      	lpm r28, Z+
0012fd 91d5                      	lpm r29, Z+
0012fe 0fcc                      	lsl r28
0012ff 1fdd                      	rol r29
001300 93c0 281d                 	sts pulse1_pattern, r28
001302 93d0 281e                 	sts pulse1_pattern+1, r29
001304 9220 281f                 	sts pulse1_pattern_delay_rows, zero
001306 9220 2820                 	sts pulse1_pattern_delay_frames, zero
001308 9220 2821                 	sts pulse1_pattern_offset, zero
00130a 9220 2822                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
00130c 91c5                      	lpm r28, Z+
00130d 91d5                      	lpm r29, Z+
00130e 0fcc                      	lsl r28
00130f 1fdd                      	rol r29
001310 93c0 286c                 	sts pulse2_pattern, r28
001312 93d0 286d                 	sts pulse2_pattern+1, r29
001314 9220 286e                 	sts pulse2_pattern_delay_rows, zero
001316 9220 286f                 	sts pulse2_pattern_delay_frames, zero
001318 9220 2870                 	sts pulse2_pattern_offset, zero
00131a 9220 2871                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
00131c 91c5                      	lpm r28, Z+
00131d 91d5                      	lpm r29, Z+
00131e 0fcc                      	lsl r28
00131f 1fdd                      	rol r29
001320 93c0 28bb                 	sts triangle_pattern, r28
001322 93d0 28bc                 	sts triangle_pattern+1, r29
001324 9220 28bd                 	sts triangle_pattern_delay_rows, zero
001326 9220 28be                 	sts triangle_pattern_delay_frames, zero
001328 9220 28bf                 	sts triangle_pattern_offset, zero
00132a 9220 28c0                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
00132c efcf                      	ldi r28, 0xFF
00132d 9220 2825                 	sts pulse1_volume_macro_offset, zero
00132f 93c0 2826                 	sts pulse1_volume_macro_loop, r28
001331 93c0 2827                 	sts pulse1_volume_macro_release, r28
001333 9220 282a                 	sts pulse1_arpeggio_macro_offset, zero
001335 93c0 282b                 	sts pulse1_arpeggio_macro_loop, r28
001337 93c0 282c                 	sts pulse1_arpeggio_macro_release, r28
001339 93c0 282d                 	sts pulse1_arpeggio_macro_mode, r28
00133b 9220 2832                 	sts pulse1_pitch_macro_offset, zero
00133d 93c0 2833                 	sts pulse1_pitch_macro_loop, r28
00133f 93c0 2834                 	sts pulse1_pitch_macro_release, r28
001341 9220 2838                 	sts pulse1_hi_pitch_macro_offset, zero
001343 93c0 2839                 	sts pulse1_hi_pitch_macro_loop, r28
001345 93c0 283a                 	sts pulse1_hi_pitch_macro_release, r28
001347 9220 283d                 	sts pulse1_duty_macro_offset, zero
001349 93c0 283e                 	sts pulse1_duty_macro_loop, r28
00134b 93c0 283f                 	sts pulse1_duty_macro_release, r28
                                 
00134d 9220 2823                 	sts pulse1_volume_macro, zero
00134f 9220 2824                 	sts pulse1_volume_macro+1, zero
001351 9220 2828                 	sts pulse1_arpeggio_macro, zero
001353 9220 2829                 	sts pulse1_arpeggio_macro+1, zero
001355 9220 282e                 	sts pulse1_total_pitch_offset, zero
001357 9220 282f                 	sts pulse1_total_pitch_offset+1, zero
001359 9220 2830                 	sts pulse1_pitch_macro, zero
00135b 9220 2831                 	sts pulse1_pitch_macro+1, zero
00135d 9220 2835                 	sts pulse1_total_hi_pitch_offset, zero
00135f 9220 2836                 	sts pulse1_hi_pitch_macro, zero
001361 9220 2837                 	sts pulse1_hi_pitch_macro+1, zero
001363 9220 283b                 	sts pulse1_duty_macro, zero
001365 9220 283c                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001367 e00f                      	ldi pulse1_volume_divider, 0x0F
001368 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00136a 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
00136b 9190 2800                 	lds pulse_channel_flags, pulse1_param
00136d 7390                      	andi pulse_channel_flags, 0b00110000
00136e 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
00136f 9220 2806                 	sts pulse1_output_volume, zero
001371 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001373 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001374 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001375 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001376 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
001378 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
001379 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
00137a efcf                      	ldi r28, 0xFF
00137b 9220 2840                 	sts pulse1_fx_0xy_sequence, zero
00137d 9220 2841                 	sts pulse1_fx_0xy_sequence+1, zero
00137f 9220 2842                 	sts pulse1_fx_1xx, zero
001381 9220 2843                 	sts pulse1_fx_1xx+1, zero
001383 9220 2844                 	sts pulse1_fx_1xx_total, zero
001385 9220 2845                 	sts pulse1_fx_1xx_total+1, zero
001387 9220 2846                 	sts pulse1_fx_2xx, zero
001389 9220 2847                 	sts pulse1_fx_2xx+1, zero
00138b 9220 2848                 	sts pulse1_fx_2xx_total, zero
00138d 9220 2849                 	sts pulse1_fx_2xx_total+1, zero
00138f 9220 284a                 	sts pulse1_fx_3xx_start, zero
001391 9220 284b                 	sts pulse1_fx_3xx_start+1, zero
001393 9220 284c                 	sts pulse1_fx_3xx_target, zero
001395 9220 284d                 	sts pulse1_fx_3xx_target+1, zero
001397 9220 284e                 	sts pulse1_fx_3xx_speed, zero
001399 9220 284f                 	sts pulse1_fx_3xx_speed+1, zero
00139b 9220 2850                 	sts pulse1_fx_3xx_total_offset, zero
00139d 9220 2851                 	sts pulse1_fx_3xx_total_offset+1, zero
00139f 9220 2852                 	sts pulse1_fx_4xy_speed, zero
0013a1 9220 2853                 	sts pulse1_fx_4xy_depth, zero
0013a3 9220 2854                 	sts pulse1_fx_4xy_phase, zero
0013a5 9220 2855                 	sts pulse1_fx_7xy_speed, zero
0013a7 9220 2856                 	sts pulse1_fx_7xy_depth, zero
0013a9 9220 2857                 	sts pulse1_fx_7xy_phase, zero
0013ab 9220 2858                 	sts pulse1_fx_7xy_value, zero
0013ad 9220 2859                 	sts pulse1_fx_Axy, zero
0013af 93c0 285a                 	sts pulse1_fx_Gxx_pre, r28
0013b1 93c0 285b                 	sts pulse1_fx_Gxx_post, r28
0013b3 9220 285c                 	sts pulse1_fx_Pxx_total, zero
0013b5 9220 285d                 	sts pulse1_fx_Pxx_total+1, zero
0013b7 9220 285e                 	sts pulse1_fx_Qxy_target, zero
0013b9 9220 285f                 	sts pulse1_fx_Qxy_target+1, zero
0013bb 9220 2860                 	sts pulse1_fx_Qxy_speed, zero
0013bd 9220 2861                 	sts pulse1_fx_Qxy_speed+1, zero
0013bf 9220 2862                 	sts pulse1_fx_Qxy_total_offset, zero
0013c1 9220 2863                 	sts pulse1_fx_Qxy_total_offset+1, zero
0013c3 9220 2864                 	sts pulse1_fx_Rxy_target, zero
0013c5 9220 2865                 	sts pulse1_fx_Rxy_target+1, zero
0013c7 9220 2866                 	sts pulse1_fx_Rxy_speed, zero
0013c9 9220 2867                 	sts pulse1_fx_Rxy_speed+1, zero
0013cb 9220 2868                 	sts pulse1_fx_Rxy_total_offset, zero
0013cd 9220 2869                 	sts pulse1_fx_Rxy_total_offset+1, zero
0013cf 93c0 286a                 	sts pulse1_fx_Sxx_pre, r28
0013d1 93c0 286b                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
0013d3 efcf                      	ldi r28, 0xFF
0013d4 9220 2874                 	sts pulse2_volume_macro_offset, zero
0013d6 93c0 2875                 	sts pulse2_volume_macro_loop, r28
0013d8 93c0 2876                 	sts pulse2_volume_macro_release, r28
0013da 9220 2879                 	sts pulse2_arpeggio_macro_offset, zero
0013dc 93c0 287a                 	sts pulse2_arpeggio_macro_loop, r28
0013de 93c0 287b                 	sts pulse2_arpeggio_macro_release, r28
0013e0 93c0 287c                 	sts pulse2_arpeggio_macro_mode, r28
0013e2 9220 2881                 	sts pulse2_pitch_macro_offset, zero
0013e4 93c0 2882                 	sts pulse2_pitch_macro_loop, r28
0013e6 93c0 2883                 	sts pulse2_pitch_macro_release, r28
0013e8 9220 2887                 	sts pulse2_hi_pitch_macro_offset, zero
0013ea 93c0 2888                 	sts pulse2_hi_pitch_macro_loop, r28
0013ec 93c0 2889                 	sts pulse2_hi_pitch_macro_release, r28
0013ee 9220 288c                 	sts pulse2_duty_macro_offset, zero
0013f0 93c0 288d                 	sts pulse2_duty_macro_loop, r28
0013f2 93c0 288e                 	sts pulse2_duty_macro_release, r28
                                 
0013f4 9220 2872                 	sts pulse2_volume_macro, zero
0013f6 9220 2873                 	sts pulse2_volume_macro+1, zero
0013f8 9220 2877                 	sts pulse2_arpeggio_macro, zero
0013fa 9220 2878                 	sts pulse2_arpeggio_macro+1, zero
0013fc 9220 287d                 	sts pulse2_total_pitch_offset, zero
0013fe 9220 287e                 	sts pulse2_total_pitch_offset+1, zero
001400 9220 287f                 	sts pulse2_pitch_macro, zero
001402 9220 2880                 	sts pulse2_pitch_macro+1, zero
001404 9220 2884                 	sts pulse2_total_hi_pitch_offset, zero
001406 9220 2885                 	sts pulse2_hi_pitch_macro, zero
001408 9220 2886                 	sts pulse2_hi_pitch_macro+1, zero
00140a 9220 288a                 	sts pulse2_duty_macro, zero
00140c 9220 288b                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
00140e e02f                      	ldi pulse2_volume_divider, 0x0F
00140f 9130 2808                 	lds pulse2_volume_decay, pulse2_param
001411 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
001412 91d0 2808                 	lds r29, pulse2_param
001414 73d0                      	andi r29, 0b00110000
001415 62d0                      	sbr r29, 0b0100000 //set start flag
001416 95d2                      	swap r29
001417 2b9d                      	or pulse_channel_flags, r29
001418 9220 280e                 	sts pulse2_output_volume, zero
00141a 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
00141c 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
00141d e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00141e 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
00141f 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
001421 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
001422 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001423 efcf                      	ldi r28, 0xFF
001424 9220 288f                 	sts pulse2_fx_0xy_sequence, zero
001426 9220 2890                 	sts pulse2_fx_0xy_sequence+1, zero
001428 9220 2891                 	sts pulse2_fx_1xx, zero
00142a 9220 2892                 	sts pulse2_fx_1xx+1, zero
00142c 9220 2893                 	sts pulse2_fx_1xx_total, zero
00142e 9220 2894                 	sts pulse2_fx_1xx_total+1, zero
001430 9220 2895                 	sts pulse2_fx_2xx, zero
001432 9220 2896                 	sts pulse2_fx_2xx+1, zero
001434 9220 2897                 	sts pulse2_fx_2xx_total, zero
001436 9220 2898                 	sts pulse2_fx_2xx_total+1, zero
001438 9220 2899                 	sts pulse2_fx_3xx_start, zero
00143a 9220 289a                 	sts pulse2_fx_3xx_start+1, zero
00143c 9220 289b                 	sts pulse2_fx_3xx_target, zero
00143e 9220 289c                 	sts pulse2_fx_3xx_target+1, zero
001440 9220 289d                 	sts pulse2_fx_3xx_speed, zero
001442 9220 289e                 	sts pulse2_fx_3xx_speed+1, zero
001444 9220 289f                 	sts pulse2_fx_3xx_total_offset, zero
001446 9220 28a0                 	sts pulse2_fx_3xx_total_offset+1, zero
001448 9220 28a1                 	sts pulse2_fx_4xy_speed, zero
00144a 9220 28a2                 	sts pulse2_fx_4xy_depth, zero
00144c 9220 28a3                 	sts pulse2_fx_4xy_phase, zero
00144e 9220 28a4                 	sts pulse2_fx_7xy_speed, zero
001450 9220 28a5                 	sts pulse2_fx_7xy_depth, zero
001452 9220 28a6                 	sts pulse2_fx_7xy_phase, zero
001454 9220 28a7                 	sts pulse2_fx_7xy_value, zero
001456 9220 28a8                 	sts pulse2_fx_Axy, zero
001458 93c0 28a9                 	sts pulse2_fx_Gxx_pre, r28
00145a 93c0 28aa                 	sts pulse2_fx_Gxx_post, r28
00145c 9220 28ab                 	sts pulse2_fx_Pxx_total, zero
00145e 9220 28ac                 	sts pulse2_fx_Pxx_total+1, zero
001460 9220 28ad                 	sts pulse2_fx_Qxy_target, zero
001462 9220 28ae                 	sts pulse2_fx_Qxy_target+1, zero
001464 9220 28af                 	sts pulse2_fx_Qxy_speed, zero
001466 9220 28b0                 	sts pulse2_fx_Qxy_speed+1, zero
001468 9220 28b1                 	sts pulse2_fx_Qxy_total_offset, zero
00146a 9220 28b2                 	sts pulse2_fx_Qxy_total_offset+1, zero
00146c 9220 28b3                 	sts pulse2_fx_Rxy_target, zero
00146e 9220 28b4                 	sts pulse2_fx_Rxy_target+1, zero
001470 9220 28b5                 	sts pulse2_fx_Rxy_speed, zero
001472 9220 28b6                 	sts pulse2_fx_Rxy_speed+1, zero
001474 9220 28b7                 	sts pulse2_fx_Rxy_total_offset, zero
001476 9220 28b8                 	sts pulse2_fx_Rxy_total_offset+1, zero
001478 93c0 28b9                 	sts pulse2_fx_Sxx_pre, r28
00147a 93c0 28ba                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
00147c efcf                      	ldi r28, 0xFF
00147d 9220 28c3                 	sts triangle_volume_macro_offset, zero
00147f 93c0 28c4                 	sts triangle_volume_macro_loop, r28
001481 93c0 28c5                 	sts triangle_volume_macro_release, r28
001483 9220 28c8                 	sts triangle_arpeggio_macro_offset, zero
001485 93c0 28c9                 	sts triangle_arpeggio_macro_loop, r28
001487 93c0 28ca                 	sts triangle_arpeggio_macro_release, r28
001489 93c0 28cb                 	sts triangle_arpeggio_macro_mode, r28
00148b 9220 28d0                 	sts triangle_pitch_macro_offset, zero
00148d 93c0 28d1                 	sts triangle_pitch_macro_loop, r28
00148f 93c0 28d2                 	sts triangle_pitch_macro_release, r28
001491 9220 28d6                 	sts triangle_hi_pitch_macro_offset, zero
001493 93c0 28d7                 	sts triangle_hi_pitch_macro_loop, r28
001495 93c0 28d8                 	sts triangle_hi_pitch_macro_release, r28
001497 9220 28db                 	sts triangle_duty_macro_offset, zero
001499 93c0 28dc                 	sts triangle_duty_macro_loop, r28
00149b 93c0 28dd                 	sts triangle_duty_macro_release, r28
                                 
00149d 9220 28c1                 	sts triangle_volume_macro, zero
00149f 9220 28c2                 	sts triangle_volume_macro+1, zero
0014a1 9220 28c6                 	sts triangle_arpeggio_macro, zero
0014a3 9220 28c7                 	sts triangle_arpeggio_macro+1, zero
0014a5 9220 28cc                 	sts triangle_total_pitch_offset, zero
0014a7 9220 28cd                 	sts triangle_total_pitch_offset+1, zero
0014a9 9220 28ce                 	sts triangle_pitch_macro, zero
0014ab 9220 28cf                 	sts triangle_pitch_macro+1, zero
0014ad 9220 28d3                 	sts triangle_total_hi_pitch_offset, zero
0014af 9220 28d4                 	sts triangle_hi_pitch_macro, zero
0014b1 9220 28d5                 	sts triangle_hi_pitch_macro+1, zero
0014b3 9220 28d9                 	sts triangle_duty_macro, zero
0014b5 9220 28da                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 SEQUENCE
0014b7 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
0014b8 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 3 FX
0014b9 efcf                      	ldi r28, 0xFF
0014ba 9220 28de                 	sts triangle_fx_0xy_sequence, zero
0014bc 9220 28df                 	sts triangle_fx_0xy_sequence+1, zero
0014be 9220 28e0                 	sts triangle_fx_1xx, zero
0014c0 9220 28e1                 	sts triangle_fx_1xx+1, zero
0014c2 9220 28e2                 	sts triangle_fx_1xx_total, zero
0014c4 9220 28e3                 	sts triangle_fx_1xx_total+1, zero
0014c6 9220 28e4                 	sts triangle_fx_2xx, zero
0014c8 9220 28e5                 	sts triangle_fx_2xx+1, zero
0014ca 9220 28e6                 	sts triangle_fx_2xx_total, zero
0014cc 9220 28e7                 	sts triangle_fx_2xx_total+1, zero
0014ce 9220 28e8                 	sts triangle_fx_3xx_start, zero
0014d0 9220 28e9                 	sts triangle_fx_3xx_start+1, zero
0014d2 9220 28ea                 	sts triangle_fx_3xx_target, zero
0014d4 9220 28eb                 	sts triangle_fx_3xx_target+1, zero
0014d6 9220 28ec                 	sts triangle_fx_3xx_speed, zero
0014d8 9220 28ed                 	sts triangle_fx_3xx_speed+1, zero
0014da 9220 28ee                 	sts triangle_fx_3xx_total_offset, zero
0014dc 9220 28ef                 	sts triangle_fx_3xx_total_offset+1, zero
0014de 9220 28f0                 	sts triangle_fx_4xy_speed, zero
0014e0 9220 28f1                 	sts triangle_fx_4xy_depth, zero
0014e2 9220 28f2                 	sts triangle_fx_4xy_phase, zero
0014e4 93c0 28f3                 	sts triangle_fx_Gxx_pre, r28
0014e6 93c0 28f4                 	sts triangle_fx_Gxx_post, r28
0014e8 9220 28f5                 	sts triangle_fx_Pxx_total, zero
0014ea 9220 28f6                 	sts triangle_fx_Pxx_total+1, zero
0014ec 9220 28f7                 	sts triangle_fx_Qxy_target, zero
0014ee 9220 28f8                 	sts triangle_fx_Qxy_target+1, zero
0014f0 9220 28f9                 	sts triangle_fx_Qxy_speed, zero
0014f2 9220 28fa                 	sts triangle_fx_Qxy_speed+1, zero
0014f4 9220 28fb                 	sts triangle_fx_Qxy_total_offset, zero
0014f6 9220 28fc                 	sts triangle_fx_Qxy_total_offset+1, zero
0014f8 9220 28fd                 	sts triangle_fx_Rxy_target, zero
0014fa 9220 28fe                 	sts triangle_fx_Rxy_target+1, zero
0014fc 9220 28ff                 	sts triangle_fx_Rxy_speed, zero
0014fe 9220 2900                 	sts triangle_fx_Rxy_speed+1, zero
001500 9220 2901                 	sts triangle_fx_Rxy_total_offset, zero
001502 9220 2902                 	sts triangle_fx_Rxy_total_offset+1, zero
001504 93c0 2903                 	sts triangle_fx_Sxx_pre, r28
001506 93c0 2904                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//PINS
001508 efcf                      	ldi r28, 0xFF
001509 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
00150a e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
00150b 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
00150d e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
00150e 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001510 e1c5                      	ldi r28, 0x15 //set the period for CMP0
001511 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
001513 e0c5                      	ldi r28, 0x05
001514 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
001516 e2cb                      	ldi r28, 0x2B //set the period for CMP1
001517 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
001519 e0ca                      	ldi r28, 0x0A
00151a 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
00151c e4c1                      	ldi r28, 0x41 //set the period for CMP2
00151d 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
00151f e0cf                      	ldi r28, 0x0F
001520 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
001522 e5c7                      	ldi r28, 0x57 //set the period for OVF
001523 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
001525 e1c4                      	ldi r28, 0x14
001526 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
001528 e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
001529 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
00152b e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
00152c 93c0 0a81                 	sts TCB0_CTRLB, r28
00152e e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
00152f 93c0 0a85                 	sts TCB0_INTCTRL, r28
001531 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001533 93c0 0a8c                 	sts TCB0_CCMPL, r28
001535 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001537 93c0 0a8d                 	sts TCB0_CCMPH, r28
001539 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00153a 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
00153c e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00153d 93b0 0a91                 	sts TCB1_CTRLB, r27
00153f e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001540 93b0 0a95                 	sts TCB1_INTCTRL, r27
001542 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001544 93b0 0a9c                 	sts TCB1_CCMPL, r27
001546 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001548 93b0 0a9d                 	sts TCB1_CCMPH, r27
00154a e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
00154b 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
00154d e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
00154e 93b0 0aa1                 	sts TCB2_CTRLB, r27
001550 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001551 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001553 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
001555 93b0 0aac                 	sts TCB2_CCMPL, r27
001557 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
001559 93b0 0aad                 	sts TCB2_CCMPH, r27
00155b e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
00155c 93b0 0aa0                 	sts TCB2_CTRLA, r27
00155e 9478                      	sei //global interrupt enable
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
00155f 91c0 2806                 	lds r28, pulse1_output_volume
001561 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
001563 fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
001564 c015                      	rjmp volume_mixer_pulse1_off
                                 
001565 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
001566 f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
001567 91e0 0a8c                 	lds r30, TCB0_CCMPL
001569 e5f9                      	ldi r31, 0x059
00156a 17ef                      	cp r30, r31
00156b 91e0 0a8d                 	lds r30, TCB0_CCMPH
00156d e0f0                      	ldi r31, 0x00
00156e 07ef                      	cpc r30, r31
00156f f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
001570 91e0 0a8c                 	lds r30, TCB0_CCMPL
001572 e6f6                      	ldi r31, 0x66
001573 17ef                      	cp r30, r31
001574 91e0 0a8d                 	lds r30, TCB0_CCMPH
001576 e5f9                      	ldi r31, 0x59
001577 07ef                      	cpc r30, r31
001578 f408                      	brsh volume_mixer_pulse1_off
001579 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
00157a 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
00157b fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
00157c c015                      	rjmp volume_mixer_pulse2_off
                                 
00157d 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
00157e f099                      	breq volume_mixer_pulse2_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
00157f 91e0 0a9c                 	lds r30, TCB1_CCMPL
001581 e5f9                      	ldi r31, 0x059
001582 17ef                      	cp r30, r31
001583 91e0 0a9d                 	lds r30, TCB1_CCMPH
001585 e0f0                      	ldi r31, 0x00
001586 07ef                      	cpc r30, r31
001587 f050                      	brlo volume_mixer_pulse2_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
001588 91e0 0a9c                 	lds r30, TCB1_CCMPL
00158a e6f6                      	ldi r31, 0x66
00158b 17ef                      	cp r30, r31
00158c 91e0 0a9d                 	lds r30, TCB1_CCMPH
00158e e5f9                      	ldi r31, 0x59
00158f 07ef                      	cpc r30, r31
001590 f408                      	brsh volume_mixer_pulse2_off
001591 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001592 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
001593 0fcd                      	add r28, r29
001594 e1e6                      	ldi ZL, LOW(pulse_volume_table << 1)
001595 e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
001596 0fec                      	add ZL, r28
001597 1df2                      	adc ZH, zero
001598 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001599 2fd4                      	mov r29, triangle_sequence
00159a fdd4                      	sbrc r29, 4 //check 5th bit
00159b 95d0                      	com r29
00159c 70df                      	andi r29, 0x0F
00159d 2fed                      	mov r30, r29
00159e 0fde                      	add r29, r30 //multiply the triangle volume by 3
00159f 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
0015a0 e3e6                      	ldi ZL, LOW(tnd_volume_table << 1)
0015a1 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
0015a2 0fed                      	add ZL, r29
0015a3 1df2                      	adc ZH, zero
0015a4 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
0015a5 0fcd                      	add r28, r29
0015a6 b9c1                      	out VPORTA_OUT, r28
0015a7 cfb7                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
0015a8 b7bf                      	in r27, CPU_SREG
0015a9 93bf                      	push r27
0015aa 94f8                      	cli
                                 
                                 	//ENVELOPE
0015ab d053                      	rcall pulse1_envelope_routine
0015ac d09f                      	rcall pulse2_envelope_routine
                                 
0015ad e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
0015ae 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0015b0 91bf                      	pop r27
0015b1 bfbf                      	out CPU_SREG, r27
0015b2 9518                      	reti
                                 
                                 sequence_1_3:
0015b3 b7bf                      	in r27, CPU_SREG
0015b4 93bf                      	push r27
0015b5 94f8                      	cli
                                 
                                 	//ENVELOPE
0015b6 d048                      	rcall pulse1_envelope_routine
0015b7 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
0015b8 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
0015b9 d01b                      	rcall pulse1_sweep_routine
0015ba fcf3                      	sbrc pulse2_sweep, 3
0015bb d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
0015bc fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
0015bd c002                      	rjmp sequence_1_3_pulse2_length
0015be 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
0015bf 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
0015c0 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
0015c1 c002                      	rjmp sequence_1_3_exit
0015c2 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
0015c3 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
0015c4 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
0015c5 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0015c7 91bf                      	pop r27
0015c8 bfbf                      	out CPU_SREG, r27
0015c9 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
0015ca b7bf                      	in r27, CPU_SREG
0015cb 93bf                      	push r27
0015cc 94f8                      	cli
                                 
0015cd 0caa                      	lsl pulse1_sequence //shifts sequence to the left
0015ce 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
0015cf e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0015d0 93b0 0a86                 	sts TCB0_INTFLAGS, r27
0015d2 91bf                      	pop r27
0015d3 bfbf                      	out CPU_SREG, r27
0015d4 9518                      	reti
                                 
                                 pulse1_sweep_routine:
0015d5 2dbc                      	mov r27, pulse1_sweep
0015d6 70b7                      	andi r27, 0x07 //mask for period divider bits
0015d7 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
0015d8 93df                      	push r29
0015d9 2ddc                      	mov r29, pulse1_sweep
0015da 95d2                      	swap r29
0015db 70d7                      	andi r29, 0x07 //mask for shift bits
0015dc f411                      	brne pulse1_sweep_routine_action_main //shift != 0
0015dd 91df                      	pop r29
0015de c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
0015df 91a0 0a8c                 	lds r26, TCB0_CCMPL
0015e1 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
0015e3 95b6                      	lsr r27
0015e4 95a7                      	ror r26
0015e5 95da                      	dec r29
0015e6 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
0015e7 fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
0015e8 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
0015e9 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
0015ea 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
0015eb 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
0015ed 0fad                      	add r26, r29
0015ee 91d0 0a8d                 	lds r29, TCB0_CCMPH
0015f0 1fbd                      	adc r27, r29
                                 
0015f1 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
0015f3 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0015f5 91df                      	pop r29
0015f6 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
0015f7 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
0015f8 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
0015f9 9508                      	ret
                                 
                                 pulse1_sweep_reload:
0015fa 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0015fc 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
0015fd 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
0015fe 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
0015ff fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
001600 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001601 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001602 f011                      	breq PC+3 //if the divider == 0, check loop flag
001603 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001604 9508                      	ret
                                 
001605 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001607 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001608 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001609 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
00160a e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
00160b 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
00160c 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
00160d f409                      	brne PC+2 //if decay != 0, go decrement
00160e 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
00160f 951a                      	dec pulse1_volume_decay
001610 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001611 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
001612 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001614 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001615 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001616 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
001617 b7bf                      	in r27, CPU_SREG
001618 93bf                      	push r27
001619 94f8                      	cli
                                 
00161a 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
00161b 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00161c e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00161d 93b0 0a96                 	sts TCB1_INTFLAGS, r27
00161f 91bf                      	pop r27
001620 bfbf                      	out CPU_SREG, r27
001621 9518                      	reti
                                 
                                 pulse2_sweep_routine:
001622 2dbf                      	mov r27, pulse2_sweep
001623 70b7                      	andi r27, 0x07 //mask for period divider bits
001624 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001625 93df                      	push r29
001626 2ddf                      	mov r29, pulse2_sweep
001627 95d2                      	swap r29
001628 70d7                      	andi r29, 0x07 //mask for shift bits
001629 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
00162a 91df                      	pop r29
00162b c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
00162c 91a0 0a9c                 	lds r26, TCB1_CCMPL
00162e 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
001630 95b6                      	lsr r27
001631 95a7                      	ror r26
001632 95da                      	dec r29
001633 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001634 fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
001635 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001636 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001637 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001638 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
00163a 0fad                      	add r26, r29
00163b 91d0 0a9d                 	lds r29, TCB1_CCMPH
00163d 1fbd                      	adc r27, r29
                                 
00163e 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
001640 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001642 91df                      	pop r29
001643 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
001644 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
001645 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
001646 9508                      	ret
                                 
                                 pulse2_sweep_reload:
001647 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001649 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
00164a 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
00164b 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
00164c fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
00164d c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
00164e 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
00164f f011                      	breq PC+3 //if the divider == 0, check loop flag
001650 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
001651 9508                      	ret
                                 
001652 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
001654 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001655 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
001656 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001657 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001658 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001659 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
00165a f409                      	brne PC+2 //if decay != 0, go decrement
00165b 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
00165c 953a                      	dec pulse2_volume_decay
00165d 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
00165e 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
00165f 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
001661 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001662 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
001663 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
001664 b7bf                      	in r27, CPU_SREG
001665 93bf                      	push r27
001666 94f8                      	cli
                                 
001667 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
001668 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
001669 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00166a 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
00166c 91bf                      	pop r27
00166d bfbf                      	out CPU_SREG, r27
00166e 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
00166f e3ec                      	ldi ZL, LOW(length << 1)
001670 e5f4                      	ldi ZH, HIGH(length << 1)
001671 0fed                      	add ZL, r29
001672 1df2                      	adc ZH, zero
001673 91d4                      	lpm r29, Z
001674 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
001675 e5ec                      	ldi ZL, LOW(sequences << 1)
001676 e5f4                      	ldi ZH, HIGH(sequences << 1)
001677 0fed                      	add ZL, r29
001678 1df2                      	adc ZH, zero
001679 91d4                      	lpm r29, Z
00167a 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
00167b b7bf                      	in r27, CPU_SREG
00167c 93bf                      	push r27
00167d 94f8                      	cli
00167e 93cf                      	push r28
00167f 93df                      	push r29
001680 93ef                      	push r30
001681 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001682 91a0 281a                 	lds r26, song_fx_Bxx
001684 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
001685 f4a9                      	brne sound_driver_fx_Bxx_routine
001686 91a0 281b                 	lds r26, song_fx_Cxx
001688 11a2                      	cpse r26, zero
001689 c073                      	rjmp sound_driver_fx_Cxx_routine
00168a 91a0 281c                 	lds r26, song_fx_Dxx
00168c 11a2                      	cpse r26, zero
00168d c080                      	rjmp sound_driver_fx_Dxx_routine
                                 
00168e 91a0 2815                 	lds r26, song_frame_offset
001690 91b0 2816                 	lds r27, song_frame_offset+1
001692 91c0 2817                 	lds r28, song_size
001694 91d0 2818                 	lds r29, song_size+1
001696 17ac                      	cp r26, r28
001697 07bd                      	cpc r27, r29
001698 f408                      	brsh sound_driver_fx_song_loop
001699 c0d3                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
00169a e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
00169b 91e0 2813                 	lds ZL, song_frames
00169d 91f0 2814                 	lds ZH, song_frames+1
00169f 27cc                      	clr r28 //initialize r29:r28 to 0
0016a0 27dd                      	clr r29
0016a1 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
0016a2 95aa                      	dec r26
0016a3 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
0016a4 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
0016a5 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
0016a6 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
0016a7 93c0 2815                 	sts song_frame_offset, r28
0016a9 93d0 2816                 	sts song_frame_offset+1, r29
0016ab 0fec                      	add ZL, r28
0016ac 1ffd                      	adc ZH, r29
                                 
0016ad 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
0016ae 91b5                      	lpm r27, Z+
0016af 0faa                      	lsl r26
0016b0 1fbb                      	rol r27
0016b1 93a0 281d                 	sts pulse1_pattern, r26
0016b3 93b0 281e                 	sts pulse1_pattern+1, r27
0016b5 91a5                      	lpm r26, Z+
0016b6 91b5                      	lpm r27, Z+
0016b7 0faa                      	lsl r26
0016b8 1fbb                      	rol r27
0016b9 93a0 286c                 	sts pulse2_pattern, r26
0016bb 93b0 286d                 	sts pulse2_pattern+1, r27
0016bd 91a5                      	lpm r26, Z+
0016be 91b5                      	lpm r27, Z+
0016bf 0faa                      	lsl r26
0016c0 1fbb                      	rol r27
0016c1 93a0 28bb                 	sts triangle_pattern, r26
0016c3 93b0 28bc                 	sts triangle_pattern+1, r27
                                 
0016c5 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0016c7 9220 2822                 	sts pulse1_pattern_offset+1, zero
0016c9 9220 281f                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0016cb 9220 2820                 	sts pulse1_pattern_delay_frames, zero
0016cd 9220 2870                 	sts pulse2_pattern_offset, zero
0016cf 9220 2871                 	sts pulse2_pattern_offset+1, zero
0016d1 9220 286e                 	sts pulse2_pattern_delay_rows, zero
0016d3 9220 286f                 	sts pulse2_pattern_delay_frames, zero
0016d5 9220 28bf                 	sts triangle_pattern_offset, zero
0016d7 9220 28c0                 	sts triangle_pattern_offset+1, zero
0016d9 9220 28bd                 	sts triangle_pattern_delay_rows, zero
0016db 9220 28be                 	sts triangle_pattern_delay_frames, zero
                                 
0016dd efaf                      	ldi r26, 0xFF
0016de 93a0 285a                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0016e0 93a0 285b                 	sts pulse1_fx_Gxx_post, r26
0016e2 93a0 286a                 	sts pulse1_fx_Sxx_pre, r26
0016e4 93a0 286b                 	sts pulse1_fx_Sxx_post, r26
0016e6 93a0 28a9                 	sts pulse2_fx_Gxx_pre, r26
0016e8 93a0 28aa                 	sts pulse2_fx_Gxx_post, r26
0016ea 93a0 28b9                 	sts pulse2_fx_Sxx_pre, r26
0016ec 93a0 28ba                 	sts pulse2_fx_Sxx_post, r26
0016ee 93a0 28f3                 	sts triangle_fx_Gxx_pre, r26
0016f0 93a0 28f4                 	sts triangle_fx_Gxx_post, r26
0016f2 93a0 2903                 	sts triangle_fx_Sxx_pre, r26
0016f4 93a0 2904                 	sts triangle_fx_Sxx_post, r26
                                 
0016f6 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
0016f8 9220 281b                 	sts song_fx_Cxx, zero
0016fa 9220 281c                 	sts song_fx_Dxx, zero
0016fc c070                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0016fd 91ff                      	pop r31
0016fe 91ef                      	pop r30
0016ff 91df                      	pop r29
001700 91cf                      	pop r28
001701 91bf                      	pop r27
001702 bfbf                      	out CPU_SREG, r27
001703 94f8                      	cli //disable global interrupts
                                 		
001704 efaf                      	ldi r26, 0xFF
001705 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
001707 9220 281b                 	sts song_fx_Cxx, zero
001709 9220 281c                 	sts song_fx_Dxx, zero
                                 
00170b 9220 2806                 	sts pulse1_output_volume, zero //mute all channels
00170d 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
00170e 91e0 2813                 	lds ZL, song_frames
001710 91f0 2814                 	lds ZH, song_frames+1
001712 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001714 91b0 2816                 	lds r27, song_frame_offset+1
001716 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001717 93a0 2815                 	sts song_frame_offset, r26
001719 93b0 2816                 	sts song_frame_offset+1, r27
00171b 0fea                      	add ZL, r26
00171c 1ffb                      	adc ZH, r27
                                 
00171d 91a5                      	lpm r26, Z+ //load the address of the next pattern
00171e 91b5                      	lpm r27, Z+
00171f 0faa                      	lsl r26
001720 1fbb                      	rol r27
001721 93a0 281d                 	sts pulse1_pattern, r26
001723 93b0 281e                 	sts pulse1_pattern+1, r27
001725 91a5                      	lpm r26, Z+
001726 91b5                      	lpm r27, Z+
001727 0faa                      	lsl r26
001728 1fbb                      	rol r27
001729 93a0 286c                 	sts pulse2_pattern, r26
00172b 93b0 286d                 	sts pulse2_pattern+1, r27
00172d 91a5                      	lpm r26, Z+
00172e 91b5                      	lpm r27, Z+
00172f 0faa                      	lsl r26
001730 1fbb                      	rol r27
001731 93a0 28bb                 	sts triangle_pattern, r26
001733 93b0 28bc                 	sts triangle_pattern+1, r27
                                 
001735 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001737 9220 2822                 	sts pulse1_pattern_offset+1, zero
001739 9220 281f                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00173b 9220 2820                 	sts pulse1_pattern_delay_frames, zero
00173d 9220 2870                 	sts pulse2_pattern_offset, zero
00173f 9220 2871                 	sts pulse2_pattern_offset+1, zero
001741 9220 286e                 	sts pulse2_pattern_delay_rows, zero
001743 9220 286f                 	sts pulse2_pattern_delay_frames, zero
001745 9220 28bf                 	sts triangle_pattern_offset, zero
001747 9220 28c0                 	sts triangle_pattern_offset+1, zero
001749 9220 28bd                 	sts triangle_pattern_delay_rows, zero
00174b 9220 28be                 	sts triangle_pattern_delay_frames, zero
                                 
00174d efaf                      	ldi r26, 0xFF
00174e 93a0 285a                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001750 93a0 285b                 	sts pulse1_fx_Gxx_post, r26
001752 93a0 286a                 	sts pulse1_fx_Sxx_pre, r26
001754 93a0 286b                 	sts pulse1_fx_Sxx_post, r26
001756 93a0 28a9                 	sts pulse2_fx_Gxx_pre, r26
001758 93a0 28aa                 	sts pulse2_fx_Gxx_post, r26
00175a 93a0 28b9                 	sts pulse2_fx_Sxx_pre, r26
00175c 93a0 28ba                 	sts pulse2_fx_Sxx_post, r26
00175e 93a0 28f3                 	sts triangle_fx_Gxx_pre, r26
001760 93a0 28f4                 	sts triangle_fx_Gxx_post, r26
001762 93a0 2903                 	sts triangle_fx_Sxx_pre, r26
001764 93a0 2904                 	sts triangle_fx_Sxx_post, r26
                                 
001766 93a0 281a                 	sts song_fx_Bxx, r26 //reset all song effects
001768 9220 281b                 	sts song_fx_Cxx, zero
00176a 9220 281c                 	sts song_fx_Dxx, zero
00176c c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
00176d 91a0 281f                 	lds r26, pulse1_pattern_delay_rows
00176f 91b0 2820                 	lds r27, pulse1_pattern_delay_frames
001771 9610                      	adiw r27:r26, 0
001772 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
001773 c2d7                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001774 91e0 281d                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001776 91f0 281e                 	lds ZH, pulse1_pattern+1
001778 91a0 2821                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
00177a 91b0 2822                 	lds r27, pulse1_pattern_offset+1
00177c 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00177d 1ffb                      	adc ZH, r27
00177e 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00177f 35b7                      	cpi r27, 0x57
001780 f408                      	brsh sound_driver_channel0_check_if_volume
001781 c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001782 36b7                      	cpi r27, 0x67
001783 f408                      	brsh sound_driver_channel0_check_if_delay
001784 c1b6                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001785 3eb3                      	cpi r27, 0xE3
001786 f408                      	brsh sound_driver_channel0_check_if_instrument
001787 c1bd                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001788 f409                      	brne sound_driver_channel0_check_if_release
001789 c1c0                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
00178a 3eb4                      	cpi r27, 0xE4
00178b f409                      	brne sound_driver_channel0_check_if_end
00178c c269                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
00178d 3fbf                      	cpi r27, 0xFF
00178e f409                      	brne sound_driver_channel0_check_if_fx
00178f c28b                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001790 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001791 91a4                      	lpm r26, Z //load the fx data into r26
001792 d2ae                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001793 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001794 e6e0                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001795 e5f4                      	ldi ZH, HIGH(channel0_fx << 1)
001796 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001797 0feb                      	add ZL, r27 //add offset
001798 1df2                      	adc ZH, zero
001799 91c5                      	lpm r28, Z+ //load address bytes
00179a 91d4                      	lpm r29, Z
00179b 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00179c 2ffd                      	mov ZH, r29
00179d 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
00179e 93a0 2840                 	sts pulse1_fx_0xy_sequence, r26
0017a0 9220 2841                 	sts pulse1_fx_0xy_sequence+1, zero
0017a2 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
0017a3 9220 2846                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
0017a5 9220 2847                 	sts pulse1_fx_2xx+1, zero
0017a7 9220 2840                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0017a9 9220 2841                 	sts pulse1_fx_0xy_sequence+1, zero
0017ab 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017ac 937f                      	push r23
0017ad 2f6a                      	mov r22, r26 //store the rate into r22
0017ae eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017af 9f67                      	mul r22, r23
0017b0 917f                      	pop r23
0017b1 916f                      	pop r22
                                 
0017b2 9416                      	lsr r1 //shift out the fractional bits
0017b3 9407                      	ror r0
0017b4 9416                      	lsr r1
0017b5 9407                      	ror r0
0017b6 9416                      	lsr r1
0017b7 9407                      	ror r0
0017b8 9416                      	lsr r1
0017b9 9407                      	ror r0
0017ba 9200 2842                 	sts pulse1_fx_1xx, r0
0017bc 9210 2843                 	sts pulse1_fx_1xx+1, r1
0017be cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0017bf 9220 2842                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0017c1 9220 2843                 	sts pulse1_fx_1xx+1, zero
0017c3 9220 2840                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0017c5 9220 2841                 	sts pulse1_fx_0xy_sequence+1, zero
0017c7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017c8 937f                      	push r23
0017c9 2f6a                      	mov r22, r26 //store the rate into r22
0017ca eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017cb 9f67                      	mul r22, r23
0017cc 917f                      	pop r23
0017cd 916f                      	pop r22
                                 
0017ce 9416                      	lsr r1 //shift out the fractional bits
0017cf 9407                      	ror r0
0017d0 9416                      	lsr r1
0017d1 9407                      	ror r0
0017d2 9416                      	lsr r1
0017d3 9407                      	ror r0
0017d4 9416                      	lsr r1
0017d5 9407                      	ror r0
0017d6 9200 2846                 	sts pulse1_fx_2xx, r0
0017d8 9210 2847                 	sts pulse1_fx_2xx+1, r1
0017da cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0017db 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017dc 937f                      	push r23
0017dd 2f6a                      	mov r22, r26 //store the rate into r22
0017de eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017df 9f67                      	mul r22, r23
0017e0 917f                      	pop r23
0017e1 916f                      	pop r22
                                 
0017e2 9416                      	lsr r1 //shift out the fractional bits
0017e3 9407                      	ror r0
0017e4 9416                      	lsr r1
0017e5 9407                      	ror r0
0017e6 9416                      	lsr r1
0017e7 9407                      	ror r0
0017e8 9416                      	lsr r1
0017e9 9407                      	ror r0
0017ea 9200 284e                 	sts pulse1_fx_3xx_speed, r0
0017ec 9210 284f                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0017ee 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0017ef c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0017f0 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0017f1 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0017f3 91b0 0a8d                 	lds r27, TCB0_CCMPH
0017f5 93a0 284a                 	sts pulse1_fx_3xx_start, r26
0017f7 93b0 284b                 	sts pulse1_fx_3xx_start+1, r27
                                 
0017f9 9220 2850                 	sts pulse1_fx_3xx_total_offset, zero
0017fb 9220 2851                 	sts pulse1_fx_3xx_total_offset+1, zero
0017fd cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0017fe 2fba                      	mov r27, r26
0017ff 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001800 95a2                      	swap r26
001801 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001802 93a0 2852                 	sts pulse1_fx_4xy_speed, r26
001804 93b0 2853                 	sts pulse1_fx_4xy_depth, r27
001806 9220 2854                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
001808 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
001809 2fba                      	mov r27, r26
00180a 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00180b 95a2                      	swap r26
00180c 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00180d 93a0 2855                 	sts pulse1_fx_7xy_speed, r26
00180f 93b0 2856                 	sts pulse1_fx_7xy_depth, r27
001811 9220 2857                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
001813 9220 2858                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001815 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001816 93a0 2859                 	sts pulse1_fx_Axy, r26
001818 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
001819 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00181b cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
00181c 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00181e cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
00181f 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001821 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
001822 91b0 2800                 	lds r27, pulse1_param
001824 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001825 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001826 93b0 2800                 	sts pulse1_param, r27
001828 6096                      	sbr pulse_channel_flags, 6
001829 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
00182a 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
00182c cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
00182d 15a2                      	cp r26, zero
00182e f051                      	breq sound_driver_channel0_fx_Gxx_invalid
00182f 91b0 2819                 	lds r27, song_speed
001831 17ab                      	cp r26, r27
001832 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
001833 93a0 285a                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001835 e0b1                      	ldi r27, 0x01
001836 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
001838 c215                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
001839 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
00183a cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
00183b cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
00183c cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
00183d cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
00183e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00183f 937f                      	push r23
001840 2f6a                      	mov r22, r26
001841 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001842 9f67                      	mul r22, r23
001843 917f                      	pop r23
001844 916f                      	pop r22
001845 9416                      	lsr r1 //shift out the fractional bits
001846 9407                      	ror r0
001847 9416                      	lsr r1
001848 9407                      	ror r0
001849 9416                      	lsr r1
00184a 9407                      	ror r0
00184b 9416                      	lsr r1
00184c 9407                      	ror r0
00184d 9200 285c                 	sts pulse1_fx_Pxx_total, r0
00184f 9210 285d                 	sts pulse1_fx_Pxx_total+1, r1
001851 cf22                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
001852 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
001854 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
001856 9630                      	adiw Z, 0
001857 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001858 cf1b                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001859 91e0 2830                 	lds ZL, pulse1_pitch_macro
00185b 91f0 2831                 	lds ZH, pulse1_pitch_macro+1
00185d 9630                      	adiw Z, 0
00185e f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
00185f cf14                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001860 91e0 2836                 	lds ZL, pulse1_hi_pitch_macro
001862 91f0 2837                 	lds ZH, pulse1_hi_pitch_macro+1
001864 9630                      	adiw Z, 0
001865 f009                      	breq sound_driver_channel0_fx_Qxy_process
001866 cf0d                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001867 2fba                      	mov r27, r26 //copy fx parameters into r27
001868 70bf                      	andi r27, 0x0F //mask note index offset
001869 91c0 2807                 	lds r28, pulse1_note //load current note index
00186b 0fbc                      	add r27, r28
00186c 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00186d f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
00186e e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
00186f e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001870 e0f0                      	ldi ZH, HIGH(note_table << 1)
001871 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001872 0feb                      	add ZL, r27 //add offset
001873 1df2                      	adc ZH, zero
001874 91c5                      	lpm r28, Z+ //load bytes
001875 91d4                      	lpm r29, Z
001876 93c0 285e                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001878 93d0 285f                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
00187a 95a2                      	swap r26
00187b 70af                      	andi r26, 0x0F //mask effect speed
00187c 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00187d 95a3                      	inc r26 //increment the speed by 1
                                 
00187e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00187f 937f                      	push r23
001880 2f6a                      	mov r22, r26 //store the speed data into r27
001881 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001882 9f67                      	mul r22, r23
001883 917f                      	pop r23
001884 916f                      	pop r22
                                 
001885 9416                      	lsr r1 //shift out the fractional bits
001886 9407                      	ror r0
001887 9416                      	lsr r1
001888 9407                      	ror r0
001889 9416                      	lsr r1
00188a 9407                      	ror r0
00188b 9416                      	lsr r1
00188c 9407                      	ror r0
                                 
00188d 9200 2860                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
00188f 9210 2861                 	sts pulse1_fx_Qxy_speed+1, r1
001891 9220 2862                 	sts pulse1_fx_Qxy_total_offset, zero
001893 9220 2863                 	sts pulse1_fx_Qxy_total_offset+1, zero
001895 cede                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001896 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
001898 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
00189a 9630                      	adiw Z, 0
00189b f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
00189c ced7                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
00189d 91e0 2830                 	lds ZL, pulse1_pitch_macro
00189f 91f0 2831                 	lds ZH, pulse1_pitch_macro+1
0018a1 9630                      	adiw Z, 0
0018a2 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0018a3 ced0                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0018a4 91e0 2836                 	lds ZL, pulse1_hi_pitch_macro
0018a6 91f0 2837                 	lds ZH, pulse1_hi_pitch_macro+1
0018a8 9630                      	adiw Z, 0
0018a9 f009                      	breq sound_driver_channel0_fx_Rxy_process
0018aa cec9                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0018ab 2fba                      	mov r27, r26 //copy fx parameters into r27
0018ac 70bf                      	andi r27, 0x0F //mask note index offset
0018ad 91c0 2807                 	lds r28, pulse1_note //load current note index
0018af 1bcb                      	sub r28, r27
0018b0 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0018b1 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0018b2 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
0018b3 e0f0                      	ldi ZH, HIGH(note_table << 1)
0018b4 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0018b5 0fec                      	add ZL, r28 //add offset
0018b6 1df2                      	adc ZH, zero
0018b7 91c5                      	lpm r28, Z+ //load bytes
0018b8 91d4                      	lpm r29, Z
0018b9 93c0 2864                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0018bb 93d0 2865                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0018bd 95a2                      	swap r26
0018be 70af                      	andi r26, 0x0F //mask effect speed
0018bf 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0018c0 95a3                      	inc r26 //increment the speed by 1
                                 
0018c1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018c2 937f                      	push r23
0018c3 2f6a                      	mov r22, r26 //store the speed data into r27
0018c4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018c5 9f67                      	mul r22, r23
0018c6 917f                      	pop r23
0018c7 916f                      	pop r22
                                 
0018c8 9416                      	lsr r1 //shift out the fractional bits
0018c9 9407                      	ror r0
0018ca 9416                      	lsr r1
0018cb 9407                      	ror r0
0018cc 9416                      	lsr r1
0018cd 9407                      	ror r0
0018ce 9416                      	lsr r1
0018cf 9407                      	ror r0
                                 
0018d0 9200 2866                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
0018d2 9210 2867                 	sts pulse1_fx_Rxy_speed+1, r1
0018d4 9220 2868                 	sts pulse1_fx_Rxy_total_offset, zero
0018d6 9220 2869                 	sts pulse1_fx_Rxy_total_offset+1, zero
0018d8 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
0018d9 15a2                      	cp r26, zero
0018da f051                      	breq sound_driver_channel0_fx_Sxx_invalid
0018db 91b0 2819                 	lds r27, song_speed
0018dd 17ab                      	cp r26, r27
0018de f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
0018df 93a0 286a                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0018e1 e0b1                      	ldi r27, 0x01
0018e2 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
0018e4 c169                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
0018e5 ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
0018e6 e5ec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0018e7 e5f4                      	ldi ZH, HIGH(sequences << 1)
0018e8 0fea                      	add ZL, r26 //offset the pointer
0018e9 1df2                      	adc ZH, zero
                                 
0018ea 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0018eb 95a7                      	ror r26
0018ec 95a7                      	ror r26
0018ed 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0018ef 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0018f0 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0018f1 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0018f2 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0018f3 ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0018f4 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0018f5 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0018f6 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0018f7 93c0 2800                 	sts pulse1_param, r28
0018f9 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0018fa ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
0018fb ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
0018fc ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
0018fd ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
0018fe 93b0 2807                 	sts pulse1_note, r27 //store the note index
001900 e0a3                      	ldi r26, 0x03
001901 e0b2                      	ldi r27, 0x02
001902 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001904 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
001906 93b0 2832                 	sts pulse1_pitch_macro_offset, r27
001908 93b0 2838                 	sts pulse1_hi_pitch_macro_offset, r27
00190a 93b0 283d                 	sts pulse1_duty_macro_offset, r27
00190c 9220 282e                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
00190e 9220 282f                 	sts pulse1_total_pitch_offset+1, zero
001910 9220 2835                 	sts pulse1_total_hi_pitch_offset, zero
001912 9220 2844                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001914 9220 2845                 	sts pulse1_fx_1xx_total+1, zero
001916 9220 2848                 	sts pulse1_fx_2xx_total, zero
001918 9220 2849                 	sts pulse1_fx_2xx_total+1, zero
00191a 9220 2850                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
00191c 9220 2851                 	sts pulse1_fx_3xx_total_offset+1, zero
00191e 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001920 91b0 0a8d                 	lds r27, TCB0_CCMPH
001922 93a0 284a                 	sts pulse1_fx_3xx_start, r26
001924 93b0 284b                 	sts pulse1_fx_3xx_start+1, r27
001926 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001928 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001929 9220 285e                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00192b 9220 285f                 	sts pulse1_fx_Qxy_target+1, zero
00192d 9220 2862                 	sts pulse1_fx_Qxy_total_offset, zero
00192f 9220 2863                 	sts pulse1_fx_Qxy_total_offset+1, zero
001931 9220 2864                 	sts pulse1_fx_Rxy_target, zero
001933 9220 2865                 	sts pulse1_fx_Rxy_target+1, zero
001935 9220 2868                 	sts pulse1_fx_Rxy_total_offset, zero
001937 9220 2869                 	sts pulse1_fx_Rxy_total_offset+1, zero
001939 d0fd                      	rcall sound_driver_channel0_increment_offset
00193a ce39                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
00193b 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
00193c 91a0 2800                 	lds r26, pulse1_param
00193e 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
00193f 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001940 93a0 2800                 	sts pulse1_param, r26
001942 6096                      	sbr pulse_channel_flags, 6
001943 d0f3                      	rcall sound_driver_channel0_increment_offset
001944 ce2f                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001945 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001946 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
001948 d0ee                      	rcall sound_driver_channel0_increment_offset
001949 c104                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
00194a 9220 2823                 	sts pulse1_volume_macro, zero //reset all macro addresses
00194c 9220 2824                 	sts pulse1_volume_macro+1, zero
00194e 9220 2828                 	sts pulse1_arpeggio_macro, zero
001950 9220 2829                 	sts pulse1_arpeggio_macro+1, zero
001952 9220 2830                 	sts pulse1_pitch_macro, zero
001954 9220 2831                 	sts pulse1_pitch_macro+1, zero
001956 9220 2836                 	sts pulse1_hi_pitch_macro, zero
001958 9220 2837                 	sts pulse1_hi_pitch_macro+1, zero
00195a 9220 283b                 	sts pulse1_duty_macro, zero
00195c 9220 283c                 	sts pulse1_duty_macro+1, zero
00195e 9220 282e                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001960 9220 282f                 	sts pulse1_total_pitch_offset+1, zero
001962 9220 2835                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001964 9631                      	adiw Z, 1 //point to the byte next to the flag
001965 91b4                      	lpm r27, Z //store the instrument offset into r27
001966 ede6                      	ldi ZL, LOW(instruments) //point Z to instruments table
001967 e1f1                      	ldi ZH, HIGH(instruments)
001968 0feb                      	add ZL, r27 //point Z to offsetted instrument
001969 1df2                      	adc ZH, zero
00196a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00196b 1fff                      	rol ZH
00196c 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00196d 91b4                      	lpm r27, Z
                                 
00196e 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
00196f 1fbb                      	rol r27
001970 2fea                      	mov ZL, r26
001971 2ffb                      	mov ZH, r27
001972 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001973 9632                      	adiw Z, 2 //point Z to the address of the macro
001974 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001975 95aa                      	dec r26
001976 f019                      	breq sound_driver_channel0_instrument_change_exit
001977 95b6                      	lsr r27
001978 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001979 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
00197a e0a3                      	ldi r26, 0x03
00197b e0b2                      	ldi r27, 0x02
00197c 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00197e 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
001980 93b0 2832                 	sts pulse1_pitch_macro_offset, r27
001982 93b0 2838                 	sts pulse1_hi_pitch_macro_offset, r27
001984 93b0 283d                 	sts pulse1_duty_macro_offset, r27
001986 d0ba                      	rcall sound_driver_channel0_increment_offset_twice
001987 cdec                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001988 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001989 91d5                      	lpm r29, Z+
                                 
00198a 30a5                      	cpi r26, 5
00198b f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
00198c 30a4                      	cpi r26, 4
00198d f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
00198e 30a3                      	cpi r26, 3
00198f f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001990 30a2                      	cpi r26, 2
001991 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001992 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001993 93c0 2823                 	sts pulse1_volume_macro, r28
001995 93d0 2824                 	sts pulse1_volume_macro+1, r29
001997 d041                      	rcall sound_driver_channel0_instrument_change_read_header
001998 93c0 2827                 	sts pulse1_volume_macro_release, r28
00199a 93d0 2826                 	sts pulse1_volume_macro_loop, r29
00199c cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
00199d 93c0 2828                 	sts pulse1_arpeggio_macro, r28
00199f 93d0 2829                 	sts pulse1_arpeggio_macro+1, r29
0019a1 9220 285e                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019a3 9220 285f                 	sts pulse1_fx_Qxy_target+1, zero
0019a5 9220 2864                 	sts pulse1_fx_Rxy_target, zero
0019a7 9220 2865                 	sts pulse1_fx_Rxy_target+1, zero
0019a9 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0019aa cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0019ab 93c0 2830                 	sts pulse1_pitch_macro, r28
0019ad 93d0 2831                 	sts pulse1_pitch_macro+1, r29
0019af 9220 285e                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019b1 9220 285f                 	sts pulse1_fx_Qxy_target+1, zero
0019b3 9220 2864                 	sts pulse1_fx_Rxy_target, zero
0019b5 9220 2865                 	sts pulse1_fx_Rxy_target+1, zero
0019b7 d021                      	rcall sound_driver_channel0_instrument_change_read_header
0019b8 93c0 2834                 	sts pulse1_pitch_macro_release, r28
0019ba 93d0 2833                 	sts pulse1_pitch_macro_loop, r29
0019bc cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0019bd 93c0 2836                 	sts pulse1_hi_pitch_macro, r28
0019bf 93d0 2837                 	sts pulse1_hi_pitch_macro+1, r29
0019c1 9220 285e                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0019c3 9220 285f                 	sts pulse1_fx_Qxy_target+1, zero
0019c5 9220 2864                 	sts pulse1_fx_Rxy_target, zero
0019c7 9220 2865                 	sts pulse1_fx_Rxy_target+1, zero
0019c9 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
0019ca 93c0 283a                 	sts pulse1_hi_pitch_macro_release, r28
0019cc 93d0 2839                 	sts pulse1_hi_pitch_macro_loop, r29
0019ce cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
0019cf 93c0 283b                 	sts pulse1_duty_macro, r28
0019d1 93d0 283c                 	sts pulse1_duty_macro+1, r29
0019d3 d005                      	rcall sound_driver_channel0_instrument_change_read_header
0019d4 93c0 283f                 	sts pulse1_duty_macro_release, r28
0019d6 93d0 283e                 	sts pulse1_duty_macro_loop, r29
0019d8 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
0019d9 93ef                      	push ZL
0019da 93ff                      	push ZH
0019db 2fec                      	mov ZL, r28
0019dc 2ffd                      	mov ZH, r29
0019dd 0fee                      	lsl ZL
0019de 1fff                      	rol ZH
0019df 91c5                      	lpm r28, Z+
0019e0 91d4                      	lpm r29, Z
0019e1 91ff                      	pop ZH
0019e2 91ef                      	pop ZL
0019e3 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
0019e4 93ef                      	push ZL
0019e5 93ff                      	push ZH
0019e6 2fec                      	mov ZL, r28
0019e7 2ffd                      	mov ZH, r29
0019e8 0fee                      	lsl ZL
0019e9 1fff                      	rol ZH
0019ea 91c5                      	lpm r28, Z+
0019eb 91d5                      	lpm r29, Z+
0019ec 93c0 282c                 	sts pulse1_arpeggio_macro_release, r28
0019ee 93d0 282b                 	sts pulse1_arpeggio_macro_loop, r29
0019f0 91c4                      	lpm r28, Z
0019f1 93c0 282d                 	sts pulse1_arpeggio_macro_mode, r28
0019f3 91ff                      	pop ZH
0019f4 91ef                      	pop ZL
0019f5 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
0019f6 91b0 2827                 	lds r27, pulse1_volume_macro_release
0019f8 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0019f9 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
0019fa 95b3                      	inc r27
0019fb 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
0019fd 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
0019ff 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001a00 f019                      	breq sound_driver_channel0_release_pitch
001a01 95b3                      	inc r27
001a02 93b0 282a                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001a04 91b0 2834                 	lds r27, pulse1_pitch_macro_release
001a06 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001a07 f019                      	breq sound_driver_channel0_release_hi_pitch
001a08 95b3                      	inc r27
001a09 93b0 2832                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001a0b 91b0 283a                 	lds r27, pulse1_hi_pitch_macro_release
001a0d 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001a0e f019                      	breq sound_driver_channel0_release_duty
001a0f 95b3                      	inc r27
001a10 93b0 2838                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001a12 91b0 283f                 	lds r27, pulse1_duty_macro_release
001a14 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001a15 f019                      	breq sound_driver_channel0_release_exit
001a16 95b3                      	inc r27
001a17 93b0 283d                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001a19 d01d                      	rcall sound_driver_channel0_increment_offset
001a1a cd59                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001a1b 91e0 2813                 	lds ZL, song_frames
001a1d 91f0 2814                 	lds ZH, song_frames+1
001a1f 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001a21 91b0 2816                 	lds r27, song_frame_offset+1
001a23 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001a24 93a0 2815                 	sts song_frame_offset, r26
001a26 93b0 2816                 	sts song_frame_offset+1, r27
001a28 0fea                      	add ZL, r26
001a29 1ffb                      	adc ZH, r27
                                 
001a2a 91a5                      	lpm r26, Z+ //load the address of the next pattern
001a2b 91b4                      	lpm r27, Z
001a2c 0faa                      	lsl r26
001a2d 1fbb                      	rol r27
001a2e 93a0 281d                 	sts pulse1_pattern, r26
001a30 93b0 281e                 	sts pulse1_pattern+1, r27
                                 
001a32 9220 2821                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001a34 9220 2822                 	sts pulse1_pattern_offset+1, zero
001a36 cd3d                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001a37 91e0 2821                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001a39 91f0 2822                 	lds ZH, pulse1_pattern_offset+1
001a3b 9631                      	adiw Z, 1
001a3c 93e0 2821                 	sts pulse1_pattern_offset, ZL
001a3e 93f0 2822                 	sts pulse1_pattern_offset+1, ZH
001a40 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001a41 91e0 2821                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001a43 91f0 2822                 	lds ZH, pulse1_pattern_offset+1
001a45 9632                      	adiw Z, 2 //increment the pointer twice
001a46 93e0 2821                 	sts pulse1_pattern_offset, ZL
001a48 93f0 2822                 	sts pulse1_pattern_offset+1, ZH
001a4a 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
001a4b 95ba                      	dec r27
001a4c 93b0 2820                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001a4e 91a0 286e                 	lds r26, pulse2_pattern_delay_rows
001a50 91b0 286f                 	lds r27, pulse2_pattern_delay_frames
001a52 9610                      	adiw r27:r26, 0
001a53 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001a54 c2d3                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001a55 91e0 286c                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001a57 91f0 286d                 	lds ZH, pulse2_pattern+1
001a59 91a0 2870                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001a5b 91b0 2871                 	lds r27, pulse2_pattern_offset+1
001a5d 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001a5e 1ffb                      	adc ZH, r27
001a5f 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001a60 35b7                      	cpi r27, 0x57
001a61 f408                      	brsh sound_driver_channel1_check_if_volume
001a62 c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001a63 36b7                      	cpi r27, 0x67
001a64 f408                      	brsh sound_driver_channel1_check_if_delay
001a65 c1b6                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001a66 3eb3                      	cpi r27, 0xE3
001a67 f408                      	brsh sound_driver_channel1_check_if_instrument
001a68 c1bd                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001a69 f409                      	brne sound_driver_channel1_check_if_release
001a6a c1c0                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001a6b 3eb4                      	cpi r27, 0xE4
001a6c f409                      	brne sound_driver_channel1_check_if_end
001a6d c269                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001a6e 3fbf                      	cpi r27, 0xFF
001a6f f409                      	brne sound_driver_channel1_check_if_fx
001a70 c28b                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001a71 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001a72 91a4                      	lpm r26, Z //load the fx data into r26
001a73 d2aa                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001a74 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001a75 e9e4                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001a76 e5f4                      	ldi ZH, HIGH(channel1_fx << 1)
001a77 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001a78 0feb                      	add ZL, r27 //add offset
001a79 1df2                      	adc ZH, zero
001a7a 91c5                      	lpm r28, Z+ //load address bytes
001a7b 91d4                      	lpm r29, Z
001a7c 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001a7d 2ffd                      	mov ZH, r29
001a7e 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001a7f 93a0 288f                 	sts pulse2_fx_0xy_sequence, r26
001a81 9220 2890                 	sts pulse2_fx_0xy_sequence+1, zero
001a83 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001a84 9220 2895                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001a86 9220 2896                 	sts pulse2_fx_2xx+1, zero
001a88 9220 288f                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001a8a 9220 2890                 	sts pulse2_fx_0xy_sequence+1, zero
001a8c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a8d 937f                      	push r23
001a8e 2f6a                      	mov r22, r26 //store the rate into r22
001a8f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a90 9f67                      	mul r22, r23
001a91 917f                      	pop r23
001a92 916f                      	pop r22
                                 
001a93 9416                      	lsr r1 //shift out the fractional bits
001a94 9407                      	ror r0
001a95 9416                      	lsr r1
001a96 9407                      	ror r0
001a97 9416                      	lsr r1
001a98 9407                      	ror r0
001a99 9416                      	lsr r1
001a9a 9407                      	ror r0
001a9b 9200 2891                 	sts pulse2_fx_1xx, r0
001a9d 9210 2892                 	sts pulse2_fx_1xx+1, r1
001a9f cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001aa0 9220 2891                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001aa2 9220 2892                 	sts pulse2_fx_1xx+1, zero
001aa4 9220 288f                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001aa6 9220 2890                 	sts pulse2_fx_0xy_sequence+1, zero
001aa8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001aa9 937f                      	push r23
001aaa 2f6a                      	mov r22, r26 //store the rate into r22
001aab eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001aac 9f67                      	mul r22, r23
001aad 917f                      	pop r23
001aae 916f                      	pop r22
                                 
001aaf 9416                      	lsr r1 //shift out the fractional bits
001ab0 9407                      	ror r0
001ab1 9416                      	lsr r1
001ab2 9407                      	ror r0
001ab3 9416                      	lsr r1
001ab4 9407                      	ror r0
001ab5 9416                      	lsr r1
001ab6 9407                      	ror r0
001ab7 9200 2895                 	sts pulse2_fx_2xx, r0
001ab9 9210 2896                 	sts pulse2_fx_2xx+1, r1
001abb cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001abc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001abd 937f                      	push r23
001abe 2f6a                      	mov r22, r26 //store the rate into r22
001abf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ac0 9f67                      	mul r22, r23
001ac1 917f                      	pop r23
001ac2 916f                      	pop r22
                                 
001ac3 9416                      	lsr r1 //shift out the fractional bits
001ac4 9407                      	ror r0
001ac5 9416                      	lsr r1
001ac6 9407                      	ror r0
001ac7 9416                      	lsr r1
001ac8 9407                      	ror r0
001ac9 9416                      	lsr r1
001aca 9407                      	ror r0
001acb 9200 289d                 	sts pulse2_fx_3xx_speed, r0
001acd 9210 289e                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001acf 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001ad0 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001ad1 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001ad2 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ad4 91b0 0a9d                 	lds r27, TCB1_CCMPH
001ad6 93a0 2899                 	sts pulse2_fx_3xx_start, r26
001ad8 93b0 289a                 	sts pulse2_fx_3xx_start+1, r27
                                 
001ada 9220 289f                 	sts pulse2_fx_3xx_total_offset, zero
001adc 9220 28a0                 	sts pulse2_fx_3xx_total_offset+1, zero
001ade cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001adf 2fba                      	mov r27, r26
001ae0 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001ae1 95a2                      	swap r26
001ae2 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001ae3 93a0 28a1                 	sts pulse2_fx_4xy_speed, r26
001ae5 93b0 28a2                 	sts pulse2_fx_4xy_depth, r27
001ae7 9220 28a3                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001ae9 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001aea 2fba                      	mov r27, r26
001aeb 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001aec 95a2                      	swap r26
001aed 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001aee 93a0 28a4                 	sts pulse2_fx_7xy_speed, r26
001af0 93b0 28a5                 	sts pulse2_fx_7xy_depth, r27
001af2 9220 28a6                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001af4 9220 28a7                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001af6 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001af7 93a0 28a8                 	sts pulse2_fx_Axy, r26
001af9 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001afa 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001afc cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001afd 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001aff cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001b00 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001b02 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001b03 91b0 2808                 	lds r27, pulse2_param
001b05 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001b06 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001b07 93b0 2808                 	sts pulse2_param, r27
001b09 6092                      	sbr pulse_channel_flags, 2
001b0a cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001b0b 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001b0d cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001b0e 15a2                      	cp r26, zero
001b0f f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001b10 91b0 2819                 	lds r27, song_speed
001b12 17ab                      	cp r26, r27
001b13 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001b14 93a0 28a9                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001b16 e0b1                      	ldi r27, 0x01
001b17 93b0 286e                 	sts pulse2_pattern_delay_rows, r27
001b19 c211                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001b1a cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001b1b cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001b1c cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001b1d cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001b1e cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001b1f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b20 937f                      	push r23
001b21 2f6a                      	mov r22, r26
001b22 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b23 9f67                      	mul r22, r23
001b24 917f                      	pop r23
001b25 916f                      	pop r22
001b26 9416                      	lsr r1 //shift out the fractional bits
001b27 9407                      	ror r0
001b28 9416                      	lsr r1
001b29 9407                      	ror r0
001b2a 9416                      	lsr r1
001b2b 9407                      	ror r0
001b2c 9416                      	lsr r1
001b2d 9407                      	ror r0
001b2e 9200 28ab                 	sts pulse2_fx_Pxx_total, r0
001b30 9210 28ac                 	sts pulse2_fx_Pxx_total+1, r1
001b32 cf22                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001b33 91e0 2877                 	lds ZL, pulse2_arpeggio_macro
001b35 91f0 2878                 	lds ZH, pulse2_arpeggio_macro+1
001b37 9630                      	adiw Z, 0
001b38 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001b39 cf1b                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001b3a 91e0 287f                 	lds ZL, pulse2_pitch_macro
001b3c 91f0 2880                 	lds ZH, pulse2_pitch_macro+1
001b3e 9630                      	adiw Z, 0
001b3f f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001b40 cf14                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001b41 91e0 2885                 	lds ZL, pulse2_hi_pitch_macro
001b43 91f0 2886                 	lds ZH, pulse2_hi_pitch_macro+1
001b45 9630                      	adiw Z, 0
001b46 f009                      	breq sound_driver_channel1_fx_Qxy_process
001b47 cf0d                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001b48 2fba                      	mov r27, r26 //copy fx parameters into r27
001b49 70bf                      	andi r27, 0x0F //mask note index offset
001b4a 91c0 280f                 	lds r28, pulse2_note //load current note index
001b4c 0fbc                      	add r27, r28
001b4d 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001b4e f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001b4f e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001b50 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001b51 e0f0                      	ldi ZH, HIGH(note_table << 1)
001b52 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001b53 0feb                      	add ZL, r27 //add offset
001b54 1df2                      	adc ZH, zero
001b55 91c5                      	lpm r28, Z+ //load bytes
001b56 91d4                      	lpm r29, Z
001b57 93c0 28ad                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001b59 93d0 28ae                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001b5b 95a2                      	swap r26
001b5c 70af                      	andi r26, 0x0F //mask effect speed
001b5d 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b5e 95a3                      	inc r26 //increment the speed by 1
                                 
001b5f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b60 937f                      	push r23
001b61 2f6a                      	mov r22, r26 //store the speed data into r27
001b62 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b63 9f67                      	mul r22, r23
001b64 917f                      	pop r23
001b65 916f                      	pop r22
                                 
001b66 9416                      	lsr r1 //shift out the fractional bits
001b67 9407                      	ror r0
001b68 9416                      	lsr r1
001b69 9407                      	ror r0
001b6a 9416                      	lsr r1
001b6b 9407                      	ror r0
001b6c 9416                      	lsr r1
001b6d 9407                      	ror r0
                                 
001b6e 9200 28af                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001b70 9210 28b0                 	sts pulse2_fx_Qxy_speed+1, r1
001b72 9220 28b1                 	sts pulse2_fx_Qxy_total_offset, zero
001b74 9220 28b2                 	sts pulse2_fx_Qxy_total_offset+1, zero
001b76 cede                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001b77 91e0 2877                 	lds ZL, pulse2_arpeggio_macro
001b79 91f0 2878                 	lds ZH, pulse2_arpeggio_macro+1
001b7b 9630                      	adiw Z, 0
001b7c f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001b7d ced7                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001b7e 91e0 287f                 	lds ZL, pulse2_pitch_macro
001b80 91f0 2880                 	lds ZH, pulse2_pitch_macro+1
001b82 9630                      	adiw Z, 0
001b83 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001b84 ced0                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001b85 91e0 2885                 	lds ZL, pulse2_hi_pitch_macro
001b87 91f0 2886                 	lds ZH, pulse2_hi_pitch_macro+1
001b89 9630                      	adiw Z, 0
001b8a f009                      	breq sound_driver_channel1_fx_Rxy_process
001b8b cec9                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001b8c 2fba                      	mov r27, r26 //copy fx parameters into r27
001b8d 70bf                      	andi r27, 0x0F //mask note index offset
001b8e 91c0 280f                 	lds r28, pulse2_note //load current note index
001b90 1bcb                      	sub r28, r27
001b91 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001b92 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001b93 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001b94 e0f0                      	ldi ZH, HIGH(note_table << 1)
001b95 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001b96 0fec                      	add ZL, r28 //add offset
001b97 1df2                      	adc ZH, zero
001b98 91c5                      	lpm r28, Z+ //load bytes
001b99 91d4                      	lpm r29, Z
001b9a 93c0 28b3                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001b9c 93d0 28b4                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001b9e 95a2                      	swap r26
001b9f 70af                      	andi r26, 0x0F //mask effect speed
001ba0 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001ba1 95a3                      	inc r26 //increment the speed by 1
                                 
001ba2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ba3 937f                      	push r23
001ba4 2f6a                      	mov r22, r26 //store the speed data into r27
001ba5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ba6 9f67                      	mul r22, r23
001ba7 917f                      	pop r23
001ba8 916f                      	pop r22
                                 
001ba9 9416                      	lsr r1 //shift out the fractional bits
001baa 9407                      	ror r0
001bab 9416                      	lsr r1
001bac 9407                      	ror r0
001bad 9416                      	lsr r1
001bae 9407                      	ror r0
001baf 9416                      	lsr r1
001bb0 9407                      	ror r0
                                 
001bb1 9200 28b5                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001bb3 9210 28b6                 	sts pulse2_fx_Rxy_speed+1, r1
001bb5 9220 28b7                 	sts pulse2_fx_Rxy_total_offset, zero
001bb7 9220 28b8                 	sts pulse2_fx_Rxy_total_offset+1, zero
001bb9 ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001bba 15a2                      	cp r26, zero
001bbb f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001bbc 91b0 2819                 	lds r27, song_speed
001bbe 17ab                      	cp r26, r27
001bbf f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001bc0 93a0 28b9                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001bc2 e0b1                      	ldi r27, 0x01
001bc3 93b0 286e                 	sts pulse2_pattern_delay_rows, r27
001bc5 c165                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001bc6 ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001bc7 e5ec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001bc8 e5f4                      	ldi ZH, HIGH(sequences << 1)
001bc9 0fea                      	add ZL, r26 //offset the pointer
001bca 1df2                      	adc ZH, zero
                                 
001bcb 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001bcc 95a7                      	ror r26
001bcd 95a7                      	ror r26
001bce 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001bd0 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001bd1 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001bd2 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001bd3 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001bd4 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001bd5 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001bd6 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001bd7 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001bd8 93c0 2808                 	sts pulse2_param, r28
001bda ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001bdb ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001bdc ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001bdd ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001bde ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001bdf 93b0 280f                 	sts pulse2_note, r27 //store the note index
001be1 e0a3                      	ldi r26, 0x03
001be2 e0b2                      	ldi r27, 0x02
001be3 93b0 2874                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001be5 93a0 2879                 	sts pulse2_arpeggio_macro_offset, r26
001be7 93b0 2881                 	sts pulse2_pitch_macro_offset, r27
001be9 93b0 2887                 	sts pulse2_hi_pitch_macro_offset, r27
001beb 93b0 288c                 	sts pulse2_duty_macro_offset, r27
001bed 9220 287d                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001bef 9220 287e                 	sts pulse2_total_pitch_offset+1, zero
001bf1 9220 2884                 	sts pulse2_total_hi_pitch_offset, zero
001bf3 9220 2893                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001bf5 9220 2894                 	sts pulse2_fx_1xx_total+1, zero
001bf7 9220 2897                 	sts pulse2_fx_2xx_total, zero
001bf9 9220 2898                 	sts pulse2_fx_2xx_total+1, zero
001bfb 9220 289f                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001bfd 9220 28a0                 	sts pulse2_fx_3xx_total_offset+1, zero
001bff 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001c01 91b0 0a9d                 	lds r27, TCB1_CCMPH
001c03 93a0 2899                 	sts pulse2_fx_3xx_start, r26
001c05 93b0 289a                 	sts pulse2_fx_3xx_start+1, r27
001c07 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001c09 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001c0a 9220 28ad                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c0c 9220 28ae                 	sts pulse2_fx_Qxy_target+1, zero
001c0e 9220 28b1                 	sts pulse2_fx_Qxy_total_offset, zero
001c10 9220 28b2                 	sts pulse2_fx_Qxy_total_offset+1, zero
001c12 9220 28b3                 	sts pulse2_fx_Rxy_target, zero
001c14 9220 28b4                 	sts pulse2_fx_Rxy_target+1, zero
001c16 9220 28b7                 	sts pulse2_fx_Rxy_total_offset, zero
001c18 9220 28b8                 	sts pulse2_fx_Rxy_total_offset+1, zero
001c1a d0f9                      	rcall sound_driver_channel1_increment_offset
001c1b ce39                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001c1c 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001c1d 91a0 2808                 	lds r26, pulse2_param
001c1f 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001c20 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001c21 93a0 2808                 	sts pulse2_param, r26
001c23 6092                      	sbr pulse_channel_flags, 2
001c24 d0ef                      	rcall sound_driver_channel1_increment_offset
001c25 ce2f                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001c26 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001c27 93b0 286e                 	sts pulse2_pattern_delay_rows, r27
001c29 d0ea                      	rcall sound_driver_channel1_increment_offset
001c2a c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001c2b 9220 2872                 	sts pulse2_volume_macro, zero //reset all macro addresses
001c2d 9220 2873                 	sts pulse2_volume_macro+1, zero
001c2f 9220 2877                 	sts pulse2_arpeggio_macro, zero
001c31 9220 2878                 	sts pulse2_arpeggio_macro+1, zero
001c33 9220 287f                 	sts pulse2_pitch_macro, zero
001c35 9220 2880                 	sts pulse2_pitch_macro+1, zero
001c37 9220 2885                 	sts pulse2_hi_pitch_macro, zero
001c39 9220 2886                 	sts pulse2_hi_pitch_macro+1, zero
001c3b 9220 288a                 	sts pulse2_duty_macro, zero
001c3d 9220 288b                 	sts pulse2_duty_macro+1, zero
001c3f 9220 287d                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001c41 9220 287e                 	sts pulse2_total_pitch_offset+1, zero
001c43 9220 2884                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001c45 9631                      	adiw Z, 1 //point to the byte next to the flag
001c46 91b4                      	lpm r27, Z //store the instrument offset into r27
001c47 ede6                      	ldi ZL, LOW(instruments) //point Z to instruments table
001c48 e1f1                      	ldi ZH, HIGH(instruments)
001c49 0feb                      	add ZL, r27 //point Z to offsetted instrument
001c4a 1df2                      	adc ZH, zero
001c4b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001c4c 1fff                      	rol ZH
001c4d 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001c4e 91b4                      	lpm r27, Z
                                 
001c4f 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001c50 1fbb                      	rol r27
001c51 2fea                      	mov ZL, r26
001c52 2ffb                      	mov ZH, r27
001c53 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001c54 9632                      	adiw Z, 2 //point Z to the address of the macro
001c55 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001c56 95aa                      	dec r26
001c57 f019                      	breq sound_driver_channel1_instrument_change_exit
001c58 95b6                      	lsr r27
001c59 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001c5a cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001c5b e0a3                      	ldi r26, 0x03
001c5c e0b2                      	ldi r27, 0x02
001c5d 93b0 2874                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001c5f 93a0 2879                 	sts pulse2_arpeggio_macro_offset, r26
001c61 93b0 2881                 	sts pulse2_pitch_macro_offset, r27
001c63 93b0 2887                 	sts pulse2_hi_pitch_macro_offset, r27
001c65 93b0 288c                 	sts pulse2_duty_macro_offset, r27
001c67 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001c68 cdec                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001c69 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001c6a 91d5                      	lpm r29, Z+
                                 
001c6b 30a5                      	cpi r26, 5
001c6c f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001c6d 30a4                      	cpi r26, 4
001c6e f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001c6f 30a3                      	cpi r26, 3
001c70 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001c71 30a2                      	cpi r26, 2
001c72 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001c73 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001c74 93c0 2872                 	sts pulse2_volume_macro, r28
001c76 93d0 2873                 	sts pulse2_volume_macro+1, r29
001c78 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001c79 93c0 2876                 	sts pulse2_volume_macro_release, r28
001c7b 93d0 2875                 	sts pulse2_volume_macro_loop, r29
001c7d cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001c7e 93c0 2877                 	sts pulse2_arpeggio_macro, r28
001c80 93d0 2878                 	sts pulse2_arpeggio_macro+1, r29
001c82 9220 28ad                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c84 9220 28ae                 	sts pulse2_fx_Qxy_target+1, zero
001c86 9220 28b3                 	sts pulse2_fx_Rxy_target, zero
001c88 9220 28b4                 	sts pulse2_fx_Rxy_target+1, zero
001c8a d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001c8b cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001c8c 93c0 287f                 	sts pulse2_pitch_macro, r28
001c8e 93d0 2880                 	sts pulse2_pitch_macro+1, r29
001c90 9220 28ad                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c92 9220 28ae                 	sts pulse2_fx_Qxy_target+1, zero
001c94 9220 28b3                 	sts pulse2_fx_Rxy_target, zero
001c96 9220 28b4                 	sts pulse2_fx_Rxy_target+1, zero
001c98 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001c99 93c0 2883                 	sts pulse2_pitch_macro_release, r28
001c9b 93d0 2882                 	sts pulse2_pitch_macro_loop, r29
001c9d cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001c9e 93c0 2885                 	sts pulse2_hi_pitch_macro, r28
001ca0 93d0 2886                 	sts pulse2_hi_pitch_macro+1, r29
001ca2 9220 28ad                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ca4 9220 28ae                 	sts pulse2_fx_Qxy_target+1, zero
001ca6 9220 28b3                 	sts pulse2_fx_Rxy_target, zero
001ca8 9220 28b4                 	sts pulse2_fx_Rxy_target+1, zero
001caa d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001cab 93c0 2889                 	sts pulse2_hi_pitch_macro_release, r28
001cad 93d0 2888                 	sts pulse2_hi_pitch_macro_loop, r29
001caf cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001cb0 93c0 288a                 	sts pulse2_duty_macro, r28
001cb2 93d0 288b                 	sts pulse2_duty_macro+1, r29
001cb4 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001cb5 93c0 288e                 	sts pulse2_duty_macro_release, r28
001cb7 93d0 288d                 	sts pulse2_duty_macro_loop, r29
001cb9 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001cba 93ef                      	push ZL
001cbb 93ff                      	push ZH
001cbc 2fec                      	mov ZL, r28
001cbd 2ffd                      	mov ZH, r29
001cbe 0fee                      	lsl ZL
001cbf 1fff                      	rol ZH
001cc0 91c5                      	lpm r28, Z+
001cc1 91d4                      	lpm r29, Z
001cc2 91ff                      	pop ZH
001cc3 91ef                      	pop ZL
001cc4 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001cc5 93ef                      	push ZL
001cc6 93ff                      	push ZH
001cc7 2fec                      	mov ZL, r28
001cc8 2ffd                      	mov ZH, r29
001cc9 0fee                      	lsl ZL
001cca 1fff                      	rol ZH
001ccb 91c5                      	lpm r28, Z+
001ccc 91d5                      	lpm r29, Z+
001ccd 93c0 287b                 	sts pulse2_arpeggio_macro_release, r28
001ccf 93d0 287a                 	sts pulse2_arpeggio_macro_loop, r29
001cd1 91c4                      	lpm r28, Z
001cd2 93c0 287c                 	sts pulse2_arpeggio_macro_mode, r28
001cd4 91ff                      	pop ZH
001cd5 91ef                      	pop ZL
001cd6 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001cd7 91b0 2876                 	lds r27, pulse2_volume_macro_release
001cd9 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001cda f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001cdb 95b3                      	inc r27
001cdc 93b0 2874                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001cde 91b0 287b                 	lds r27, pulse2_arpeggio_macro_release
001ce0 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001ce1 f019                      	breq sound_driver_channel1_release_pitch
001ce2 95b3                      	inc r27
001ce3 93b0 2879                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001ce5 91b0 2883                 	lds r27, pulse2_pitch_macro_release
001ce7 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001ce8 f019                      	breq sound_driver_channel1_release_hi_pitch
001ce9 95b3                      	inc r27
001cea 93b0 2881                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001cec 91b0 2889                 	lds r27, pulse2_hi_pitch_macro_release
001cee 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001cef f019                      	breq sound_driver_channel1_release_duty
001cf0 95b3                      	inc r27
001cf1 93b0 2887                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001cf3 91b0 288e                 	lds r27, pulse2_duty_macro_release
001cf5 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001cf6 f019                      	breq sound_driver_channel1_release_exit
001cf7 95b3                      	inc r27
001cf8 93b0 288c                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001cfa d019                      	rcall sound_driver_channel1_increment_offset
001cfb cd59                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001cfc 91e0 2813                 	lds ZL, song_frames
001cfe 91f0 2814                 	lds ZH, song_frames+1
001d00 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001d02 91b0 2816                 	lds r27, song_frame_offset+1
001d04 9612                      	adiw r27:r26, 2 //offset for channel 1
001d05 0fea                      	add ZL, r26
001d06 1ffb                      	adc ZH, r27
                                 
001d07 91a5                      	lpm r26, Z+ //load the address of the next pattern
001d08 91b4                      	lpm r27, Z
001d09 0faa                      	lsl r26
001d0a 1fbb                      	rol r27
001d0b 93a0 286c                 	sts pulse2_pattern, r26
001d0d 93b0 286d                 	sts pulse2_pattern+1, r27
                                 
001d0f 9220 2870                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001d11 9220 2871                 	sts pulse2_pattern_offset+1, zero
001d13 cd41                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001d14 91e0 2870                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001d16 91f0 2871                 	lds ZH, pulse2_pattern_offset+1
001d18 9631                      	adiw Z, 1
001d19 93e0 2870                 	sts pulse2_pattern_offset, ZL
001d1b 93f0 2871                 	sts pulse2_pattern_offset+1, ZH
001d1d 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001d1e 91e0 2870                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001d20 91f0 2871                 	lds ZH, pulse2_pattern_offset+1
001d22 9632                      	adiw Z, 2 //increment the pointer twice
001d23 93e0 2870                 	sts pulse2_pattern_offset, ZL
001d25 93f0 2871                 	sts pulse2_pattern_offset+1, ZH
001d27 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001d28 95ba                      	dec r27
001d29 93b0 286f                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001d2b 91a0 28bd                 	lds r26, triangle_pattern_delay_rows
001d2d 91b0 28be                 	lds r27, triangle_pattern_delay_frames
001d2f 9610                      	adiw r27:r26, 0
001d30 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001d31 c2bb                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001d32 91e0 28bb                 	lds ZL, triangle_pattern //current pattern for triangle
001d34 91f0 28bc                 	lds ZH, triangle_pattern+1
001d36 91a0 28bf                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001d38 91b0 28c0                 	lds r27, triangle_pattern_offset+1
001d3a 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001d3b 1ffb                      	adc ZH, r27
001d3c 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001d3d 35b7                      	cpi r27, 0x57
001d3e f408                      	brsh sound_driver_channel2_check_if_volume
001d3f c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001d40 36b7                      	cpi r27, 0x67
001d41 f408                      	brsh sound_driver_channel2_check_if_delay
001d42 c19a                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001d43 3eb3                      	cpi r27, 0xE3
001d44 f408                      	brsh sound_driver_channel2_check_if_instrument
001d45 c1a5                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001d46 f409                      	brne sound_driver_channel2_check_if_release
001d47 c1a8                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001d48 3eb4                      	cpi r27, 0xE4
001d49 f409                      	brne sound_driver_channel2_check_if_end
001d4a c251                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001d4b 3fbf                      	cpi r27, 0xFF
001d4c f409                      	brne sound_driver_channel2_check_if_fx
001d4d c273                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001d4e 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001d4f 91a4                      	lpm r26, Z //load the fx data into r26
001d50 d292                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001d51 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001d52 ece8                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001d53 e5f4                      	ldi ZH, HIGH(channel2_fx << 1)
001d54 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001d55 0feb                      	add ZL, r27 //add offset
001d56 1df2                      	adc ZH, zero
001d57 91c5                      	lpm r28, Z+ //load address bytes
001d58 91d4                      	lpm r29, Z
001d59 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001d5a 2ffd                      	mov ZH, r29
001d5b 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001d5c 93a0 28de                 	sts triangle_fx_0xy_sequence, r26
001d5e 9220 28df                 	sts triangle_fx_0xy_sequence+1, zero
001d60 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001d61 9220 28e4                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001d63 9220 28e5                 	sts triangle_fx_2xx+1, zero
001d65 9220 28de                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001d67 9220 28df                 	sts triangle_fx_0xy_sequence+1, zero
001d69 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d6a 937f                      	push r23
001d6b 2f6a                      	mov r22, r26 //store the rate into r22
001d6c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d6d 9f67                      	mul r22, r23
001d6e 917f                      	pop r23
001d6f 916f                      	pop r22
                                 
001d70 9416                      	lsr r1 //shift out the fractional bits
001d71 9407                      	ror r0
001d72 9416                      	lsr r1
001d73 9407                      	ror r0
001d74 9416                      	lsr r1
001d75 9407                      	ror r0
001d76 9416                      	lsr r1
001d77 9407                      	ror r0
001d78 9200 28e0                 	sts triangle_fx_1xx, r0
001d7a 9210 28e1                 	sts triangle_fx_1xx+1, r1
001d7c cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001d7d 9220 28e0                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001d7f 9220 28e1                 	sts triangle_fx_1xx+1, zero
001d81 9220 28de                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001d83 9220 28df                 	sts triangle_fx_0xy_sequence+1, zero
001d85 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d86 937f                      	push r23
001d87 2f6a                      	mov r22, r26 //store the rate into r22
001d88 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d89 9f67                      	mul r22, r23
001d8a 917f                      	pop r23
001d8b 916f                      	pop r22
                                 
001d8c 9416                      	lsr r1 //shift out the fractional bits
001d8d 9407                      	ror r0
001d8e 9416                      	lsr r1
001d8f 9407                      	ror r0
001d90 9416                      	lsr r1
001d91 9407                      	ror r0
001d92 9416                      	lsr r1
001d93 9407                      	ror r0
001d94 9200 28e4                 	sts triangle_fx_2xx, r0
001d96 9210 28e5                 	sts triangle_fx_2xx+1, r1
001d98 cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001d99 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d9a 937f                      	push r23
001d9b 2f6a                      	mov r22, r26 //store the rate into r22
001d9c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d9d 9f67                      	mul r22, r23
001d9e 917f                      	pop r23
001d9f 916f                      	pop r22
                                 
001da0 9416                      	lsr r1 //shift out the fractional bits
001da1 9407                      	ror r0
001da2 9416                      	lsr r1
001da3 9407                      	ror r0
001da4 9416                      	lsr r1
001da5 9407                      	ror r0
001da6 9416                      	lsr r1
001da7 9407                      	ror r0
001da8 9200 28ec                 	sts triangle_fx_3xx_speed, r0
001daa 9210 28ed                 	sts triangle_fx_3xx_speed+1, r1
                                 
001dac 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001dad c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001dae cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001daf 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001db1 91b0 0aad                 	lds r27, TCB2_CCMPH
001db3 93a0 28e8                 	sts triangle_fx_3xx_start, r26
001db5 93b0 28e9                 	sts triangle_fx_3xx_start+1, r27
                                 
001db7 9220 28ee                 	sts triangle_fx_3xx_total_offset, zero
001db9 9220 28ef                 	sts triangle_fx_3xx_total_offset+1, zero
001dbb cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001dbc 2fba                      	mov r27, r26
001dbd 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001dbe 95a2                      	swap r26
001dbf 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001dc0 93a0 28f0                 	sts triangle_fx_4xy_speed, r26
001dc2 93b0 28f1                 	sts triangle_fx_4xy_depth, r27
001dc4 9220 28f2                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001dc6 cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001dc7 cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001dc8 cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001dc9 93a0 281a                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001dcb cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001dcc 93b0 281b                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001dce cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001dcf 93b0 281c                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001dd1 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001dd2 15a2                      	cp r26, zero
001dd3 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001dd4 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001dd5 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001dd7 cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001dd8 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001dda 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001ddc 9220 0aad                 	sts TCB2_CCMPH, zero
001dde cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001ddf 93a0 2819                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001de1 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001de2 15a2                      	cp r26, zero
001de3 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001de4 91b0 2819                 	lds r27, song_speed
001de6 17ab                      	cp r26, r27
001de7 f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001de8 93a0 28f3                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001dea e0b1                      	ldi r27, 0x01
001deb 93b0 28bd                 	sts triangle_pattern_delay_rows, r27
001ded c202                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel2_fx_Gxx_invalid:
001dee cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001def cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001df0 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001df1 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001df2 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001df3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001df4 937f                      	push r23
001df5 2f6a                      	mov r22, r26
001df6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001df7 9f67                      	mul r22, r23
001df8 917f                      	pop r23
001df9 916f                      	pop r22
001dfa 9416                      	lsr r1 //shift out the fractional bits
001dfb 9407                      	ror r0
001dfc 9416                      	lsr r1
001dfd 9407                      	ror r0
001dfe 9416                      	lsr r1
001dff 9407                      	ror r0
001e00 9416                      	lsr r1
001e01 9407                      	ror r0
001e02 9200 28f5                 	sts triangle_fx_Pxx_total, r0
001e04 9210 28f6                 	sts triangle_fx_Pxx_total+1, r1
001e06 cf2b                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001e07 91e0 28c6                 	lds ZL, triangle_arpeggio_macro
001e09 91f0 28c7                 	lds ZH, triangle_arpeggio_macro+1
001e0b 9630                      	adiw Z, 0
001e0c f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001e0d cf24                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001e0e 91e0 28ce                 	lds ZL, triangle_pitch_macro
001e10 91f0 28cf                 	lds ZH, triangle_pitch_macro+1
001e12 9630                      	adiw Z, 0
001e13 f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001e14 cf1d                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001e15 91e0 28d4                 	lds ZL, triangle_hi_pitch_macro
001e17 91f0 28d5                 	lds ZH, triangle_hi_pitch_macro+1
001e19 9630                      	adiw Z, 0
001e1a f009                      	breq sound_driver_channel2_fx_Qxy_process
001e1b cf16                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001e1c 2fba                      	mov r27, r26 //copy fx parameters into r27
001e1d 70bf                      	andi r27, 0x0F //mask note index offset
001e1e 91c0 2812                 	lds r28, triangle_note //load current note index
001e20 0fbc                      	add r27, r28
001e21 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001e22 f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001e23 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001e24 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001e25 e0f0                      	ldi ZH, HIGH(note_table << 1)
001e26 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001e27 0feb                      	add ZL, r27 //add offset
001e28 1df2                      	adc ZH, zero
001e29 91c5                      	lpm r28, Z+ //load bytes
001e2a 91d4                      	lpm r29, Z
001e2b 93c0 28f7                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001e2d 93d0 28f8                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001e2f 95a2                      	swap r26
001e30 70af                      	andi r26, 0x0F //mask effect speed
001e31 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e32 95a3                      	inc r26 //increment the speed by 1
                                 
001e33 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e34 937f                      	push r23
001e35 2f6a                      	mov r22, r26 //store the speed data into r27
001e36 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e37 9f67                      	mul r22, r23
001e38 917f                      	pop r23
001e39 916f                      	pop r22
                                 
001e3a 9416                      	lsr r1 //shift out the fractional bits
001e3b 9407                      	ror r0
001e3c 9416                      	lsr r1
001e3d 9407                      	ror r0
001e3e 9416                      	lsr r1
001e3f 9407                      	ror r0
001e40 9416                      	lsr r1
001e41 9407                      	ror r0
                                 
001e42 9200 28f9                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001e44 9210 28fa                 	sts triangle_fx_Qxy_speed+1, r1
001e46 9220 28fb                 	sts triangle_fx_Qxy_total_offset, zero
001e48 9220 28fc                 	sts triangle_fx_Qxy_total_offset+1, zero
001e4a cee7                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001e4b 91e0 28c6                 	lds ZL, triangle_arpeggio_macro
001e4d 91f0 28c7                 	lds ZH, triangle_arpeggio_macro+1
001e4f 9630                      	adiw Z, 0
001e50 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001e51 cee0                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001e52 91e0 28ce                 	lds ZL, triangle_pitch_macro
001e54 91f0 28cf                 	lds ZH, triangle_pitch_macro+1
001e56 9630                      	adiw Z, 0
001e57 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001e58 ced9                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001e59 91e0 28d4                 	lds ZL, triangle_hi_pitch_macro
001e5b 91f0 28d5                 	lds ZH, triangle_hi_pitch_macro+1
001e5d 9630                      	adiw Z, 0
001e5e f009                      	breq sound_driver_channel2_fx_Rxy_process
001e5f ced2                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001e60 2fba                      	mov r27, r26 //copy fx parameters into r27
001e61 70bf                      	andi r27, 0x0F //mask note index offset
001e62 91c0 2812                 	lds r28, triangle_note //load current note index
001e64 1bcb                      	sub r28, r27
001e65 f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001e66 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001e67 e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001e68 e0f0                      	ldi ZH, HIGH(note_table << 1)
001e69 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001e6a 0fec                      	add ZL, r28 //add offset
001e6b 1df2                      	adc ZH, zero
001e6c 91c5                      	lpm r28, Z+ //load bytes
001e6d 91d4                      	lpm r29, Z
001e6e 93c0 28fd                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001e70 93d0 28fe                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001e72 95a2                      	swap r26
001e73 70af                      	andi r26, 0x0F //mask effect speed
001e74 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e75 95a3                      	inc r26 //increment the speed by 1
                                 
001e76 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e77 937f                      	push r23
001e78 2f6a                      	mov r22, r26 //store the speed data into r27
001e79 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e7a 9f67                      	mul r22, r23
001e7b 917f                      	pop r23
001e7c 916f                      	pop r22
                                 
001e7d 9416                      	lsr r1 //shift out the fractional bits
001e7e 9407                      	ror r0
001e7f 9416                      	lsr r1
001e80 9407                      	ror r0
001e81 9416                      	lsr r1
001e82 9407                      	ror r0
001e83 9416                      	lsr r1
001e84 9407                      	ror r0
                                 
001e85 9200 28ff                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001e87 9210 2900                 	sts triangle_fx_Rxy_speed+1, r1
001e89 9220 2901                 	sts triangle_fx_Rxy_total_offset, zero
001e8b 9220 2902                 	sts triangle_fx_Rxy_total_offset+1, zero
001e8d cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001e8e 15a2                      	cp r26, zero
001e8f f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001e90 91b0 2819                 	lds r27, song_speed
001e92 17ab                      	cp r26, r27
001e93 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001e94 93a0 2903                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001e96 e0b1                      	ldi r27, 0x01
001e97 93b0 28bd                 	sts triangle_pattern_delay_rows, r27
001e99 c156                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel2_fx_Sxx_invalid:
001e9a ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001e9b ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001e9c ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001e9d ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001e9e ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001e9f ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001ea0 93b0 2812                 	sts triangle_note, r27 //store the note index
001ea2 e0a3                      	ldi r26, 0x03
001ea3 e0b2                      	ldi r27, 0x02
001ea4 93b0 28c3                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001ea6 93a0 28c8                 	sts triangle_arpeggio_macro_offset, r26
001ea8 93b0 28d0                 	sts triangle_pitch_macro_offset, r27
001eaa 93b0 28d6                 	sts triangle_hi_pitch_macro_offset, r27
001eac 93b0 28db                 	sts triangle_duty_macro_offset, r27
001eae 9220 28cc                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001eb0 9220 28cc                 	sts triangle_total_pitch_offset, zero
001eb2 9220 28d3                 	sts triangle_total_hi_pitch_offset, zero
001eb4 9220 28e2                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001eb6 9220 28e3                 	sts triangle_fx_1xx_total+1, zero
001eb8 9220 28e6                 	sts triangle_fx_2xx_total, zero
001eba 9220 28e7                 	sts triangle_fx_2xx_total+1, zero
001ebc 9220 28ee                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001ebe 9220 28ef                 	sts triangle_fx_3xx_total_offset+1, zero
001ec0 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ec2 91b0 0aad                 	lds r27, TCB2_CCMPH
001ec4 93a0 28e8                 	sts triangle_fx_3xx_start, r26
001ec6 93b0 28e9                 	sts triangle_fx_3xx_start+1, r27
001ec8 9220 28f7                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001eca 9220 28f8                 	sts triangle_fx_Qxy_target+1, zero
001ecc 9220 28fb                 	sts triangle_fx_Qxy_total_offset, zero
001ece 9220 28fc                 	sts triangle_fx_Qxy_total_offset+1, zero
001ed0 9220 28fd                 	sts triangle_fx_Rxy_target, zero
001ed2 9220 28fe                 	sts triangle_fx_Rxy_target+1, zero
001ed4 9220 2901                 	sts triangle_fx_Rxy_total_offset, zero
001ed6 9220 2902                 	sts triangle_fx_Rxy_total_offset+1, zero
001ed8 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ed9 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001edb d0fd                      	rcall sound_driver_channel2_increment_offset
001edc ce55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001edd d0fb                      	rcall sound_driver_channel2_increment_offset
001ede 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001edf f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001ee0 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ee1 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001ee3 ce4e                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001ee4 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001ee6 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001ee8 9220 0aad                 	sts TCB2_CCMPH, zero
001eea ce47                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001eeb 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001eec 93b0 28bd                 	sts triangle_pattern_delay_rows, r27
001eee d0ea                      	rcall sound_driver_channel2_increment_offset
001eef c100                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001ef0 9220 28c1                 	sts triangle_volume_macro, zero //reset all macro addresses
001ef2 9220 28c2                 	sts triangle_volume_macro+1, zero
001ef4 9220 28c6                 	sts triangle_arpeggio_macro, zero
001ef6 9220 28c7                 	sts triangle_arpeggio_macro+1, zero
001ef8 9220 28ce                 	sts triangle_pitch_macro, zero
001efa 9220 28cf                 	sts triangle_pitch_macro+1, zero
001efc 9220 28d4                 	sts triangle_hi_pitch_macro, zero
001efe 9220 28d5                 	sts triangle_hi_pitch_macro+1, zero
001f00 9220 28d9                 	sts triangle_duty_macro, zero
001f02 9220 28da                 	sts triangle_duty_macro+1, zero
001f04 9220 28cc                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001f06 9220 28cd                 	sts triangle_total_pitch_offset+1, zero
001f08 9220 28d3                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001f0a 9631                      	adiw Z, 1 //point to the byte next to the flag
001f0b 91b4                      	lpm r27, Z //store the instrument offset into r27
001f0c ede6                      	ldi ZL, LOW(instruments) //point Z to instruments table
001f0d e1f1                      	ldi ZH, HIGH(instruments)
001f0e 0feb                      	add ZL, r27 //point Z to offsetted instrument
001f0f 1df2                      	adc ZH, zero
001f10 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001f11 1fff                      	rol ZH
001f12 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001f13 91b4                      	lpm r27, Z
                                 
001f14 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001f15 1fbb                      	rol r27
001f16 2fea                      	mov ZL, r26
001f17 2ffb                      	mov ZH, r27
001f18 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001f19 9632                      	adiw Z, 2 //point Z to the address of the macro
001f1a e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001f1b 95aa                      	dec r26
001f1c f019                      	breq sound_driver_channel2_instrument_change_exit
001f1d 95b6                      	lsr r27
001f1e f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001f1f cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001f20 e0a3                      	ldi r26, 0x03
001f21 e0b2                      	ldi r27, 0x02
001f22 93b0 28c3                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001f24 93a0 28c8                 	sts triangle_arpeggio_macro_offset, r26
001f26 93b0 28d0                 	sts triangle_pitch_macro_offset, r27
001f28 93b0 28d6                 	sts triangle_hi_pitch_macro_offset, r27
001f2a 93b0 28db                 	sts triangle_duty_macro_offset, r27
001f2c d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001f2d ce04                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001f2e 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001f2f 91d5                      	lpm r29, Z+
                                 
001f30 30a5                      	cpi r26, 5
001f31 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
001f32 30a4                      	cpi r26, 4
001f33 f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
001f34 30a3                      	cpi r26, 3
001f35 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
001f36 30a2                      	cpi r26, 2
001f37 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
001f38 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
001f39 93c0 28c1                 	sts triangle_volume_macro, r28
001f3b 93d0 28c2                 	sts triangle_volume_macro+1, r29
001f3d d041                      	rcall sound_driver_channel2_instrument_change_read_header
001f3e 93c0 28c5                 	sts triangle_volume_macro_release, r28
001f40 93d0 28c4                 	sts triangle_volume_macro_loop, r29
001f42 cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
001f43 93c0 28c6                 	sts triangle_arpeggio_macro, r28
001f45 93d0 28c7                 	sts triangle_arpeggio_macro+1, r29
001f47 9220 28f7                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f49 9220 28f8                 	sts triangle_fx_Qxy_target+1, zero
001f4b 9220 28fd                 	sts triangle_fx_Rxy_target, zero
001f4d 9220 28fe                 	sts triangle_fx_Rxy_target+1, zero
001f4f d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
001f50 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
001f51 93c0 28ce                 	sts triangle_pitch_macro, r28
001f53 93d0 28cf                 	sts triangle_pitch_macro+1, r29
001f55 9220 28f7                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f57 9220 28f8                 	sts triangle_fx_Qxy_target+1, zero
001f59 9220 28fd                 	sts triangle_fx_Rxy_target, zero
001f5b 9220 28fe                 	sts triangle_fx_Rxy_target+1, zero
001f5d d021                      	rcall sound_driver_channel2_instrument_change_read_header
001f5e 93c0 28d2                 	sts triangle_pitch_macro_release, r28
001f60 93d0 28d1                 	sts triangle_pitch_macro_loop, r29
001f62 cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001f63 93c0 28d4                 	sts triangle_hi_pitch_macro, r28
001f65 93d0 28d5                 	sts triangle_hi_pitch_macro+1, r29
001f67 9220 28f7                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f69 9220 28f8                 	sts triangle_fx_Qxy_target+1, zero
001f6b 9220 28fd                 	sts triangle_fx_Rxy_target, zero
001f6d 9220 28fe                 	sts triangle_fx_Rxy_target+1, zero
001f6f d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001f70 93c0 28d8                 	sts triangle_hi_pitch_macro_release, r28
001f72 93d0 28d7                 	sts triangle_hi_pitch_macro_loop, r29
001f74 cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
001f75 93c0 28d9                 	sts triangle_duty_macro, r28
001f77 93d0 28da                 	sts triangle_duty_macro+1, r29
001f79 d005                      	rcall sound_driver_channel2_instrument_change_read_header
001f7a 93c0 28dd                 	sts triangle_duty_macro_release, r28
001f7c 93d0 28dc                 	sts triangle_duty_macro_loop, r29
001f7e cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001f7f 93ef                      	push ZL
001f80 93ff                      	push ZH
001f81 2fec                      	mov ZL, r28
001f82 2ffd                      	mov ZH, r29
001f83 0fee                      	lsl ZL
001f84 1fff                      	rol ZH
001f85 91c5                      	lpm r28, Z+
001f86 91d4                      	lpm r29, Z
001f87 91ff                      	pop ZH
001f88 91ef                      	pop ZL
001f89 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
001f8a 93ef                      	push ZL
001f8b 93ff                      	push ZH
001f8c 2fec                      	mov ZL, r28
001f8d 2ffd                      	mov ZH, r29
001f8e 0fee                      	lsl ZL
001f8f 1fff                      	rol ZH
001f90 91c5                      	lpm r28, Z+
001f91 91d5                      	lpm r29, Z+
001f92 93c0 28ca                 	sts triangle_arpeggio_macro_release, r28
001f94 93d0 28c9                 	sts triangle_arpeggio_macro_loop, r29
001f96 91c4                      	lpm r28, Z
001f97 93c0 28cb                 	sts triangle_arpeggio_macro_mode, r28
001f99 91ff                      	pop ZH
001f9a 91ef                      	pop ZL
001f9b 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001f9c 91b0 28c5                 	lds r27, triangle_volume_macro_release
001f9e 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001f9f f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001fa0 95b3                      	inc r27
001fa1 93b0 28c3                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001fa3 91b0 28ca                 	lds r27, triangle_arpeggio_macro_release
001fa5 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001fa6 f019                      	breq sound_driver_channel2_release_pitch
001fa7 95b3                      	inc r27
001fa8 93b0 28c8                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
001faa 91b0 28d2                 	lds r27, triangle_pitch_macro_release
001fac 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001fad f019                      	breq sound_driver_channel2_release_hi_pitch
001fae 95b3                      	inc r27
001faf 93b0 28d0                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001fb1 91b0 28d8                 	lds r27, triangle_hi_pitch_macro_release
001fb3 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001fb4 f019                      	breq sound_driver_channel2_release_duty
001fb5 95b3                      	inc r27
001fb6 93b0 28d6                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
001fb8 91b0 28dd                 	lds r27, triangle_duty_macro_release
001fba 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001fbb f019                      	breq sound_driver_channel2_release_exit
001fbc 95b3                      	inc r27
001fbd 93b0 28db                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001fbf d019                      	rcall sound_driver_channel2_increment_offset
001fc0 cd71                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001fc1 91e0 2813                 	lds ZL, song_frames
001fc3 91f0 2814                 	lds ZH, song_frames+1
001fc5 91a0 2815                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001fc7 91b0 2816                 	lds r27, song_frame_offset+1
001fc9 9614                      	adiw r27:r26, 4 //offset for channel 2
001fca 0fea                      	add ZL, r26
001fcb 1ffb                      	adc ZH, r27
                                 
001fcc 91a5                      	lpm r26, Z+ //load the address of the next pattern
001fcd 91b4                      	lpm r27, Z
001fce 0faa                      	lsl r26
001fcf 1fbb                      	rol r27
001fd0 93a0 28bb                 	sts triangle_pattern, r26
001fd2 93b0 28bc                 	sts triangle_pattern+1, r27
                                 
001fd4 9220 28bf                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001fd6 9220 28c0                 	sts triangle_pattern_offset+1, zero
001fd8 cd59                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
001fd9 91e0 28bf                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001fdb 91f0 28c0                 	lds ZH, triangle_pattern_offset+1
001fdd 9631                      	adiw Z, 1
001fde 93e0 28bf                 	sts triangle_pattern_offset, ZL
001fe0 93f0 28c0                 	sts triangle_pattern_offset+1, ZH
001fe2 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001fe3 91e0 28bf                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001fe5 91f0 28c0                 	lds ZH, triangle_pattern_offset+1
001fe7 9632                      	adiw Z, 2 //increment the pointer twice
001fe8 93e0 28bf                 	sts triangle_pattern_offset, ZL
001fea 93f0 28c0                 	sts triangle_pattern_offset+1, ZH
001fec 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001fed 95ba                      	dec r27
001fee 93b0 28be                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
001ff0 91f0 2819                 	lds r31, song_speed
001ff2 2fef                      	mov r30, r31
001ff3 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
001ff4 91a0 2820                 	lds r26, pulse1_pattern_delay_frames
001ff6 11a2                      	cpse r26, zero
001ff7 c042                      	rjmp sound_driver_calculate_delays_pulse2
001ff8 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
001ff9 2faf                      	mov r26, r31 //move the speed to r26
001ffa 91b0 281f                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
001ffc 15b2                      	cp r27, zero
001ffd f409                      	brne PC+2
001ffe c03b                      	rjmp sound_driver_calculate_delays_pulse2
001fff 95ba                      	dec r27
002000 93b0 281f                 	sts pulse1_pattern_delay_rows, r27
002002 11b2                      	cpse r27, zero
002003 c034                      	rjmp sound_driver_calculate_delays_pulse1_store
002004 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002005 efbf                      	ldi r27, 0xFF
002006 91c0 286a                 	lds r28, pulse1_fx_Sxx_pre
002008 91d0 286b                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
00200a 17cb                      	cp r28, r27
00200b f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
00200c c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
00200d 17db                      	cp r29, r27
00200e f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
00200f c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
002010 91c0 285a                 	lds r28, pulse1_fx_Gxx_pre
002012 91d0 285b                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
002014 17cb                      	cp r28, r27
002015 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
002016 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
002017 17db                      	cp r29, r27
002018 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
002019 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
00201a 93b0 286a                 	sts pulse1_fx_Sxx_pre, r27
00201c 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00201d 93e0 286b                 	sts pulse1_fx_Sxx_post, r30
00201f 95ca                      	dec r28
002020 93c0 2820                 	sts pulse1_pattern_delay_frames, r28
002022 2fef                      	mov r30, r31
002023 50e1                      	subi r30, 1
002024 c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
002025 93b0 286b                 	sts pulse1_fx_Sxx_post, r27
002027 2fad                      	mov r26, r29
002028 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
002029 93b0 285a                 	sts pulse1_fx_Gxx_pre, r27
00202b 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00202c 93e0 285b                 	sts pulse1_fx_Gxx_post, r30
00202e 95ca                      	dec r28
00202f 93c0 2820                 	sts pulse1_pattern_delay_frames, r28
002031 2fef                      	mov r30, r31
002032 50e1                      	subi r30, 1
002033 c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
002034 93b0 285b                 	sts pulse1_fx_Gxx_post, r27
002036 2fad                      	mov r26, r29
002037 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
002038 93a0 2820                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
00203a 91a0 286f                 	lds r26, pulse2_pattern_delay_frames
00203c 11a2                      	cpse r26, zero
00203d c042                      	rjmp sound_driver_calculate_delays_triangle
00203e c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
00203f 2faf                      	mov r26, r31 //move the speed to r26
002040 91b0 286e                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
002042 15b2                      	cp r27, zero
002043 f409                      	brne PC+2
002044 c03b                      	rjmp sound_driver_calculate_delays_triangle
002045 95ba                      	dec r27
002046 93b0 286e                 	sts pulse2_pattern_delay_rows, r27
002048 11b2                      	cpse r27, zero
002049 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
00204a 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
00204b efbf                      	ldi r27, 0xFF
00204c 91c0 28b9                 	lds r28, pulse2_fx_Sxx_pre
00204e 91d0 28ba                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
002050 17cb                      	cp r28, r27
002051 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
002052 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
002053 17db                      	cp r29, r27
002054 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
002055 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
002056 91c0 28a9                 	lds r28, pulse2_fx_Gxx_pre
002058 91d0 28aa                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
00205a 17cb                      	cp r28, r27
00205b f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
00205c c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
00205d 17db                      	cp r29, r27
00205e f0f9                      	breq sound_driver_calculate_delays_pulse2_store
00205f c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
002060 93b0 28b9                 	sts pulse2_fx_Sxx_pre, r27
002062 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002063 93e0 28ba                 	sts pulse2_fx_Sxx_post, r30
002065 95ca                      	dec r28
002066 93c0 286f                 	sts pulse2_pattern_delay_frames, r28
002068 2fef                      	mov r30, r31
002069 50e1                      	subi r30, 1
00206a cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
00206b 93b0 28ba                 	sts pulse2_fx_Sxx_post, r27
00206d 2fad                      	mov r26, r29
00206e c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
00206f 93b0 28a9                 	sts pulse2_fx_Gxx_pre, r27
002071 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002072 93e0 28aa                 	sts pulse2_fx_Gxx_post, r30
002074 95ca                      	dec r28
002075 93c0 286f                 	sts pulse2_pattern_delay_frames, r28
002077 2fef                      	mov r30, r31
002078 50e1                      	subi r30, 1
002079 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
00207a 93b0 28aa                 	sts pulse2_fx_Gxx_post, r27
00207c 2fad                      	mov r26, r29
00207d c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
00207e 93a0 286f                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
002080 91a0 28be                 	lds r26, triangle_pattern_delay_frames
002082 11a2                      	cpse r26, zero
002083 c042                      	rjmp sound_driver_calculate_delays_noise
002084 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
002085 2faf                      	mov r26, r31 //move the speed to r26
002086 91b0 28bd                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
002088 15b2                      	cp r27, zero
002089 f409                      	brne PC+2
00208a c03b                      	rjmp sound_driver_calculate_delays_noise
00208b 95ba                      	dec r27
00208c 93b0 28bd                 	sts triangle_pattern_delay_rows, r27
00208e 11b2                      	cpse r27, zero
00208f c034                      	rjmp sound_driver_calculate_delays_triangle_store
002090 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
002091 efbf                      	ldi r27, 0xFF
002092 91c0 2903                 	lds r28, triangle_fx_Sxx_pre
002094 91d0 2904                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
002096 17cb                      	cp r28, r27
002097 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
002098 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
002099 17db                      	cp r29, r27
00209a f009                      	breq sound_driver_calculate_delays_triangle_Gxx
00209b c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
00209c 91c0 28f3                 	lds r28, triangle_fx_Gxx_pre
00209e 91d0 28f4                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
0020a0 17cb                      	cp r28, r27
0020a1 f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
0020a2 c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
0020a3 17db                      	cp r29, r27
0020a4 f0f9                      	breq sound_driver_calculate_delays_triangle_store
0020a5 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
0020a6 93b0 2903                 	sts triangle_fx_Sxx_pre, r27
0020a8 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020a9 93e0 2904                 	sts triangle_fx_Sxx_post, r30
0020ab 95ca                      	dec r28
0020ac 93c0 28be                 	sts triangle_pattern_delay_frames, r28
0020ae 2fef                      	mov r30, r31
0020af 50e1                      	subi r30, 1
0020b0 c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
0020b1 93b0 2904                 	sts triangle_fx_Sxx_post, r27
0020b3 2fad                      	mov r26, r29
0020b4 c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
0020b5 93b0 28f3                 	sts triangle_fx_Gxx_pre, r27
0020b7 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0020b8 93e0 28f4                 	sts triangle_fx_Gxx_post, r30
0020ba 95ca                      	dec r28
0020bb 93c0 28be                 	sts triangle_pattern_delay_frames, r28
0020bd 2fef                      	mov r30, r31
0020be 50e1                      	subi r30, 1
0020bf c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
0020c0 93b0 28f4                 	sts triangle_fx_Gxx_post, r27
0020c2 2fad                      	mov r26, r29
0020c3 c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
0020c4 93a0 28be                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
0020c6 91e0 2823                 	lds ZL, pulse1_volume_macro
0020c8 91f0 2824                 	lds ZH, pulse1_volume_macro+1
0020ca 9630                      	adiw Z, 0
0020cb f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
0020cc 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0020cd 1fff                      	rol ZH
0020ce 91a0 2825                 	lds r26, pulse1_volume_macro_offset
0020d0 0fea                      	add ZL, r26
0020d1 1df2                      	adc ZH, zero
                                 
0020d2 91b0 2827                 	lds r27, pulse1_volume_macro_release
0020d4 17ba                      	cp r27, r26
0020d5 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
0020d6 91a0 2826                 	lds r26, pulse1_volume_macro_loop
0020d8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0020d9 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0020da c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
0020db 95a3                      	inc r26 //increment the macro offset
0020dc 93a0 2825                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
0020de 91b4                      	lpm r27, Z //load volume data into r27
0020df 3fbf                      	cpi r27, 0xFF //check for macro end flag
0020e0 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
0020e1 91b0 2827                 	lds r27, pulse1_volume_macro_release
0020e3 3fbf                      	cpi r27, 0xFF
0020e4 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
0020e5 91b0 2826                 	lds r27, pulse1_volume_macro_loop //load the loop index
0020e7 93b0 2825                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
0020e9 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
0020ea 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0020eb 93a0 2825                 	sts pulse1_volume_macro_offset, r26
0020ed cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
0020ee efec                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0020ef e5f4                      	ldi ZH, HIGH(volumes << 1)
0020f0 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0020f1 0feb                      	add ZL, r27 //add offset to the table
0020f2 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0020f3 91b0 2800                 	lds r27, pulse1_param //load main volume
0020f5 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0020f6 91a0 2858                 	lds r26, pulse1_fx_7xy_value
0020f8 30a0                      	cpi r26, 0x00
0020f9 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0020fa 0feb                      	add ZL, r27 //offset the volume table by the main volume
0020fb 1df2                      	adc ZH, zero
0020fc 91b4                      	lpm r27, Z
0020fd 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0020ff c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002100 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002102 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002103 91a0 2858                 	lds r26, pulse1_fx_7xy_value
002105 30a0                      	cpi r26, 0x00
002106 f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
002107 93b0 2806                 	sts pulse1_output_volume, r27
002109 c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
00210a 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00210b f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00210c f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00210d e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
00210e 0feb                      	add ZL, r27 //offset the volume table by the main volume
00210f 1df2                      	adc ZH, zero
002110 91b4                      	lpm r27, Z
002111 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002113 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002114 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002115 0feb                      	add ZL, r27 //offset the volume table by the main volume
002116 1df2                      	adc ZH, zero
002117 91b4                      	lpm r27, Z
002118 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00211a c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
00211b 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00211c f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
00211d f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
00211e 93b0 2806                 	sts pulse1_output_volume, r27
002120 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002121 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002122 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002124 91e0 2828                 	lds ZL, pulse1_arpeggio_macro
002126 91f0 2829                 	lds ZH, pulse1_arpeggio_macro+1
002128 9630                      	adiw Z, 0
002129 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00212a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00212b 1fff                      	rol ZH
00212c 91a0 282a                 	lds r26, pulse1_arpeggio_macro_offset
00212e 0fea                      	add ZL, r26
00212f 1df2                      	adc ZH, zero
                                 
002130 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
002132 17ba                      	cp r27, r26
002133 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002134 91a0 282b                 	lds r26, pulse1_arpeggio_macro_loop
002136 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002137 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002138 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
002139 95a3                      	inc r26 //increment the macro offset
00213a 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00213c 91b4                      	lpm r27, Z //load arpeggio data into r27
00213d 38b0                      	cpi r27, 0x80 //check for macro end flag
00213e f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
00213f c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002140 50a1                      	subi r26, 1 //keep the offset at the end flag
002141 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26
002143 91b0 282d                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002145 30b1                      	cpi r27, 0x01
002146 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
002147 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
002149 3fbf                      	cpi r27, 0xFF
00214a f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
00214b 91b0 282b                 	lds r27, pulse1_arpeggio_macro_loop
00214d 3fbf                      	cpi r27, 0xFF
00214e f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00214f c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002150 91b0 282c                 	lds r27, pulse1_arpeggio_macro_release
002152 3fbf                      	cpi r27, 0xFF
002153 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
002154 91b0 282b                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
002156 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002157 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
002158 91c0 2840                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
00215a 91d0 2841                 	lds r29, pulse1_fx_0xy_sequence+1
00215c 9620                      	adiw r29:r28, 0
00215d f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00215e 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00215f 93a0 282a                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
002161 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002162 93b0 282a                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
002164 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
002165 91c0 2840                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
002167 91d0 2841                 	lds r29, pulse1_fx_0xy_sequence+1
002169 9620                      	adiw r29:r28, 0 //check for 0xy effect
00216a f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
00216b 95d6                      	lsr r29
00216c 95c7                      	ror r28
00216d 95d7                      	ror r29
00216e 95c7                      	ror r28
00216f 95d7                      	ror r29
002170 95c7                      	ror r28
002171 95d7                      	ror r29
002172 95c7                      	ror r28
002173 95d7                      	ror r29
002174 95d2                      	swap r29
                                 
002175 93c0 2840                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
002177 93d0 2841                 	sts pulse1_fx_0xy_sequence+1, r29
002179 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00217a 91a0 2807                 	lds r26, pulse1_note //load the current note index
00217c 0fac                      	add r26, r28 //add the note offset
00217d c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00217e 91a0 2807                 	lds r26, pulse1_note //load the current note index
002180 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002181 9220 282e                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002183 9220 282f                 	sts pulse1_total_pitch_offset+1, zero
002185 9220 2835                 	sts pulse1_total_hi_pitch_offset, zero
002187 91a0 282d                 	lds r26, pulse1_arpeggio_macro_mode
002189 30a1                      	cpi r26, 0x01 //absolute mode
00218a f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
00218b f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
00218c c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
00218d 91a0 2807                 	lds r26, pulse1_note //load the current note index
00218f 0fab                      	add r26, r27 //offset the note with the arpeggio data
002190 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002191 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002192 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002193 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002194 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002195 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
002196 fda7                      	sbrc r26, 7 //check if result is negative
002197 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002198 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
002199 2fab                      	mov r26, r27 //move the arpeggio data into r26
00219a c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
00219b 91a0 2807                 	lds r26, pulse1_note //load the current note index
00219d 0fab                      	add r26, r27 //offset the note with the arpeggio data
00219e fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00219f c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0021a0 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0021a2 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0021a3 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0021a4 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0021a5 93a0 2807                 	sts pulse1_note, r26
0021a7 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
0021a8 fda7                      	sbrc r26, 7 //check if result is negative
0021a9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0021aa 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
0021ac e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
0021ad e0f0                      	ldi ZH, HIGH(note_table << 1)
0021ae 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0021af 0fea                      	add ZL, r26 //add offset
0021b0 1df2                      	adc ZH, zero
0021b1 91a5                      	lpm r26, Z+ //load bytes
0021b2 91b4                      	lpm r27, Z
0021b3 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
0021b5 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
0021b7 93a0 284c                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0021b9 93b0 284d                 	sts pulse1_fx_3xx_target+1, r27
0021bb c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
0021bc 91e0 2830                 	lds ZL, pulse1_pitch_macro
0021be 91f0 2831                 	lds ZH, pulse1_pitch_macro+1
0021c0 9630                      	adiw Z, 0
0021c1 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
0021c2 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
0021c3 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0021c4 1fff                      	rol ZH
0021c5 91a0 2832                 	lds r26, pulse1_pitch_macro_offset
0021c7 0fea                      	add ZL, r26
0021c8 1df2                      	adc ZH, zero
                                 
0021c9 91b0 2834                 	lds r27, pulse1_pitch_macro_release
0021cb 17ba                      	cp r27, r26
0021cc f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
0021cd 91a0 2833                 	lds r26, pulse1_pitch_macro_loop
0021cf 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0021d0 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0021d1 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
0021d2 95a3                      	inc r26 //increment the macro offset
0021d3 93a0 2832                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
0021d5 91b4                      	lpm r27, Z //load pitch data into r27
0021d6 38b0                      	cpi r27, 0x80 //check for macro end flag
0021d7 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
0021d8 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0021d9 93a0 2832                 	sts pulse1_pitch_macro_offset, r26
0021db 91b0 2834                 	lds r27, pulse1_pitch_macro_release
0021dd 3fbf                      	cpi r27, 0xFF
0021de f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
0021df 91b0 2833                 	lds r27, pulse1_pitch_macro_loop //load the loop index
0021e1 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0021e2 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0021e3 93b0 2832                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
0021e5 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
0021e6 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
0021e7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0021e8 937f                      	push r23
0021e9 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0021ea eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0021eb 0367                      	mulsu r22, r23
0021ec 917f                      	pop r23
0021ed 916f                      	pop r22
                                 
0021ee 9416                      	lsr r1 //shift out the fractional bits
0021ef 9407                      	ror r0
0021f0 9416                      	lsr r1
0021f1 9407                      	ror r0
0021f2 9416                      	lsr r1
0021f3 9407                      	ror r0
0021f4 9416                      	lsr r1
0021f5 9407                      	ror r0
0021f6 fe13                      	sbrs r1, 3 //check if result was a negative number
0021f7 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0021f8 efb0                      	ldi r27, 0xF0
0021f9 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0021fa 91a0 282e                 	lds r26, pulse1_total_pitch_offset
0021fc 91b0 282f                 	lds r27, pulse1_total_pitch_offset+1
0021fe 0e0a                      	add r0, r26
0021ff 1e1b                      	adc r1, r27
002200 9200 282e                 	sts pulse1_total_pitch_offset, r0
002202 9210 282f                 	sts pulse1_total_pitch_offset+1, r1
002204 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002206 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002208 0da0                      	add r26, r0 //offset the timer values
002209 1db1                      	adc r27, r1
                                 	
00220a 91c0 2844                 	lds r28, pulse1_fx_1xx_total
00220c 91d0 2845                 	lds r29, pulse1_fx_1xx_total+1
00220e 1bac                      	sub r26, r28
00220f 0bbd                      	sbc r27, r29
002210 91c0 2848                 	lds r28, pulse1_fx_2xx_total
002212 91d0 2849                 	lds r29, pulse1_fx_2xx_total+1
002214 0fac                      	add r26, r28
002215 1fbd                      	adc r27, r29
002216 91c0 285c                 	lds r28, pulse1_fx_Pxx_total
002218 91d0 285d                 	lds r29, pulse1_fx_Pxx_total+1
00221a 0fac                      	add r26, r28
00221b 1fbd                      	adc r27, r29
00221c 91c0 2862                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00221e 91d0 2863                 	lds r29, pulse1_fx_Qxy_total_offset+1
002220 1bac                      	sub r26, r28
002221 0bbd                      	sbc r27, r29
002222 91c0 2868                 	lds r28, pulse1_fx_Rxy_total_offset
002224 91d0 2869                 	lds r29, pulse1_fx_Rxy_total_offset+1
002226 0fac                      	add r26, r28
002227 1fbd                      	adc r27, r29
                                 
002228 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00222a 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
00222c 91e0 2836                 	lds ZL, pulse1_hi_pitch_macro
00222e 91f0 2837                 	lds ZH, pulse1_hi_pitch_macro+1
002230 9630                      	adiw Z, 0
002231 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
002232 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
002233 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002234 1fff                      	rol ZH
002235 91a0 2838                 	lds r26, pulse1_hi_pitch_macro_offset
002237 0fea                      	add ZL, r26
002238 1df2                      	adc ZH, zero
                                 
002239 91b0 283a                 	lds r27, pulse1_hi_pitch_macro_release
00223b 17ba                      	cp r27, r26
00223c f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00223d 91a0 2839                 	lds r26, pulse1_hi_pitch_macro_loop
00223f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002240 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002241 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
002242 95a3                      	inc r26 //increment the macro offset
002243 93a0 2838                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
002245 91b4                      	lpm r27, Z //load hi pitch data into r27
002246 38b0                      	cpi r27, 0x80 //check for macro end flag
002247 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
002248 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002249 93a0 2838                 	sts pulse1_hi_pitch_macro_offset, r26
00224b 91b0 283a                 	lds r27, pulse1_hi_pitch_macro_release
00224d 3fbf                      	cpi r27, 0xFF
00224e f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
00224f 91b0 2839                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
002251 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002252 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002253 93b0 2838                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
002255 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
002256 91b0 2835                 	lds r27, pulse1_total_hi_pitch_offset
002258 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
002259 91a0 2835                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
00225b 0fba                      	add r27, r26
00225c 93b0 2835                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
00225e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00225f 937f                      	push r23
002260 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002261 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002262 0367                      	mulsu r22, r23
002263 917f                      	pop r23
002264 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
002265 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002267 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002269 0da0                      	add r26, r0 //offset the timer values
00226a 1db1                      	adc r27, r1
00226b 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
00226d 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
00226f 91e0 283b                 	lds ZL, pulse1_duty_macro
002271 91f0 283c                 	lds ZH, pulse1_duty_macro+1
002273 9630                      	adiw Z, 0
002274 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
002275 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002276 1fff                      	rol ZH
002277 91a0 283d                 	lds r26, pulse1_duty_macro_offset
002279 0fea                      	add ZL, r26
00227a 1df2                      	adc ZH, zero
                                 
00227b 91b0 283f                 	lds r27, pulse1_duty_macro_release
00227d 17ba                      	cp r27, r26
00227e f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
00227f 91a0 283e                 	lds r26, pulse1_duty_macro_loop
002281 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002282 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002283 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
002284 95a3                      	inc r26 //increment the macro offset
002285 93a0 283d                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
002287 91b4                      	lpm r27, Z //load pitch data into r27
002288 3fbf                      	cpi r27, 0xFF //check for macro end flag
002289 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
00228a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00228b 93a0 283d                 	sts pulse1_duty_macro_offset, r26
00228d 91b0 283f                 	lds r27, pulse1_duty_macro_release
00228f 3fbf                      	cpi r27, 0xFF
002290 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
002291 91b0 283e                 	lds r27, pulse1_duty_macro_loop //load the loop index
002293 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002294 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002295 93b0 283d                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
002297 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
002298 e5ec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002299 e5f4                      	ldi ZH, HIGH(sequences << 1)
00229a 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
00229b 1df2                      	adc ZH, zero
                                 
00229c 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00229d 95b7                      	ror r27
00229e 95b7                      	ror r27
00229f 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0022a1 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0022a2 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0022a3 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0022a4 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0022a5 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0022a6 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0022a7 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0022a8 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0022a9 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0022ab 91e0 2842                 	lds ZL, pulse1_fx_1xx
0022ad 91f0 2843                 	lds ZH, pulse1_fx_1xx+1
0022af 9630                      	adiw Z, 0
0022b0 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0022b1 91a0 2844                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0022b3 91b0 2845                 	lds r27, pulse1_fx_1xx_total+1
0022b5 0fae                      	add r26, ZL //increase the total offset by the rate
0022b6 1fbf                      	adc r27, ZH
0022b7 93a0 2844                 	sts pulse1_fx_1xx_total, r26
0022b9 93b0 2845                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0022bb 91e0 2846                 	lds ZL, pulse1_fx_2xx
0022bd 91f0 2847                 	lds ZH, pulse1_fx_2xx+1
0022bf 9630                      	adiw Z, 0
0022c0 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0022c1 91a0 2848                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0022c3 91b0 2849                 	lds r27, pulse1_fx_2xx_total+1
0022c5 0fae                      	add r26, ZL //increase the total offset by the rate
0022c6 1fbf                      	adc r27, ZH
0022c7 93a0 2848                 	sts pulse1_fx_2xx_total, r26
0022c9 93b0 2849                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0022cb 91e0 284e                 	lds ZL, pulse1_fx_3xx_speed
0022cd 91f0 284f                 	lds ZH, pulse1_fx_3xx_speed+1
0022cf 9630                      	adiw Z, 0
0022d0 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0022d1 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0022d2 91a0 284a                 	lds r26, pulse1_fx_3xx_start
0022d4 91b0 284b                 	lds r27, pulse1_fx_3xx_start+1
0022d6 9610                      	adiw r26:r27, 0
0022d7 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0022d8 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0022d9 91c0 284c                 	lds r28, pulse1_fx_3xx_target
0022db 91d0 284d                 	lds r29, pulse1_fx_3xx_target+1
                                 
0022dd 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0022de 07bd                      	cpc r27, r29
0022df f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0022e0 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0022e1 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0022e2 9220 284a                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0022e4 9220 284b                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0022e6 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0022e7 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0022e8 0bdb                      	sbc r29, r27
0022e9 91a0 2850                 	lds r26, pulse1_fx_3xx_total_offset
0022eb 91b0 2851                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0022ed 0fae                      	add r26, ZL //add the speed to the total offset
0022ee 1fbf                      	adc r27, ZH
0022ef 1bca                      	sub r28, r26 //invert the total difference with the total offset
0022f0 0bdb                      	sbc r29, r27
0022f1 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0022f2 93a0 2850                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0022f4 93b0 2851                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0022f6 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0022f8 91b0 0a8d                 	lds r27, TCB0_CCMPH
0022fa 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0022fb 0bbd                      	sbc r27, r29
0022fc 93a0 0a8c                 	sts TCB0_CCMPL, r26
0022fe 93b0 0a8d                 	sts TCB0_CCMPH, r27
002300 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002301 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002302 0bbd                      	sbc r27, r29
002303 91c0 2850                 	lds r28, pulse1_fx_3xx_total_offset
002305 91d0 2851                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
002307 0fce                      	add r28, ZL //add the speed to the total offset
002308 1fdf                      	adc r29, ZH
002309 1bac                      	sub r26, r28 //invert the total difference with the total offset
00230a 0bbd                      	sbc r27, r29
00230b f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00230c 93c0 2850                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
00230e 93d0 2851                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
002310 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
002312 91d0 0a8d                 	lds r29, TCB0_CCMPH
002314 0fca                      	add r28, r26 //offset the current timer period with the total offset
002315 1fdb                      	adc r29, r27
002316 93c0 0a8c                 	sts TCB0_CCMPL, r28
002318 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
00231a 91a0 2852                 	lds r26, pulse1_fx_4xy_speed
00231c 15a2                      	cp r26, zero
00231d f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
00231e c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00231f 91b0 2853                 	lds r27, pulse1_fx_4xy_depth
002321 91c0 2854                 	lds r28, pulse1_fx_4xy_phase
002323 0fca                      	add r28, r26 //increase the phase by the speed
002324 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002325 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002326 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
002327 93c0 2854                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
002329 31c0                      	cpi r28, 16
00232a f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
00232b 32c0                      	cpi r28, 32
00232c f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
00232d 33c0                      	cpi r28, 48
00232e f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
00232f c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
002330 70cf                      	andi r28, 0x0F //mask for values 0-15
002331 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
002332 6fc0                      	ori r28, 0xF0
002333 95c0                      	com r28 //invert values 0-15
002334 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
002335 70cf                      	andi r28, 0x0F //mask for values 0-15
002336 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
002337 6fc0                      	ori r28, 0xF0
002338 95c0                      	com r28 //invert values 0-15
002339 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
00233a 95b2                      	swap r27 //multiply depth by 16
00233b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00233c e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00233d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00233e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00233f 1df2                      	adc ZH, zero
002340 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002341 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002342 937f                      	push r23
002343 2f6c                      	mov r22, r28 //store the vibrato value into r22
002344 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002345 9f67                      	mul r22, r23
002346 917f                      	pop r23
002347 916f                      	pop r22
                                 
002348 9416                      	lsr r1 //shift out the fractional bits
002349 9407                      	ror r0
00234a 9416                      	lsr r1
00234b 9407                      	ror r0
00234c 9416                      	lsr r1
00234d 9407                      	ror r0
00234e 9416                      	lsr r1
00234f 9407                      	ror r0
                                 	
002350 91a0 0a8c                 	lds r26, TCB0_CCMPL
002352 91b0 0a8d                 	lds r27, TCB0_CCMPH
002354 0da0                      	add r26, r0
002355 1db1                      	adc r27, r1
002356 93a0 0a8c                 	sts TCB0_CCMPL, r26
002358 93b0 0a8d                 	sts TCB0_CCMPH, r27
00235a c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
00235b 95b2                      	swap r27 //multiply depth by 16
00235c 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
00235d e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00235e e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00235f 0fec                      	add ZL, r28 //offset the table by the depth+phase
002360 1df2                      	adc ZH, zero
002361 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002362 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002363 937f                      	push r23
002364 2f6c                      	mov r22, r28 //store the vibrato value into r22
002365 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002366 9f67                      	mul r22, r23
002367 917f                      	pop r23
002368 916f                      	pop r22
                                 
002369 9416                      	lsr r1 //shift out the fractional bits
00236a 9407                      	ror r0
00236b 9416                      	lsr r1
00236c 9407                      	ror r0
00236d 9416                      	lsr r1
00236e 9407                      	ror r0
00236f 9416                      	lsr r1
002370 9407                      	ror r0
                                 
002371 91a0 0a8c                 	lds r26, TCB0_CCMPL
002373 91b0 0a8d                 	lds r27, TCB0_CCMPH
002375 19a0                      	sub r26, r0
002376 09b1                      	sbc r27, r1
002377 93a0 0a8c                 	sts TCB0_CCMPL, r26
002379 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
00237b 91a0 2855                 	lds r26, pulse1_fx_7xy_speed
00237d 15a2                      	cp r26, zero
00237e f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
00237f 91b0 2856                 	lds r27, pulse1_fx_7xy_depth
002381 91c0 2857                 	lds r28, pulse1_fx_7xy_phase
002383 0fca                      	add r28, r26 //increase the phase by the speed
002384 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002385 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002386 e0c0                      	ldi r28, 0x00
002387 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
002388 93c0 2857                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
00238a 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
00238b ffc4                      	sbrs r28, 4
00238c c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
00238d c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
00238e 70cf                      	andi r28, 0x0F //mask for values 0-15
00238f c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
002390 6fc0                      	ori r28, 0xF0
002391 95c0                      	com r28 //invert values 0-15
002392 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002393 95b2                      	swap r27 //multiply depth by 16
002394 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002395 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002396 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002397 0fec                      	add ZL, r28 //offset the table by the depth+phase
002398 1df2                      	adc ZH, zero
002399 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00239a 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
00239b 93c0 2858                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
00239d 91b0 2859                 	lds r27, pulse1_fx_Axy
00239f 15b2                      	cp r27, zero
0023a0 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0023a1 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0023a3 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0023a5 2fda                      	mov r29, r26 //copy fractional volume into r29
0023a6 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0023a7 95e2                      	swap r30
0023a8 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0023a9 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0023aa 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0023ab f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0023ac 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0023ad fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0023ae c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0023af 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0023b0 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0023b1 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0023b2 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0023b3 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0023b4 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0023b5 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0023b6 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0023b8 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0023b9 95a2                      	swap r26
0023ba 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0023bb 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0023bc 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0023be 91e0 285e                 	lds ZL, pulse1_fx_Qxy_target
0023c0 91f0 285f                 	lds ZH, pulse1_fx_Qxy_target+1
0023c2 9630                      	adiw Z, 0
0023c3 f139                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0023c4 91a0 2862                 	lds r26, pulse1_fx_Qxy_total_offset
0023c6 91b0 2863                 	lds r27, pulse1_fx_Qxy_total_offset+1
0023c8 91c0 0a8c                 	lds r28, TCB0_CCMPL
0023ca 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0023cc 1bec                      	sub ZL, r28 //calculate the difference to the target
0023cd 0bfd                      	sbc ZH, r29
0023ce f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0023cf f088                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0023d0 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0023d1 0bbf                      	sbc r27, ZH
                                 
0023d2 91c0 285c                 	lds r28, pulse1_fx_Pxx_total
0023d4 91d0 285d                 	lds r29, pulse1_fx_Pxx_total+1
                                 
0023d6 0fac                      	add r26, r28
0023d7 1fbd                      	adc r27, r29
                                 
0023d8 93a0 2862                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0023da 93b0 2863                 	sts pulse1_fx_Qxy_total_offset+1, r27
0023dc 9220 285e                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0023de 9220 285f                 	sts pulse1_fx_Qxy_target+1, zero
0023e0 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0023e1 91c0 2860                 	lds r28, pulse1_fx_Qxy_speed
0023e3 91d0 2861                 	lds r29, pulse1_fx_Qxy_speed+1
0023e5 0fac                      	add r26, r28 //increase the total offset by the speed
0023e6 1fbd                      	adc r27, r29
0023e7 93a0 2862                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0023e9 93b0 2863                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0023eb 91e0 2864                 	lds ZL, pulse1_fx_Rxy_target
0023ed 91f0 2865                 	lds ZH, pulse1_fx_Rxy_target+1
0023ef 9630                      	adiw Z, 0
0023f0 f139                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0023f1 91a0 2868                 	lds r26, pulse1_fx_Rxy_total_offset
0023f3 91b0 2869                 	lds r27, pulse1_fx_Rxy_total_offset+1
0023f5 91c0 0a8c                 	lds r28, TCB0_CCMPL
0023f7 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0023f9 1bce                      	sub r28, ZL //calculate the difference to the target
0023fa 0bdf                      	sbc r29, ZH
0023fb f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0023fc f088                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0023fd 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0023fe 0bbd                      	sbc r27, r29
                                 
0023ff 91c0 285c                 	lds r28, pulse1_fx_Pxx_total
002401 91d0 285d                 	lds r29, pulse1_fx_Pxx_total+1
                                 
002403 0fac                      	add r26, r28
002404 1fbd                      	adc r27, r29
                                 
002405 93a0 2868                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002407 93b0 2869                 	sts pulse1_fx_Rxy_total_offset+1, r27
002409 9220 2864                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
00240b 9220 2865                 	sts pulse1_fx_Rxy_target+1, zero
00240d c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
00240e 91c0 2866                 	lds r28, pulse1_fx_Rxy_speed
002410 91d0 2867                 	lds r29, pulse1_fx_Rxy_speed+1
002412 0fac                      	add r26, r28 //increase the total offset by the speed
002413 1fbd                      	adc r27, r29
002414 93a0 2868                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002416 93b0 2869                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
002418 91e0 2872                 	lds ZL, pulse2_volume_macro
00241a 91f0 2873                 	lds ZH, pulse2_volume_macro+1
00241c 9630                      	adiw Z, 0
00241d f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
00241e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00241f 1fff                      	rol ZH
002420 91a0 2874                 	lds r26, pulse2_volume_macro_offset
002422 0fea                      	add ZL, r26
002423 1df2                      	adc ZH, zero
                                 
002424 91b0 2876                 	lds r27, pulse2_volume_macro_release
002426 17ba                      	cp r27, r26
002427 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
002428 91a0 2875                 	lds r26, pulse2_volume_macro_loop
00242a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00242b f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00242c c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
00242d 95a3                      	inc r26 //increment the macro offset
00242e 93a0 2874                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
002430 91b4                      	lpm r27, Z //load volume data into r27
002431 3fbf                      	cpi r27, 0xFF //check for macro end flag
002432 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
002433 91b0 2876                 	lds r27, pulse2_volume_macro_release
002435 3fbf                      	cpi r27, 0xFF
002436 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
002437 91b0 2875                 	lds r27, pulse2_volume_macro_loop //load the loop index
002439 93b0 2874                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
00243b cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
00243c 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00243d 93a0 2874                 	sts pulse2_volume_macro_offset, r26
00243f cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
002440 efec                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002441 e5f4                      	ldi ZH, HIGH(volumes << 1)
002442 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002443 0feb                      	add ZL, r27 //add offset to the table
002444 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
002445 91b0 2808                 	lds r27, pulse2_param //load main volume
002447 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002448 91a0 28a7                 	lds r26, pulse2_fx_7xy_value
00244a 30a0                      	cpi r26, 0x00
00244b f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
00244c 0feb                      	add ZL, r27 //offset the volume table by the main volume
00244d 1df2                      	adc ZH, zero
00244e 91b4                      	lpm r27, Z
00244f 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002451 c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
002452 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002454 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002455 91a0 28a7                 	lds r26, pulse2_fx_7xy_value
002457 30a0                      	cpi r26, 0x00
002458 f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
002459 93b0 280e                 	sts pulse2_output_volume, r27
00245b c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
00245c 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00245d f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
00245e f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
00245f e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
002460 0feb                      	add ZL, r27 //offset the volume table by the main volume
002461 1df2                      	adc ZH, zero
002462 91b4                      	lpm r27, Z
002463 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002465 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
002466 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002467 0feb                      	add ZL, r27 //offset the volume table by the main volume
002468 1df2                      	adc ZH, zero
002469 91b4                      	lpm r27, Z
00246a 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00246c c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
00246d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00246e f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00246f f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
002470 93b0 280e                 	sts pulse2_output_volume, r27
002472 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
002473 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002474 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002476 91e0 2877                 	lds ZL, pulse2_arpeggio_macro
002478 91f0 2878                 	lds ZH, pulse2_arpeggio_macro+1
00247a 9630                      	adiw Z, 0
00247b f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00247c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00247d 1fff                      	rol ZH
00247e 91a0 2879                 	lds r26, pulse2_arpeggio_macro_offset
002480 0fea                      	add ZL, r26
002481 1df2                      	adc ZH, zero
                                 
002482 91b0 287b                 	lds r27, pulse2_arpeggio_macro_release
002484 17ba                      	cp r27, r26
002485 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002486 91a0 287a                 	lds r26, pulse2_arpeggio_macro_loop
002488 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002489 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00248a c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
00248b 95a3                      	inc r26 //increment the macro offset
00248c 93a0 2879                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
00248e 91b4                      	lpm r27, Z //load arpeggio data into r27
00248f 38b0                      	cpi r27, 0x80 //check for macro end flag
002490 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
002491 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
002492 50a1                      	subi r26, 1 //keep the offset at the end flag
002493 93a0 2879                 	sts pulse2_arpeggio_macro_offset, r26
002495 91b0 287c                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002497 30b1                      	cpi r27, 0x01
002498 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
002499 91b0 287b                 	lds r27, pulse2_arpeggio_macro_release
00249b 3fbf                      	cpi r27, 0xFF
00249c f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
00249d 91b0 287a                 	lds r27, pulse2_arpeggio_macro_loop
00249f 3fbf                      	cpi r27, 0xFF
0024a0 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0024a1 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
0024a2 91b0 287b                 	lds r27, pulse2_arpeggio_macro_release
0024a4 3fbf                      	cpi r27, 0xFF
0024a5 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
0024a6 91b0 287a                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
0024a8 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0024a9 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
0024aa 91c0 288f                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
0024ac 91d0 2890                 	lds r29, pulse2_fx_0xy_sequence+1
0024ae 9620                      	adiw r29:r28, 0
0024af f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0024b0 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0024b1 93a0 2879                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
0024b3 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
0024b4 93b0 2879                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
0024b6 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
0024b7 91c0 288f                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
0024b9 91d0 2890                 	lds r29, pulse2_fx_0xy_sequence+1
0024bb 9620                      	adiw r29:r28, 0 //check for 0xy effect
0024bc f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
0024bd 95d6                      	lsr r29
0024be 95c7                      	ror r28
0024bf 95d7                      	ror r29
0024c0 95c7                      	ror r28
0024c1 95d7                      	ror r29
0024c2 95c7                      	ror r28
0024c3 95d7                      	ror r29
0024c4 95c7                      	ror r28
0024c5 95d7                      	ror r29
0024c6 95d2                      	swap r29
                                 
0024c7 93c0 288f                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
0024c9 93d0 2890                 	sts pulse2_fx_0xy_sequence+1, r29
0024cb 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0024cc 91a0 280f                 	lds r26, pulse2_note //load the current note index
0024ce 0fac                      	add r26, r28 //add the note offset
0024cf c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0024d0 91a0 280f                 	lds r26, pulse2_note //load the current note index
0024d2 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0024d3 9220 287d                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0024d5 9220 287e                 	sts pulse2_total_pitch_offset+1, zero
0024d7 9220 2884                 	sts pulse2_total_hi_pitch_offset, zero
0024d9 91a0 287c                 	lds r26, pulse2_arpeggio_macro_mode
0024db 30a1                      	cpi r26, 0x01 //absolute mode
0024dc f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0024dd f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0024de c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0024df 91a0 280f                 	lds r26, pulse2_note //load the current note index
0024e1 0fab                      	add r26, r27 //offset the note with the arpeggio data
0024e2 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0024e3 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0024e4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0024e5 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0024e6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0024e7 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0024e8 fda7                      	sbrc r26, 7 //check if result is negative
0024e9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0024ea c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0024eb 2fab                      	mov r26, r27 //move the arpeggio data into r26
0024ec c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0024ed 91a0 280f                 	lds r26, pulse2_note //load the current note index
0024ef 0fab                      	add r26, r27 //offset the note with the arpeggio data
0024f0 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0024f1 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0024f2 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0024f4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0024f5 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0024f6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0024f7 93a0 280f                 	sts pulse2_note, r26
0024f9 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0024fa fda7                      	sbrc r26, 7 //check if result is negative
0024fb e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0024fc 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
0024fe e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
0024ff e0f0                      	ldi ZH, HIGH(note_table << 1)
002500 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002501 0fea                      	add ZL, r26 //add offset
002502 1df2                      	adc ZH, zero
002503 91a5                      	lpm r26, Z+ //load bytes
002504 91b4                      	lpm r27, Z
002505 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
002507 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
002509 93a0 289b                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00250b 93b0 289c                 	sts pulse2_fx_3xx_target+1, r27
00250d c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
00250e 91e0 287f                 	lds ZL, pulse2_pitch_macro
002510 91f0 2880                 	lds ZH, pulse2_pitch_macro+1
002512 9630                      	adiw Z, 0
002513 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002514 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002515 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002516 1fff                      	rol ZH
002517 91a0 2881                 	lds r26, pulse2_pitch_macro_offset
002519 0fea                      	add ZL, r26
00251a 1df2                      	adc ZH, zero
                                 
00251b 91b0 2883                 	lds r27, pulse2_pitch_macro_release
00251d 17ba                      	cp r27, r26
00251e f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
00251f 91a0 2882                 	lds r26, pulse2_pitch_macro_loop
002521 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002522 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002523 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002524 95a3                      	inc r26 //increment the macro offset
002525 93a0 2881                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002527 91b4                      	lpm r27, Z //load pitch data into r27
002528 38b0                      	cpi r27, 0x80 //check for macro end flag
002529 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
00252a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00252b 93a0 2881                 	sts pulse2_pitch_macro_offset, r26
00252d 91b0 2883                 	lds r27, pulse2_pitch_macro_release
00252f 3fbf                      	cpi r27, 0xFF
002530 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002531 91b0 2882                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002533 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002534 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002535 93b0 2881                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002537 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002538 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
002539 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00253a 937f                      	push r23
00253b 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00253c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00253d 0367                      	mulsu r22, r23
00253e 917f                      	pop r23
00253f 916f                      	pop r22
                                 
002540 9416                      	lsr r1 //shift out the fractional bits
002541 9407                      	ror r0
002542 9416                      	lsr r1
002543 9407                      	ror r0
002544 9416                      	lsr r1
002545 9407                      	ror r0
002546 9416                      	lsr r1
002547 9407                      	ror r0
002548 fe13                      	sbrs r1, 3 //check if result was a negative number
002549 c002                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
00254a efb0                      	ldi r27, 0xF0
00254b 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
00254c 91a0 287d                 	lds r26, pulse2_total_pitch_offset
00254e 91b0 287e                 	lds r27, pulse2_total_pitch_offset+1
002550 0e0a                      	add r0, r26
002551 1e1b                      	adc r1, r27
002552 9200 287d                 	sts pulse2_total_pitch_offset, r0
002554 9210 287e                 	sts pulse2_total_pitch_offset+1, r1
002556 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002558 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
00255a 0da0                      	add r26, r0 //offset the timer values
00255b 1db1                      	adc r27, r1
                                 	
00255c 91c0 2893                 	lds r28, pulse2_fx_1xx_total
00255e 91d0 2894                 	lds r29, pulse2_fx_1xx_total+1
002560 1bac                      	sub r26, r28
002561 0bbd                      	sbc r27, r29
002562 91c0 2897                 	lds r28, pulse2_fx_2xx_total
002564 91d0 2898                 	lds r29, pulse2_fx_2xx_total+1
002566 0fac                      	add r26, r28
002567 1fbd                      	adc r27, r29
002568 91c0 28ab                 	lds r28, pulse2_fx_Pxx_total
00256a 91d0 28ac                 	lds r29, pulse2_fx_Pxx_total+1
00256c 0fac                      	add r26, r28
00256d 1fbd                      	adc r27, r29
00256e 91c0 28b1                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002570 91d0 28b2                 	lds r29, pulse2_fx_Qxy_total_offset+1
002572 1bac                      	sub r26, r28
002573 0bbd                      	sbc r27, r29
002574 91c0 28b7                 	lds r28, pulse2_fx_Rxy_total_offset
002576 91d0 28b8                 	lds r29, pulse2_fx_Rxy_total_offset+1
002578 0fac                      	add r26, r28
002579 1fbd                      	adc r27, r29
                                 
00257a 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
00257c 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
00257e 91e0 2885                 	lds ZL, pulse2_hi_pitch_macro
002580 91f0 2886                 	lds ZH, pulse2_hi_pitch_macro+1
002582 9630                      	adiw Z, 0
002583 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002584 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002585 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002586 1fff                      	rol ZH
002587 91a0 2887                 	lds r26, pulse2_hi_pitch_macro_offset
002589 0fea                      	add ZL, r26
00258a 1df2                      	adc ZH, zero
                                 
00258b 91b0 2889                 	lds r27, pulse2_hi_pitch_macro_release
00258d 17ba                      	cp r27, r26
00258e f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00258f 91a0 2888                 	lds r26, pulse2_hi_pitch_macro_loop
002591 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002592 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002593 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002594 95a3                      	inc r26 //increment the macro offset
002595 93a0 2887                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002597 91b4                      	lpm r27, Z //load hi pitch data into r27
002598 38b0                      	cpi r27, 0x80 //check for macro end flag
002599 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
00259a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00259b 93a0 2887                 	sts pulse2_hi_pitch_macro_offset, r26
00259d 91b0 2889                 	lds r27, pulse2_hi_pitch_macro_release
00259f 3fbf                      	cpi r27, 0xFF
0025a0 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
0025a1 91b0 2888                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
0025a3 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0025a4 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0025a5 93b0 2887                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
0025a7 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
0025a8 91b0 2884                 	lds r27, pulse2_total_hi_pitch_offset
0025aa c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
0025ab 91a0 2884                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
0025ad 0fba                      	add r27, r26
0025ae 93b0 2884                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
0025b0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025b1 937f                      	push r23
0025b2 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0025b3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025b4 0367                      	mulsu r22, r23
0025b5 917f                      	pop r23
0025b6 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
0025b7 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0025b9 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0025bb 0da0                      	add r26, r0 //offset the timer values
0025bc 1db1                      	adc r27, r1
0025bd 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0025bf 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
0025c1 91e0 288a                 	lds ZL, pulse2_duty_macro
0025c3 91f0 288b                 	lds ZH, pulse2_duty_macro+1
0025c5 9630                      	adiw Z, 0
0025c6 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
0025c7 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0025c8 1fff                      	rol ZH
0025c9 91a0 288c                 	lds r26, pulse2_duty_macro_offset
0025cb 0fea                      	add ZL, r26
0025cc 1df2                      	adc ZH, zero
                                 
0025cd 91b0 288e                 	lds r27, pulse2_duty_macro_release
0025cf 17ba                      	cp r27, r26
0025d0 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
0025d1 91a0 288d                 	lds r26, pulse2_duty_macro_loop
0025d3 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025d4 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025d5 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
0025d6 95a3                      	inc r26 //increment the macro offset
0025d7 93a0 288c                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
0025d9 91b4                      	lpm r27, Z //load pitch data into r27
0025da 3fbf                      	cpi r27, 0xFF //check for macro end flag
0025db f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
0025dc 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0025dd 93a0 288c                 	sts pulse2_duty_macro_offset, r26
0025df 91b0 288e                 	lds r27, pulse2_duty_macro_release
0025e1 3fbf                      	cpi r27, 0xFF
0025e2 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
0025e3 91b0 288d                 	lds r27, pulse2_duty_macro_loop //load the loop index
0025e5 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0025e6 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0025e7 93b0 288c                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
0025e9 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
0025ea e5ec                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0025eb e5f4                      	ldi ZH, HIGH(sequences << 1)
0025ec 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0025ed 1df2                      	adc ZH, zero
                                 
0025ee 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
0025ef 95b7                      	ror r27
0025f0 95b7                      	ror r27
0025f1 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
0025f3 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
0025f4 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0025f5 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0025f6 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
0025f7 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
0025f8 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
0025f9 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0025fa 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0025fb 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
0025fd 91e0 2891                 	lds ZL, pulse2_fx_1xx
0025ff 91f0 2892                 	lds ZH, pulse2_fx_1xx+1
002601 9630                      	adiw Z, 0
002602 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002603 91a0 2893                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002605 91b0 2894                 	lds r27, pulse2_fx_1xx_total+1
002607 0fae                      	add r26, ZL //increase the total offset by the rate
002608 1fbf                      	adc r27, ZH
002609 93a0 2893                 	sts pulse2_fx_1xx_total, r26
00260b 93b0 2894                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
00260d 91e0 2895                 	lds ZL, pulse2_fx_2xx
00260f 91f0 2896                 	lds ZH, pulse2_fx_2xx+1
002611 9630                      	adiw Z, 0
002612 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002613 91a0 2897                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002615 91b0 2898                 	lds r27, pulse2_fx_2xx_total+1
002617 0fae                      	add r26, ZL //increase the total offset by the rate
002618 1fbf                      	adc r27, ZH
002619 93a0 2897                 	sts pulse2_fx_2xx_total, r26
00261b 93b0 2898                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
00261d 91e0 289d                 	lds ZL, pulse2_fx_3xx_speed
00261f 91f0 289e                 	lds ZH, pulse2_fx_3xx_speed+1
002621 9630                      	adiw Z, 0
002622 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002623 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002624 91a0 2899                 	lds r26, pulse2_fx_3xx_start
002626 91b0 289a                 	lds r27, pulse2_fx_3xx_start+1
002628 9610                      	adiw r26:r27, 0
002629 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
00262a c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
00262b 91c0 289b                 	lds r28, pulse2_fx_3xx_target
00262d 91d0 289c                 	lds r29, pulse2_fx_3xx_target+1
                                 
00262f 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002630 07bd                      	cpc r27, r29
002631 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002632 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002633 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002634 9220 2899                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002636 9220 289a                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002638 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002639 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
00263a 0bdb                      	sbc r29, r27
00263b 91a0 289f                 	lds r26, pulse2_fx_3xx_total_offset
00263d 91b0 28a0                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
00263f 0fae                      	add r26, ZL //add the speed to the total offset
002640 1fbf                      	adc r27, ZH
002641 1bca                      	sub r28, r26 //invert the total difference with the total offset
002642 0bdb                      	sbc r29, r27
002643 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002644 93a0 289f                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002646 93b0 28a0                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002648 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
00264a 91b0 0a9d                 	lds r27, TCB1_CCMPH
00264c 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00264d 0bbd                      	sbc r27, r29
00264e 93a0 0a9c                 	sts TCB1_CCMPL, r26
002650 93b0 0a9d                 	sts TCB1_CCMPH, r27
002652 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002653 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002654 0bbd                      	sbc r27, r29
002655 91c0 289f                 	lds r28, pulse2_fx_3xx_total_offset
002657 91d0 28a0                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002659 0fce                      	add r28, ZL //add the speed to the total offset
00265a 1fdf                      	adc r29, ZH
00265b 1bac                      	sub r26, r28 //invert the total difference with the total offset
00265c 0bbd                      	sbc r27, r29
00265d f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00265e 93c0 289f                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002660 93d0 28a0                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002662 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002664 91d0 0a9d                 	lds r29, TCB1_CCMPH
002666 0fca                      	add r28, r26 //offset the current timer period with the total offset
002667 1fdb                      	adc r29, r27
002668 93c0 0a9c                 	sts TCB1_CCMPL, r28
00266a 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
00266c 91a0 28a1                 	lds r26, pulse2_fx_4xy_speed
00266e 15a2                      	cp r26, zero
00266f f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002670 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002671 91b0 28a2                 	lds r27, pulse2_fx_4xy_depth
002673 91c0 28a3                 	lds r28, pulse2_fx_4xy_phase
002675 0fca                      	add r28, r26 //increase the phase by the speed
002676 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002677 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002678 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002679 93c0 28a3                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
00267b 31c0                      	cpi r28, 16
00267c f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
00267d 32c0                      	cpi r28, 32
00267e f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
00267f 33c0                      	cpi r28, 48
002680 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002681 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002682 70cf                      	andi r28, 0x0F //mask for values 0-15
002683 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002684 6fc0                      	ori r28, 0xF0
002685 95c0                      	com r28 //invert values 0-15
002686 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002687 70cf                      	andi r28, 0x0F //mask for values 0-15
002688 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002689 6fc0                      	ori r28, 0xF0
00268a 95c0                      	com r28 //invert values 0-15
00268b c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
00268c 95b2                      	swap r27 //multiply depth by 16
00268d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00268e e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00268f e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002690 0fec                      	add ZL, r28 //offset the table by the depth+phase
002691 1df2                      	adc ZH, zero
002692 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002693 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002694 937f                      	push r23
002695 2f6c                      	mov r22, r28 //store the vibrato value into r22
002696 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002697 9f67                      	mul r22, r23
002698 917f                      	pop r23
002699 916f                      	pop r22
                                 
00269a 9416                      	lsr r1 //shift out the fractional bits
00269b 9407                      	ror r0
00269c 9416                      	lsr r1
00269d 9407                      	ror r0
00269e 9416                      	lsr r1
00269f 9407                      	ror r0
0026a0 9416                      	lsr r1
0026a1 9407                      	ror r0
                                 	
0026a2 91a0 0a9c                 	lds r26, TCB1_CCMPL
0026a4 91b0 0a9d                 	lds r27, TCB1_CCMPH
0026a6 0da0                      	add r26, r0
0026a7 1db1                      	adc r27, r1
0026a8 93a0 0a9c                 	sts TCB1_CCMPL, r26
0026aa 93b0 0a9d                 	sts TCB1_CCMPH, r27
0026ac c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
0026ad 95b2                      	swap r27 //multiply depth by 16
0026ae 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0026af e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0026b0 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0026b1 0fec                      	add ZL, r28 //offset the table by the depth+phase
0026b2 1df2                      	adc ZH, zero
0026b3 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0026b4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026b5 937f                      	push r23
0026b6 2f6c                      	mov r22, r28 //store the vibrato value into r22
0026b7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026b8 9f67                      	mul r22, r23
0026b9 917f                      	pop r23
0026ba 916f                      	pop r22
                                 
0026bb 9416                      	lsr r1 //shift out the fractional bits
0026bc 9407                      	ror r0
0026bd 9416                      	lsr r1
0026be 9407                      	ror r0
0026bf 9416                      	lsr r1
0026c0 9407                      	ror r0
0026c1 9416                      	lsr r1
0026c2 9407                      	ror r0
                                 
0026c3 91a0 0a9c                 	lds r26, TCB1_CCMPL
0026c5 91b0 0a9d                 	lds r27, TCB1_CCMPH
0026c7 19a0                      	sub r26, r0
0026c8 09b1                      	sbc r27, r1
0026c9 93a0 0a9c                 	sts TCB1_CCMPL, r26
0026cb 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
0026cd 91a0 28a4                 	lds r26, pulse2_fx_7xy_speed
0026cf 15a2                      	cp r26, zero
0026d0 f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0026d1 91b0 28a5                 	lds r27, pulse2_fx_7xy_depth
0026d3 91c0 28a6                 	lds r28, pulse2_fx_7xy_phase
0026d5 0fca                      	add r28, r26 //increase the phase by the speed
0026d6 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0026d7 f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0026d8 e0c0                      	ldi r28, 0x00
0026d9 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
0026da 93c0 28a6                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
0026dc 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0026dd ffc4                      	sbrs r28, 4
0026de c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
0026df c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
0026e0 70cf                      	andi r28, 0x0F //mask for values 0-15
0026e1 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
0026e2 6fc0                      	ori r28, 0xF0
0026e3 95c0                      	com r28 //invert values 0-15
0026e4 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
0026e5 95b2                      	swap r27 //multiply depth by 16
0026e6 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0026e7 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0026e8 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0026e9 0fec                      	add ZL, r28 //offset the table by the depth+phase
0026ea 1df2                      	adc ZH, zero
0026eb 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0026ec 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0026ed 93c0 28a7                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
0026ef 91b0 28a8                 	lds r27, pulse2_fx_Axy
0026f1 15b2                      	cp r27, zero
0026f2 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0026f3 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
0026f5 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
0026f7 2fda                      	mov r29, r26 //copy fractional volume into r29
0026f8 2fec                      	mov r30, r28 //copy the pulse2_param into r30
0026f9 95e2                      	swap r30
0026fa 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0026fb 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0026fc 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0026fd f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
0026fe 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
0026ff fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002700 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002701 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002702 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002703 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002704 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002705 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002706 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002707 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002708 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
00270a 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
00270b 95a2                      	swap r26
00270c 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
00270d 2bca                      	or r28, r26 //store the new volume back into pulse2_param
00270e 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002710 91e0 28ad                 	lds ZL, pulse2_fx_Qxy_target
002712 91f0 28ae                 	lds ZH, pulse2_fx_Qxy_target+1
002714 9630                      	adiw Z, 0
002715 f139                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002716 91a0 28b1                 	lds r26, pulse2_fx_Qxy_total_offset
002718 91b0 28b2                 	lds r27, pulse2_fx_Qxy_total_offset+1
00271a 91c0 0a9c                 	lds r28, TCB1_CCMPL
00271c 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
00271e 1bec                      	sub ZL, r28 //calculate the difference to the target
00271f 0bfd                      	sbc ZH, r29
002720 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002721 f088                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002722 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
002723 0bbf                      	sbc r27, ZH
                                 
002724 91c0 28ab                 	lds r28, pulse2_fx_Pxx_total
002726 91d0 28ac                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002728 0fac                      	add r26, r28
002729 1fbd                      	adc r27, r29
                                 
00272a 93a0 28b1                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
00272c 93b0 28b2                 	sts pulse2_fx_Qxy_total_offset+1, r27
00272e 9220 28ad                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002730 9220 28ae                 	sts pulse2_fx_Qxy_target+1, zero
002732 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002733 91c0 28af                 	lds r28, pulse2_fx_Qxy_speed
002735 91d0 28b0                 	lds r29, pulse2_fx_Qxy_speed+1
002737 0fac                      	add r26, r28 //increase the total offset by the speed
002738 1fbd                      	adc r27, r29
002739 93a0 28b1                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
00273b 93b0 28b2                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
00273d 91e0 28b3                 	lds ZL, pulse2_fx_Rxy_target
00273f 91f0 28b4                 	lds ZH, pulse2_fx_Rxy_target+1
002741 9630                      	adiw Z, 0
002742 f139                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002743 91a0 28b7                 	lds r26, pulse2_fx_Rxy_total_offset
002745 91b0 28b8                 	lds r27, pulse2_fx_Rxy_total_offset+1
002747 91c0 0a9c                 	lds r28, TCB1_CCMPL
002749 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
00274b 1bce                      	sub r28, ZL //calculate the difference to the target
00274c 0bdf                      	sbc r29, ZH
00274d f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
00274e f088                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
00274f 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002750 0bbd                      	sbc r27, r29
                                 
002751 91c0 28ab                 	lds r28, pulse2_fx_Pxx_total
002753 91d0 28ac                 	lds r29, pulse2_fx_Pxx_total+1
                                 
002755 0fac                      	add r26, r28
002756 1fbd                      	adc r27, r29
                                 
002757 93a0 28b7                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002759 93b0 28b8                 	sts pulse2_fx_Rxy_total_offset+1, r27
00275b 9220 28b3                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
00275d 9220 28b4                 	sts pulse2_fx_Rxy_target+1, zero
00275f c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002760 91c0 28b5                 	lds r28, pulse2_fx_Rxy_speed
002762 91d0 28b6                 	lds r29, pulse2_fx_Rxy_speed+1
002764 0fac                      	add r26, r28 //increase the total offset by the speed
002765 1fbd                      	adc r27, r29
002766 93a0 28b7                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002768 93b0 28b8                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
00276a 91e0 28c1                 	lds ZL, triangle_volume_macro
00276c 91f0 28c2                 	lds ZH, triangle_volume_macro+1
00276e 9630                      	adiw Z, 0
00276f f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002770 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002771 1fff                      	rol ZH
002772 91a0 28c3                 	lds r26, triangle_volume_macro_offset
002774 0fea                      	add ZL, r26
002775 1df2                      	adc ZH, zero
                                 
002776 91b0 28c5                 	lds r27, triangle_volume_macro_release
002778 17ba                      	cp r27, r26
002779 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
00277a 91a0 28c4                 	lds r26, triangle_volume_macro_loop
00277c 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00277d f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00277e c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
00277f 95a3                      	inc r26 //increment the macro offset
002780 93a0 28c3                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002782 91b4                      	lpm r27, Z //load volume data into r27
002783 3fbf                      	cpi r27, 0xFF //check for macro end flag
002784 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002785 91b0 28c5                 	lds r27, triangle_volume_macro_release
002787 3fbf                      	cpi r27, 0xFF
002788 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002789 91b0 28c4                 	lds r27, triangle_volume_macro_loop //load the loop index
00278b 93b0 28c3                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
00278d cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
00278e 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00278f 93a0 28c3                 	sts triangle_volume_macro_offset, r26
002791 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002792 15b2                      	cp r27, zero
002793 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002794 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002796 30b1                      	cpi r27, TCB_CAPT_bm
002797 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002798 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002799 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00279b c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
00279c 9220 0aa5                 	sts TCB2_INTCTRL, zero
00279e 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
0027a0 9220 0aad                 	sts TCB2_CCMPH, zero
0027a2 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0027a3 91e0 28c6                 	lds ZL, triangle_arpeggio_macro
0027a5 91f0 28c7                 	lds ZH, triangle_arpeggio_macro+1
0027a7 9630                      	adiw Z, 0
0027a8 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0027a9 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0027aa 1fff                      	rol ZH
0027ab 91a0 28c8                 	lds r26, triangle_arpeggio_macro_offset
0027ad 0fea                      	add ZL, r26
0027ae 1df2                      	adc ZH, zero
                                 
0027af 91b0 28ca                 	lds r27, triangle_arpeggio_macro_release
0027b1 17ba                      	cp r27, r26
0027b2 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0027b3 91a0 28c9                 	lds r26, triangle_arpeggio_macro_loop
0027b5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0027b6 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0027b7 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
0027b8 95a3                      	inc r26 //increment the macro offset
0027b9 93a0 28c8                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
0027bb 91b4                      	lpm r27, Z //load arpeggio data into r27
0027bc 38b0                      	cpi r27, 0x80 //check for macro end flag
0027bd f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
0027be c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
0027bf 50a1                      	subi r26, 1 //keep the offset at the end flag
0027c0 93a0 28c8                 	sts triangle_arpeggio_macro_offset, r26
0027c2 91b0 28cb                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0027c4 30b1                      	cpi r27, 0x01
0027c5 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
0027c6 91b0 28ca                 	lds r27, triangle_arpeggio_macro_release
0027c8 3fbf                      	cpi r27, 0xFF
0027c9 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
0027ca 91b0 28c9                 	lds r27, triangle_arpeggio_macro_loop
0027cc 3fbf                      	cpi r27, 0xFF
0027cd f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0027ce c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
0027cf 91b0 28ca                 	lds r27, triangle_arpeggio_macro_release
0027d1 3fbf                      	cpi r27, 0xFF
0027d2 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
0027d3 91b0 28c9                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
0027d5 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0027d6 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
0027d7 91c0 28de                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
0027d9 91d0 28df                 	lds r29, triangle_fx_0xy_sequence+1
0027db 9620                      	adiw r29:r28, 0
0027dc f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0027dd 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0027de 93a0 28c8                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
0027e0 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
0027e1 93b0 28c8                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
0027e3 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
0027e4 91c0 28de                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
0027e6 91d0 28df                 	lds r29, triangle_fx_0xy_sequence+1
0027e8 9620                      	adiw r29:r28, 0 //check for 0xy effect
0027e9 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_xy:
0027ea 95d6                      	lsr r29
0027eb 95c7                      	ror r28
0027ec 95d7                      	ror r29
0027ed 95c7                      	ror r28
0027ee 95d7                      	ror r29
0027ef 95c7                      	ror r28
0027f0 95d7                      	ror r29
0027f1 95c7                      	ror r28
0027f2 95d7                      	ror r29
0027f3 95d2                      	swap r29
                                 
0027f4 93c0 28de                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
0027f6 93d0 28df                 	sts triangle_fx_0xy_sequence+1, r29
0027f8 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0027f9 91a0 2812                 	lds r26, triangle_note //load the current note index
0027fb 0fac                      	add r26, r28 //add the note offset
0027fc c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0027fd 91a0 2812                 	lds r26, triangle_note //load the current note index
0027ff c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002800 9220 28cc                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002802 9220 28cd                 	sts triangle_total_pitch_offset+1, zero
002804 9220 28d3                 	sts triangle_total_hi_pitch_offset, zero
002806 91a0 28cb                 	lds r26, triangle_arpeggio_macro_mode
002808 30a1                      	cpi r26, 0x01 //absolute mode
002809 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
00280a f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
00280b c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
00280c 91a0 2812                 	lds r26, triangle_note //load the current note index
00280e 0fab                      	add r26, r27 //offset the note with the arpeggio data
00280f fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002810 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002811 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002812 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002813 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002814 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002815 fda7                      	sbrc r26, 7 //check if result is negative
002816 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002817 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002818 2fab                      	mov r26, r27 //move the arpeggio data into r26
002819 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
00281a 91a0 2812                 	lds r26, triangle_note //load the current note index
00281c 0fab                      	add r26, r27 //offset the note with the arpeggio data
00281d fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00281e c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
00281f 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002821 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002822 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002823 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002824 93a0 2812                 	sts triangle_note, r26
002826 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002827 fda7                      	sbrc r26, 7 //check if result is negative
002828 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002829 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
00282b e6e8                      	ldi ZL, LOW(note_table << 1) //load in note table
00282c e0f0                      	ldi ZH, HIGH(note_table << 1)
00282d 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00282e 0fea                      	add ZL, r26 //add offset
00282f 1df2                      	adc ZH, zero
002830 91a5                      	lpm r26, Z+ //load bytes
002831 91b4                      	lpm r27, Z
002832 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002834 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002836 93a0 28ea                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002838 93b0 28eb                 	sts triangle_fx_3xx_target+1, r27
00283a c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
00283b 91e0 28ce                 	lds ZL, triangle_pitch_macro
00283d 91f0 28cf                 	lds ZH, triangle_pitch_macro+1
00283f 9630                      	adiw Z, 0
002840 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002841 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002842 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002843 1fff                      	rol ZH
002844 91a0 28d0                 	lds r26, triangle_pitch_macro_offset
002846 0fea                      	add ZL, r26
002847 1df2                      	adc ZH, zero
                                 
002848 91b0 28d2                 	lds r27, triangle_pitch_macro_release
00284a 17ba                      	cp r27, r26
00284b f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
00284c 91a0 28d1                 	lds r26, triangle_pitch_macro_loop
00284e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00284f f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002850 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002851 95a3                      	inc r26 //increment the macro offset
002852 93a0 28d0                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002854 91b4                      	lpm r27, Z //load pitch data into r27
002855 38b0                      	cpi r27, 0x80 //check for macro end flag
002856 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002857 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002858 93a0 28d0                 	sts triangle_pitch_macro_offset, r26
00285a 91b0 28d2                 	lds r27, triangle_pitch_macro_release
00285c 3fbf                      	cpi r27, 0xFF
00285d f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
00285e 91b0 28d1                 	lds r27, triangle_pitch_macro_loop //load the loop index
002860 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002861 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002862 93b0 28d0                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002864 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002865 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002866 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002867 937f                      	push r23
002868 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002869 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00286a 0367                      	mulsu r22, r23
00286b 917f                      	pop r23
00286c 916f                      	pop r22
                                 
00286d 9416                      	lsr r1 //shift out the fractional bits
00286e 9407                      	ror r0
00286f 9416                      	lsr r1
002870 9407                      	ror r0
002871 9416                      	lsr r1
002872 9407                      	ror r0
002873 9416                      	lsr r1
002874 9407                      	ror r0
002875 fe13                      	sbrs r1, 3 //check if result was a negative number
002876 c002                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002877 efb0                      	ldi r27, 0xF0
002878 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002879 91a0 28cc                 	lds r26, triangle_total_pitch_offset
00287b 91b0 28cd                 	lds r27, triangle_total_pitch_offset+1
00287d 0e0a                      	add r0, r26
00287e 1e1b                      	adc r1, r27
00287f 9200 28cc                 	sts triangle_total_pitch_offset, r0
002881 9210 28cd                 	sts triangle_total_pitch_offset+1, r1
002883 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002885 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002887 0da0                      	add r26, r0 //offset the timer values
002888 1db1                      	adc r27, r1
                                 	
002889 91c0 28e2                 	lds r28, triangle_fx_1xx_total
00288b 91d0 28e3                 	lds r29, triangle_fx_1xx_total+1
00288d 1bac                      	sub r26, r28
00288e 0bbd                      	sbc r27, r29
00288f 91c0 28e6                 	lds r28, triangle_fx_2xx_total
002891 91d0 28e7                 	lds r29, triangle_fx_2xx_total+1
002893 0fac                      	add r26, r28
002894 1fbd                      	adc r27, r29
002895 91c0 28f5                 	lds r28, triangle_fx_Pxx_total
002897 91d0 28f6                 	lds r29, triangle_fx_Pxx_total+1
002899 0fac                      	add r26, r28
00289a 1fbd                      	adc r27, r29
00289b 91c0 28fb                 	lds r28, triangle_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00289d 91d0 28fc                 	lds r29, triangle_fx_Qxy_total_offset+1
00289f 1bac                      	sub r26, r28
0028a0 0bbd                      	sbc r27, r29
0028a1 91c0 2901                 	lds r28, triangle_fx_Rxy_total_offset
0028a3 91d0 2902                 	lds r29, triangle_fx_Rxy_total_offset+1
0028a5 0fac                      	add r26, r28
0028a6 1fbd                      	adc r27, r29
                                 
0028a7 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
0028a9 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
0028ab 91e0 28d4                 	lds ZL, triangle_hi_pitch_macro
0028ad 91f0 28d5                 	lds ZH, triangle_hi_pitch_macro+1
0028af 9630                      	adiw Z, 0
0028b0 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
0028b1 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
0028b2 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0028b3 1fff                      	rol ZH
0028b4 91a0 28d6                 	lds r26, triangle_hi_pitch_macro_offset
0028b6 0fea                      	add ZL, r26
0028b7 1df2                      	adc ZH, zero
                                 
0028b8 91b0 28d8                 	lds r27, triangle_hi_pitch_macro_release
0028ba 17ba                      	cp r27, r26
0028bb f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0028bc 91a0 28d7                 	lds r26, triangle_hi_pitch_macro_loop
0028be 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0028bf f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0028c0 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
0028c1 95a3                      	inc r26 //increment the macro offset
0028c2 93a0 28d6                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
0028c4 91b4                      	lpm r27, Z //load hi pitch data into r27
0028c5 38b0                      	cpi r27, 0x80 //check for macro end flag
0028c6 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
0028c7 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0028c8 93a0 28d6                 	sts triangle_hi_pitch_macro_offset, r26
0028ca 91b0 28d8                 	lds r27, triangle_hi_pitch_macro_release
0028cc 3fbf                      	cpi r27, 0xFF
0028cd f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
0028ce 91b0 28d7                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
0028d0 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0028d1 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0028d2 93b0 28d6                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
0028d4 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
0028d5 91b0 28d3                 	lds r27, triangle_total_hi_pitch_offset
0028d7 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
0028d8 91a0 28d3                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
0028da 0fba                      	add r27, r26
0028db 93b0 28d3                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
0028dd 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028de 937f                      	push r23
0028df 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0028e0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028e1 0367                      	mulsu r22, r23
0028e2 917f                      	pop r23
0028e3 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
0028e4 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
0028e6 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
0028e8 0da0                      	add r26, r0 //offset the timer values
0028e9 1db1                      	adc r27, r1
0028ea 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
0028ec 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
0028ee 91e0 28e0                 	lds ZL, triangle_fx_1xx
0028f0 91f0 28e1                 	lds ZH, triangle_fx_1xx+1
0028f2 9630                      	adiw Z, 0
0028f3 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
0028f4 91a0 28e2                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
0028f6 91b0 28e3                 	lds r27, triangle_fx_1xx_total+1
0028f8 0fae                      	add r26, ZL //increase the total offset by the rate
0028f9 1fbf                      	adc r27, ZH
0028fa 93a0 28e2                 	sts triangle_fx_1xx_total, r26
0028fc 93b0 28e3                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
0028fe 91e0 28e4                 	lds ZL, triangle_fx_2xx
002900 91f0 28e5                 	lds ZH, triangle_fx_2xx+1
002902 9630                      	adiw Z, 0
002903 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002904 91a0 28e6                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002906 91b0 28e7                 	lds r27, triangle_fx_2xx_total+1
002908 0fae                      	add r26, ZL //increase the total offset by the rate
002909 1fbf                      	adc r27, ZH
00290a 93a0 28e6                 	sts triangle_fx_2xx_total, r26
00290c 93b0 28e7                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
00290e 91e0 28ec                 	lds ZL, triangle_fx_3xx_speed
002910 91f0 28ed                 	lds ZH, triangle_fx_3xx_speed+1
002912 9630                      	adiw Z, 0
002913 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002914 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002915 91a0 28e8                 	lds r26, triangle_fx_3xx_start
002917 91b0 28e9                 	lds r27, triangle_fx_3xx_start+1
002919 9610                      	adiw r26:r27, 0
00291a f409                      	brne sound_driver_channel2_fx_3xx_routine_main
00291b c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
00291c 91c0 28ea                 	lds r28, triangle_fx_3xx_target
00291e 91d0 28eb                 	lds r29, triangle_fx_3xx_target+1
                                 
002920 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002921 07bd                      	cpc r27, r29
002922 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002923 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002924 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002925 9220 28e8                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002927 9220 28e9                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002929 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
00292a 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
00292b 0bdb                      	sbc r29, r27
00292c 91a0 28ee                 	lds r26, triangle_fx_3xx_total_offset
00292e 91b0 28ef                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002930 0fae                      	add r26, ZL //add the speed to the total offset
002931 1fbf                      	adc r27, ZH
002932 1bca                      	sub r28, r26 //invert the total difference with the total offset
002933 0bdb                      	sbc r29, r27
002934 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002935 93a0 28ee                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002937 93b0 28ef                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002939 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
00293b 91b0 0aad                 	lds r27, TCB2_CCMPH
00293d 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00293e 0bbd                      	sbc r27, r29
00293f 93a0 0aac                 	sts TCB2_CCMPL, r26
002941 93b0 0aad                 	sts TCB2_CCMPH, r27
002943 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002944 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002945 0bbd                      	sbc r27, r29
002946 91c0 28ee                 	lds r28, triangle_fx_3xx_total_offset
002948 91d0 28ef                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
00294a 0fce                      	add r28, ZL //add the speed to the total offset
00294b 1fdf                      	adc r29, ZH
00294c 1bac                      	sub r26, r28 //invert the total difference with the total offset
00294d 0bbd                      	sbc r27, r29
00294e f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00294f 93c0 28ee                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002951 93d0 28ef                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002953 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002955 91d0 0aad                 	lds r29, TCB2_CCMPH
002957 0fca                      	add r28, r26 //offset the current timer period with the total offset
002958 1fdb                      	adc r29, r27
002959 93c0 0aac                 	sts TCB2_CCMPL, r28
00295b 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
00295d 91a0 28f0                 	lds r26, triangle_fx_4xy_speed
00295f 15a2                      	cp r26, zero
002960 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002961 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002962 91b0 28f1                 	lds r27, triangle_fx_4xy_depth
002964 91c0 28f2                 	lds r28, triangle_fx_4xy_phase
002966 0fca                      	add r28, r26 //increase the phase by the speed
002967 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002968 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002969 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
00296a 93c0 28f2                 	sts triangle_fx_4xy_phase, r28 //store the new phase
00296c 31c0                      	cpi r28, 16
00296d f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
00296e 32c0                      	cpi r28, 32
00296f f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002970 33c0                      	cpi r28, 48
002971 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002972 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002973 70cf                      	andi r28, 0x0F //mask for values 0-15
002974 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002975 6fc0                      	ori r28, 0xF0
002976 95c0                      	com r28 //invert values 0-15
002977 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002978 70cf                      	andi r28, 0x0F //mask for values 0-15
002979 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
00297a 6fc0                      	ori r28, 0xF0
00297b 95c0                      	com r28 //invert values 0-15
00297c c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
00297d 95b2                      	swap r27 //multiply depth by 16
00297e 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00297f e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002980 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002981 0fec                      	add ZL, r28 //offset the table by the depth+phase
002982 1df2                      	adc ZH, zero
002983 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002984 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002985 937f                      	push r23
002986 2f6c                      	mov r22, r28 //store the vibrato value into r22
002987 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002988 9f67                      	mul r22, r23
002989 917f                      	pop r23
00298a 916f                      	pop r22
                                 
00298b 9416                      	lsr r1 //shift out the fractional bits
00298c 9407                      	ror r0
00298d 9416                      	lsr r1
00298e 9407                      	ror r0
00298f 9416                      	lsr r1
002990 9407                      	ror r0
002991 9416                      	lsr r1
002992 9407                      	ror r0
                                 	
002993 91a0 0aac                 	lds r26, TCB2_CCMPL
002995 91b0 0aad                 	lds r27, TCB2_CCMPH
002997 0da0                      	add r26, r0
002998 1db1                      	adc r27, r1
002999 93a0 0aac                 	sts TCB2_CCMPL, r26
00299b 93b0 0aad                 	sts TCB2_CCMPH, r27
00299d c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
00299e 95b2                      	swap r27 //multiply depth by 16
00299f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0029a0 e1e6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0029a1 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0029a2 0fec                      	add ZL, r28 //offset the table by the depth+phase
0029a3 1df2                      	adc ZH, zero
0029a4 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0029a5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0029a6 937f                      	push r23
0029a7 2f6c                      	mov r22, r28 //store the vibrato value into r22
0029a8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0029a9 9f67                      	mul r22, r23
0029aa 917f                      	pop r23
0029ab 916f                      	pop r22
                                 
0029ac 9416                      	lsr r1 //shift out the fractional bits
0029ad 9407                      	ror r0
0029ae 9416                      	lsr r1
0029af 9407                      	ror r0
0029b0 9416                      	lsr r1
0029b1 9407                      	ror r0
0029b2 9416                      	lsr r1
0029b3 9407                      	ror r0
                                 
0029b4 91a0 0aac                 	lds r26, TCB2_CCMPL
0029b6 91b0 0aad                 	lds r27, TCB2_CCMPH
0029b8 19a0                      	sub r26, r0
0029b9 09b1                      	sbc r27, r1
0029ba 93a0 0aac                 	sts TCB2_CCMPL, r26
0029bc 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
0029be 91e0 28f7                 	lds ZL, triangle_fx_Qxy_target
0029c0 91f0 28f8                 	lds ZH, triangle_fx_Qxy_target+1
0029c2 9630                      	adiw Z, 0
0029c3 f139                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0029c4 91a0 28fb                 	lds r26, triangle_fx_Qxy_total_offset
0029c6 91b0 28fc                 	lds r27, triangle_fx_Qxy_total_offset+1
0029c8 91c0 0aac                 	lds r28, TCB2_CCMPL
0029ca 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
0029cc 1bec                      	sub ZL, r28 //calculate the difference to the target
0029cd 0bfd                      	sbc ZH, r29
0029ce f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
0029cf f088                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
0029d0 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
0029d1 0bbf                      	sbc r27, ZH
                                 
0029d2 91c0 28f5                 	lds r28, triangle_fx_Pxx_total
0029d4 91d0 28f6                 	lds r29, triangle_fx_Pxx_total+1
                                 
0029d6 0fac                      	add r26, r28
0029d7 1fbd                      	adc r27, r29
                                 
0029d8 93a0 28fb                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
0029da 93b0 28fc                 	sts triangle_fx_Qxy_total_offset+1, r27
0029dc 9220 28f7                 	sts triangle_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
0029de 9220 28f8                 	sts triangle_fx_Qxy_target+1, zero
0029e0 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
0029e1 91c0 28f9                 	lds r28, triangle_fx_Qxy_speed
0029e3 91d0 28fa                 	lds r29, triangle_fx_Qxy_speed+1
0029e5 0fac                      	add r26, r28 //increase the total offset by the speed
0029e6 1fbd                      	adc r27, r29
0029e7 93a0 28fb                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
0029e9 93b0 28fc                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
0029eb 91e0 28fd                 	lds ZL, triangle_fx_Rxy_target
0029ed 91f0 28fe                 	lds ZH, triangle_fx_Rxy_target+1
0029ef 9630                      	adiw Z, 0
0029f0 f139                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
0029f1 91a0 2901                 	lds r26, triangle_fx_Rxy_total_offset
0029f3 91b0 2902                 	lds r27, triangle_fx_Rxy_total_offset+1
0029f5 91c0 0aac                 	lds r28, TCB2_CCMPL
0029f7 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
0029f9 1bce                      	sub r28, ZL //calculate the difference to the target
0029fa 0bdf                      	sbc r29, ZH
0029fb f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
0029fc f088                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
0029fd 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
0029fe 0bbd                      	sbc r27, r29
                                 
0029ff 91c0 28f5                 	lds r28, triangle_fx_Pxx_total
002a01 91d0 28f6                 	lds r29, triangle_fx_Pxx_total+1
                                 
002a03 0fac                      	add r26, r28
002a04 1fbd                      	adc r27, r29
                                 
002a05 93a0 2901                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002a07 93b0 2902                 	sts triangle_fx_Rxy_total_offset+1, r27
002a09 9220 28fd                 	sts triangle_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
002a0b 9220 28fe                 	sts triangle_fx_Rxy_target+1, zero
002a0d c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002a0e 91c0 28ff                 	lds r28, triangle_fx_Rxy_speed
002a10 91d0 2900                 	lds r29, triangle_fx_Rxy_speed+1
002a12 0fac                      	add r26, r28 //increase the total offset by the speed
002a13 1fbd                      	adc r27, r29
002a14 93a0 2901                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002a16 93b0 2902                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
                                 
                                 sound_driver_exit:
002a18 91ff                      	pop r31
002a19 91ef                      	pop r30
002a1a 91df                      	pop r29
002a1b 91cf                      	pop r28
002a1c 940c 15b6                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
002a1e 7f05
002a1f 010a
002a20 0214
002a21 0328
002a22 0450
002a23 051e
002a24 0607
002a25 070d
002a26 0806
002a27 090c
002a28 0a18
002a29 0b30
002a2a 0c60
002a2b 0d24
002a2c 0e08
002a2d 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
002a2e 0301
002a2f fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
002a30 179e
002a31 17a3
002a32 17bf
002a33 17db
002a34 17fe                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
002a35 1809
002a36 1816
002a37 1819
002a38 181c
002a39 181f                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
002a3a 1822
002a3b 182a
002a3c 182d
002a3d 183a
002a3e 183b                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
002a3f 183c
002a40 183d
002a41 183e
002a42 1852
002a43 1896                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
002a44 18d9
002a45 18e6
002a46 18fa
002a47 18fb
002a48 18fc                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
002a49 18fd                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
002a4a 1a7f
002a4b 1a84
002a4c 1aa0
002a4d 1abc
002a4e 1adf                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
002a4f 1aea
002a50 1af7
002a51 1afa
002a52 1afd
002a53 1b00                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
002a54 1b03
002a55 1b0b
002a56 1b0e
002a57 1b1b
002a58 1b1c                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
002a59 1b1d
002a5a 1b1e
002a5b 1b1f
002a5c 1b33
002a5d 1b77                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
002a5e 1bba
002a5f 1bc7
002a60 1bdb
002a61 1bdc
002a62 1bdd                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
002a63 1bde                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
002a64 1d5c
002a65 1d61
002a66 1d7d
002a67 1d99
002a68 1dbc                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
002a69 1dc7
002a6a 1dc8
002a6b 1dc9
002a6c 1dcc
002a6d 1dcf                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
002a6e 1dd2
002a6f 1ddf
002a70 1de2
002a71 1def
002a72 1df0                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
002a73 1df1
002a74 1df2
002a75 1df3
002a76 1e07
002a77 1e4b                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
002a78 1e8e
002a79 1e9b
002a7a 1e9c
002a7b 1e9d
002a7c 1e9e                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
002a7d 1e9f                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
002a7e 0000
002a7f 0000
002a80 0000
002a81 0000
002a82 0000
002a83 0000
002a84 0000
002a85 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
002a86 0100
002a87 0101
002a88 0101
002a89 0101
002a8a 0101
002a8b 0101
002a8c 0101
002a8d 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
002a8e 0100
002a8f 0101
002a90 0101
002a91 0101
002a92 0101
002a93 0101
002a94 0101
002a95 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
002a96 0100
002a97 0101
002a98 0101
002a99 0101
002a9a 0101
002a9b 0202
002a9c 0202
002a9d 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
002a9e 0100
002a9f 0101
002aa0 0101
002aa1 0101
002aa2 0202
002aa3 0202
002aa4 0303
002aa5 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
002aa6 0100
002aa7 0101
002aa8 0101
002aa9 0202
002aaa 0302
002aab 0303
002aac 0404
002aad 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
002aae 0100
002aaf 0101
002ab0 0201
002ab1 0202
002ab2 0303
002ab3 0404
002ab4 0504
002ab5 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
002ab6 0100
002ab7 0101
002ab8 0201
002ab9 0302
002aba 0403
002abb 0504
002abc 0605
002abd 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
002abe 0100
002abf 0101
002ac0 0202
002ac1 0303
002ac2 0404
002ac3 0505
002ac4 0606
002ac5 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
002ac6 0100
002ac7 0101
002ac8 0302
002ac9 0403
002aca 0504
002acb 0606
002acc 0707
002acd 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
002ace 0100
002acf 0201
002ad0 0302
002ad1 0404
002ad2 0605
002ad3 0706
002ad4 0808
002ad5 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
002ad6 0100
002ad7 0201
002ad8 0302
002ad9 0504
002ada 0605
002adb 0807
002adc 0908
002add 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
002ade 0100
002adf 0201
002ae0 0403
002ae1 0504
002ae2 0706
002ae3 0808
002ae4 0a09
002ae5 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
002ae6 0100
002ae7 0201
002ae8 0403
002ae9 0605
002aea 0706
002aeb 0908
002aec 0b0a
002aed 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
002aee 0100
002aef 0201
002af0 0403
002af1 0605
002af2 0807
002af3 0a09
002af4 0c0b
002af5 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
002af6 0100
002af7 0302
002af8 0504
002af9 0706
002afa 0908
002afb 0b0a
002afc 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 187 r0 : 144 r1 : 150 r2 : 529 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   0 r22: 120 r23: 120 r24:   0 r25:  24 r26: 726 r27: 884 r28: 535 
r29: 293 r30: 289 r31: 261 
Registers used: 24 out of 35 (68.6%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 113 add   : 147 adiw  :  80 and   :   0 
andi  :  71 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   5 brcs  :   9 break :   0 breq  : 127 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  60 brlt  :   0 brmi  :   0 
brne  :  92 brpl  :   0 brsh  :  24 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   4 
clc   :   0 clh   :   0 cli   :   7 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  13 cp    :  76 cpc   :   8 
cpi   : 126 cpse  :  17 dec   :  29 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   3 in    :   6 inc   :  36 
jmp   :   9 ld    :   0 ldd   :   0 ldi   : 226 lds   : 549 lpm   : 197 
lsl   :  58 lsr   : 124 mov   : 105 movw  :   0 mul   :  24 muls  :   0 
mulsu :   6 neg   :   0 nop   :   0 or    :  14 ori   :   8 out   :   8 
pop   :  90 push  :  84 rcall :  39 ret   :  28 reti  :   6 rjmp  : 385 
rol   :  38 ror   : 142 sbc   :  36 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  10 sbrc  :  21 sbrs  :  13 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1057 sub   :  49 subi  :  39 swap  :  35 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0055fc  12004   9936  21940   49152  44.6%
[.dseg] 0x002800 0x002907      0    263    263    6144   4.3%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 56 warnings
