
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Sat Jan 16 22:53:07 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4005 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           song_frames: .byte 2
002812                           song_frame_offset: .byte 2
002814                           song_size: .byte 2
002816                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002817                           song_fx_Bxx: .byte 1
002818                           song_fx_Cxx: .byte 1
002819                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
00281a                           pulse1_pattern: .byte 2
00281c                           pulse1_pattern_delay_rows: .byte 1
00281d                           pulse1_pattern_delay_frames: .byte 1
00281e                           pulse1_pattern_offset: .byte 2
                                 
002820                           pulse1_volume_macro: .byte 2
002822                           pulse1_volume_macro_offset: .byte 1
002823                           pulse1_volume_macro_loop: .byte 1
002824                           pulse1_volume_macro_release: .byte 1
                                 
002825                           pulse1_arpeggio_macro: .byte 2
002827                           pulse1_arpeggio_macro_offset: .byte 1
002828                           pulse1_arpeggio_macro_loop: .byte 1
002829                           pulse1_arpeggio_macro_release: .byte 1
00282a                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00282b                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00282c                           pulse1_pitch_macro: .byte 2
00282e                           pulse1_pitch_macro_offset: .byte 1
00282f                           pulse1_pitch_macro_loop: .byte 1
002830                           pulse1_pitch_macro_release: .byte 1
                                 
002831                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002832                           pulse1_hi_pitch_macro: .byte 2
002834                           pulse1_hi_pitch_macro_offset: .byte 1
002835                           pulse1_hi_pitch_macro_loop: .byte 1
002836                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002837                           pulse1_duty_macro: .byte 2
002839                           pulse1_duty_macro_offset: .byte 1
00283a                           pulse1_duty_macro_loop: .byte 1
00283b                           pulse1_duty_macro_release: .byte 1
                                 
00283c                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00283e                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002840                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002842                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002844                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002846                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002848                           pulse1_fx_3xx_target: .byte 2 //target note period
00284a                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00284c                           pulse1_fx_3xx_total_offset: .byte 2
00284e                           pulse1_fx_4xy_speed: .byte 1
00284f                           pulse1_fx_4xy_depth: .byte 1
002850                           pulse1_fx_4xy_phase: .byte 1
002851                           pulse1_fx_7xy_speed: .byte 1
002852                           pulse1_fx_7xy_depth: .byte 1
002853                           pulse1_fx_7xy_phase: .byte 1
002854                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002855                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002856                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002857                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002858                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002859                           pulse1_fx_Qxy_target: .byte 2 //target note period
00285b                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00285d                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00285f                           pulse1_fx_Rxy_target: .byte 2 //target note period
002861                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002863                           pulse1_fx_Rxy_total_offset: .byte 2
002865                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002866                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002867                           pulse2_pattern: .byte 2
002869                           pulse2_pattern_delay_rows: .byte 1
00286a                           pulse2_pattern_delay_frames: .byte 1
00286b                           pulse2_pattern_offset: .byte 2
                                 
00286d                           pulse2_volume_macro: .byte 2
00286f                           pulse2_volume_macro_offset: .byte 1
002870                           pulse2_volume_macro_loop: .byte 1
002871                           pulse2_volume_macro_release: .byte 1
                                 
002872                           pulse2_arpeggio_macro: .byte 2
002874                           pulse2_arpeggio_macro_offset: .byte 1
002875                           pulse2_arpeggio_macro_loop: .byte 1
002876                           pulse2_arpeggio_macro_release: .byte 1
002877                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002878                           pulse2_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
002879                           pulse2_pitch_macro: .byte 2
00287b                           pulse2_pitch_macro_offset: .byte 1
00287c                           pulse2_pitch_macro_loop: .byte 1
00287d                           pulse2_pitch_macro_release: .byte 1
                                 
00287e                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00287f                           pulse2_hi_pitch_macro: .byte 2
002881                           pulse2_hi_pitch_macro_offset: .byte 1
002882                           pulse2_hi_pitch_macro_loop: .byte 1
002883                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002884                           pulse2_duty_macro: .byte 2
002886                           pulse2_duty_macro_offset: .byte 1
002887                           pulse2_duty_macro_loop: .byte 1
002888                           pulse2_duty_macro_release: .byte 1
                                 
002889                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00288b                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00288d                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00288f                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002891                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002893                           pulse2_fx_3xx_start: .byte 2 //the starting note period
002895                           pulse2_fx_3xx_target: .byte 2 //target note period
002897                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002899                           pulse2_fx_3xx_total_offset: .byte 2
00289b                           pulse2_fx_4xy_speed: .byte 1
00289c                           pulse2_fx_4xy_depth: .byte 1
00289d                           pulse2_fx_4xy_phase: .byte 1
00289e                           pulse2_fx_7xy_speed: .byte 1
00289f                           pulse2_fx_7xy_depth: .byte 1
0028a0                           pulse2_fx_7xy_phase: .byte 1
0028a1                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028a2                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028a3                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028a4                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028a5                           pulse2_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
0028a6                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028a8                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028aa                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028ac                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028ae                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028b0                           pulse2_fx_Rxy_total_offset: .byte 2
0028b2                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028b3                           pulse2_fx_Sxx_post: .byte 1
                                 
0028b4                           triangle_pattern_delay: .byte 1
0028b5                           noise_pattern_delay: .byte 1
0028b6                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 
                                 reset:
000000 940c 11e5                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 14d7                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 140f                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 141a                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 140f                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1431                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 147e                 	jmp pulse2_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(72): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(73): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(103): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(114): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(140): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(141): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(142): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(145): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(153): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(156): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(158): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(159): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(161): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(164): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(165): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(166): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(169): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(170): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(171): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(282): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(283): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(284): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(286): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(291): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(292): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(293): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(294): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(295): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(296): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(297): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(298): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(299): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(301): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(305): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(306): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(307): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(308): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(311): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(313): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(317): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(322): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(323): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(324): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(326): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(327): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(328): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(331): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(332): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(335): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(336): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(338): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(345): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(346): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(209): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
0011e5 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
0011e6 93c0 0034                 	sts CPU_CCP, r28
0011e8 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
0011e9 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
0011eb 2422                      	clr zero
                                 
                                 	//MEMORY
0011ec e3c0                      	ldi r28, 0b00110000
0011ed 93c0 2800                 	sts pulse1_param, r28
0011ef e8c0                      	ldi r28, 0b10000000
0011f0 93c0 2801                 	sts pulse1_sweep_param, r28
0011f2 efcf                      	ldi r28, 0xFF
0011f3 93c0 2802                 	sts pulse1_timerL, r28
0011f5 93c0 2803                 	sts pulse1_timerH, r28
0011f7 93c0 2804                 	sts pulse1_length, r28
                                 
0011f9 e3c0                      	ldi r28, 0b00110000
0011fa 93c0 2808                 	sts pulse2_param, r28
0011fc e8c0                      	ldi r28, 0b10000000
0011fd 93c0 2809                 	sts pulse2_sweep_param, r28
0011ff efcf                      	ldi r28, 0xFF
001200 93c0 280a                 	sts pulse2_timerL, r28
001202 93c0 280b                 	sts pulse2_timerH, r28
001204 93c0 280c                 	sts pulse2_length, r28
                                 
001206 e0c2                      	ldi r28, 0x02
001207 93c0 2812                 	sts song_frame_offset, r28
001209 9220 2813                 	sts song_frame_offset+1, zero
00120b e0e6                      	ldi ZL, LOW(song0_frames << 1)
00120c e0f2                      	ldi ZH, HIGH(song0_frames << 1)
00120d 93e0 2810                 	sts song_frames, ZL
00120f 93f0 2811                 	sts song_frames+1, ZH
001211 91c5                      	lpm r28, Z+ //load the song size
001212 91d5                      	lpm r29, Z+
001213 93c0 2814                 	sts song_size, r28
001215 93d0 2815                 	sts song_size+1, r29
001217 9220 2816                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
001219 91c5                      	lpm r28, Z+
00121a 91d5                      	lpm r29, Z+
00121b 0fcc                      	lsl r28
00121c 1fdd                      	rol r29
00121d 93c0 281a                 	sts pulse1_pattern, r28
00121f 93d0 281b                 	sts pulse1_pattern+1, r29
001221 9220 281c                 	sts pulse1_pattern_delay_rows, zero
001223 9220 281d                 	sts pulse1_pattern_delay_frames, zero
001225 9220 281e                 	sts pulse1_pattern_offset, zero
001227 9220 281f                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
001229 91c5                      	lpm r28, Z+
00122a 91d5                      	lpm r29, Z+
00122b 0fcc                      	lsl r28
00122c 1fdd                      	rol r29
00122d 93c0 2867                 	sts pulse2_pattern, r28
00122f 93d0 2868                 	sts pulse2_pattern+1, r29
001231 9220 2869                 	sts pulse2_pattern_delay_rows, zero
001233 9220 286a                 	sts pulse2_pattern_delay_frames, zero
001235 9220 286b                 	sts pulse2_pattern_offset, zero
001237 9220 286c                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
001239 efcf                      	ldi r28, 0xFF
00123a 9220 2822                 	sts pulse1_volume_macro_offset, zero
00123c 93c0 2823                 	sts pulse1_volume_macro_loop, r28
00123e 93c0 2824                 	sts pulse1_volume_macro_release, r28
001240 9220 2827                 	sts pulse1_arpeggio_macro_offset, zero
001242 93c0 2828                 	sts pulse1_arpeggio_macro_loop, r28
001244 93c0 2829                 	sts pulse1_arpeggio_macro_release, r28
001246 93c0 282a                 	sts pulse1_arpeggio_macro_mode, r28
001248 9220 282e                 	sts pulse1_pitch_macro_offset, zero
00124a 93c0 282f                 	sts pulse1_pitch_macro_loop, r28
00124c 93c0 2830                 	sts pulse1_pitch_macro_release, r28
00124e 9220 2834                 	sts pulse1_hi_pitch_macro_offset, zero
001250 93c0 2835                 	sts pulse1_hi_pitch_macro_loop, r28
001252 93c0 2836                 	sts pulse1_hi_pitch_macro_release, r28
001254 9220 2839                 	sts pulse1_duty_macro_offset, zero
001256 93c0 283a                 	sts pulse1_duty_macro_loop, r28
001258 93c0 283b                 	sts pulse1_duty_macro_release, r28
                                 
00125a 9220 2820                 	sts pulse1_volume_macro, zero
00125c 9220 2821                 	sts pulse1_volume_macro+1, zero
00125e 9220 2825                 	sts pulse1_arpeggio_macro, zero
001260 9220 2826                 	sts pulse1_arpeggio_macro+1, zero
001262 9220 282b                 	sts pulse1_total_pitch_offset, zero
001264 9220 282c                 	sts pulse1_pitch_macro, zero
001266 9220 282d                 	sts pulse1_pitch_macro+1, zero
001268 9220 2831                 	sts pulse1_total_hi_pitch_offset, zero
00126a 9220 2832                 	sts pulse1_hi_pitch_macro, zero
00126c 9220 2833                 	sts pulse1_hi_pitch_macro+1, zero
00126e 9220 2837                 	sts pulse1_duty_macro, zero
001270 9220 2838                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001272 e00f                      	ldi pulse1_volume_divider, 0x0F
001273 9110 2800                 	lds pulse1_volume_decay, pulse1_param
001275 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001276 9190 2800                 	lds channel_flags, pulse1_param
001278 7390                      	andi channel_flags, 0b00110000
001279 6490                      	sbr channel_flags, 0b01000000 //set start flag
00127a 9220 2806                 	sts pulse1_output_volume, zero
00127c 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
00127e 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
00127f e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001280 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001281 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
001283 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
001284 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
001285 efcf                      	ldi r28, 0xFF
001286 93c0 2817                 	sts song_fx_Bxx, r28
001288 9220 2818                 	sts song_fx_Cxx, zero
00128a 9220 2819                 	sts song_fx_Dxx, zero
00128c 9220 283c                 	sts pulse1_fx_0xy_sequence, zero
00128e 9220 283d                 	sts pulse1_fx_0xy_sequence+1, zero
001290 9220 283e                 	sts pulse1_fx_1xx, zero
001292 9220 283f                 	sts pulse1_fx_1xx+1, zero
001294 9220 2840                 	sts pulse1_fx_1xx_total, zero
001296 9220 2841                 	sts pulse1_fx_1xx_total+1, zero
001298 9220 2842                 	sts pulse1_fx_2xx, zero
00129a 9220 2843                 	sts pulse1_fx_2xx+1, zero
00129c 9220 2844                 	sts pulse1_fx_2xx_total, zero
00129e 9220 2845                 	sts pulse1_fx_2xx_total+1, zero
0012a0 9220 2846                 	sts pulse1_fx_3xx_start, zero
0012a2 9220 2847                 	sts pulse1_fx_3xx_start+1, zero
0012a4 9220 2848                 	sts pulse1_fx_3xx_target, zero
0012a6 9220 2849                 	sts pulse1_fx_3xx_target+1, zero
0012a8 9220 284a                 	sts pulse1_fx_3xx_speed, zero
0012aa 9220 284b                 	sts pulse1_fx_3xx_speed+1, zero
0012ac 9220 284c                 	sts pulse1_fx_3xx_total_offset, zero
0012ae 9220 284d                 	sts pulse1_fx_3xx_total_offset+1, zero
0012b0 9220 284e                 	sts pulse1_fx_4xy_speed, zero
0012b2 9220 284f                 	sts pulse1_fx_4xy_depth, zero
0012b4 9220 2850                 	sts pulse1_fx_4xy_phase, zero
0012b6 9220 2851                 	sts pulse1_fx_7xy_speed, zero
0012b8 9220 2852                 	sts pulse1_fx_7xy_depth, zero
0012ba 9220 2853                 	sts pulse1_fx_7xy_phase, zero
0012bc 9220 2854                 	sts pulse1_fx_7xy_value, zero
0012be 9220 2855                 	sts pulse1_fx_Axy, zero
0012c0 93c0 2856                 	sts pulse1_fx_Gxx_pre, r28
0012c2 93c0 2857                 	sts pulse1_fx_Gxx_post, r28
0012c4 9220 2858                 	sts pulse1_fx_Pxx, zero
0012c6 9220 2859                 	sts pulse1_fx_Qxy_target, zero
0012c8 9220 285a                 	sts pulse1_fx_Qxy_target+1, zero
0012ca 9220 285b                 	sts pulse1_fx_Qxy_speed, zero
0012cc 9220 285c                 	sts pulse1_fx_Qxy_speed+1, zero
0012ce 9220 285d                 	sts pulse1_fx_Qxy_total_offset, zero
0012d0 9220 285e                 	sts pulse1_fx_Qxy_total_offset+1, zero
0012d2 9220 285f                 	sts pulse1_fx_Rxy_target, zero
0012d4 9220 2860                 	sts pulse1_fx_Rxy_target+1, zero
0012d6 9220 2861                 	sts pulse1_fx_Rxy_speed, zero
0012d8 9220 2862                 	sts pulse1_fx_Rxy_speed+1, zero
0012da 9220 2863                 	sts pulse1_fx_Rxy_total_offset, zero
0012dc 9220 2864                 	sts pulse1_fx_Rxy_total_offset+1, zero
0012de 93c0 2865                 	sts pulse1_fx_Sxx_pre, r28
0012e0 93c0 2866                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
0012e2 efcf                      	ldi r28, 0xFF
0012e3 9220 286f                 	sts pulse2_volume_macro_offset, zero
0012e5 93c0 2870                 	sts pulse2_volume_macro_loop, r28
0012e7 93c0 2871                 	sts pulse2_volume_macro_release, r28
0012e9 9220 2874                 	sts pulse2_arpeggio_macro_offset, zero
0012eb 93c0 2875                 	sts pulse2_arpeggio_macro_loop, r28
0012ed 93c0 2876                 	sts pulse2_arpeggio_macro_release, r28
0012ef 93c0 2877                 	sts pulse2_arpeggio_macro_mode, r28
0012f1 9220 287b                 	sts pulse2_pitch_macro_offset, zero
0012f3 93c0 287c                 	sts pulse2_pitch_macro_loop, r28
0012f5 93c0 287d                 	sts pulse2_pitch_macro_release, r28
0012f7 9220 2881                 	sts pulse2_hi_pitch_macro_offset, zero
0012f9 93c0 2882                 	sts pulse2_hi_pitch_macro_loop, r28
0012fb 93c0 2883                 	sts pulse2_hi_pitch_macro_release, r28
0012fd 9220 2886                 	sts pulse2_duty_macro_offset, zero
0012ff 93c0 2887                 	sts pulse2_duty_macro_loop, r28
001301 93c0 2888                 	sts pulse2_duty_macro_release, r28
                                 
001303 9220 286d                 	sts pulse2_volume_macro, zero
001305 9220 286e                 	sts pulse2_volume_macro+1, zero
001307 9220 2872                 	sts pulse2_arpeggio_macro, zero
001309 9220 2873                 	sts pulse2_arpeggio_macro+1, zero
00130b 9220 2878                 	sts pulse2_total_pitch_offset, zero
00130d 9220 2879                 	sts pulse2_pitch_macro, zero
00130f 9220 287a                 	sts pulse2_pitch_macro+1, zero
001311 9220 287e                 	sts pulse2_total_hi_pitch_offset, zero
001313 9220 287f                 	sts pulse2_hi_pitch_macro, zero
001315 9220 2880                 	sts pulse2_hi_pitch_macro+1, zero
001317 9220 2884                 	sts pulse2_duty_macro, zero
001319 9220 2885                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
00131b e02f                      	ldi pulse2_volume_divider, 0x0F
00131c 9130 2808                 	lds pulse2_volume_decay, pulse2_param
00131e 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
00131f 91d0 2808                 	lds r29, pulse2_param
001321 73d0                      	andi r29, 0b00110000
001322 62d0                      	sbr r29, 0b0100000 //set start flag
001323 95d2                      	swap r29
001324 2b9d                      	or channel_flags, r29
001325 9220 280e                 	sts pulse2_output_volume, zero
001327 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
001329 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
00132a e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
00132b 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
00132c 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
00132e 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
00132f 6098                      	sbr channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001330 efcf                      	ldi r28, 0xFF
001331 93c0 2817                 	sts song_fx_Bxx, r28
001333 9220 2818                 	sts song_fx_Cxx, zero
001335 9220 2819                 	sts song_fx_Dxx, zero
001337 9220 2889                 	sts pulse2_fx_0xy_sequence, zero
001339 9220 288a                 	sts pulse2_fx_0xy_sequence+1, zero
00133b 9220 288b                 	sts pulse2_fx_1xx, zero
00133d 9220 288c                 	sts pulse2_fx_1xx+1, zero
00133f 9220 288d                 	sts pulse2_fx_1xx_total, zero
001341 9220 288e                 	sts pulse2_fx_1xx_total+1, zero
001343 9220 288f                 	sts pulse2_fx_2xx, zero
001345 9220 2890                 	sts pulse2_fx_2xx+1, zero
001347 9220 2891                 	sts pulse2_fx_2xx_total, zero
001349 9220 2892                 	sts pulse2_fx_2xx_total+1, zero
00134b 9220 2893                 	sts pulse2_fx_3xx_start, zero
00134d 9220 2894                 	sts pulse2_fx_3xx_start+1, zero
00134f 9220 2895                 	sts pulse2_fx_3xx_target, zero
001351 9220 2896                 	sts pulse2_fx_3xx_target+1, zero
001353 9220 2897                 	sts pulse2_fx_3xx_speed, zero
001355 9220 2898                 	sts pulse2_fx_3xx_speed+1, zero
001357 9220 2899                 	sts pulse2_fx_3xx_total_offset, zero
001359 9220 289a                 	sts pulse2_fx_3xx_total_offset+1, zero
00135b 9220 289b                 	sts pulse2_fx_4xy_speed, zero
00135d 9220 289c                 	sts pulse2_fx_4xy_depth, zero
00135f 9220 289d                 	sts pulse2_fx_4xy_phase, zero
001361 9220 289e                 	sts pulse2_fx_7xy_speed, zero
001363 9220 289f                 	sts pulse2_fx_7xy_depth, zero
001365 9220 28a0                 	sts pulse2_fx_7xy_phase, zero
001367 9220 28a1                 	sts pulse2_fx_7xy_value, zero
001369 9220 28a2                 	sts pulse2_fx_Axy, zero
00136b 93c0 28a3                 	sts pulse2_fx_Gxx_pre, r28
00136d 93c0 28a4                 	sts pulse2_fx_Gxx_post, r28
00136f 9220 28a5                 	sts pulse2_fx_Pxx, zero
001371 9220 28a6                 	sts pulse2_fx_Qxy_target, zero
001373 9220 28a7                 	sts pulse2_fx_Qxy_target+1, zero
001375 9220 28a8                 	sts pulse2_fx_Qxy_speed, zero
001377 9220 28a9                 	sts pulse2_fx_Qxy_speed+1, zero
001379 9220 28aa                 	sts pulse2_fx_Qxy_total_offset, zero
00137b 9220 28ab                 	sts pulse2_fx_Qxy_total_offset+1, zero
00137d 9220 28ac                 	sts pulse2_fx_Rxy_target, zero
00137f 9220 28ad                 	sts pulse2_fx_Rxy_target+1, zero
001381 9220 28ae                 	sts pulse2_fx_Rxy_speed, zero
001383 9220 28af                 	sts pulse2_fx_Rxy_speed+1, zero
001385 9220 28b0                 	sts pulse2_fx_Rxy_total_offset, zero
001387 9220 28b1                 	sts pulse2_fx_Rxy_total_offset+1, zero
001389 93c0 28b2                 	sts pulse2_fx_Sxx_pre, r28
00138b 93c0 28b3                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 
                                 	//PINS
00138d efcf                      	ldi r28, 0xFF
00138e b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTD to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
00138f e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
001390 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
001392 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
001393 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001395 e1c5                      	ldi r28, 0x15 //set the period for CMP0
001396 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
001398 e0c5                      	ldi r28, 0x05
001399 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
00139b e2cb                      	ldi r28, 0x2B //set the period for CMP1
00139c 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
00139e e0ca                      	ldi r28, 0x0A
00139f 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
0013a1 e4c1                      	ldi r28, 0x41 //set the period for CMP2
0013a2 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
0013a4 e0cf                      	ldi r28, 0x0F
0013a5 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
0013a7 e5c7                      	ldi r28, 0x57 //set the period for OVF
0013a8 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
0013aa e1c4                      	ldi r28, 0x14
0013ab 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
0013ad e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0013ae 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0013b0 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
0013b1 93c0 0a81                 	sts TCB0_CTRLB, r28
0013b3 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
0013b4 93c0 0a85                 	sts TCB0_INTCTRL, r28
0013b6 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
0013b8 93c0 0a8c                 	sts TCB0_CCMPL, r28
0013ba 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
0013bc 93c0 0a8d                 	sts TCB0_CCMPH, r28
0013be e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0013bf 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
0013c1 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0013c2 93b0 0a91                 	sts TCB1_CTRLB, r27
0013c4 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0013c5 93b0 0a95                 	sts TCB1_INTCTRL, r27
0013c7 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
0013c9 93b0 0a9c                 	sts TCB1_CCMPL, r27
0013cb 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0013cd 93b0 0a9d                 	sts TCB1_CCMPH, r27
0013cf e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0013d0 93b0 0a90                 	sts TCB1_CTRLA, r27
0013d2 9478                      	sei //global interrupt enable
                                 
                                 volume_mixer:
0013d3 91c0 2806                 	lds r28, pulse1_output_volume
0013d5 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0013d7 fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0013d8 c015                      	rjmp volume_mixer_pulse1_off
                                 
0013d9 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
0013da f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0013db 91e0 0a8c                 	lds r30, TCB0_CCMPL
0013dd e5f9                      	ldi r31, 0x059
0013de 17ef                      	cp r30, r31
0013df 91e0 0a8d                 	lds r30, TCB0_CCMPH
0013e1 e0f0                      	ldi r31, 0x00
0013e2 07ef                      	cpc r30, r31
0013e3 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0013e4 91e0 0a8c                 	lds r30, TCB0_CCMPL
0013e6 e6f6                      	ldi r31, 0x66
0013e7 17ef                      	cp r30, r31
0013e8 91e0 0a8d                 	lds r30, TCB0_CCMPH
0013ea e5f9                      	ldi r31, 0x59
0013eb 07ef                      	cpc r30, r31
0013ec f408                      	brsh volume_mixer_pulse1_off
0013ed c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0013ee 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0013ef fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0013f0 c015                      	rjmp volume_mixer_pulse2_off
                                 
0013f1 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
0013f2 f099                      	breq volume_mixer_pulse2_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0013f3 91e0 0a9c                 	lds r30, TCB1_CCMPL
0013f5 e5f9                      	ldi r31, 0x059
0013f6 17ef                      	cp r30, r31
0013f7 91e0 0a9d                 	lds r30, TCB1_CCMPH
0013f9 e0f0                      	ldi r31, 0x00
0013fa 07ef                      	cpc r30, r31
0013fb f050                      	brlo volume_mixer_pulse2_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
0013fc 91e0 0a9c                 	lds r30, TCB1_CCMPL
0013fe e6f6                      	ldi r31, 0x66
0013ff 17ef                      	cp r30, r31
001400 91e0 0a9d                 	lds r30, TCB1_CCMPH
001402 e5f9                      	ldi r31, 0x59
001403 07ef                      	cpc r30, r31
001404 f408                      	brsh volume_mixer_pulse2_off
001405 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001406 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
001407 0fcd                      	add r28, r29
001408 eee6                      	ldi ZL, LOW(pulse_volume_table << 1)
001409 e0f1                      	ldi ZH, HIGH(pulse_volume_table << 1)
00140a 0fec                      	add ZL, r28
00140b 1df2                      	adc ZH, zero
00140c 91c4                      	lpm r28, Z
00140d b9c1                      	out VPORTA_OUT, r28
00140e cfc4                      	rjmp volume_mixer
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
00140f b7bf                      	in r27, CPU_SREG
001410 93bf                      	push r27
001411 94f8                      	cli
                                 
                                 	//ENVELOPE
001412 d053                      	rcall pulse1_envelope_routine
001413 d09f                      	rcall pulse2_envelope_routine
                                 
001414 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
001415 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001417 91bf                      	pop r27
001418 bfbf                      	out CPU_SREG, r27
001419 9518                      	reti
                                 
                                 sequence_1_3:
00141a b7bf                      	in r27, CPU_SREG
00141b 93bf                      	push r27
00141c 94f8                      	cli
                                 
                                 	//ENVELOPE
00141d d048                      	rcall pulse1_envelope_routine
00141e d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
00141f fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001420 d01b                      	rcall pulse1_sweep_routine
001421 fcf3                      	sbrc pulse2_sweep, 3
001422 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001423 fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
001424 c002                      	rjmp sequence_1_3_pulse2_length
001425 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001426 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001427 fd91                      	sbrc channel_flags, 1 //check if the length counter halt bit is cleared
001428 c002                      	rjmp sequence_1_3_exit
001429 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
00142a 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
00142b e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
00142c 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
00142e 91bf                      	pop r27
00142f bfbf                      	out CPU_SREG, r27
001430 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001431 b7bf                      	in r27, CPU_SREG
001432 93bf                      	push r27
001433 94f8                      	cli
                                 
001434 0caa                      	lsl pulse1_sequence //shifts sequence to the left
001435 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001436 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001437 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001439 91bf                      	pop r27
00143a bfbf                      	out CPU_SREG, r27
00143b 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00143c 2dbc                      	mov r27, pulse1_sweep
00143d 70b7                      	andi r27, 0x07 //mask for period divider bits
00143e f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00143f 93df                      	push r29
001440 2ddc                      	mov r29, pulse1_sweep
001441 95d2                      	swap r29
001442 70d7                      	andi r29, 0x07 //mask for shift bits
001443 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001444 91df                      	pop r29
001445 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001446 91a0 0a8c                 	lds r26, TCB0_CCMPL
001448 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
00144a 95b6                      	lsr r27
00144b 95a7                      	ror r26
00144c 95da                      	dec r29
00144d f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00144e fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
00144f c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001450 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001451 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001452 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001454 0fad                      	add r26, r29
001455 91d0 0a8d                 	lds r29, TCB0_CCMPH
001457 1fbd                      	adc r27, r29
                                 
001458 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00145a 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
00145c 91df                      	pop r29
00145d c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
00145e 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
00145f ff97                      	sbrs channel_flags, 7 //if the reload flag is set, reload the sweep divider
001460 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001461 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001463 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
001464 779f                      	cbr channel_flags, 0b10000000 //clear reload flag
001465 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001466 fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
001467 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001468 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001469 f011                      	breq PC+3 //if the divider == 0, check loop flag
00146a 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
00146b 9508                      	ret
                                 
00146c 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
00146e 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00146f ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
001470 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001471 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001472 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001473 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001474 f409                      	brne PC+2 //if decay != 0, go decrement
001475 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001476 951a                      	dec pulse1_volume_decay
001477 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001478 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
001479 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
00147b 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00147c e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
00147d 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
00147e b7bf                      	in r27, CPU_SREG
00147f 93bf                      	push r27
001480 94f8                      	cli
                                 
001481 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
001482 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001483 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001484 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001486 91bf                      	pop r27
001487 bfbf                      	out CPU_SREG, r27
001488 9518                      	reti
                                 
                                 pulse2_sweep_routine:
001489 2dbf                      	mov r27, pulse2_sweep
00148a 70b7                      	andi r27, 0x07 //mask for period divider bits
00148b f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00148c 93df                      	push r29
00148d 2ddf                      	mov r29, pulse2_sweep
00148e 95d2                      	swap r29
00148f 70d7                      	andi r29, 0x07 //mask for shift bits
001490 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001491 91df                      	pop r29
001492 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001493 91a0 0a9c                 	lds r26, TCB1_CCMPL
001495 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
001497 95b6                      	lsr r27
001498 95a7                      	ror r26
001499 95da                      	dec r29
00149a f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00149b fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
00149c c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
00149d 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
00149e 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
00149f 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
0014a1 0fad                      	add r26, r29
0014a2 91d0 0a9d                 	lds r29, TCB1_CCMPH
0014a4 1fbd                      	adc r27, r29
                                 
0014a5 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
0014a7 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0014a9 91df                      	pop r29
0014aa c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
0014ab 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
0014ac ff93                      	sbrs channel_flags, 3 //if the reload flag is set, reload the sweep divider
0014ad 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0014ae 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0014b0 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
0014b1 7f97                      	cbr channel_flags, 0b00001000 //clear reload flag
0014b2 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0014b3 fd92                      	sbrc channel_flags, 2 //check if start flag is cleared
0014b4 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0014b5 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0014b6 f011                      	breq PC+3 //if the divider == 0, check loop flag
0014b7 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0014b8 9508                      	ret
                                 
0014b9 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0014bb 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0014bc ff91                      	sbrs channel_flags, 1 //check if the loop flag is set
0014bd c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0014be e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0014bf 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0014c0 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0014c1 f409                      	brne PC+2 //if decay != 0, go decrement
0014c2 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0014c3 953a                      	dec pulse2_volume_decay
0014c4 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0014c5 7f9b                      	cbr channel_flags, 0b00000100 //if the start flag is set, clear it
0014c6 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0014c8 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0014c9 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0014ca 9508                      	ret
                                 
                                 
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0014cb e0e2                      	ldi ZL, LOW(length << 1)
0014cc e4f5                      	ldi ZH, HIGH(length << 1)
0014cd 0fed                      	add ZL, r29
0014ce 1df2                      	adc ZH, zero
0014cf 91d4                      	lpm r29, Z
0014d0 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0014d1 e2e2                      	ldi ZL, LOW(sequences << 1)
0014d2 e4f5                      	ldi ZH, HIGH(sequences << 1)
0014d3 0fed                      	add ZL, r29
0014d4 1df2                      	adc ZH, zero
0014d5 91d4                      	lpm r29, Z
0014d6 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
0014d7 b7bf                      	in r27, CPU_SREG
0014d8 93bf                      	push r27
0014d9 94f8                      	cli
0014da 93cf                      	push r28
0014db 93df                      	push r29
0014dc 93ef                      	push r30
0014dd 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
0014de 91a0 2817                 	lds r26, song_fx_Bxx
0014e0 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
0014e1 f4a9                      	brne sound_driver_fx_Bxx_routine
0014e2 91a0 2818                 	lds r26, song_fx_Cxx
0014e4 11a2                      	cpse r26, zero
0014e5 c04b                      	rjmp sound_driver_fx_Cxx_routine
0014e6 91a0 2819                 	lds r26, song_fx_Dxx
0014e8 11a2                      	cpse r26, zero
0014e9 c058                      	rjmp sound_driver_fx_Dxx_routine
                                 
0014ea 91a0 2812                 	lds r26, song_frame_offset
0014ec 91b0 2813                 	lds r27, song_frame_offset+1
0014ee 91c0 2814                 	lds r28, song_size
0014f0 91d0 2815                 	lds r29, song_size+1
0014f2 17ac                      	cp r26, r28
0014f3 07bd                      	cpc r27, r29
0014f4 f408                      	brsh sound_driver_fx_song_loop
0014f5 c083                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
0014f6 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
0014f7 91e0 2810                 	lds ZL, song_frames
0014f9 91f0 2811                 	lds ZH, song_frames+1
0014fb 27cc                      	clr r28 //initialize r29:r28 to 0
0014fc 27dd                      	clr r29
0014fd 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
0014fe 95aa                      	dec r26
0014ff f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001500 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
001501 cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
001502 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
001503 93c0 2812                 	sts song_frame_offset, r28
001505 93d0 2813                 	sts song_frame_offset+1, r29
001507 0fec                      	add ZL, r28
001508 1ffd                      	adc ZH, r29
                                 
001509 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
00150a 91b5                      	lpm r27, Z+
00150b 0faa                      	lsl r26
00150c 1fbb                      	rol r27
00150d 93a0 281a                 	sts pulse1_pattern, r26
00150f 93b0 281b                 	sts pulse1_pattern+1, r27
001511 91a5                      	lpm r26, Z+
001512 91b5                      	lpm r27, Z+
001513 0faa                      	lsl r26
001514 1fbb                      	rol r27
001515 93a0 2867                 	sts pulse2_pattern, r26
001517 93b0 2868                 	sts pulse2_pattern+1, r27
                                 
001519 9220 281e                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00151b 9220 281f                 	sts pulse1_pattern_offset+1, zero
00151d 9220 281c                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00151f 9220 281d                 	sts pulse1_pattern_delay_frames, zero
001521 9220 286b                 	sts pulse2_pattern_offset, zero
001523 9220 286c                 	sts pulse2_pattern_offset+1, zero
001525 9220 2869                 	sts pulse2_pattern_delay_rows, zero
001527 9220 286a                 	sts pulse2_pattern_delay_frames, zero
                                 
001529 efaf                      	ldi r26, 0xFF
00152a 93a0 2817                 	sts song_fx_Bxx, r26 //reset all song effects
00152c 9220 2818                 	sts song_fx_Cxx, zero
00152e 9220 2819                 	sts song_fx_Dxx, zero
001530 c048                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
001531 91ff                      	pop r31
001532 91ef                      	pop r30
001533 91df                      	pop r29
001534 91cf                      	pop r28
001535 91bf                      	pop r27
001536 bfbf                      	out CPU_SREG, r27
001537 94f8                      	cli //disable global interrupts
                                 		
001538 efaf                      	ldi r26, 0xFF
001539 93a0 2817                 	sts song_fx_Bxx, r26 //reset all song effects
00153b 9220 2818                 	sts song_fx_Cxx, zero
00153d 9220 2819                 	sts song_fx_Dxx, zero
                                 
00153f 9220 2806                 	sts pulse1_output_volume, zero //mute all channels
001541 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
001542 91e0 2810                 	lds ZL, song_frames
001544 91f0 2811                 	lds ZH, song_frames+1
001546 91a0 2812                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001548 91b0 2813                 	lds r27, song_frame_offset+1
00154a 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
00154b 93a0 2812                 	sts song_frame_offset, r26
00154d 93b0 2813                 	sts song_frame_offset+1, r27
00154f 0fea                      	add ZL, r26
001550 1ffb                      	adc ZH, r27
                                 
001551 91a5                      	lpm r26, Z+ //load the address of the next pattern
001552 91b5                      	lpm r27, Z+
001553 0faa                      	lsl r26
001554 1fbb                      	rol r27
001555 93a0 281a                 	sts pulse1_pattern, r26
001557 93b0 281b                 	sts pulse1_pattern+1, r27
001559 91a5                      	lpm r26, Z+
00155a 91b5                      	lpm r27, Z+
00155b 0faa                      	lsl r26
00155c 1fbb                      	rol r27
00155d 93a0 2867                 	sts pulse2_pattern, r26
00155f 93b0 2868                 	sts pulse2_pattern+1, r27
                                 
001561 9220 281e                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001563 9220 281f                 	sts pulse1_pattern_offset+1, zero
001565 9220 281c                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001567 9220 281d                 	sts pulse1_pattern_delay_frames, zero
001569 9220 286b                 	sts pulse2_pattern_offset, zero
00156b 9220 286c                 	sts pulse2_pattern_offset+1, zero
00156d 9220 2869                 	sts pulse2_pattern_delay_rows, zero
00156f 9220 286a                 	sts pulse2_pattern_delay_frames, zero
                                 
001571 efaf                      	ldi r26, 0xFF
001572 93a0 2817                 	sts song_fx_Bxx, r26 //reset all song effects
001574 9220 2818                 	sts song_fx_Cxx, zero
001576 9220 2819                 	sts song_fx_Dxx, zero
001578 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001579 91a0 281c                 	lds r26, pulse1_pattern_delay_rows
00157b 91b0 281d                 	lds r27, pulse1_pattern_delay_frames
00157d 9610                      	adiw r27:r26, 0
00157e f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
00157f c2cf                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001580 91e0 281a                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001582 91f0 281b                 	lds ZH, pulse1_pattern+1
001584 91a0 281e                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001586 91b0 281f                 	lds r27, pulse1_pattern_offset+1
001588 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001589 1ffb                      	adc ZH, r27
00158a 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00158b 35b7                      	cpi r27, 0x57
00158c f408                      	brsh sound_driver_channel0_check_if_volume
00158d c178                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
00158e 36b7                      	cpi r27, 0x67
00158f f408                      	brsh sound_driver_channel0_check_if_delay
001590 c1b0                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001591 3eb3                      	cpi r27, 0xE3
001592 f408                      	brsh sound_driver_channel0_check_if_instrument
001593 c1b7                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001594 f409                      	brne sound_driver_channel0_check_if_release
001595 c1ba                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001596 3eb4                      	cpi r27, 0xE4
001597 f409                      	brne sound_driver_channel0_check_if_end
001598 c261                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001599 3fbf                      	cpi r27, 0xFF
00159a f409                      	brne sound_driver_channel0_check_if_fx
00159b c283                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
00159c 9631                      	adiw Z, 1 //point Z to the byte next to the flag
00159d 91a4                      	lpm r26, Z //load the fx data into r26
00159e d2a6                      	rcall sound_driver_channel0_increment_offset_twice
                                 
00159f 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0015a0 e2e6                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
0015a1 e4f5                      	ldi ZH, HIGH(channel0_fx << 1)
0015a2 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0015a3 0feb                      	add ZL, r27 //add offset
0015a4 1df2                      	adc ZH, zero
0015a5 91c5                      	lpm r28, Z+ //load address bytes
0015a6 91d4                      	lpm r29, Z
0015a7 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0015a8 2ffd                      	mov ZH, r29
0015a9 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
0015aa 93a0 283c                 	sts pulse1_fx_0xy_sequence, r26
0015ac 9220 283d                 	sts pulse1_fx_0xy_sequence+1, zero
0015ae cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
0015af 9220 2842                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
0015b1 9220 2843                 	sts pulse1_fx_2xx+1, zero
0015b3 9220 283c                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0015b5 9220 283d                 	sts pulse1_fx_0xy_sequence+1, zero
0015b7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015b8 937f                      	push r23
0015b9 2f6a                      	mov r22, r26 //store the rate into r22
0015ba eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015bb 9f67                      	mul r22, r23
0015bc 917f                      	pop r23
0015bd 916f                      	pop r22
                                 
0015be 9416                      	lsr r1 //shift out the fractional bits
0015bf 9407                      	ror r0
0015c0 9416                      	lsr r1
0015c1 9407                      	ror r0
0015c2 9416                      	lsr r1
0015c3 9407                      	ror r0
0015c4 9416                      	lsr r1
0015c5 9407                      	ror r0
0015c6 9200 283e                 	sts pulse1_fx_1xx, r0
0015c8 9210 283f                 	sts pulse1_fx_1xx+1, r1
0015ca cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0015cb 9220 283e                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0015cd 9220 283f                 	sts pulse1_fx_1xx+1, zero
0015cf 9220 283c                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0015d1 9220 283d                 	sts pulse1_fx_0xy_sequence+1, zero
0015d3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015d4 937f                      	push r23
0015d5 2f6a                      	mov r22, r26 //store the rate into r22
0015d6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015d7 9f67                      	mul r22, r23
0015d8 917f                      	pop r23
0015d9 916f                      	pop r22
                                 
0015da 9416                      	lsr r1 //shift out the fractional bits
0015db 9407                      	ror r0
0015dc 9416                      	lsr r1
0015dd 9407                      	ror r0
0015de 9416                      	lsr r1
0015df 9407                      	ror r0
0015e0 9416                      	lsr r1
0015e1 9407                      	ror r0
0015e2 9200 2842                 	sts pulse1_fx_2xx, r0
0015e4 9210 2843                 	sts pulse1_fx_2xx+1, r1
0015e6 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0015e7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0015e8 937f                      	push r23
0015e9 2f6a                      	mov r22, r26 //store the rate into r22
0015ea eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0015eb 9f67                      	mul r22, r23
0015ec 917f                      	pop r23
0015ed 916f                      	pop r22
                                 
0015ee 9416                      	lsr r1 //shift out the fractional bits
0015ef 9407                      	ror r0
0015f0 9416                      	lsr r1
0015f1 9407                      	ror r0
0015f2 9416                      	lsr r1
0015f3 9407                      	ror r0
0015f4 9416                      	lsr r1
0015f5 9407                      	ror r0
0015f6 9200 284a                 	sts pulse1_fx_3xx_speed, r0
0015f8 9210 284b                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0015fa 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0015fb c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0015fc cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0015fd 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0015ff 91b0 0a8d                 	lds r27, TCB0_CCMPH
001601 93a0 2846                 	sts pulse1_fx_3xx_start, r26
001603 93b0 2847                 	sts pulse1_fx_3xx_start+1, r27
                                 
001605 9220 284c                 	sts pulse1_fx_3xx_total_offset, zero
001607 9220 284d                 	sts pulse1_fx_3xx_total_offset+1, zero
001609 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
00160a 2fba                      	mov r27, r26
00160b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00160c 95a2                      	swap r26
00160d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
00160e 93a0 284e                 	sts pulse1_fx_4xy_speed, r26
001610 93b0 284f                 	sts pulse1_fx_4xy_depth, r27
001612 9220 2850                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
001614 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
001615 2fba                      	mov r27, r26
001616 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001617 95a2                      	swap r26
001618 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001619 93a0 2851                 	sts pulse1_fx_7xy_speed, r26
00161b 93b0 2852                 	sts pulse1_fx_7xy_depth, r27
00161d 9220 2853                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
00161f 9220 2854                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
001621 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
001622 93a0 2855                 	sts pulse1_fx_Axy, r26
001624 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
001625 93a0 2817                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001627 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
001628 93b0 2818                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00162a cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
00162b 93b0 2819                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00162d cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
00162e 91b0 2800                 	lds r27, pulse1_param
001630 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001631 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001632 93b0 2800                 	sts pulse1_param, r27
001634 6096                      	sbr channel_flags, 6
001635 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
001636 93a0 2816                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001638 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
001639 15a2                      	cp r26, zero
00163a f051                      	breq sound_driver_channel0_fx_Gxx_invalid
00163b 91b0 2816                 	lds r27, song_speed
00163d 17ab                      	cp r26, r27
00163e f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
00163f 93a0 2856                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001641 e0b1                      	ldi r27, 0x01
001642 93b0 281c                 	sts pulse1_pattern_delay_rows, r27
001644 c20d                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
001645 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001646 95a2                      	swap r26
001647 68a8                      	ori r26, 0b10001000 //enable negate and enable sweep flag
001648 2eca                      	mov pulse1_sweep, r26
001649 92c0 2801                 	sts pulse1_sweep_param, pulse1_sweep
00164b 6097                      	sbr channel_flags, 7 //set reload flag
00164c cf33                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
00164d 95a2                      	swap r26
00164e 77af                      	andi r26, 0b01111111 //disable negate flag
00164f 60a8                      	ori r26, 0b00001000 //enable sweep flag
001650 2eca                      	mov pulse1_sweep, r26
001651 92c0 2801                 	sts pulse1_sweep_param, pulse1_sweep
001653 6097                      	sbr channel_flags, 7 //set reload flag
001654 cf2b                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
001655 cf2a                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
001656 cf29                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
001657 93a0 2858                 	sts pulse1_fx_Pxx, r26
001659 cf26                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
00165a 91e0 2825                 	lds ZL, pulse1_arpeggio_macro
00165c 91f0 2826                 	lds ZH, pulse1_arpeggio_macro+1
00165e 9630                      	adiw Z, 0
00165f f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001660 cf1f                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001661 91e0 282c                 	lds ZL, pulse1_pitch_macro
001663 91f0 282d                 	lds ZH, pulse1_pitch_macro+1
001665 9630                      	adiw Z, 0
001666 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001667 cf18                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
001668 91e0 2832                 	lds ZL, pulse1_hi_pitch_macro
00166a 91f0 2833                 	lds ZH, pulse1_hi_pitch_macro+1
00166c 9630                      	adiw Z, 0
00166d f009                      	breq sound_driver_channel0_fx_Qxy_process
00166e cf11                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
00166f 2fba                      	mov r27, r26 //copy fx parameters into r27
001670 70bf                      	andi r27, 0x0F //mask note index offset
001671 91c0 2807                 	lds r28, pulse1_note //load current note index
001673 0fbc                      	add r27, r28
001674 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001675 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001676 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001677 e3e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001678 e0f0                      	ldi ZH, HIGH(note_table << 1)
001679 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
00167a 0feb                      	add ZL, r27 //add offset
00167b 1df2                      	adc ZH, zero
00167c 91c5                      	lpm r28, Z+ //load bytes
00167d 91d4                      	lpm r29, Z
00167e 93c0 2859                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001680 93d0 285a                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001682 95a2                      	swap r26
001683 70af                      	andi r26, 0x0F //mask effect speed
001684 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001685 95a3                      	inc r26 //increment the speed by 1
                                 
001686 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001687 937f                      	push r23
001688 2f6a                      	mov r22, r26 //store the speed data into r27
001689 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00168a 9f67                      	mul r22, r23
00168b 917f                      	pop r23
00168c 916f                      	pop r22
                                 
00168d 9416                      	lsr r1 //shift out the fractional bits
00168e 9407                      	ror r0
00168f 9416                      	lsr r1
001690 9407                      	ror r0
001691 9416                      	lsr r1
001692 9407                      	ror r0
001693 9416                      	lsr r1
001694 9407                      	ror r0
                                 
001695 9200 285b                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001697 9210 285c                 	sts pulse1_fx_Qxy_speed+1, r1
001699 9220 285d                 	sts pulse1_fx_Qxy_total_offset, zero
00169b 9220 285e                 	sts pulse1_fx_Qxy_total_offset+1, zero
00169d cee2                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
00169e 91e0 2825                 	lds ZL, pulse1_arpeggio_macro
0016a0 91f0 2826                 	lds ZH, pulse1_arpeggio_macro+1
0016a2 9630                      	adiw Z, 0
0016a3 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
0016a4 cedb                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
0016a5 91e0 282c                 	lds ZL, pulse1_pitch_macro
0016a7 91f0 282d                 	lds ZH, pulse1_pitch_macro+1
0016a9 9630                      	adiw Z, 0
0016aa f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
0016ab ced4                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
0016ac 91e0 2832                 	lds ZL, pulse1_hi_pitch_macro
0016ae 91f0 2833                 	lds ZH, pulse1_hi_pitch_macro+1
0016b0 9630                      	adiw Z, 0
0016b1 f009                      	breq sound_driver_channel0_fx_Rxy_process
0016b2 cecd                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
0016b3 2fba                      	mov r27, r26 //copy fx parameters into r27
0016b4 70bf                      	andi r27, 0x0F //mask note index offset
0016b5 91c0 2807                 	lds r28, pulse1_note //load current note index
0016b7 1bcb                      	sub r28, r27
0016b8 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
0016b9 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
0016ba e3e8                      	ldi ZL, LOW(note_table << 1) //load in note table
0016bb e0f0                      	ldi ZH, HIGH(note_table << 1)
0016bc 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0016bd 0fec                      	add ZL, r28 //add offset
0016be 1df2                      	adc ZH, zero
0016bf 91c5                      	lpm r28, Z+ //load bytes
0016c0 91d4                      	lpm r29, Z
0016c1 93c0 285f                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0016c3 93d0 2860                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
0016c5 95a2                      	swap r26
0016c6 70af                      	andi r26, 0x0F //mask effect speed
0016c7 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0016c8 95a3                      	inc r26 //increment the speed by 1
                                 
0016c9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0016ca 937f                      	push r23
0016cb 2f6a                      	mov r22, r26 //store the speed data into r27
0016cc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0016cd 9f67                      	mul r22, r23
0016ce 917f                      	pop r23
0016cf 916f                      	pop r22
                                 
0016d0 9416                      	lsr r1 //shift out the fractional bits
0016d1 9407                      	ror r0
0016d2 9416                      	lsr r1
0016d3 9407                      	ror r0
0016d4 9416                      	lsr r1
0016d5 9407                      	ror r0
0016d6 9416                      	lsr r1
0016d7 9407                      	ror r0
                                 
0016d8 9200 2861                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
0016da 9210 2862                 	sts pulse1_fx_Rxy_speed+1, r1
0016dc 9220 2863                 	sts pulse1_fx_Rxy_total_offset, zero
0016de 9220 2864                 	sts pulse1_fx_Rxy_total_offset+1, zero
0016e0 ce9f                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
0016e1 15a2                      	cp r26, zero
0016e2 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
0016e3 91b0 2816                 	lds r27, song_speed
0016e5 17ab                      	cp r26, r27
0016e6 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
0016e7 93a0 2865                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0016e9 e0b1                      	ldi r27, 0x01
0016ea 93b0 281c                 	sts pulse1_pattern_delay_rows, r27
0016ec c165                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
0016ed ce92                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
0016ee e2e2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0016ef e4f5                      	ldi ZH, HIGH(sequences << 1)
0016f0 0fea                      	add ZL, r26 //offset the pointer
0016f1 1df2                      	adc ZH, zero
                                 
0016f2 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0016f3 95a7                      	ror r26
0016f4 95a7                      	ror r26
0016f5 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0016f7 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0016f8 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0016f9 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0016fa c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0016fb ce84                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0016fc 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0016fd 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0016fe 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0016ff 93c0 2800                 	sts pulse1_param, r28
001701 ce7e                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
001702 ce7d                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
001703 ce7c                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
001704 ce7b                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001705 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001706 93b0 2807                 	sts pulse1_note, r27 //store the note index
001708 e0a3                      	ldi r26, 0x03
001709 e0b2                      	ldi r27, 0x02
00170a 93b0 2822                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00170c 93a0 2827                 	sts pulse1_arpeggio_macro_offset, r26
00170e 93b0 282e                 	sts pulse1_pitch_macro_offset, r27
001710 93b0 2834                 	sts pulse1_hi_pitch_macro_offset, r27
001712 93b0 2839                 	sts pulse1_duty_macro_offset, r27
001714 9220 282b                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
001716 9220 2831                 	sts pulse1_total_hi_pitch_offset, zero
001718 9220 2840                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00171a 9220 2841                 	sts pulse1_fx_1xx_total+1, zero
00171c 9220 2844                 	sts pulse1_fx_2xx_total, zero
00171e 9220 2845                 	sts pulse1_fx_2xx_total+1, zero
001720 9220 284c                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001722 9220 284d                 	sts pulse1_fx_3xx_total_offset+1, zero
001724 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001726 91b0 0a8d                 	lds r27, TCB0_CCMPH
001728 93a0 2846                 	sts pulse1_fx_3xx_start, r26
00172a 93b0 2847                 	sts pulse1_fx_3xx_start+1, r27
00172c 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
00172e 6097                      	sbr channel_flags, 7 //set reload flag
00172f 9220 2859                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001731 9220 285a                 	sts pulse1_fx_Qxy_target+1, zero
001733 9220 285d                 	sts pulse1_fx_Qxy_total_offset, zero
001735 9220 285e                 	sts pulse1_fx_Qxy_total_offset+1, zero
001737 9220 285f                 	sts pulse1_fx_Rxy_target, zero
001739 9220 2860                 	sts pulse1_fx_Rxy_target+1, zero
00173b 9220 2863                 	sts pulse1_fx_Rxy_total_offset, zero
00173d 9220 2864                 	sts pulse1_fx_Rxy_total_offset+1, zero
00173f d0fb                      	rcall sound_driver_channel0_increment_offset
001740 ce3f                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001741 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001742 91a0 2800                 	lds r26, pulse1_param
001744 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001745 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001746 93a0 2800                 	sts pulse1_param, r26
001748 6096                      	sbr channel_flags, 6
001749 d0f1                      	rcall sound_driver_channel0_increment_offset
00174a ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
00174b 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00174c 93b0 281c                 	sts pulse1_pattern_delay_rows, r27
00174e d0ec                      	rcall sound_driver_channel0_increment_offset
00174f c102                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001750 9220 2820                 	sts pulse1_volume_macro, zero //reset all macro addresses
001752 9220 2821                 	sts pulse1_volume_macro+1, zero
001754 9220 2825                 	sts pulse1_arpeggio_macro, zero
001756 9220 2826                 	sts pulse1_arpeggio_macro+1, zero
001758 9220 282c                 	sts pulse1_pitch_macro, zero
00175a 9220 282d                 	sts pulse1_pitch_macro+1, zero
00175c 9220 2832                 	sts pulse1_hi_pitch_macro, zero
00175e 9220 2833                 	sts pulse1_hi_pitch_macro+1, zero
001760 9220 2837                 	sts pulse1_duty_macro, zero
001762 9220 2838                 	sts pulse1_duty_macro+1, zero
001764 9220 282b                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001766 9220 2831                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001768 9631                      	adiw Z, 1 //point to the byte next to the flag
001769 91b4                      	lpm r27, Z //store the instrument offset into r27
00176a ece5                      	ldi ZL, LOW(instruments) //point Z to instruments table
00176b e0ff                      	ldi ZH, HIGH(instruments)
00176c 0feb                      	add ZL, r27 //point Z to offsetted instrument
00176d 1df2                      	adc ZH, zero
00176e 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00176f 1fff                      	rol ZH
001770 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001771 91b4                      	lpm r27, Z
                                 
001772 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001773 1fbb                      	rol r27
001774 2fea                      	mov ZL, r26
001775 2ffb                      	mov ZH, r27
001776 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001777 9632                      	adiw Z, 2 //point Z to the address of the macro
001778 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001779 95aa                      	dec r26
00177a f019                      	breq sound_driver_channel0_instrument_change_exit
00177b 95b6                      	lsr r27
00177c f078                      	brcs sound_driver_channel0_instrument_change_load_macro
00177d cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
00177e e0a3                      	ldi r26, 0x03
00177f e0b2                      	ldi r27, 0x02
001780 93b0 2822                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001782 93a0 2827                 	sts pulse1_arpeggio_macro_offset, r26
001784 93b0 282e                 	sts pulse1_pitch_macro_offset, r27
001786 93b0 2834                 	sts pulse1_hi_pitch_macro_offset, r27
001788 93b0 2839                 	sts pulse1_duty_macro_offset, r27
00178a d0ba                      	rcall sound_driver_channel0_increment_offset_twice
00178b cdf4                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
00178c 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
00178d 91d5                      	lpm r29, Z+
                                 
00178e 30a5                      	cpi r26, 5
00178f f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001790 30a4                      	cpi r26, 4
001791 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001792 30a3                      	cpi r26, 3
001793 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001794 30a2                      	cpi r26, 2
001795 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001796 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001797 93c0 2820                 	sts pulse1_volume_macro, r28
001799 93d0 2821                 	sts pulse1_volume_macro+1, r29
00179b d041                      	rcall sound_driver_channel0_instrument_change_read_header
00179c 93c0 2824                 	sts pulse1_volume_macro_release, r28
00179e 93d0 2823                 	sts pulse1_volume_macro_loop, r29
0017a0 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
0017a1 93c0 2825                 	sts pulse1_arpeggio_macro, r28
0017a3 93d0 2826                 	sts pulse1_arpeggio_macro+1, r29
0017a5 9220 2859                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0017a7 9220 285a                 	sts pulse1_fx_Qxy_target+1, zero
0017a9 9220 285f                 	sts pulse1_fx_Rxy_target, zero
0017ab 9220 2860                 	sts pulse1_fx_Rxy_target+1, zero
0017ad d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
0017ae cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
0017af 93c0 282c                 	sts pulse1_pitch_macro, r28
0017b1 93d0 282d                 	sts pulse1_pitch_macro+1, r29
0017b3 9220 2859                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0017b5 9220 285a                 	sts pulse1_fx_Qxy_target+1, zero
0017b7 9220 285f                 	sts pulse1_fx_Rxy_target, zero
0017b9 9220 2860                 	sts pulse1_fx_Rxy_target+1, zero
0017bb d021                      	rcall sound_driver_channel0_instrument_change_read_header
0017bc 93c0 2830                 	sts pulse1_pitch_macro_release, r28
0017be 93d0 282f                 	sts pulse1_pitch_macro_loop, r29
0017c0 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
0017c1 93c0 2832                 	sts pulse1_hi_pitch_macro, r28
0017c3 93d0 2833                 	sts pulse1_hi_pitch_macro+1, r29
0017c5 9220 2859                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0017c7 9220 285a                 	sts pulse1_fx_Qxy_target+1, zero
0017c9 9220 285f                 	sts pulse1_fx_Rxy_target, zero
0017cb 9220 2860                 	sts pulse1_fx_Rxy_target+1, zero
0017cd d00f                      	rcall sound_driver_channel0_instrument_change_read_header
0017ce 93c0 2836                 	sts pulse1_hi_pitch_macro_release, r28
0017d0 93d0 2835                 	sts pulse1_hi_pitch_macro_loop, r29
0017d2 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
0017d3 93c0 2837                 	sts pulse1_duty_macro, r28
0017d5 93d0 2838                 	sts pulse1_duty_macro+1, r29
0017d7 d005                      	rcall sound_driver_channel0_instrument_change_read_header
0017d8 93c0 283b                 	sts pulse1_duty_macro_release, r28
0017da 93d0 283a                 	sts pulse1_duty_macro_loop, r29
0017dc cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
0017dd 93ef                      	push ZL
0017de 93ff                      	push ZH
0017df 2fec                      	mov ZL, r28
0017e0 2ffd                      	mov ZH, r29
0017e1 0fee                      	lsl ZL
0017e2 1fff                      	rol ZH
0017e3 91c5                      	lpm r28, Z+
0017e4 91d4                      	lpm r29, Z
0017e5 91ff                      	pop ZH
0017e6 91ef                      	pop ZL
0017e7 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
0017e8 93ef                      	push ZL
0017e9 93ff                      	push ZH
0017ea 2fec                      	mov ZL, r28
0017eb 2ffd                      	mov ZH, r29
0017ec 0fee                      	lsl ZL
0017ed 1fff                      	rol ZH
0017ee 91c5                      	lpm r28, Z+
0017ef 91d5                      	lpm r29, Z+
0017f0 93c0 2829                 	sts pulse1_arpeggio_macro_release, r28
0017f2 93d0 2828                 	sts pulse1_arpeggio_macro_loop, r29
0017f4 91c4                      	lpm r28, Z
0017f5 93c0 282a                 	sts pulse1_arpeggio_macro_mode, r28
0017f7 91ff                      	pop ZH
0017f8 91ef                      	pop ZL
0017f9 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
0017fa 91b0 2824                 	lds r27, pulse1_volume_macro_release
0017fc 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0017fd f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
0017fe 95b3                      	inc r27
0017ff 93b0 2822                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001801 91b0 2829                 	lds r27, pulse1_arpeggio_macro_release
001803 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001804 f019                      	breq sound_driver_channel0_release_pitch
001805 95b3                      	inc r27
001806 93b0 2827                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001808 91b0 2830                 	lds r27, pulse1_pitch_macro_release
00180a 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00180b f019                      	breq sound_driver_channel0_release_hi_pitch
00180c 95b3                      	inc r27
00180d 93b0 282e                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
00180f 91b0 2836                 	lds r27, pulse1_hi_pitch_macro_release
001811 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001812 f019                      	breq sound_driver_channel0_release_duty
001813 95b3                      	inc r27
001814 93b0 2834                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001816 91b0 283b                 	lds r27, pulse1_duty_macro_release
001818 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001819 f019                      	breq sound_driver_channel0_release_exit
00181a 95b3                      	inc r27
00181b 93b0 2839                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
00181d d01d                      	rcall sound_driver_channel0_increment_offset
00181e cd61                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
00181f 91e0 2810                 	lds ZL, song_frames
001821 91f0 2811                 	lds ZH, song_frames+1
001823 91a0 2812                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001825 91b0 2813                 	lds r27, song_frame_offset+1
001827 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001828 93a0 2812                 	sts song_frame_offset, r26
00182a 93b0 2813                 	sts song_frame_offset+1, r27
00182c 0fea                      	add ZL, r26
00182d 1ffb                      	adc ZH, r27
                                 
00182e 91a5                      	lpm r26, Z+ //load the address of the next pattern
00182f 91b4                      	lpm r27, Z
001830 0faa                      	lsl r26
001831 1fbb                      	rol r27
001832 93a0 281a                 	sts pulse1_pattern, r26
001834 93b0 281b                 	sts pulse1_pattern+1, r27
                                 
001836 9220 281e                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001838 9220 281f                 	sts pulse1_pattern_offset+1, zero
00183a cd45                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
00183b 91e0 281e                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
00183d 91f0 281f                 	lds ZH, pulse1_pattern_offset+1
00183f 9631                      	adiw Z, 1
001840 93e0 281e                 	sts pulse1_pattern_offset, ZL
001842 93f0 281f                 	sts pulse1_pattern_offset+1, ZH
001844 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001845 91e0 281e                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001847 91f0 281f                 	lds ZH, pulse1_pattern_offset+1
001849 9632                      	adiw Z, 2 //increment the pointer twice
00184a 93e0 281e                 	sts pulse1_pattern_offset, ZL
00184c 93f0 281f                 	sts pulse1_pattern_offset+1, ZH
00184e 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
00184f 95ba                      	dec r27
001850 93b0 281d                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
001852 91a0 2869                 	lds r26, pulse2_pattern_delay_rows
001854 91b0 286a                 	lds r27, pulse2_pattern_delay_frames
001856 9610                      	adiw r27:r26, 0
001857 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001858 c2cb                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
001859 91e0 2867                 	lds ZL, pulse2_pattern //current pattern for pulse 2
00185b 91f0 2868                 	lds ZH, pulse2_pattern+1
00185d 91a0 286b                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
00185f 91b0 286c                 	lds r27, pulse2_pattern_offset+1
001861 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001862 1ffb                      	adc ZH, r27
001863 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001864 35b7                      	cpi r27, 0x57
001865 f408                      	brsh sound_driver_channel1_check_if_volume
001866 c178                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001867 36b7                      	cpi r27, 0x67
001868 f408                      	brsh sound_driver_channel1_check_if_delay
001869 c1b0                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
00186a 3eb3                      	cpi r27, 0xE3
00186b f408                      	brsh sound_driver_channel1_check_if_instrument
00186c c1b7                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
00186d f409                      	brne sound_driver_channel1_check_if_release
00186e c1ba                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
00186f 3eb4                      	cpi r27, 0xE4
001870 f409                      	brne sound_driver_channel1_check_if_end
001871 c261                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001872 3fbf                      	cpi r27, 0xFF
001873 f409                      	brne sound_driver_channel1_check_if_fx
001874 c283                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001875 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001876 91a4                      	lpm r26, Z //load the fx data into r26
001877 d2a2                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001878 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001879 e5ea                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
00187a e4f5                      	ldi ZH, HIGH(channel1_fx << 1)
00187b 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00187c 0feb                      	add ZL, r27 //add offset
00187d 1df2                      	adc ZH, zero
00187e 91c5                      	lpm r28, Z+ //load address bytes
00187f 91d4                      	lpm r29, Z
001880 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001881 2ffd                      	mov ZH, r29
001882 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001883 93a0 2889                 	sts pulse2_fx_0xy_sequence, r26
001885 9220 288a                 	sts pulse2_fx_0xy_sequence+1, zero
001887 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001888 9220 288f                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
00188a 9220 2890                 	sts pulse2_fx_2xx+1, zero
00188c 9220 2889                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
00188e 9220 288a                 	sts pulse2_fx_0xy_sequence+1, zero
001890 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001891 937f                      	push r23
001892 2f6a                      	mov r22, r26 //store the rate into r22
001893 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001894 9f67                      	mul r22, r23
001895 917f                      	pop r23
001896 916f                      	pop r22
                                 
001897 9416                      	lsr r1 //shift out the fractional bits
001898 9407                      	ror r0
001899 9416                      	lsr r1
00189a 9407                      	ror r0
00189b 9416                      	lsr r1
00189c 9407                      	ror r0
00189d 9416                      	lsr r1
00189e 9407                      	ror r0
00189f 9200 288b                 	sts pulse2_fx_1xx, r0
0018a1 9210 288c                 	sts pulse2_fx_1xx+1, r1
0018a3 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
0018a4 9220 288b                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
0018a6 9220 288c                 	sts pulse2_fx_1xx+1, zero
0018a8 9220 2889                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
0018aa 9220 288a                 	sts pulse2_fx_0xy_sequence+1, zero
0018ac 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018ad 937f                      	push r23
0018ae 2f6a                      	mov r22, r26 //store the rate into r22
0018af eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018b0 9f67                      	mul r22, r23
0018b1 917f                      	pop r23
0018b2 916f                      	pop r22
                                 
0018b3 9416                      	lsr r1 //shift out the fractional bits
0018b4 9407                      	ror r0
0018b5 9416                      	lsr r1
0018b6 9407                      	ror r0
0018b7 9416                      	lsr r1
0018b8 9407                      	ror r0
0018b9 9416                      	lsr r1
0018ba 9407                      	ror r0
0018bb 9200 288f                 	sts pulse2_fx_2xx, r0
0018bd 9210 2890                 	sts pulse2_fx_2xx+1, r1
0018bf cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
0018c0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018c1 937f                      	push r23
0018c2 2f6a                      	mov r22, r26 //store the rate into r22
0018c3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018c4 9f67                      	mul r22, r23
0018c5 917f                      	pop r23
0018c6 916f                      	pop r22
                                 
0018c7 9416                      	lsr r1 //shift out the fractional bits
0018c8 9407                      	ror r0
0018c9 9416                      	lsr r1
0018ca 9407                      	ror r0
0018cb 9416                      	lsr r1
0018cc 9407                      	ror r0
0018cd 9416                      	lsr r1
0018ce 9407                      	ror r0
0018cf 9200 2897                 	sts pulse2_fx_3xx_speed, r0
0018d1 9210 2898                 	sts pulse2_fx_3xx_speed+1, r1
                                 
0018d3 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0018d4 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
0018d5 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
0018d6 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0018d8 91b0 0a9d                 	lds r27, TCB1_CCMPH
0018da 93a0 2893                 	sts pulse2_fx_3xx_start, r26
0018dc 93b0 2894                 	sts pulse2_fx_3xx_start+1, r27
                                 
0018de 9220 2899                 	sts pulse2_fx_3xx_total_offset, zero
0018e0 9220 289a                 	sts pulse2_fx_3xx_total_offset+1, zero
0018e2 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
0018e3 2fba                      	mov r27, r26
0018e4 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0018e5 95a2                      	swap r26
0018e6 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0018e7 93a0 289b                 	sts pulse2_fx_4xy_speed, r26
0018e9 93b0 289c                 	sts pulse2_fx_4xy_depth, r27
0018eb 9220 289d                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
0018ed cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
0018ee 2fba                      	mov r27, r26
0018ef 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0018f0 95a2                      	swap r26
0018f1 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0018f2 93a0 289e                 	sts pulse2_fx_7xy_speed, r26
0018f4 93b0 289f                 	sts pulse2_fx_7xy_depth, r27
0018f6 9220 28a0                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
0018f8 9220 28a1                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
0018fa cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
0018fb 93a0 28a2                 	sts pulse2_fx_Axy, r26
0018fd cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
0018fe 93a0 2817                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001900 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001901 93b0 2818                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001903 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001904 93b0 2819                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001906 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001907 91b0 2808                 	lds r27, pulse2_param
001909 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
00190a 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
00190b 93b0 2808                 	sts pulse2_param, r27
00190d 6092                      	sbr channel_flags, 2
00190e cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
00190f 93a0 2816                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001911 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001912 15a2                      	cp r26, zero
001913 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001914 91b0 2816                 	lds r27, song_speed
001916 17ab                      	cp r26, r27
001917 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001918 93a0 28a3                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00191a e0b1                      	ldi r27, 0x01
00191b 93b0 2869                 	sts pulse2_pattern_delay_rows, r27
00191d c209                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel1_fx_Gxx_invalid:
00191e cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
00191f 95a2                      	swap r26
001920 68a8                      	ori r26, 0b10001000 //enable negate and enable sweep flag
001921 2efa                      	mov pulse2_sweep, r26
001922 92f0 2809                 	sts pulse2_sweep_param, pulse2_sweep
001924 6093                      	sbr channel_flags, 3 //set reload flag
001925 cf33                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001926 95a2                      	swap r26
001927 77af                      	andi r26, 0b01111111 //disable negate flag
001928 60a8                      	ori r26, 0b00001000 //enable sweep flag
001929 2efa                      	mov pulse2_sweep, r26
00192a 92f0 2809                 	sts pulse2_sweep_param, pulse2_sweep
00192c 6093                      	sbr channel_flags, 3 //set reload flag
00192d cf2b                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
00192e cf2a                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
00192f cf29                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001930 93a0 28a5                 	sts pulse2_fx_Pxx, r26
001932 cf26                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001933 91e0 2872                 	lds ZL, pulse2_arpeggio_macro
001935 91f0 2873                 	lds ZH, pulse2_arpeggio_macro+1
001937 9630                      	adiw Z, 0
001938 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001939 cf1f                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
00193a 91e0 2879                 	lds ZL, pulse2_pitch_macro
00193c 91f0 287a                 	lds ZH, pulse2_pitch_macro+1
00193e 9630                      	adiw Z, 0
00193f f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001940 cf18                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001941 91e0 287f                 	lds ZL, pulse2_hi_pitch_macro
001943 91f0 2880                 	lds ZH, pulse2_hi_pitch_macro+1
001945 9630                      	adiw Z, 0
001946 f009                      	breq sound_driver_channel1_fx_Qxy_process
001947 cf11                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001948 2fba                      	mov r27, r26 //copy fx parameters into r27
001949 70bf                      	andi r27, 0x0F //mask note index offset
00194a 91c0 280f                 	lds r28, pulse2_note //load current note index
00194c 0fbc                      	add r27, r28
00194d 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00194e f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
00194f e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001950 e3e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001951 e0f0                      	ldi ZH, HIGH(note_table << 1)
001952 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001953 0feb                      	add ZL, r27 //add offset
001954 1df2                      	adc ZH, zero
001955 91c5                      	lpm r28, Z+ //load bytes
001956 91d4                      	lpm r29, Z
001957 93c0 28a6                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001959 93d0 28a7                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
00195b 95a2                      	swap r26
00195c 70af                      	andi r26, 0x0F //mask effect speed
00195d 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00195e 95a3                      	inc r26 //increment the speed by 1
                                 
00195f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001960 937f                      	push r23
001961 2f6a                      	mov r22, r26 //store the speed data into r27
001962 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001963 9f67                      	mul r22, r23
001964 917f                      	pop r23
001965 916f                      	pop r22
                                 
001966 9416                      	lsr r1 //shift out the fractional bits
001967 9407                      	ror r0
001968 9416                      	lsr r1
001969 9407                      	ror r0
00196a 9416                      	lsr r1
00196b 9407                      	ror r0
00196c 9416                      	lsr r1
00196d 9407                      	ror r0
                                 
00196e 9200 28a8                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001970 9210 28a9                 	sts pulse2_fx_Qxy_speed+1, r1
001972 9220 28aa                 	sts pulse2_fx_Qxy_total_offset, zero
001974 9220 28ab                 	sts pulse2_fx_Qxy_total_offset+1, zero
001976 cee2                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001977 91e0 2872                 	lds ZL, pulse2_arpeggio_macro
001979 91f0 2873                 	lds ZH, pulse2_arpeggio_macro+1
00197b 9630                      	adiw Z, 0
00197c f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
00197d cedb                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
00197e 91e0 2879                 	lds ZL, pulse2_pitch_macro
001980 91f0 287a                 	lds ZH, pulse2_pitch_macro+1
001982 9630                      	adiw Z, 0
001983 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001984 ced4                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001985 91e0 287f                 	lds ZL, pulse2_hi_pitch_macro
001987 91f0 2880                 	lds ZH, pulse2_hi_pitch_macro+1
001989 9630                      	adiw Z, 0
00198a f009                      	breq sound_driver_channel1_fx_Rxy_process
00198b cecd                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
00198c 2fba                      	mov r27, r26 //copy fx parameters into r27
00198d 70bf                      	andi r27, 0x0F //mask note index offset
00198e 91c0 280f                 	lds r28, pulse2_note //load current note index
001990 1bcb                      	sub r28, r27
001991 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001992 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001993 e3e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001994 e0f0                      	ldi ZH, HIGH(note_table << 1)
001995 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001996 0fec                      	add ZL, r28 //add offset
001997 1df2                      	adc ZH, zero
001998 91c5                      	lpm r28, Z+ //load bytes
001999 91d4                      	lpm r29, Z
00199a 93c0 28ac                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
00199c 93d0 28ad                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
00199e 95a2                      	swap r26
00199f 70af                      	andi r26, 0x0F //mask effect speed
0019a0 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0019a1 95a3                      	inc r26 //increment the speed by 1
                                 
0019a2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019a3 937f                      	push r23
0019a4 2f6a                      	mov r22, r26 //store the speed data into r27
0019a5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019a6 9f67                      	mul r22, r23
0019a7 917f                      	pop r23
0019a8 916f                      	pop r22
                                 
0019a9 9416                      	lsr r1 //shift out the fractional bits
0019aa 9407                      	ror r0
0019ab 9416                      	lsr r1
0019ac 9407                      	ror r0
0019ad 9416                      	lsr r1
0019ae 9407                      	ror r0
0019af 9416                      	lsr r1
0019b0 9407                      	ror r0
                                 
0019b1 9200 28ae                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
0019b3 9210 28af                 	sts pulse2_fx_Rxy_speed+1, r1
0019b5 9220 28b0                 	sts pulse2_fx_Rxy_total_offset, zero
0019b7 9220 28b1                 	sts pulse2_fx_Rxy_total_offset+1, zero
0019b9 ce9f                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
0019ba 15a2                      	cp r26, zero
0019bb f051                      	breq sound_driver_channel1_fx_Sxx_invalid
0019bc 91b0 2816                 	lds r27, song_speed
0019be 17ab                      	cp r26, r27
0019bf f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
0019c0 93a0 28b2                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0019c2 e0b1                      	ldi r27, 0x01
0019c3 93b0 2869                 	sts pulse2_pattern_delay_rows, r27
0019c5 c161                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel1_fx_Sxx_invalid:
0019c6 ce92                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
0019c7 e2e2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0019c8 e4f5                      	ldi ZH, HIGH(sequences << 1)
0019c9 0fea                      	add ZL, r26 //offset the pointer
0019ca 1df2                      	adc ZH, zero
                                 
0019cb 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
0019cc 95a7                      	ror r26
0019cd 95a7                      	ror r26
0019ce 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
0019d0 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
0019d1 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0019d2 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0019d3 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
0019d4 ce84                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
0019d5 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
0019d6 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0019d7 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0019d8 93c0 2808                 	sts pulse2_param, r28
0019da ce7e                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
0019db ce7d                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
0019dc ce7c                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
0019dd ce7b                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
0019de ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
0019df 93b0 280f                 	sts pulse2_note, r27 //store the note index
0019e1 e0a3                      	ldi r26, 0x03
0019e2 e0b2                      	ldi r27, 0x02
0019e3 93b0 286f                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
0019e5 93a0 2874                 	sts pulse2_arpeggio_macro_offset, r26
0019e7 93b0 287b                 	sts pulse2_pitch_macro_offset, r27
0019e9 93b0 2881                 	sts pulse2_hi_pitch_macro_offset, r27
0019eb 93b0 2886                 	sts pulse2_duty_macro_offset, r27
0019ed 9220 2878                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
0019ef 9220 287e                 	sts pulse2_total_hi_pitch_offset, zero
0019f1 9220 288d                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0019f3 9220 288e                 	sts pulse2_fx_1xx_total+1, zero
0019f5 9220 2891                 	sts pulse2_fx_2xx_total, zero
0019f7 9220 2892                 	sts pulse2_fx_2xx_total+1, zero
0019f9 9220 2899                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
0019fb 9220 289a                 	sts pulse2_fx_3xx_total_offset+1, zero
0019fd 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0019ff 91b0 0a9d                 	lds r27, TCB1_CCMPH
001a01 93a0 2893                 	sts pulse2_fx_3xx_start, r26
001a03 93b0 2894                 	sts pulse2_fx_3xx_start+1, r27
001a05 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001a07 6093                      	sbr channel_flags, 3 //set reload flag
001a08 9220 28a6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a0a 9220 28a7                 	sts pulse2_fx_Qxy_target+1, zero
001a0c 9220 28aa                 	sts pulse2_fx_Qxy_total_offset, zero
001a0e 9220 28ab                 	sts pulse2_fx_Qxy_total_offset+1, zero
001a10 9220 28ac                 	sts pulse2_fx_Rxy_target, zero
001a12 9220 28ad                 	sts pulse2_fx_Rxy_target+1, zero
001a14 9220 28b0                 	sts pulse2_fx_Rxy_total_offset, zero
001a16 9220 28b1                 	sts pulse2_fx_Rxy_total_offset+1, zero
001a18 d0f7                      	rcall sound_driver_channel1_increment_offset
001a19 ce3f                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001a1a 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001a1b 91a0 2808                 	lds r26, pulse2_param
001a1d 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001a1e 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001a1f 93a0 2808                 	sts pulse2_param, r26
001a21 6092                      	sbr channel_flags, 2
001a22 d0ed                      	rcall sound_driver_channel1_increment_offset
001a23 ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001a24 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001a25 93b0 2869                 	sts pulse2_pattern_delay_rows, r27
001a27 d0e8                      	rcall sound_driver_channel1_increment_offset
001a28 c0fe                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001a29 9220 286d                 	sts pulse2_volume_macro, zero //reset all macro addresses
001a2b 9220 286e                 	sts pulse2_volume_macro+1, zero
001a2d 9220 2872                 	sts pulse2_arpeggio_macro, zero
001a2f 9220 2873                 	sts pulse2_arpeggio_macro+1, zero
001a31 9220 2879                 	sts pulse2_pitch_macro, zero
001a33 9220 287a                 	sts pulse2_pitch_macro+1, zero
001a35 9220 287f                 	sts pulse2_hi_pitch_macro, zero
001a37 9220 2880                 	sts pulse2_hi_pitch_macro+1, zero
001a39 9220 2884                 	sts pulse2_duty_macro, zero
001a3b 9220 2885                 	sts pulse2_duty_macro+1, zero
001a3d 9220 2878                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001a3f 9220 287e                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001a41 9631                      	adiw Z, 1 //point to the byte next to the flag
001a42 91b4                      	lpm r27, Z //store the instrument offset into r27
001a43 ece5                      	ldi ZL, LOW(instruments) //point Z to instruments table
001a44 e0ff                      	ldi ZH, HIGH(instruments)
001a45 0feb                      	add ZL, r27 //point Z to offsetted instrument
001a46 1df2                      	adc ZH, zero
001a47 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001a48 1fff                      	rol ZH
001a49 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001a4a 91b4                      	lpm r27, Z
                                 
001a4b 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001a4c 1fbb                      	rol r27
001a4d 2fea                      	mov ZL, r26
001a4e 2ffb                      	mov ZH, r27
001a4f 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001a50 9632                      	adiw Z, 2 //point Z to the address of the macro
001a51 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001a52 95aa                      	dec r26
001a53 f019                      	breq sound_driver_channel1_instrument_change_exit
001a54 95b6                      	lsr r27
001a55 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001a56 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001a57 e0a3                      	ldi r26, 0x03
001a58 e0b2                      	ldi r27, 0x02
001a59 93b0 286f                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001a5b 93a0 2874                 	sts pulse2_arpeggio_macro_offset, r26
001a5d 93b0 287b                 	sts pulse2_pitch_macro_offset, r27
001a5f 93b0 2881                 	sts pulse2_hi_pitch_macro_offset, r27
001a61 93b0 2886                 	sts pulse2_duty_macro_offset, r27
001a63 d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001a64 cdf4                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001a65 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001a66 91d5                      	lpm r29, Z+
                                 
001a67 30a5                      	cpi r26, 5
001a68 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001a69 30a4                      	cpi r26, 4
001a6a f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001a6b 30a3                      	cpi r26, 3
001a6c f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001a6d 30a2                      	cpi r26, 2
001a6e f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001a6f c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001a70 93c0 286d                 	sts pulse2_volume_macro, r28
001a72 93d0 286e                 	sts pulse2_volume_macro+1, r29
001a74 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001a75 93c0 2871                 	sts pulse2_volume_macro_release, r28
001a77 93d0 2870                 	sts pulse2_volume_macro_loop, r29
001a79 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001a7a 93c0 2872                 	sts pulse2_arpeggio_macro, r28
001a7c 93d0 2873                 	sts pulse2_arpeggio_macro+1, r29
001a7e 9220 28a6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a80 9220 28a7                 	sts pulse2_fx_Qxy_target+1, zero
001a82 9220 28ac                 	sts pulse2_fx_Rxy_target, zero
001a84 9220 28ad                 	sts pulse2_fx_Rxy_target+1, zero
001a86 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001a87 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001a88 93c0 2879                 	sts pulse2_pitch_macro, r28
001a8a 93d0 287a                 	sts pulse2_pitch_macro+1, r29
001a8c 9220 28a6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a8e 9220 28a7                 	sts pulse2_fx_Qxy_target+1, zero
001a90 9220 28ac                 	sts pulse2_fx_Rxy_target, zero
001a92 9220 28ad                 	sts pulse2_fx_Rxy_target+1, zero
001a94 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001a95 93c0 287d                 	sts pulse2_pitch_macro_release, r28
001a97 93d0 287c                 	sts pulse2_pitch_macro_loop, r29
001a99 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001a9a 93c0 287f                 	sts pulse2_hi_pitch_macro, r28
001a9c 93d0 2880                 	sts pulse2_hi_pitch_macro+1, r29
001a9e 9220 28a6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001aa0 9220 28a7                 	sts pulse2_fx_Qxy_target+1, zero
001aa2 9220 28ac                 	sts pulse2_fx_Rxy_target, zero
001aa4 9220 28ad                 	sts pulse2_fx_Rxy_target+1, zero
001aa6 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001aa7 93c0 2883                 	sts pulse2_hi_pitch_macro_release, r28
001aa9 93d0 2882                 	sts pulse2_hi_pitch_macro_loop, r29
001aab cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001aac 93c0 2884                 	sts pulse2_duty_macro, r28
001aae 93d0 2885                 	sts pulse2_duty_macro+1, r29
001ab0 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001ab1 93c0 2888                 	sts pulse2_duty_macro_release, r28
001ab3 93d0 2887                 	sts pulse2_duty_macro_loop, r29
001ab5 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001ab6 93ef                      	push ZL
001ab7 93ff                      	push ZH
001ab8 2fec                      	mov ZL, r28
001ab9 2ffd                      	mov ZH, r29
001aba 0fee                      	lsl ZL
001abb 1fff                      	rol ZH
001abc 91c5                      	lpm r28, Z+
001abd 91d4                      	lpm r29, Z
001abe 91ff                      	pop ZH
001abf 91ef                      	pop ZL
001ac0 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001ac1 93ef                      	push ZL
001ac2 93ff                      	push ZH
001ac3 2fec                      	mov ZL, r28
001ac4 2ffd                      	mov ZH, r29
001ac5 0fee                      	lsl ZL
001ac6 1fff                      	rol ZH
001ac7 91c5                      	lpm r28, Z+
001ac8 91d5                      	lpm r29, Z+
001ac9 93c0 2876                 	sts pulse2_arpeggio_macro_release, r28
001acb 93d0 2875                 	sts pulse2_arpeggio_macro_loop, r29
001acd 91c4                      	lpm r28, Z
001ace 93c0 2877                 	sts pulse2_arpeggio_macro_mode, r28
001ad0 91ff                      	pop ZH
001ad1 91ef                      	pop ZL
001ad2 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001ad3 91b0 2871                 	lds r27, pulse2_volume_macro_release
001ad5 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001ad6 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001ad7 95b3                      	inc r27
001ad8 93b0 286f                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001ada 91b0 2876                 	lds r27, pulse2_arpeggio_macro_release
001adc 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001add f019                      	breq sound_driver_channel1_release_pitch
001ade 95b3                      	inc r27
001adf 93b0 2874                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001ae1 91b0 287d                 	lds r27, pulse2_pitch_macro_release
001ae3 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001ae4 f019                      	breq sound_driver_channel1_release_hi_pitch
001ae5 95b3                      	inc r27
001ae6 93b0 287b                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001ae8 91b0 2883                 	lds r27, pulse2_hi_pitch_macro_release
001aea 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001aeb f019                      	breq sound_driver_channel1_release_duty
001aec 95b3                      	inc r27
001aed 93b0 2881                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001aef 91b0 2888                 	lds r27, pulse2_duty_macro_release
001af1 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001af2 f019                      	breq sound_driver_channel1_release_exit
001af3 95b3                      	inc r27
001af4 93b0 2886                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001af6 d019                      	rcall sound_driver_channel1_increment_offset
001af7 cd61                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001af8 91e0 2810                 	lds ZL, song_frames
001afa 91f0 2811                 	lds ZH, song_frames+1
001afc 91a0 2812                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001afe 91b0 2813                 	lds r27, song_frame_offset+1
001b00 9612                      	adiw r27:r26, 2 //offset for channel 1
001b01 0fea                      	add ZL, r26
001b02 1ffb                      	adc ZH, r27
                                 
001b03 91a5                      	lpm r26, Z+ //load the address of the next pattern
001b04 91b4                      	lpm r27, Z
001b05 0faa                      	lsl r26
001b06 1fbb                      	rol r27
001b07 93a0 2867                 	sts pulse2_pattern, r26
001b09 93b0 2868                 	sts pulse2_pattern+1, r27
                                 
001b0b 9220 286b                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001b0d 9220 286c                 	sts pulse2_pattern_offset+1, zero
001b0f cd49                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001b10 91e0 286b                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001b12 91f0 286c                 	lds ZH, pulse2_pattern_offset+1
001b14 9631                      	adiw Z, 1
001b15 93e0 286b                 	sts pulse2_pattern_offset, ZL
001b17 93f0 286c                 	sts pulse2_pattern_offset+1, ZH
001b19 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001b1a 91e0 286b                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001b1c 91f0 286c                 	lds ZH, pulse2_pattern_offset+1
001b1e 9632                      	adiw Z, 2 //increment the pointer twice
001b1f 93e0 286b                 	sts pulse2_pattern_offset, ZL
001b21 93f0 286c                 	sts pulse2_pattern_offset+1, ZH
001b23 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001b24 95ba                      	dec r27
001b25 93b0 286a                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 sound_driver_calculate_delays:
001b27 91f0 2816                 	lds r31, song_speed
001b29 2fef                      	mov r30, r31
001b2a 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
001b2b 91a0 281d                 	lds r26, pulse1_pattern_delay_frames
001b2d 11a2                      	cpse r26, zero
001b2e c042                      	rjmp sound_driver_calculate_delays_pulse2
001b2f c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
001b30 2faf                      	mov r26, r31 //move the speed to r26
001b31 91b0 281c                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
001b33 15b2                      	cp r27, zero
001b34 f409                      	brne PC+2
001b35 c03b                      	rjmp sound_driver_calculate_delays_pulse2
001b36 95ba                      	dec r27
001b37 93b0 281c                 	sts pulse1_pattern_delay_rows, r27
001b39 11b2                      	cpse r27, zero
001b3a c034                      	rjmp sound_driver_calculate_delays_pulse1_store
001b3b 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
001b3c efbf                      	ldi r27, 0xFF
001b3d 91c0 2865                 	lds r28, pulse1_fx_Sxx_pre
001b3f 91d0 2866                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
001b41 17cb                      	cp r28, r27
001b42 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
001b43 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
001b44 17db                      	cp r29, r27
001b45 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
001b46 c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
001b47 91c0 2856                 	lds r28, pulse1_fx_Gxx_pre
001b49 91d0 2857                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
001b4b 17cb                      	cp r28, r27
001b4c f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
001b4d c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
001b4e 17db                      	cp r29, r27
001b4f f0f9                      	breq sound_driver_calculate_delays_pulse1_store
001b50 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
001b51 93b0 2865                 	sts pulse1_fx_Sxx_pre, r27
001b53 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001b54 93e0 2866                 	sts pulse1_fx_Sxx_post, r30
001b56 95ca                      	dec r28
001b57 93c0 281d                 	sts pulse1_pattern_delay_frames, r28
001b59 2fef                      	mov r30, r31
001b5a 50e1                      	subi r30, 1
001b5b c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
001b5c 93b0 2866                 	sts pulse1_fx_Sxx_post, r27
001b5e 2fad                      	mov r26, r29
001b5f c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
001b60 93b0 2856                 	sts pulse1_fx_Gxx_pre, r27
001b62 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001b63 93e0 2857                 	sts pulse1_fx_Gxx_post, r30
001b65 95ca                      	dec r28
001b66 93c0 281d                 	sts pulse1_pattern_delay_frames, r28
001b68 2fef                      	mov r30, r31
001b69 50e1                      	subi r30, 1
001b6a c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
001b6b 93b0 2857                 	sts pulse1_fx_Gxx_post, r27
001b6d 2fad                      	mov r26, r29
001b6e c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
001b6f 93a0 281d                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
001b71 91a0 286a                 	lds r26, pulse2_pattern_delay_frames
001b73 11a2                      	cpse r26, zero
001b74 c042                      	rjmp sound_driver_calculate_delays_triangle
001b75 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
001b76 2faf                      	mov r26, r31 //move the speed to r26
001b77 91b0 2869                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
001b79 15b2                      	cp r27, zero
001b7a f409                      	brne PC+2
001b7b c03b                      	rjmp sound_driver_calculate_delays_triangle
001b7c 95ba                      	dec r27
001b7d 93b0 2869                 	sts pulse2_pattern_delay_rows, r27
001b7f 11b2                      	cpse r27, zero
001b80 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
001b81 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
001b82 efbf                      	ldi r27, 0xFF
001b83 91c0 28b2                 	lds r28, pulse2_fx_Sxx_pre
001b85 91d0 28b3                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
001b87 17cb                      	cp r28, r27
001b88 f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
001b89 c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
001b8a 17db                      	cp r29, r27
001b8b f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
001b8c c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
001b8d 91c0 28a3                 	lds r28, pulse2_fx_Gxx_pre
001b8f 91d0 28a4                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
001b91 17cb                      	cp r28, r27
001b92 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
001b93 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
001b94 17db                      	cp r29, r27
001b95 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
001b96 c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
001b97 93b0 28b2                 	sts pulse2_fx_Sxx_pre, r27
001b99 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001b9a 93e0 28b3                 	sts pulse2_fx_Sxx_post, r30
001b9c 95ca                      	dec r28
001b9d 93c0 286a                 	sts pulse2_pattern_delay_frames, r28
001b9f 2fef                      	mov r30, r31
001ba0 50e1                      	subi r30, 1
001ba1 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
001ba2 93b0 28b3                 	sts pulse2_fx_Sxx_post, r27
001ba4 2fad                      	mov r26, r29
001ba5 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
001ba6 93b0 28a3                 	sts pulse2_fx_Gxx_pre, r27
001ba8 1bec                      	sub r30, r28 //(song speed)-1-Sxx
001ba9 93e0 28a4                 	sts pulse2_fx_Gxx_post, r30
001bab 95ca                      	dec r28
001bac 93c0 286a                 	sts pulse2_pattern_delay_frames, r28
001bae 2fef                      	mov r30, r31
001baf 50e1                      	subi r30, 1
001bb0 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
001bb1 93b0 28a4                 	sts pulse2_fx_Gxx_post, r27
001bb3 2fad                      	mov r26, r29
001bb4 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
001bb5 93a0 286a                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
                                 
                                 
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
001bb7 91e0 2820                 	lds ZL, pulse1_volume_macro
001bb9 91f0 2821                 	lds ZH, pulse1_volume_macro+1
001bbb 9630                      	adiw Z, 0
001bbc f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
001bbd 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001bbe 1fff                      	rol ZH
001bbf 91a0 2822                 	lds r26, pulse1_volume_macro_offset
001bc1 0fea                      	add ZL, r26
001bc2 1df2                      	adc ZH, zero
                                 
001bc3 91b0 2824                 	lds r27, pulse1_volume_macro_release
001bc5 17ba                      	cp r27, r26
001bc6 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
001bc7 91a0 2823                 	lds r26, pulse1_volume_macro_loop
001bc9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001bca f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001bcb c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
001bcc 95a3                      	inc r26 //increment the macro offset
001bcd 93a0 2822                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
001bcf 91b4                      	lpm r27, Z //load volume data into r27
001bd0 3fbf                      	cpi r27, 0xFF //check for macro end flag
001bd1 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
001bd2 91b0 2824                 	lds r27, pulse1_volume_macro_release
001bd4 3fbf                      	cpi r27, 0xFF
001bd5 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
001bd6 91b0 2823                 	lds r27, pulse1_volume_macro_loop //load the loop index
001bd8 93b0 2822                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
001bda cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
001bdb 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
001bdc 93a0 2822                 	sts pulse1_volume_macro_offset, r26
001bde cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
001bdf e8ee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
001be0 e4f5                      	ldi ZH, HIGH(volumes << 1)
001be1 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
001be2 0feb                      	add ZL, r27 //add offset to the table
001be3 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
001be4 91b0 2800                 	lds r27, pulse1_param //load main volume
001be6 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001be7 91a0 2854                 	lds r26, pulse1_fx_7xy_value
001be9 30a0                      	cpi r26, 0x00
001bea f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
001beb 0feb                      	add ZL, r27 //offset the volume table by the main volume
001bec 1df2                      	adc ZH, zero
001bed 91b4                      	lpm r27, Z
001bee 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001bf0 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
001bf1 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
001bf3 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001bf4 91a0 2854                 	lds r26, pulse1_fx_7xy_value
001bf6 30a0                      	cpi r26, 0x00
001bf7 f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
001bf8 93b0 2806                 	sts pulse1_output_volume, r27
001bfa c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
001bfb 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001bfc f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
001bfd f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
001bfe e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
001bff 0feb                      	add ZL, r27 //offset the volume table by the main volume
001c00 1df2                      	adc ZH, zero
001c01 91b4                      	lpm r27, Z
001c02 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001c04 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
001c05 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001c06 0feb                      	add ZL, r27 //offset the volume table by the main volume
001c07 1df2                      	adc ZH, zero
001c08 91b4                      	lpm r27, Z
001c09 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001c0b c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
001c0c 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001c0d f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001c0e f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001c0f 93b0 2806                 	sts pulse1_output_volume, r27
001c11 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
001c12 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001c13 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001c15 91e0 2825                 	lds ZL, pulse1_arpeggio_macro
001c17 91f0 2826                 	lds ZH, pulse1_arpeggio_macro+1
001c19 9630                      	adiw Z, 0
001c1a f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
001c1b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001c1c 1fff                      	rol ZH
001c1d 91a0 2827                 	lds r26, pulse1_arpeggio_macro_offset
001c1f 0fea                      	add ZL, r26
001c20 1df2                      	adc ZH, zero
                                 
001c21 91b0 2829                 	lds r27, pulse1_arpeggio_macro_release
001c23 17ba                      	cp r27, r26
001c24 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
001c25 91a0 2828                 	lds r26, pulse1_arpeggio_macro_loop
001c27 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001c28 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
001c29 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
001c2a 95a3                      	inc r26 //increment the macro offset
001c2b 93a0 2827                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
001c2d 91b4                      	lpm r27, Z //load arpeggio data into r27
001c2e 38b0                      	cpi r27, 0x80 //check for macro end flag
001c2f f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
001c30 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
001c31 50a1                      	subi r26, 1 //keep the offset at the end flag
001c32 93a0 2827                 	sts pulse1_arpeggio_macro_offset, r26
001c34 91b0 282a                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001c36 30b1                      	cpi r27, 0x01
001c37 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
001c38 91b0 2829                 	lds r27, pulse1_arpeggio_macro_release
001c3a 3fbf                      	cpi r27, 0xFF
001c3b f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
001c3c 91b0 2828                 	lds r27, pulse1_arpeggio_macro_loop
001c3e 3fbf                      	cpi r27, 0xFF
001c3f f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
001c40 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
001c41 91b0 2829                 	lds r27, pulse1_arpeggio_macro_release
001c43 3fbf                      	cpi r27, 0xFF
001c44 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
001c45 91b0 2828                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
001c47 3fbf                      	cpi r27, 0xFF //check if loop flag exists
001c48 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
001c49 91c0 283c                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
001c4b 91d0 283d                 	lds r29, pulse1_fx_0xy_sequence+1
001c4d 9620                      	adiw r29:r28, 0
001c4e f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
001c4f 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
001c50 93a0 2827                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
001c52 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
001c53 93b0 2827                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
001c55 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
001c56 91c0 283c                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
001c58 91d0 283d                 	lds r29, pulse1_fx_0xy_sequence+1
001c5a 9620                      	adiw r29:r28, 0 //check for 0xy effect
001c5b f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
001c5c 95d6                      	lsr r29
001c5d 95c7                      	ror r28
001c5e 95d7                      	ror r29
001c5f 95c7                      	ror r28
001c60 95d7                      	ror r29
001c61 95c7                      	ror r28
001c62 95d7                      	ror r29
001c63 95c7                      	ror r28
001c64 95d7                      	ror r29
001c65 95d2                      	swap r29
                                 
001c66 93c0 283c                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
001c68 93d0 283d                 	sts pulse1_fx_0xy_sequence+1, r29
001c6a 70cf                      	andi r28, 0x0F //mask out the 4 LSB
001c6b 91a0 2807                 	lds r26, pulse1_note //load the current note index
001c6d 0fac                      	add r26, r28 //add the note offset
001c6e c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
001c6f 91a0 2807                 	lds r26, pulse1_note //load the current note index
001c71 c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
001c72 9220 282b                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
001c74 9220 2831                 	sts pulse1_total_hi_pitch_offset, zero
001c76 91a0 282a                 	lds r26, pulse1_arpeggio_macro_mode
001c78 30a1                      	cpi r26, 0x01 //absolute mode
001c79 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
001c7a f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
001c7b c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
001c7c 91a0 2807                 	lds r26, pulse1_note //load the current note index
001c7e 0fab                      	add r26, r27 //offset the note with the arpeggio data
001c7f fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001c80 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
001c81 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001c82 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
001c83 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001c84 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
001c85 fda7                      	sbrc r26, 7 //check if result is negative
001c86 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001c87 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
001c88 2fab                      	mov r26, r27 //move the arpeggio data into r26
001c89 c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
001c8a 91a0 2807                 	lds r26, pulse1_note //load the current note index
001c8c 0fab                      	add r26, r27 //offset the note with the arpeggio data
001c8d fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001c8e c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
001c8f 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
001c91 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001c92 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
001c93 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001c94 93a0 2807                 	sts pulse1_note, r26
001c96 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
001c97 fda7                      	sbrc r26, 7 //check if result is negative
001c98 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001c99 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
001c9b e3e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001c9c e0f0                      	ldi ZH, HIGH(note_table << 1)
001c9d 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
001c9e 0fea                      	add ZL, r26 //add offset
001c9f 1df2                      	adc ZH, zero
001ca0 91a5                      	lpm r26, Z+ //load bytes
001ca1 91b4                      	lpm r27, Z
001ca2 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
001ca4 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
001ca6 93a0 2848                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
001ca8 93b0 2849                 	sts pulse1_fx_3xx_target+1, r27
001caa c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
001cab 91e0 282c                 	lds ZL, pulse1_pitch_macro
001cad 91f0 282d                 	lds ZH, pulse1_pitch_macro+1
001caf 9630                      	adiw Z, 0
001cb0 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
001cb1 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
001cb2 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001cb3 1fff                      	rol ZH
001cb4 91a0 282e                 	lds r26, pulse1_pitch_macro_offset
001cb6 0fea                      	add ZL, r26
001cb7 1df2                      	adc ZH, zero
                                 
001cb8 91b0 2830                 	lds r27, pulse1_pitch_macro_release
001cba 17ba                      	cp r27, r26
001cbb f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
001cbc 91a0 282f                 	lds r26, pulse1_pitch_macro_loop
001cbe 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001cbf f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001cc0 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
001cc1 95a3                      	inc r26 //increment the macro offset
001cc2 93a0 282e                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
001cc4 91b4                      	lpm r27, Z //load pitch data into r27
001cc5 38b0                      	cpi r27, 0x80 //check for macro end flag
001cc6 f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
001cc7 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001cc8 93a0 282e                 	sts pulse1_pitch_macro_offset, r26
001cca 91b0 2830                 	lds r27, pulse1_pitch_macro_release
001ccc 3fbf                      	cpi r27, 0xFF
001ccd f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
001cce 91b0 282f                 	lds r27, pulse1_pitch_macro_loop //load the loop index
001cd0 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001cd1 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
001cd2 93b0 282e                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
001cd4 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
001cd5 91b0 282b                 	lds r27, pulse1_total_pitch_offset
001cd7 c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
001cd8 91a0 282b                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
001cda 0fba                      	add r27, r26
001cdb 93b0 282b                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
001cdd 91a0 2858                 	lds r26, pulse1_fx_Pxx
001cdf 0fba                      	add r27, r26
                                 
001ce0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ce1 937f                      	push r23
001ce2 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
001ce3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ce4 0367                      	mulsu r22, r23
001ce5 917f                      	pop r23
001ce6 916f                      	pop r22
                                 
001ce7 9416                      	lsr r1 //shift out the fractional bits
001ce8 9407                      	ror r0
001ce9 9416                      	lsr r1
001cea 9407                      	ror r0
001ceb 9416                      	lsr r1
001cec 9407                      	ror r0
001ced 9416                      	lsr r1
001cee 9407                      	ror r0
001cef fe13                      	sbrs r1, 3 //check if result was a negative number
001cf0 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
001cf1 efb0                      	ldi r27, 0xF0
001cf2 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
001cf3 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
001cf5 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
001cf7 0da0                      	add r26, r0 //offset the timer values
001cf8 1db1                      	adc r27, r1
                                 	
001cf9 91c0 2840                 	lds r28, pulse1_fx_1xx_total
001cfb 91d0 2841                 	lds r29, pulse1_fx_1xx_total+1
001cfd 1bac                      	sub r26, r28
001cfe 0bbd                      	sbc r27, r29
001cff 91c0 2844                 	lds r28, pulse1_fx_2xx_total
001d01 91d0 2845                 	lds r29, pulse1_fx_2xx_total+1
001d03 0fac                      	add r26, r28
001d04 1fbd                      	adc r27, r29
001d05 91c0 285d                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
001d07 91d0 285e                 	lds r29, pulse1_fx_Qxy_total_offset+1
001d09 1bac                      	sub r26, r28
001d0a 0bbd                      	sbc r27, r29
001d0b 91c0 2863                 	lds r28, pulse1_fx_Rxy_total_offset
001d0d 91d0 2864                 	lds r29, pulse1_fx_Rxy_total_offset+1
001d0f 0fac                      	add r26, r28
001d10 1fbd                      	adc r27, r29
                                 
001d11 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
001d13 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
001d15 91e0 2832                 	lds ZL, pulse1_hi_pitch_macro
001d17 91f0 2833                 	lds ZH, pulse1_hi_pitch_macro+1
001d19 9630                      	adiw Z, 0
001d1a f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
001d1b c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
001d1c 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001d1d 1fff                      	rol ZH
001d1e 91a0 2834                 	lds r26, pulse1_hi_pitch_macro_offset
001d20 0fea                      	add ZL, r26
001d21 1df2                      	adc ZH, zero
                                 
001d22 91b0 2836                 	lds r27, pulse1_hi_pitch_macro_release
001d24 17ba                      	cp r27, r26
001d25 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
001d26 91a0 2835                 	lds r26, pulse1_hi_pitch_macro_loop
001d28 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001d29 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001d2a c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
001d2b 95a3                      	inc r26 //increment the macro offset
001d2c 93a0 2834                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
001d2e 91b4                      	lpm r27, Z //load hi pitch data into r27
001d2f 38b0                      	cpi r27, 0x80 //check for macro end flag
001d30 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
001d31 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001d32 93a0 2834                 	sts pulse1_hi_pitch_macro_offset, r26
001d34 91b0 2836                 	lds r27, pulse1_hi_pitch_macro_release
001d36 3fbf                      	cpi r27, 0xFF
001d37 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
001d38 91b0 2835                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
001d3a 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001d3b f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
001d3c 93b0 2834                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
001d3e cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
001d3f 91b0 2831                 	lds r27, pulse1_total_hi_pitch_offset
001d41 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
001d42 91a0 2831                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
001d44 0fba                      	add r27, r26
001d45 93b0 2831                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
001d47 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d48 937f                      	push r23
001d49 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
001d4a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d4b 0367                      	mulsu r22, r23
001d4c 917f                      	pop r23
001d4d 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
001d4e 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
001d50 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
001d52 0da0                      	add r26, r0 //offset the timer values
001d53 1db1                      	adc r27, r1
001d54 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
001d56 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
001d58 91e0 2837                 	lds ZL, pulse1_duty_macro
001d5a 91f0 2838                 	lds ZH, pulse1_duty_macro+1
001d5c 9630                      	adiw Z, 0
001d5d f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
001d5e 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001d5f 1fff                      	rol ZH
001d60 91a0 2839                 	lds r26, pulse1_duty_macro_offset
001d62 0fea                      	add ZL, r26
001d63 1df2                      	adc ZH, zero
                                 
001d64 91b0 283b                 	lds r27, pulse1_duty_macro_release
001d66 17ba                      	cp r27, r26
001d67 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
001d68 91a0 283a                 	lds r26, pulse1_duty_macro_loop
001d6a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001d6b f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001d6c c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
001d6d 95a3                      	inc r26 //increment the macro offset
001d6e 93a0 2839                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
001d70 91b4                      	lpm r27, Z //load pitch data into r27
001d71 3fbf                      	cpi r27, 0xFF //check for macro end flag
001d72 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
001d73 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001d74 93a0 2839                 	sts pulse1_duty_macro_offset, r26
001d76 91b0 283b                 	lds r27, pulse1_duty_macro_release
001d78 3fbf                      	cpi r27, 0xFF
001d79 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
001d7a 91b0 283a                 	lds r27, pulse1_duty_macro_loop //load the loop index
001d7c 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001d7d f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
001d7e 93b0 2839                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
001d80 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
001d81 e2e2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001d82 e4f5                      	ldi ZH, HIGH(sequences << 1)
001d83 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
001d84 1df2                      	adc ZH, zero
                                 
001d85 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
001d86 95b7                      	ror r27
001d87 95b7                      	ror r27
001d88 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
001d8a 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
001d8b 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
001d8c 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
001d8d c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
001d8e c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
001d8f 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001d90 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001d91 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001d92 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
001d94 91e0 283e                 	lds ZL, pulse1_fx_1xx
001d96 91f0 283f                 	lds ZH, pulse1_fx_1xx+1
001d98 9630                      	adiw Z, 0
001d99 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
001d9a 91a0 2840                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
001d9c 91b0 2841                 	lds r27, pulse1_fx_1xx_total+1
001d9e 0fae                      	add r26, ZL //increase the total offset by the rate
001d9f 1fbf                      	adc r27, ZH
001da0 93a0 2840                 	sts pulse1_fx_1xx_total, r26
001da2 93b0 2841                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
001da4 91e0 2842                 	lds ZL, pulse1_fx_2xx
001da6 91f0 2843                 	lds ZH, pulse1_fx_2xx+1
001da8 9630                      	adiw Z, 0
001da9 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
001daa 91a0 2844                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
001dac 91b0 2845                 	lds r27, pulse1_fx_2xx_total+1
001dae 0fae                      	add r26, ZL //increase the total offset by the rate
001daf 1fbf                      	adc r27, ZH
001db0 93a0 2844                 	sts pulse1_fx_2xx_total, r26
001db2 93b0 2845                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
001db4 91e0 284a                 	lds ZL, pulse1_fx_3xx_speed
001db6 91f0 284b                 	lds ZH, pulse1_fx_3xx_speed+1
001db8 9630                      	adiw Z, 0
001db9 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
001dba c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
001dbb 91a0 2846                 	lds r26, pulse1_fx_3xx_start
001dbd 91b0 2847                 	lds r27, pulse1_fx_3xx_start+1
001dbf 9610                      	adiw r26:r27, 0
001dc0 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
001dc1 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
001dc2 91c0 2848                 	lds r28, pulse1_fx_3xx_target
001dc4 91d0 2849                 	lds r29, pulse1_fx_3xx_target+1
                                 
001dc6 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
001dc7 07bd                      	cpc r27, r29
001dc8 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
001dc9 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
001dca c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
001dcb 9220 2846                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
001dcd 9220 2847                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
001dcf c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
001dd0 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
001dd1 0bdb                      	sbc r29, r27
001dd2 91a0 284c                 	lds r26, pulse1_fx_3xx_total_offset
001dd4 91b0 284d                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
001dd6 0fae                      	add r26, ZL //add the speed to the total offset
001dd7 1fbf                      	adc r27, ZH
001dd8 1bca                      	sub r28, r26 //invert the total difference with the total offset
001dd9 0bdb                      	sbc r29, r27
001dda f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
001ddb 93a0 284c                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
001ddd 93b0 284d                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
001ddf 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
001de1 91b0 0a8d                 	lds r27, TCB0_CCMPH
001de3 1bac                      	sub r26, r28 //offset the current timer period with the total offset
001de4 0bbd                      	sbc r27, r29
001de5 93a0 0a8c                 	sts TCB0_CCMPL, r26
001de7 93b0 0a8d                 	sts TCB0_CCMPH, r27
001de9 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
001dea 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
001deb 0bbd                      	sbc r27, r29
001dec 91c0 284c                 	lds r28, pulse1_fx_3xx_total_offset
001dee 91d0 284d                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
001df0 0fce                      	add r28, ZL //add the speed to the total offset
001df1 1fdf                      	adc r29, ZH
001df2 1bac                      	sub r26, r28 //invert the total difference with the total offset
001df3 0bbd                      	sbc r27, r29
001df4 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
001df5 93c0 284c                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
001df7 93d0 284d                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
001df9 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
001dfb 91d0 0a8d                 	lds r29, TCB0_CCMPH
001dfd 0fca                      	add r28, r26 //offset the current timer period with the total offset
001dfe 1fdb                      	adc r29, r27
001dff 93c0 0a8c                 	sts TCB0_CCMPL, r28
001e01 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
001e03 91a0 284e                 	lds r26, pulse1_fx_4xy_speed
001e05 15a2                      	cp r26, zero
001e06 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
001e07 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
001e08 91b0 284f                 	lds r27, pulse1_fx_4xy_depth
001e0a 91c0 2850                 	lds r28, pulse1_fx_4xy_phase
001e0c 0fca                      	add r28, r26 //increase the phase by the speed
001e0d 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001e0e f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
001e0f 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
001e10 93c0 2850                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
001e12 31c0                      	cpi r28, 16
001e13 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
001e14 32c0                      	cpi r28, 32
001e15 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
001e16 33c0                      	cpi r28, 48
001e17 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
001e18 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
001e19 70cf                      	andi r28, 0x0F //mask for values 0-15
001e1a c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
001e1b 6fc0                      	ori r28, 0xF0
001e1c 95c0                      	com r28 //invert values 0-15
001e1d c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
001e1e 70cf                      	andi r28, 0x0F //mask for values 0-15
001e1f c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
001e20 6fc0                      	ori r28, 0xF0
001e21 95c0                      	com r28 //invert values 0-15
001e22 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
001e23 95b2                      	swap r27 //multiply depth by 16
001e24 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001e25 eee6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001e26 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
001e27 0fec                      	add ZL, r28 //offset the table by the depth+phase
001e28 1df2                      	adc ZH, zero
001e29 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
001e2a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e2b 937f                      	push r23
001e2c 2f6c                      	mov r22, r28 //store the vibrato value into r22
001e2d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e2e 9f67                      	mul r22, r23
001e2f 917f                      	pop r23
001e30 916f                      	pop r22
                                 
001e31 9416                      	lsr r1 //shift out the fractional bits
001e32 9407                      	ror r0
001e33 9416                      	lsr r1
001e34 9407                      	ror r0
001e35 9416                      	lsr r1
001e36 9407                      	ror r0
001e37 9416                      	lsr r1
001e38 9407                      	ror r0
                                 	
001e39 91a0 0a8c                 	lds r26, TCB0_CCMPL
001e3b 91b0 0a8d                 	lds r27, TCB0_CCMPH
001e3d 0da0                      	add r26, r0
001e3e 1db1                      	adc r27, r1
001e3f 93a0 0a8c                 	sts TCB0_CCMPL, r26
001e41 93b0 0a8d                 	sts TCB0_CCMPH, r27
001e43 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
001e44 95b2                      	swap r27 //multiply depth by 16
001e45 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
001e46 eee6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001e47 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
001e48 0fec                      	add ZL, r28 //offset the table by the depth+phase
001e49 1df2                      	adc ZH, zero
001e4a 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
001e4b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e4c 937f                      	push r23
001e4d 2f6c                      	mov r22, r28 //store the vibrato value into r22
001e4e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e4f 9f67                      	mul r22, r23
001e50 917f                      	pop r23
001e51 916f                      	pop r22
                                 
001e52 9416                      	lsr r1 //shift out the fractional bits
001e53 9407                      	ror r0
001e54 9416                      	lsr r1
001e55 9407                      	ror r0
001e56 9416                      	lsr r1
001e57 9407                      	ror r0
001e58 9416                      	lsr r1
001e59 9407                      	ror r0
                                 
001e5a 91a0 0a8c                 	lds r26, TCB0_CCMPL
001e5c 91b0 0a8d                 	lds r27, TCB0_CCMPH
001e5e 19a0                      	sub r26, r0
001e5f 09b1                      	sbc r27, r1
001e60 93a0 0a8c                 	sts TCB0_CCMPL, r26
001e62 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
001e64 91a0 2851                 	lds r26, pulse1_fx_7xy_speed
001e66 15a2                      	cp r26, zero
001e67 f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
001e68 91b0 2852                 	lds r27, pulse1_fx_7xy_depth
001e6a 91c0 2853                 	lds r28, pulse1_fx_7xy_phase
001e6c 0fca                      	add r28, r26 //increase the phase by the speed
001e6d 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001e6e f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
001e6f e0c0                      	ldi r28, 0x00
001e70 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
001e71 93c0 2853                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
001e73 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
001e74 ffc4                      	sbrs r28, 4
001e75 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
001e76 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
001e77 70cf                      	andi r28, 0x0F //mask for values 0-15
001e78 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
001e79 6fc0                      	ori r28, 0xF0
001e7a 95c0                      	com r28 //invert values 0-15
001e7b c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
001e7c 95b2                      	swap r27 //multiply depth by 16
001e7d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001e7e eee6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001e7f e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
001e80 0fec                      	add ZL, r28 //offset the table by the depth+phase
001e81 1df2                      	adc ZH, zero
001e82 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
001e83 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
001e84 93c0 2854                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
001e86 91b0 2855                 	lds r27, pulse1_fx_Axy
001e88 15b2                      	cp r27, zero
001e89 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
001e8a 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
001e8c 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
001e8e 2fda                      	mov r29, r26 //copy fractional volume into r29
001e8f 2fec                      	mov r30, r28 //copy the pulse1_param into r30
001e90 95e2                      	swap r30
001e91 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
001e92 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
001e93 17ed                      	cp r30, r29 //compare the fractional and integer volumes
001e94 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
001e95 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
001e96 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
001e97 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
001e98 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
001e99 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
001e9a efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
001e9b c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
001e9c 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
001e9d f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
001e9e e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
001e9f 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
001ea1 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
001ea2 95a2                      	swap r26
001ea3 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
001ea4 2bca                      	or r28, r26 //store the new volume back into pulse1_param
001ea5 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
001ea7 91e0 2859                 	lds ZL, pulse1_fx_Qxy_target
001ea9 91f0 285a                 	lds ZH, pulse1_fx_Qxy_target+1
001eab 9630                      	adiw Z, 0
001eac f199                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
001ead 91a0 285d                 	lds r26, pulse1_fx_Qxy_total_offset
001eaf 91b0 285e                 	lds r27, pulse1_fx_Qxy_total_offset+1
001eb1 91c0 0a8c                 	lds r28, TCB0_CCMPL
001eb3 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
001eb5 1bec                      	sub ZL, r28 //calculate the difference to the target
001eb6 0bfd                      	sbc ZH, r29
001eb7 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
001eb8 f0e8                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
001eb9 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
001eba 0bbf                      	sbc r27, ZH
                                 
001ebb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ebc 937f                      	push r23
001ebd 9160 2858                 	lds r22, pulse1_fx_Pxx
001ebf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ec0 9f67                      	mul r22, r23
001ec1 917f                      	pop r23
001ec2 916f                      	pop r22
001ec3 9416                      	lsr r1 //shift out the fractional bits
001ec4 9407                      	ror r0
001ec5 9416                      	lsr r1
001ec6 9407                      	ror r0
001ec7 9416                      	lsr r1
001ec8 9407                      	ror r0
001ec9 9416                      	lsr r1
001eca 9407                      	ror r0
                                 
001ecb 0da0                      	add r26, r0
001ecc 1db2                      	adc r27, zero
                                 
001ecd 93a0 285d                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
001ecf 93b0 285e                 	sts pulse1_fx_Qxy_total_offset+1, r27
001ed1 9220 2859                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
001ed3 9220 285a                 	sts pulse1_fx_Qxy_target+1, zero
001ed5 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
001ed6 91c0 285b                 	lds r28, pulse1_fx_Qxy_speed
001ed8 91d0 285c                 	lds r29, pulse1_fx_Qxy_speed+1
001eda 0fac                      	add r26, r28 //increase the total offset by the speed
001edb 1fbd                      	adc r27, r29
001edc 93a0 285d                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
001ede 93b0 285e                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
001ee0 91e0 285f                 	lds ZL, pulse1_fx_Rxy_target
001ee2 91f0 2860                 	lds ZH, pulse1_fx_Rxy_target+1
001ee4 9630                      	adiw Z, 0
001ee5 f199                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
001ee6 91a0 2863                 	lds r26, pulse1_fx_Rxy_total_offset
001ee8 91b0 2864                 	lds r27, pulse1_fx_Rxy_total_offset+1
001eea 91c0 0a8c                 	lds r28, TCB0_CCMPL
001eec 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
001eee 1bce                      	sub r28, ZL //calculate the difference to the target
001eef 0bdf                      	sbc r29, ZH
001ef0 f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
001ef1 f0e8                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
001ef2 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
001ef3 0bbd                      	sbc r27, r29
                                 
001ef4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ef5 937f                      	push r23
001ef6 9160 2858                 	lds r22, pulse1_fx_Pxx
001ef8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ef9 9f67                      	mul r22, r23
001efa 917f                      	pop r23
001efb 916f                      	pop r22
001efc 9416                      	lsr r1 //shift out the fractional bits
001efd 9407                      	ror r0
001efe 9416                      	lsr r1
001eff 9407                      	ror r0
001f00 9416                      	lsr r1
001f01 9407                      	ror r0
001f02 9416                      	lsr r1
001f03 9407                      	ror r0
                                 
001f04 0da0                      	add r26, r0
001f05 1db2                      	adc r27, zero
                                 
001f06 93a0 2863                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
001f08 93b0 2864                 	sts pulse1_fx_Rxy_total_offset+1, r27
001f0a 9220 285f                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
001f0c 9220 2860                 	sts pulse1_fx_Rxy_target+1, zero
001f0e c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
001f0f 91c0 2861                 	lds r28, pulse1_fx_Rxy_speed
001f11 91d0 2862                 	lds r29, pulse1_fx_Rxy_speed+1
001f13 0fac                      	add r26, r28 //increase the total offset by the speed
001f14 1fbd                      	adc r27, r29
001f15 93a0 2863                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
001f17 93b0 2864                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
001f19 91e0 286d                 	lds ZL, pulse2_volume_macro
001f1b 91f0 286e                 	lds ZH, pulse2_volume_macro+1
001f1d 9630                      	adiw Z, 0
001f1e f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
001f1f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001f20 1fff                      	rol ZH
001f21 91a0 286f                 	lds r26, pulse2_volume_macro_offset
001f23 0fea                      	add ZL, r26
001f24 1df2                      	adc ZH, zero
                                 
001f25 91b0 2871                 	lds r27, pulse2_volume_macro_release
001f27 17ba                      	cp r27, r26
001f28 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
001f29 91a0 2870                 	lds r26, pulse2_volume_macro_loop
001f2b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001f2c f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001f2d c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
001f2e 95a3                      	inc r26 //increment the macro offset
001f2f 93a0 286f                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
001f31 91b4                      	lpm r27, Z //load volume data into r27
001f32 3fbf                      	cpi r27, 0xFF //check for macro end flag
001f33 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
001f34 91b0 2871                 	lds r27, pulse2_volume_macro_release
001f36 3fbf                      	cpi r27, 0xFF
001f37 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
001f38 91b0 2870                 	lds r27, pulse2_volume_macro_loop //load the loop index
001f3a 93b0 286f                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
001f3c cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
001f3d 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
001f3e 93a0 286f                 	sts pulse2_volume_macro_offset, r26
001f40 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
001f41 e8ee                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
001f42 e4f5                      	ldi ZH, HIGH(volumes << 1)
001f43 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
001f44 0feb                      	add ZL, r27 //add offset to the table
001f45 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
001f46 91b0 2808                 	lds r27, pulse2_param //load main volume
001f48 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001f49 91a0 28a1                 	lds r26, pulse2_fx_7xy_value
001f4b 30a0                      	cpi r26, 0x00
001f4c f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
001f4d 0feb                      	add ZL, r27 //offset the volume table by the main volume
001f4e 1df2                      	adc ZH, zero
001f4f 91b4                      	lpm r27, Z
001f50 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
001f52 c024                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
001f53 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
001f55 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001f56 91a0 28a1                 	lds r26, pulse2_fx_7xy_value
001f58 30a0                      	cpi r26, 0x00
001f59 f4a1                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
001f5a 93b0 280e                 	sts pulse2_output_volume, r27
001f5c c01a                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
001f5d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001f5e f040                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
001f5f f039                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
001f60 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
001f61 0feb                      	add ZL, r27 //offset the volume table by the main volume
001f62 1df2                      	adc ZH, zero
001f63 91b4                      	lpm r27, Z
001f64 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
001f66 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
001f67 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001f68 0feb                      	add ZL, r27 //offset the volume table by the main volume
001f69 1df2                      	adc ZH, zero
001f6a 91b4                      	lpm r27, Z
001f6b 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
001f6d c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
001f6e 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001f6f f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
001f70 f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
001f71 93b0 280e                 	sts pulse2_output_volume, r27
001f73 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
001f74 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001f75 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001f77 91e0 2872                 	lds ZL, pulse2_arpeggio_macro
001f79 91f0 2873                 	lds ZH, pulse2_arpeggio_macro+1
001f7b 9630                      	adiw Z, 0
001f7c f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
001f7d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001f7e 1fff                      	rol ZH
001f7f 91a0 2874                 	lds r26, pulse2_arpeggio_macro_offset
001f81 0fea                      	add ZL, r26
001f82 1df2                      	adc ZH, zero
                                 
001f83 91b0 2876                 	lds r27, pulse2_arpeggio_macro_release
001f85 17ba                      	cp r27, r26
001f86 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
001f87 91a0 2875                 	lds r26, pulse2_arpeggio_macro_loop
001f89 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001f8a f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
001f8b c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
001f8c 95a3                      	inc r26 //increment the macro offset
001f8d 93a0 2874                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
001f8f 91b4                      	lpm r27, Z //load arpeggio data into r27
001f90 38b0                      	cpi r27, 0x80 //check for macro end flag
001f91 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
001f92 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
001f93 50a1                      	subi r26, 1 //keep the offset at the end flag
001f94 93a0 2874                 	sts pulse2_arpeggio_macro_offset, r26
001f96 91b0 2877                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001f98 30b1                      	cpi r27, 0x01
001f99 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
001f9a 91b0 2876                 	lds r27, pulse2_arpeggio_macro_release
001f9c 3fbf                      	cpi r27, 0xFF
001f9d f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
001f9e 91b0 2875                 	lds r27, pulse2_arpeggio_macro_loop
001fa0 3fbf                      	cpi r27, 0xFF
001fa1 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
001fa2 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
001fa3 91b0 2876                 	lds r27, pulse2_arpeggio_macro_release
001fa5 3fbf                      	cpi r27, 0xFF
001fa6 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
001fa7 91b0 2875                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
001fa9 3fbf                      	cpi r27, 0xFF //check if loop flag exists
001faa f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
001fab 91c0 2889                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
001fad 91d0 288a                 	lds r29, pulse2_fx_0xy_sequence+1
001faf 9620                      	adiw r29:r28, 0
001fb0 f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
001fb1 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
001fb2 93a0 2874                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
001fb4 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
001fb5 93b0 2874                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
001fb7 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
001fb8 91c0 2889                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
001fba 91d0 288a                 	lds r29, pulse2_fx_0xy_sequence+1
001fbc 9620                      	adiw r29:r28, 0 //check for 0xy effect
001fbd f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_xy:
001fbe 95d6                      	lsr r29
001fbf 95c7                      	ror r28
001fc0 95d7                      	ror r29
001fc1 95c7                      	ror r28
001fc2 95d7                      	ror r29
001fc3 95c7                      	ror r28
001fc4 95d7                      	ror r29
001fc5 95c7                      	ror r28
001fc6 95d7                      	ror r29
001fc7 95d2                      	swap r29
                                 
001fc8 93c0 2889                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
001fca 93d0 288a                 	sts pulse2_fx_0xy_sequence+1, r29
001fcc 70cf                      	andi r28, 0x0F //mask out the 4 LSB
001fcd 91a0 280f                 	lds r26, pulse2_note //load the current note index
001fcf 0fac                      	add r26, r28 //add the note offset
001fd0 c02c                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
001fd1 91a0 280f                 	lds r26, pulse2_note //load the current note index
001fd3 c029                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
001fd4 9220 2878                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
001fd6 9220 287e                 	sts pulse2_total_hi_pitch_offset, zero
001fd8 91a0 2877                 	lds r26, pulse2_arpeggio_macro_mode
001fda 30a1                      	cpi r26, 0x01 //absolute mode
001fdb f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
001fdc f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
001fdd c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
001fde 91a0 280f                 	lds r26, pulse2_note //load the current note index
001fe0 0fab                      	add r26, r27 //offset the note with the arpeggio data
001fe1 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001fe2 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
001fe3 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001fe4 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
001fe5 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001fe6 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
001fe7 fda7                      	sbrc r26, 7 //check if result is negative
001fe8 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001fe9 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
001fea 2fab                      	mov r26, r27 //move the arpeggio data into r26
001feb c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
001fec 91a0 280f                 	lds r26, pulse2_note //load the current note index
001fee 0fab                      	add r26, r27 //offset the note with the arpeggio data
001fef fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
001ff0 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
001ff1 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
001ff3 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
001ff4 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
001ff5 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
001ff6 93a0 280f                 	sts pulse2_note, r26
001ff8 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
001ff9 fda7                      	sbrc r26, 7 //check if result is negative
001ffa e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
001ffb 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
001ffd e3e8                      	ldi ZL, LOW(note_table << 1) //load in note table
001ffe e0f0                      	ldi ZH, HIGH(note_table << 1)
001fff 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002000 0fea                      	add ZL, r26 //add offset
002001 1df2                      	adc ZH, zero
002002 91a5                      	lpm r26, Z+ //load bytes
002003 91b4                      	lpm r27, Z
002004 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
002006 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
002008 93a0 2895                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00200a 93b0 2896                 	sts pulse2_fx_3xx_target+1, r27
00200c c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel1_pitch:
00200d 91e0 2879                 	lds ZL, pulse2_pitch_macro
00200f 91f0 287a                 	lds ZH, pulse2_pitch_macro+1
002011 9630                      	adiw Z, 0
002012 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002013 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002014 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002015 1fff                      	rol ZH
002016 91a0 287b                 	lds r26, pulse2_pitch_macro_offset
002018 0fea                      	add ZL, r26
002019 1df2                      	adc ZH, zero
                                 
00201a 91b0 287d                 	lds r27, pulse2_pitch_macro_release
00201c 17ba                      	cp r27, r26
00201d f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
00201e 91a0 287c                 	lds r26, pulse2_pitch_macro_loop
002020 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002021 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002022 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002023 95a3                      	inc r26 //increment the macro offset
002024 93a0 287b                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002026 91b4                      	lpm r27, Z //load pitch data into r27
002027 38b0                      	cpi r27, 0x80 //check for macro end flag
002028 f489                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002029 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00202a 93a0 287b                 	sts pulse2_pitch_macro_offset, r26
00202c 91b0 287d                 	lds r27, pulse2_pitch_macro_release
00202e 3fbf                      	cpi r27, 0xFF
00202f f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
002030 91b0 287c                 	lds r27, pulse2_pitch_macro_loop //load the loop index
002032 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002033 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002034 93b0 287b                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
002036 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
002037 91b0 2878                 	lds r27, pulse2_total_pitch_offset
002039 c005                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
00203a 91a0 2878                 	lds r26, pulse2_total_pitch_offset //load the total pitch offset to change
00203c 0fba                      	add r27, r26
00203d 93b0 2878                 	sts pulse2_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
00203f 91a0 28a5                 	lds r26, pulse2_fx_Pxx
002041 0fba                      	add r27, r26
                                 
002042 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002043 937f                      	push r23
002044 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002045 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002046 0367                      	mulsu r22, r23
002047 917f                      	pop r23
002048 916f                      	pop r22
                                 
002049 9416                      	lsr r1 //shift out the fractional bits
00204a 9407                      	ror r0
00204b 9416                      	lsr r1
00204c 9407                      	ror r0
00204d 9416                      	lsr r1
00204e 9407                      	ror r0
00204f 9416                      	lsr r1
002050 9407                      	ror r0
002051 fe13                      	sbrs r1, 3 //check if result was a negative number
002052 c002                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002053 efb0                      	ldi r27, 0xF0
002054 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
002055 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002057 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002059 0da0                      	add r26, r0 //offset the timer values
00205a 1db1                      	adc r27, r1
                                 	
00205b 91c0 288d                 	lds r28, pulse2_fx_1xx_total
00205d 91d0 288e                 	lds r29, pulse2_fx_1xx_total+1
00205f 1bac                      	sub r26, r28
002060 0bbd                      	sbc r27, r29
002061 91c0 2891                 	lds r28, pulse2_fx_2xx_total
002063 91d0 2892                 	lds r29, pulse2_fx_2xx_total+1
002065 0fac                      	add r26, r28
002066 1fbd                      	adc r27, r29
002067 91c0 28aa                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002069 91d0 28ab                 	lds r29, pulse2_fx_Qxy_total_offset+1
00206b 1bac                      	sub r26, r28
00206c 0bbd                      	sbc r27, r29
00206d 91c0 28b0                 	lds r28, pulse2_fx_Rxy_total_offset
00206f 91d0 28b1                 	lds r29, pulse2_fx_Rxy_total_offset+1
002071 0fac                      	add r26, r28
002072 1fbd                      	adc r27, r29
                                 
002073 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002075 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002077 91e0 287f                 	lds ZL, pulse2_hi_pitch_macro
002079 91f0 2880                 	lds ZH, pulse2_hi_pitch_macro+1
00207b 9630                      	adiw Z, 0
00207c f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
00207d c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
00207e 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00207f 1fff                      	rol ZH
002080 91a0 2881                 	lds r26, pulse2_hi_pitch_macro_offset
002082 0fea                      	add ZL, r26
002083 1df2                      	adc ZH, zero
                                 
002084 91b0 2883                 	lds r27, pulse2_hi_pitch_macro_release
002086 17ba                      	cp r27, r26
002087 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002088 91a0 2882                 	lds r26, pulse2_hi_pitch_macro_loop
00208a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00208b f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00208c c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
00208d 95a3                      	inc r26 //increment the macro offset
00208e 93a0 2881                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002090 91b4                      	lpm r27, Z //load hi pitch data into r27
002091 38b0                      	cpi r27, 0x80 //check for macro end flag
002092 f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002093 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002094 93a0 2881                 	sts pulse2_hi_pitch_macro_offset, r26
002096 91b0 2883                 	lds r27, pulse2_hi_pitch_macro_release
002098 3fbf                      	cpi r27, 0xFF
002099 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
00209a 91b0 2882                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
00209c 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00209d f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00209e 93b0 2881                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
0020a0 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
0020a1 91b0 287e                 	lds r27, pulse2_total_hi_pitch_offset
0020a3 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
0020a4 91a0 287e                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
0020a6 0fba                      	add r27, r26
0020a7 93b0 287e                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
0020a9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0020aa 937f                      	push r23
0020ab 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0020ac eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0020ad 0367                      	mulsu r22, r23
0020ae 917f                      	pop r23
0020af 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
0020b0 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0020b2 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0020b4 0da0                      	add r26, r0 //offset the timer values
0020b5 1db1                      	adc r27, r1
0020b6 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0020b8 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
0020ba 91e0 2884                 	lds ZL, pulse2_duty_macro
0020bc 91f0 2885                 	lds ZH, pulse2_duty_macro+1
0020be 9630                      	adiw Z, 0
0020bf f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
0020c0 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0020c1 1fff                      	rol ZH
0020c2 91a0 2886                 	lds r26, pulse2_duty_macro_offset
0020c4 0fea                      	add ZL, r26
0020c5 1df2                      	adc ZH, zero
                                 
0020c6 91b0 2888                 	lds r27, pulse2_duty_macro_release
0020c8 17ba                      	cp r27, r26
0020c9 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
0020ca 91a0 2887                 	lds r26, pulse2_duty_macro_loop
0020cc 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0020cd f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0020ce c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
0020cf 95a3                      	inc r26 //increment the macro offset
0020d0 93a0 2886                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
0020d2 91b4                      	lpm r27, Z //load pitch data into r27
0020d3 3fbf                      	cpi r27, 0xFF //check for macro end flag
0020d4 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
0020d5 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0020d6 93a0 2886                 	sts pulse2_duty_macro_offset, r26
0020d8 91b0 2888                 	lds r27, pulse2_duty_macro_release
0020da 3fbf                      	cpi r27, 0xFF
0020db f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
0020dc 91b0 2887                 	lds r27, pulse2_duty_macro_loop //load the loop index
0020de 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0020df f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0020e0 93b0 2886                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
0020e2 cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
0020e3 e2e2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0020e4 e4f5                      	ldi ZH, HIGH(sequences << 1)
0020e5 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0020e6 1df2                      	adc ZH, zero
                                 
0020e7 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
0020e8 95b7                      	ror r27
0020e9 95b7                      	ror r27
0020ea 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
0020ec 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
0020ed 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0020ee 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0020ef c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
0020f0 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
0020f1 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
0020f2 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0020f3 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0020f4 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
0020f6 91e0 288b                 	lds ZL, pulse2_fx_1xx
0020f8 91f0 288c                 	lds ZH, pulse2_fx_1xx+1
0020fa 9630                      	adiw Z, 0
0020fb f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
0020fc 91a0 288d                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
0020fe 91b0 288e                 	lds r27, pulse2_fx_1xx_total+1
002100 0fae                      	add r26, ZL //increase the total offset by the rate
002101 1fbf                      	adc r27, ZH
002102 93a0 288d                 	sts pulse2_fx_1xx_total, r26
002104 93b0 288e                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002106 91e0 288f                 	lds ZL, pulse2_fx_2xx
002108 91f0 2890                 	lds ZH, pulse2_fx_2xx+1
00210a 9630                      	adiw Z, 0
00210b f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
00210c 91a0 2891                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
00210e 91b0 2892                 	lds r27, pulse2_fx_2xx_total+1
002110 0fae                      	add r26, ZL //increase the total offset by the rate
002111 1fbf                      	adc r27, ZH
002112 93a0 2891                 	sts pulse2_fx_2xx_total, r26
002114 93b0 2892                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002116 91e0 2897                 	lds ZL, pulse2_fx_3xx_speed
002118 91f0 2898                 	lds ZH, pulse2_fx_3xx_speed+1
00211a 9630                      	adiw Z, 0
00211b f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
00211c c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
00211d 91a0 2893                 	lds r26, pulse2_fx_3xx_start
00211f 91b0 2894                 	lds r27, pulse2_fx_3xx_start+1
002121 9610                      	adiw r26:r27, 0
002122 f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002123 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002124 91c0 2895                 	lds r28, pulse2_fx_3xx_target
002126 91d0 2896                 	lds r29, pulse2_fx_3xx_target+1
                                 
002128 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002129 07bd                      	cpc r27, r29
00212a f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
00212b f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00212c c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
00212d 9220 2893                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00212f 9220 2894                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002131 c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002132 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002133 0bdb                      	sbc r29, r27
002134 91a0 2899                 	lds r26, pulse2_fx_3xx_total_offset
002136 91b0 289a                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002138 0fae                      	add r26, ZL //add the speed to the total offset
002139 1fbf                      	adc r27, ZH
00213a 1bca                      	sub r28, r26 //invert the total difference with the total offset
00213b 0bdb                      	sbc r29, r27
00213c f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00213d 93a0 2899                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
00213f 93b0 289a                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002141 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002143 91b0 0a9d                 	lds r27, TCB1_CCMPH
002145 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002146 0bbd                      	sbc r27, r29
002147 93a0 0a9c                 	sts TCB1_CCMPL, r26
002149 93b0 0a9d                 	sts TCB1_CCMPH, r27
00214b c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
00214c 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00214d 0bbd                      	sbc r27, r29
00214e 91c0 2899                 	lds r28, pulse2_fx_3xx_total_offset
002150 91d0 289a                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002152 0fce                      	add r28, ZL //add the speed to the total offset
002153 1fdf                      	adc r29, ZH
002154 1bac                      	sub r26, r28 //invert the total difference with the total offset
002155 0bbd                      	sbc r27, r29
002156 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002157 93c0 2899                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002159 93d0 289a                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
00215b 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
00215d 91d0 0a9d                 	lds r29, TCB1_CCMPH
00215f 0fca                      	add r28, r26 //offset the current timer period with the total offset
002160 1fdb                      	adc r29, r27
002161 93c0 0a9c                 	sts TCB1_CCMPL, r28
002163 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002165 91a0 289b                 	lds r26, pulse2_fx_4xy_speed
002167 15a2                      	cp r26, zero
002168 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002169 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
00216a 91b0 289c                 	lds r27, pulse2_fx_4xy_depth
00216c 91c0 289d                 	lds r28, pulse2_fx_4xy_phase
00216e 0fca                      	add r28, r26 //increase the phase by the speed
00216f 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
002170 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002171 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002172 93c0 289d                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002174 31c0                      	cpi r28, 16
002175 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002176 32c0                      	cpi r28, 32
002177 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002178 33c0                      	cpi r28, 48
002179 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
00217a c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
00217b 70cf                      	andi r28, 0x0F //mask for values 0-15
00217c c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
00217d 6fc0                      	ori r28, 0xF0
00217e 95c0                      	com r28 //invert values 0-15
00217f c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002180 70cf                      	andi r28, 0x0F //mask for values 0-15
002181 c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002182 6fc0                      	ori r28, 0xF0
002183 95c0                      	com r28 //invert values 0-15
002184 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002185 95b2                      	swap r27 //multiply depth by 16
002186 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002187 eee6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002188 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
002189 0fec                      	add ZL, r28 //offset the table by the depth+phase
00218a 1df2                      	adc ZH, zero
00218b 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00218c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00218d 937f                      	push r23
00218e 2f6c                      	mov r22, r28 //store the vibrato value into r22
00218f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002190 9f67                      	mul r22, r23
002191 917f                      	pop r23
002192 916f                      	pop r22
                                 
002193 9416                      	lsr r1 //shift out the fractional bits
002194 9407                      	ror r0
002195 9416                      	lsr r1
002196 9407                      	ror r0
002197 9416                      	lsr r1
002198 9407                      	ror r0
002199 9416                      	lsr r1
00219a 9407                      	ror r0
                                 	
00219b 91a0 0a9c                 	lds r26, TCB1_CCMPL
00219d 91b0 0a9d                 	lds r27, TCB1_CCMPH
00219f 0da0                      	add r26, r0
0021a0 1db1                      	adc r27, r1
0021a1 93a0 0a9c                 	sts TCB1_CCMPL, r26
0021a3 93b0 0a9d                 	sts TCB1_CCMPH, r27
0021a5 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
0021a6 95b2                      	swap r27 //multiply depth by 16
0021a7 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0021a8 eee6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0021a9 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
0021aa 0fec                      	add ZL, r28 //offset the table by the depth+phase
0021ab 1df2                      	adc ZH, zero
0021ac 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0021ad 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0021ae 937f                      	push r23
0021af 2f6c                      	mov r22, r28 //store the vibrato value into r22
0021b0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0021b1 9f67                      	mul r22, r23
0021b2 917f                      	pop r23
0021b3 916f                      	pop r22
                                 
0021b4 9416                      	lsr r1 //shift out the fractional bits
0021b5 9407                      	ror r0
0021b6 9416                      	lsr r1
0021b7 9407                      	ror r0
0021b8 9416                      	lsr r1
0021b9 9407                      	ror r0
0021ba 9416                      	lsr r1
0021bb 9407                      	ror r0
                                 
0021bc 91a0 0a9c                 	lds r26, TCB1_CCMPL
0021be 91b0 0a9d                 	lds r27, TCB1_CCMPH
0021c0 19a0                      	sub r26, r0
0021c1 09b1                      	sbc r27, r1
0021c2 93a0 0a9c                 	sts TCB1_CCMPL, r26
0021c4 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
0021c6 91a0 289e                 	lds r26, pulse2_fx_7xy_speed
0021c8 15a2                      	cp r26, zero
0021c9 f0f1                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0021ca 91b0 289f                 	lds r27, pulse2_fx_7xy_depth
0021cc 91c0 28a0                 	lds r28, pulse2_fx_7xy_phase
0021ce 0fca                      	add r28, r26 //increase the phase by the speed
0021cf 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0021d0 f010                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0021d1 e0c0                      	ldi r28, 0x00
0021d2 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
0021d3 93c0 28a0                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
0021d5 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0021d6 ffc4                      	sbrs r28, 4
0021d7 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
0021d8 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
0021d9 70cf                      	andi r28, 0x0F //mask for values 0-15
0021da c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
0021db 6fc0                      	ori r28, 0xF0
0021dc 95c0                      	com r28 //invert values 0-15
0021dd c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
0021de 95b2                      	swap r27 //multiply depth by 16
0021df 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0021e0 eee6                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0021e1 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
0021e2 0fec                      	add ZL, r28 //offset the table by the depth+phase
0021e3 1df2                      	adc ZH, zero
0021e4 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0021e5 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0021e6 93c0 28a1                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
0021e8 91b0 28a2                 	lds r27, pulse2_fx_Axy
0021ea 15b2                      	cp r27, zero
0021eb f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0021ec 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
0021ee 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
0021f0 2fda                      	mov r29, r26 //copy fractional volume into r29
0021f1 2fec                      	mov r30, r28 //copy the pulse2_param into r30
0021f2 95e2                      	swap r30
0021f3 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0021f4 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0021f5 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0021f6 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
0021f7 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
0021f8 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0021f9 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
0021fa 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0021fb f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0021fc efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0021fd c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
0021fe 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0021ff f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002200 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002201 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002203 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002204 95a2                      	swap r26
002205 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002206 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002207 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002209 91e0 28a6                 	lds ZL, pulse2_fx_Qxy_target
00220b 91f0 28a7                 	lds ZH, pulse2_fx_Qxy_target+1
00220d 9630                      	adiw Z, 0
00220e f199                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00220f 91a0 28aa                 	lds r26, pulse2_fx_Qxy_total_offset
002211 91b0 28ab                 	lds r27, pulse2_fx_Qxy_total_offset+1
002213 91c0 0a9c                 	lds r28, TCB1_CCMPL
002215 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002217 1bec                      	sub ZL, r28 //calculate the difference to the target
002218 0bfd                      	sbc ZH, r29
002219 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
00221a f0e8                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
00221b 1bae                      	sub r26, ZL //decrease the total offset to the exact amount needed to reach the target
00221c 0bbf                      	sbc r27, ZH
                                 
00221d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00221e 937f                      	push r23
00221f 9160 28a5                 	lds r22, pulse2_fx_Pxx
002221 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002222 9f67                      	mul r22, r23
002223 917f                      	pop r23
002224 916f                      	pop r22
002225 9416                      	lsr r1 //shift out the fractional bits
002226 9407                      	ror r0
002227 9416                      	lsr r1
002228 9407                      	ror r0
002229 9416                      	lsr r1
00222a 9407                      	ror r0
00222b 9416                      	lsr r1
00222c 9407                      	ror r0
                                 
00222d 0da0                      	add r26, r0
00222e 1db2                      	adc r27, zero
                                 
00222f 93a0 28aa                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002231 93b0 28ab                 	sts pulse2_fx_Qxy_total_offset+1, r27
002233 9220 28a6                 	sts pulse2_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
002235 9220 28a7                 	sts pulse2_fx_Qxy_target+1, zero
002237 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002238 91c0 28a8                 	lds r28, pulse2_fx_Qxy_speed
00223a 91d0 28a9                 	lds r29, pulse2_fx_Qxy_speed+1
00223c 0fac                      	add r26, r28 //increase the total offset by the speed
00223d 1fbd                      	adc r27, r29
00223e 93a0 28aa                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002240 93b0 28ab                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002242 91e0 28ac                 	lds ZL, pulse2_fx_Rxy_target
002244 91f0 28ad                 	lds ZH, pulse2_fx_Rxy_target+1
002246 9630                      	adiw Z, 0
002247 f199                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002248 91a0 28b0                 	lds r26, pulse2_fx_Rxy_total_offset
00224a 91b0 28b1                 	lds r27, pulse2_fx_Rxy_total_offset+1
00224c 91c0 0a9c                 	lds r28, TCB1_CCMPL
00224e 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002250 1bce                      	sub r28, ZL //calculate the difference to the target
002251 0bdf                      	sbc r29, ZH
002252 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002253 f0e8                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002254 1bac                      	sub r26, r28 //decrease the total offset to the exact amount needed to reach the target
002255 0bbd                      	sbc r27, r29
                                 
002256 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002257 937f                      	push r23
002258 9160 28a5                 	lds r22, pulse2_fx_Pxx
00225a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00225b 9f67                      	mul r22, r23
00225c 917f                      	pop r23
00225d 916f                      	pop r22
00225e 9416                      	lsr r1 //shift out the fractional bits
00225f 9407                      	ror r0
002260 9416                      	lsr r1
002261 9407                      	ror r0
002262 9416                      	lsr r1
002263 9407                      	ror r0
002264 9416                      	lsr r1
002265 9407                      	ror r0
                                 
002266 0da0                      	add r26, r0
002267 1db2                      	adc r27, zero
                                 
002268 93a0 28b0                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
00226a 93b0 28b1                 	sts pulse2_fx_Rxy_total_offset+1, r27
00226c 9220 28ac                 	sts pulse2_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
00226e 9220 28ad                 	sts pulse2_fx_Rxy_target+1, zero
002270 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002271 91c0 28ae                 	lds r28, pulse2_fx_Rxy_speed
002273 91d0 28af                 	lds r29, pulse2_fx_Rxy_speed+1
002275 0fac                      	add r26, r28 //increase the total offset by the speed
002276 1fbd                      	adc r27, r29
002277 93a0 28b0                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002279 93b0 28b1                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
                                 
                                 sound_driver_exit:
00227b 91ff                      	pop r31
00227c 91ef                      	pop r30
00227d 91df                      	pop r29
00227e 91cf                      	pop r28
00227f 940c 141d                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
002281 7f05
002282 010a
002283 0214
002284 0328
002285 0450
002286 051e
002287 0607
002288 070d
002289 0806
00228a 090c
00228b 0a18
00228c 0b30
00228d 0c60
00228e 0d24
00228f 0e08
002290 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
002291 0301
002292 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
002293 15aa
002294 15af
002295 15cb
002296 15e7
002297 160a                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
002298 1615
002299 1622
00229a 1625
00229b 1628
00229c 162b                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
00229d 162e
00229e 1636
00229f 1639
0022a0 1646
0022a1 164d                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
0022a2 1655
0022a3 1656
0022a4 1657
0022a5 165a
0022a6 169e                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
0022a7 16e1
0022a8 16ee
0022a9 1702
0022aa 1703
0022ab 1704                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
0022ac 1705                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
0022ad 1883
0022ae 1888
0022af 18a4
0022b0 18c0
0022b1 18e3                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
0022b2 18ee
0022b3 18fb
0022b4 18fe
0022b5 1901
0022b6 1904                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
0022b7 1907
0022b8 190f
0022b9 1912
0022ba 191f
0022bb 1926                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
0022bc 192e
0022bd 192f
0022be 1930
0022bf 1933
0022c0 1977                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
0022c1 19ba
0022c2 19c7
0022c3 19db
0022c4 19dc
0022c5 19dd                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
0022c6 19de                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0022c7 0000
0022c8 0000
0022c9 0000
0022ca 0000
0022cb 0000
0022cc 0000
0022cd 0000
0022ce 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0022cf 0100
0022d0 0101
0022d1 0101
0022d2 0101
0022d3 0101
0022d4 0101
0022d5 0101
0022d6 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0022d7 0100
0022d8 0101
0022d9 0101
0022da 0101
0022db 0101
0022dc 0101
0022dd 0101
0022de 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0022df 0100
0022e0 0101
0022e1 0101
0022e2 0101
0022e3 0101
0022e4 0202
0022e5 0202
0022e6 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
0022e7 0100
0022e8 0101
0022e9 0101
0022ea 0101
0022eb 0202
0022ec 0202
0022ed 0303
0022ee 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
0022ef 0100
0022f0 0101
0022f1 0101
0022f2 0202
0022f3 0302
0022f4 0303
0022f5 0404
0022f6 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
0022f7 0100
0022f8 0101
0022f9 0201
0022fa 0202
0022fb 0303
0022fc 0404
0022fd 0504
0022fe 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
0022ff 0100
002300 0101
002301 0201
002302 0302
002303 0403
002304 0504
002305 0605
002306 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
002307 0100
002308 0101
002309 0202
00230a 0303
00230b 0404
00230c 0505
00230d 0606
00230e 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
00230f 0100
002310 0101
002311 0302
002312 0403
002313 0504
002314 0606
002315 0707
002316 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
002317 0100
002318 0201
002319 0302
00231a 0404
00231b 0605
00231c 0706
00231d 0808
00231e 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
00231f 0100
002320 0201
002321 0302
002322 0504
002323 0605
002324 0807
002325 0908
002326 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
002327 0100
002328 0201
002329 0403
00232a 0504
00232b 0706
00232c 0808
00232d 0a09
00232e 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
00232f 0100
002330 0201
002331 0403
002332 0605
002333 0706
002334 0908
002335 0b0a
002336 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
002337 0100
002338 0201
002339 0403
00233a 0605
00233b 0807
00233c 0a09
00233d 0c0b
00233e 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
00233f 0100
002340 0302
002341 0504
002342 0706
002343 0908
002344 0b0a
002345 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 131 r0 : 102 r1 : 102 r2 : 361 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:  13 
r13:   6 r14:   4 r15:  13 r16:   7 r17:   6 r18:   7 r19:   6 r20:   0 
r21:   0 r22:  88 r23:  88 r24:   0 r25:  28 r26: 526 r27: 631 r28: 388 
r29: 194 r30: 213 r31: 193 
Registers used: 23 out of 35 (65.7%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  79 add   : 106 adiw  :  55 and   :   0 
andi  :  62 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   4 brcs  :   8 break :   0 breq  :  89 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  42 brlt  :   0 brmi  :   0 
brne  :  67 brpl  :   0 brsh  :  17 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   4 
clc   :   0 clh   :   0 cli   :   6 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  10 cp    :  55 cpc   :   7 
cpi   :  89 cpse  :  14 dec   :  23 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   2 in    :   5 inc   :  25 
jmp   :   8 ld    :   0 ldd   :   0 ldi   : 171 lds   : 388 lpm   : 142 
lsl   :  40 lsr   :  94 mov   :  77 movw  :   0 mul   :  18 muls  :   0 
mulsu :   4 neg   :   0 nop   :   0 or    :  13 ori   :  10 out   :   7 
pop   :  69 push  :  63 rcall :  28 ret   :  24 reti  :   5 rjmp  : 275 
rol   :  26 ror   : 106 sbc   :  24 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  14 sbrc  :  16 sbrs  :  12 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   : 710 sub   :  34 subi  :  27 swap  :  33 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00468e   8532   9502  18034   49152  36.7%
[.dseg] 0x002800 0x0028b7      0    183    183    6144   3.0%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 106 warnings
