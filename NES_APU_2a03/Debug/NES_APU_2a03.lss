
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Sun May 23 19:32:13 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
002818                           noise_adjusted_note: .byte 1 //the resultant note index after the arpeggio macro
                                 
002819                           song_frames: .byte 2
00281b                           song_frame_offset: .byte 2
00281d                           song_size: .byte 2
00281f                           song_tempo: .byte 2
002821                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002822                           song_fx_Bxx: .byte 1
002823                           song_fx_Cxx: .byte 1
002824                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002825                           pulse1_pattern: .byte 2
002827                           pulse1_pattern_delay_rows: .byte 1
002828                           pulse1_pattern_delay_frames: .byte 1
002829                           pulse1_pattern_offset: .byte 2
                                 
00282b                           pulse1_volume_macro: .byte 2
00282d                           pulse1_volume_macro_offset: .byte 1
00282e                           pulse1_volume_macro_loop: .byte 1
00282f                           pulse1_volume_macro_release: .byte 1
                                 
002830                           pulse1_arpeggio_macro: .byte 2
002832                           pulse1_arpeggio_macro_offset: .byte 1
002833                           pulse1_arpeggio_macro_loop: .byte 1
002834                           pulse1_arpeggio_macro_release: .byte 1
002835                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002836                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002838                           pulse1_pitch_macro: .byte 2
00283a                           pulse1_pitch_macro_offset: .byte 1
00283b                           pulse1_pitch_macro_loop: .byte 1
00283c                           pulse1_pitch_macro_release: .byte 1
                                 
00283d                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283e                           pulse1_hi_pitch_macro: .byte 2
002840                           pulse1_hi_pitch_macro_offset: .byte 1
002841                           pulse1_hi_pitch_macro_loop: .byte 1
002842                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002843                           pulse1_duty_macro: .byte 2
002845                           pulse1_duty_macro_offset: .byte 1
002846                           pulse1_duty_macro_loop: .byte 1
002847                           pulse1_duty_macro_release: .byte 1
                                 
002848                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00284a                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00284c                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284e                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002850                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002852                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002854                           pulse1_fx_3xx_target: .byte 2 //target note period
002856                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002858                           pulse1_fx_3xx_total_offset: .byte 2
00285a                           pulse1_fx_4xy_speed: .byte 1
00285b                           pulse1_fx_4xy_depth: .byte 1
00285c                           pulse1_fx_4xy_phase: .byte 1
00285d                           pulse1_fx_7xy_speed: .byte 1
00285e                           pulse1_fx_7xy_depth: .byte 1
00285f                           pulse1_fx_7xy_phase: .byte 1
002860                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002861                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002862                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002863                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002864                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002866                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002867                           pulse1_fx_Qxy_target: .byte 2 //target note period
002869                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00286b                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286d                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286e                           pulse1_fx_Rxy_target: .byte 2 //target note period
002870                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002872                           pulse1_fx_Rxy_total_offset: .byte 2
002874                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002875                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002876                           pulse2_pattern: .byte 2
002878                           pulse2_pattern_delay_rows: .byte 1
002879                           pulse2_pattern_delay_frames: .byte 1
00287a                           pulse2_pattern_offset: .byte 2
                                 
00287c                           pulse2_volume_macro: .byte 2
00287e                           pulse2_volume_macro_offset: .byte 1
00287f                           pulse2_volume_macro_loop: .byte 1
002880                           pulse2_volume_macro_release: .byte 1
                                 
002881                           pulse2_arpeggio_macro: .byte 2
002883                           pulse2_arpeggio_macro_offset: .byte 1
002884                           pulse2_arpeggio_macro_loop: .byte 1
002885                           pulse2_arpeggio_macro_release: .byte 1
002886                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002887                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002889                           pulse2_pitch_macro: .byte 2
00288b                           pulse2_pitch_macro_offset: .byte 1
00288c                           pulse2_pitch_macro_loop: .byte 1
00288d                           pulse2_pitch_macro_release: .byte 1
                                 
00288e                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288f                           pulse2_hi_pitch_macro: .byte 2
002891                           pulse2_hi_pitch_macro_offset: .byte 1
002892                           pulse2_hi_pitch_macro_loop: .byte 1
002893                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002894                           pulse2_duty_macro: .byte 2
002896                           pulse2_duty_macro_offset: .byte 1
002897                           pulse2_duty_macro_loop: .byte 1
002898                           pulse2_duty_macro_release: .byte 1
                                 
002899                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00289b                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289d                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289f                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028a1                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a3                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a5                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a7                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a9                           pulse2_fx_3xx_total_offset: .byte 2
0028ab                           pulse2_fx_4xy_speed: .byte 1
0028ac                           pulse2_fx_4xy_depth: .byte 1
0028ad                           pulse2_fx_4xy_phase: .byte 1
0028ae                           pulse2_fx_7xy_speed: .byte 1
0028af                           pulse2_fx_7xy_depth: .byte 1
0028b0                           pulse2_fx_7xy_phase: .byte 1
0028b1                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028b2                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b3                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b4                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b5                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b7                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b8                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028ba                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028bc                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028be                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bf                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028c1                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c3                           pulse2_fx_Rxy_total_offset: .byte 2
0028c5                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c6                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c7                           triangle_pattern: .byte 2
0028c9                           triangle_pattern_delay_rows: .byte 1
0028ca                           triangle_pattern_delay_frames: .byte 1
0028cb                           triangle_pattern_offset: .byte 2
                                 
0028cd                           triangle_volume_macro: .byte 2
0028cf                           triangle_volume_macro_offset: .byte 1
0028d0                           triangle_volume_macro_loop: .byte 1
0028d1                           triangle_volume_macro_release: .byte 1
                                 
0028d2                           triangle_arpeggio_macro: .byte 2
0028d4                           triangle_arpeggio_macro_offset: .byte 1
0028d5                           triangle_arpeggio_macro_loop: .byte 1
0028d6                           triangle_arpeggio_macro_release: .byte 1
0028d7                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d8                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028da                           triangle_pitch_macro: .byte 2
0028dc                           triangle_pitch_macro_offset: .byte 1
0028dd                           triangle_pitch_macro_loop: .byte 1
0028de                           triangle_pitch_macro_release: .byte 1
                                 
0028df                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028e0                           triangle_hi_pitch_macro: .byte 2
0028e2                           triangle_hi_pitch_macro_offset: .byte 1
0028e3                           triangle_hi_pitch_macro_loop: .byte 1
0028e4                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e5                           triangle_duty_macro: .byte 2
0028e7                           triangle_duty_macro_offset: .byte 1
0028e8                           triangle_duty_macro_loop: .byte 1
0028e9                           triangle_duty_macro_release: .byte 1
                                 
0028ea                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028ec                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028ee                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028f0                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028f2                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f4                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f6                           triangle_fx_3xx_target: .byte 2 //target note period
0028f8                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028fa                           triangle_fx_3xx_total_offset: .byte 2
0028fc                           triangle_fx_4xy_speed: .byte 1
0028fd                           triangle_fx_4xy_depth: .byte 1
0028fe                           triangle_fx_4xy_phase: .byte 1
0028ff                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002900                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002901                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002903                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002904                           triangle_fx_Qxy_target: .byte 2 //target note period
002906                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002908                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00290a                           triangle_fx_Rxy_target_note: .byte 1 //target note index
00290b                           triangle_fx_Rxy_target: .byte 2 //target note period
00290d                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290f                           triangle_fx_Rxy_total_offset: .byte 2
002911                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002912                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002913                           noise_pattern: .byte 2
002915                           noise_pattern_delay_rows: .byte 1
002916                           noise_pattern_delay_frames: .byte 1
002917                           noise_pattern_offset: .byte 2
                                 
002919                           noise_volume_macro: .byte 2
00291b                           noise_volume_macro_offset: .byte 1
00291c                           noise_volume_macro_loop: .byte 1
00291d                           noise_volume_macro_release: .byte 1
                                 
00291e                           noise_arpeggio_macro: .byte 2
002920                           noise_arpeggio_macro_offset: .byte 1
002921                           noise_arpeggio_macro_loop: .byte 1
002922                           noise_arpeggio_macro_release: .byte 1
002923                           noise_arpeggio_macro_mode: .byte 1
                                 
002924                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002926                           noise_pitch_macro: .byte 2
002928                           noise_pitch_macro_offset: .byte 1
002929                           noise_pitch_macro_loop: .byte 1
00292a                           noise_pitch_macro_release: .byte 1
                                 
00292b                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00292c                           noise_hi_pitch_macro: .byte 2
00292e                           noise_hi_pitch_macro_offset: .byte 1
00292f                           noise_hi_pitch_macro_loop: .byte 1
002930                           noise_hi_pitch_macro_release: .byte 1
                                 
002931                           noise_duty_macro: .byte 2
002933                           noise_duty_macro_offset: .byte 1
002934                           noise_duty_macro_loop: .byte 1
002935                           noise_duty_macro_release: .byte 1
                                 
002936                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002938                           noise_fx_1xx: .byte 1 //refers to the rate in which to subtract the pitch from by the 1xx
002939                           noise_fx_1xx_total: .byte 1 //the total pitch offset for 1xx
00293a                           noise_fx_2xx: .byte 1 //refers to the rate in which to add to the pitch by the 2xx
00293b                           noise_fx_2xx_total: .byte 1 //the total pitch offset for 2xx
00293c                           noise_fx_4xy_speed: .byte 1
00293d                           noise_fx_4xy_depth: .byte 1
00293e                           noise_fx_4xy_phase: .byte 1
00293f                           noise_fx_4xy_offset: .byte 1
002940                           noise_fx_7xy_speed: .byte 1
002941                           noise_fx_7xy_depth: .byte 1
002942                           noise_fx_7xy_phase: .byte 1
002943                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002944                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002945                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002946                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002947                           noise_fx_Pxx_total: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002948                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002949                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
00294a                           dpcm_pattern: .byte 2
00294c                           dpcm_pattern_delay_rows: .byte 1
00294d                           dpcm_pattern_delay_frames: .byte 1
00294e                           dpcm_pattern_offset: .byte 2
                                 
002950                           dpcm_sample: .byte 2
002952                           dpcm_sample_offset: .byte 2
                                 
002954                           dpcm_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002955                           dpcm_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002956                           dpcm_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002957                           dpcm_fx_Sxx_post: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 //NOTE: same idea with one
                                 .def zero = r2
                                 .def one = r3
                                 .def frame_sequence = r4
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r7
                                 .def pulse1_length_counter = r8
                                 .def pulse1_sweep = r9 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r10
                                 .def pulse2_length_counter = r11
                                 .def pulse2_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 .def dpcm_shift = r13
                                 .def dpcm_bit_counter = r14
                                 .def dpcm_period = r15
                                 .def dpcm_length_LOW = r23
                                 .def dpcm_length_HIGH = r24
                                 
                                 
                                 reset:
000000 940c 1259                 	jmp init
                                 
                                 .org RTC_CNT_vect
000006 940c 1605                 	jmp frame_counter_routine
                                 
                                 .org TCB0_INT_vect
000018 940c 162d                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 167a                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 16c7                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 16d2                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(114): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(124): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(223): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(224): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(230): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(233): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(237): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(238): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(239): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(240): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(246): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(248): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(249): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(250): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(251): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(252): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(358): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
001259 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
00125a 93c0 0034                 	sts CPU_CCP, r28
00125c e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
00125d 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
00125f 2422                      	clr zero
                                 	//ONE
001260 e0c1                      	ldi r28, 1
001261 2e3c                      	mov one, r28
                                 	//FRAME SEQUENCE
001262 2c42                      	mov frame_sequence, zero
                                 
                                 	//MEMORY
001263 e3c0                      	ldi r28, 0b00110000
001264 93c0 2800                 	sts pulse1_param, r28
001266 e8c0                      	ldi r28, 0b10000000
001267 93c0 2801                 	sts pulse1_sweep_param, r28
001269 efcf                      	ldi r28, 0xFF
00126a 93c0 2802                 	sts pulse1_timerL, r28
00126c 93c0 2803                 	sts pulse1_timerH, r28
00126e 93c0 2804                 	sts pulse1_length, r28
                                 
001270 e3c0                      	ldi r28, 0b00110000
001271 93c0 2808                 	sts pulse2_param, r28
001273 e8c0                      	ldi r28, 0b10000000
001274 93c0 2809                 	sts pulse2_sweep_param, r28
001276 efcf                      	ldi r28, 0xFF
001277 93c0 280a                 	sts pulse2_timerL, r28
001279 93c0 280b                 	sts pulse2_timerH, r28
00127b 93c0 280c                 	sts pulse2_length, r28
                                 
00127d efcf                      	ldi r28, 0xFF
00127e 93c0 2810                 	sts triangle_timerL, r28
001280 93c0 2811                 	sts triangle_timerH, r28
                                 
001282 e3c0                      	ldi r28, 0b00110000
001283 93c0 2813                 	sts noise_param, r28
001285 e0cf                      	ldi r28, 0b00001111
001286 93c0 2814                 	sts noise_period, r28
                                 
001288 e0c4                      	ldi r28, 0x04
001289 93c0 281b                 	sts song_frame_offset, r28
00128b 9220 281c                 	sts song_frame_offset+1, zero
00128d efcf                      	ldi r28, 0xFF
00128e 93c0 2822                 	sts song_fx_Bxx, r28
001290 9220 2823                 	sts song_fx_Cxx, zero
001292 9220 2824                 	sts song_fx_Dxx, zero
001294 e4ee                      	ldi ZL, LOW(song0_frames << 1)
001295 e0f3                      	ldi ZH, HIGH(song0_frames << 1)
001296 93e0 2819                 	sts song_frames, ZL
001298 93f0 281a                 	sts song_frames+1, ZH
00129a 91c5                      	lpm r28, Z+ //load the song size
00129b 91d5                      	lpm r29, Z+
00129c 93c0 281d                 	sts song_size, r28
00129e 93d0 281e                 	sts song_size+1, r29
0012a0 91c5                      	lpm r28, Z+ //load the song tempo
0012a1 91d5                      	lpm r29, Z+
0012a2 93c0 281f                 	sts song_tempo, r28
0012a4 93d0 2820                 	sts song_tempo+1, r29
0012a6 9220 2821                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
0012a8 91c5                      	lpm r28, Z+
0012a9 91d5                      	lpm r29, Z+
0012aa 0fcc                      	lsl r28
0012ab 1fdd                      	rol r29
0012ac 93c0 2825                 	sts pulse1_pattern, r28
0012ae 93d0 2826                 	sts pulse1_pattern+1, r29
0012b0 9220 2827                 	sts pulse1_pattern_delay_rows, zero
0012b2 9230 2828                 	sts pulse1_pattern_delay_frames, one
0012b4 9220 2829                 	sts pulse1_pattern_offset, zero
0012b6 9220 282a                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0012b8 91c5                      	lpm r28, Z+
0012b9 91d5                      	lpm r29, Z+
0012ba 0fcc                      	lsl r28
0012bb 1fdd                      	rol r29
0012bc 93c0 2876                 	sts pulse2_pattern, r28
0012be 93d0 2877                 	sts pulse2_pattern+1, r29
0012c0 9220 2878                 	sts pulse2_pattern_delay_rows, zero
0012c2 9230 2879                 	sts pulse2_pattern_delay_frames, one
0012c4 9220 287a                 	sts pulse2_pattern_offset, zero
0012c6 9220 287b                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0012c8 91c5                      	lpm r28, Z+
0012c9 91d5                      	lpm r29, Z+
0012ca 0fcc                      	lsl r28
0012cb 1fdd                      	rol r29
0012cc 93c0 28c7                 	sts triangle_pattern, r28
0012ce 93d0 28c8                 	sts triangle_pattern+1, r29
0012d0 9220 28c9                 	sts triangle_pattern_delay_rows, zero
0012d2 9230 28ca                 	sts triangle_pattern_delay_frames, one
0012d4 9220 28cb                 	sts triangle_pattern_offset, zero
0012d6 9220 28cc                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0012d8 91c5                      	lpm r28, Z+
0012d9 91d5                      	lpm r29, Z+
0012da 0fcc                      	lsl r28
0012db 1fdd                      	rol r29
0012dc 93c0 2913                 	sts noise_pattern, r28
0012de 93d0 2914                 	sts noise_pattern+1, r29
0012e0 9220 2915                 	sts noise_pattern_delay_rows, zero
0012e2 9230 2916                 	sts noise_pattern_delay_frames, one
0012e4 9220 2917                 	sts noise_pattern_offset, zero
0012e6 9220 2918                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 4
0012e8 91c5                      	lpm r28, Z+
0012e9 91d5                      	lpm r29, Z+
0012ea 0fcc                      	lsl r28
0012eb 1fdd                      	rol r29
0012ec 93c0 294a                 	sts dpcm_pattern, r28
0012ee 93d0 294b                 	sts dpcm_pattern+1, r29
0012f0 9220 294c                 	sts dpcm_pattern_delay_rows, zero
0012f2 9230 294d                 	sts dpcm_pattern_delay_frames, one
0012f4 9220 294e                 	sts dpcm_pattern_offset, zero
0012f6 9220 294f                 	sts dpcm_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0012f8 efcf                      	ldi r28, 0xFF
0012f9 9220 282d                 	sts pulse1_volume_macro_offset, zero
0012fb 93c0 282e                 	sts pulse1_volume_macro_loop, r28
0012fd 93c0 282f                 	sts pulse1_volume_macro_release, r28
0012ff 9220 2832                 	sts pulse1_arpeggio_macro_offset, zero
001301 93c0 2833                 	sts pulse1_arpeggio_macro_loop, r28
001303 93c0 2834                 	sts pulse1_arpeggio_macro_release, r28
001305 93c0 2835                 	sts pulse1_arpeggio_macro_mode, r28
001307 9220 283a                 	sts pulse1_pitch_macro_offset, zero
001309 93c0 283b                 	sts pulse1_pitch_macro_loop, r28
00130b 93c0 283c                 	sts pulse1_pitch_macro_release, r28
00130d 9220 2840                 	sts pulse1_hi_pitch_macro_offset, zero
00130f 93c0 2841                 	sts pulse1_hi_pitch_macro_loop, r28
001311 93c0 2842                 	sts pulse1_hi_pitch_macro_release, r28
001313 9220 2845                 	sts pulse1_duty_macro_offset, zero
001315 93c0 2846                 	sts pulse1_duty_macro_loop, r28
001317 93c0 2847                 	sts pulse1_duty_macro_release, r28
                                 
001319 9220 282b                 	sts pulse1_volume_macro, zero
00131b 9220 282c                 	sts pulse1_volume_macro+1, zero
00131d 9220 2830                 	sts pulse1_arpeggio_macro, zero
00131f 9220 2831                 	sts pulse1_arpeggio_macro+1, zero
001321 9220 2836                 	sts pulse1_total_pitch_offset, zero
001323 9220 2837                 	sts pulse1_total_pitch_offset+1, zero
001325 9220 2838                 	sts pulse1_pitch_macro, zero
001327 9220 2839                 	sts pulse1_pitch_macro+1, zero
001329 9220 283d                 	sts pulse1_total_hi_pitch_offset, zero
00132b 9220 283e                 	sts pulse1_hi_pitch_macro, zero
00132d 9220 283f                 	sts pulse1_hi_pitch_macro+1, zero
00132f 9220 2843                 	sts pulse1_duty_macro, zero
001331 9220 2844                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001333 e00f                      	ldi pulse1_volume_divider, 0x0F
001334 9110 2800                 	lds pulse1_volume_decay, pulse1_param
001336 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001337 9190 2800                 	lds pulse_channel_flags, pulse1_param
001339 7390                      	andi pulse_channel_flags, 0b00110000
00133a 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
00133b 9220 2806                 	sts pulse1_output_volume, zero
00133d 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
00133f 2e8c                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001340 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001341 2e7c                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001342 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param
001344 9492                      	swap pulse1_sweep //swap data from high byte and low byte
001345 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
001346 efcf                      	ldi r28, 0xFF
001347 9220 2848                 	sts pulse1_fx_0xy_sequence, zero
001349 9220 2849                 	sts pulse1_fx_0xy_sequence+1, zero
00134b 9220 284a                 	sts pulse1_fx_1xx, zero
00134d 9220 284b                 	sts pulse1_fx_1xx+1, zero
00134f 9220 284c                 	sts pulse1_fx_1xx_total, zero
001351 9220 284d                 	sts pulse1_fx_1xx_total+1, zero
001353 9220 284e                 	sts pulse1_fx_2xx, zero
001355 9220 284f                 	sts pulse1_fx_2xx+1, zero
001357 9220 2850                 	sts pulse1_fx_2xx_total, zero
001359 9220 2851                 	sts pulse1_fx_2xx_total+1, zero
00135b 9220 2852                 	sts pulse1_fx_3xx_start, zero
00135d 9220 2853                 	sts pulse1_fx_3xx_start+1, zero
00135f 9220 2854                 	sts pulse1_fx_3xx_target, zero
001361 9220 2855                 	sts pulse1_fx_3xx_target+1, zero
001363 9220 2856                 	sts pulse1_fx_3xx_speed, zero
001365 9220 2857                 	sts pulse1_fx_3xx_speed+1, zero
001367 9220 2858                 	sts pulse1_fx_3xx_total_offset, zero
001369 9220 2859                 	sts pulse1_fx_3xx_total_offset+1, zero
00136b 9220 285a                 	sts pulse1_fx_4xy_speed, zero
00136d 9220 285b                 	sts pulse1_fx_4xy_depth, zero
00136f 9220 285c                 	sts pulse1_fx_4xy_phase, zero
001371 9220 285d                 	sts pulse1_fx_7xy_speed, zero
001373 9220 285e                 	sts pulse1_fx_7xy_depth, zero
001375 9220 285f                 	sts pulse1_fx_7xy_phase, zero
001377 9220 2860                 	sts pulse1_fx_7xy_value, zero
001379 9220 2861                 	sts pulse1_fx_Axy, zero
00137b 93c0 2862                 	sts pulse1_fx_Gxx_pre, r28
00137d 93c0 2863                 	sts pulse1_fx_Gxx_post, r28
00137f 9220 2864                 	sts pulse1_fx_Pxx_total, zero
001381 9220 2865                 	sts pulse1_fx_Pxx_total+1, zero
001383 9220 2866                 	sts pulse1_fx_Qxy_target_note, zero
001385 9220 2867                 	sts pulse1_fx_Qxy_target, zero
001387 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
001389 9220 2869                 	sts pulse1_fx_Qxy_speed, zero
00138b 9220 286a                 	sts pulse1_fx_Qxy_speed+1, zero
00138d 9220 286b                 	sts pulse1_fx_Qxy_total_offset, zero
00138f 9220 286c                 	sts pulse1_fx_Qxy_total_offset+1, zero
001391 9220 286d                 	sts pulse1_fx_Rxy_target_note, zero
001393 9220 286e                 	sts pulse1_fx_Rxy_target, zero
001395 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
001397 9220 2870                 	sts pulse1_fx_Rxy_speed, zero
001399 9220 2871                 	sts pulse1_fx_Rxy_speed+1, zero
00139b 9220 2872                 	sts pulse1_fx_Rxy_total_offset, zero
00139d 9220 2873                 	sts pulse1_fx_Rxy_total_offset+1, zero
00139f 93c0 2874                 	sts pulse1_fx_Sxx_pre, r28
0013a1 93c0 2875                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
0013a3 efcf                      	ldi r28, 0xFF
0013a4 9220 287e                 	sts pulse2_volume_macro_offset, zero
0013a6 93c0 287f                 	sts pulse2_volume_macro_loop, r28
0013a8 93c0 2880                 	sts pulse2_volume_macro_release, r28
0013aa 9220 2883                 	sts pulse2_arpeggio_macro_offset, zero
0013ac 93c0 2884                 	sts pulse2_arpeggio_macro_loop, r28
0013ae 93c0 2885                 	sts pulse2_arpeggio_macro_release, r28
0013b0 93c0 2886                 	sts pulse2_arpeggio_macro_mode, r28
0013b2 9220 288b                 	sts pulse2_pitch_macro_offset, zero
0013b4 93c0 288c                 	sts pulse2_pitch_macro_loop, r28
0013b6 93c0 288d                 	sts pulse2_pitch_macro_release, r28
0013b8 9220 2891                 	sts pulse2_hi_pitch_macro_offset, zero
0013ba 93c0 2892                 	sts pulse2_hi_pitch_macro_loop, r28
0013bc 93c0 2893                 	sts pulse2_hi_pitch_macro_release, r28
0013be 9220 2896                 	sts pulse2_duty_macro_offset, zero
0013c0 93c0 2897                 	sts pulse2_duty_macro_loop, r28
0013c2 93c0 2898                 	sts pulse2_duty_macro_release, r28
                                 
0013c4 9220 287c                 	sts pulse2_volume_macro, zero
0013c6 9220 287d                 	sts pulse2_volume_macro+1, zero
0013c8 9220 2881                 	sts pulse2_arpeggio_macro, zero
0013ca 9220 2882                 	sts pulse2_arpeggio_macro+1, zero
0013cc 9220 2887                 	sts pulse2_total_pitch_offset, zero
0013ce 9220 2888                 	sts pulse2_total_pitch_offset+1, zero
0013d0 9220 2889                 	sts pulse2_pitch_macro, zero
0013d2 9220 288a                 	sts pulse2_pitch_macro+1, zero
0013d4 9220 288e                 	sts pulse2_total_hi_pitch_offset, zero
0013d6 9220 288f                 	sts pulse2_hi_pitch_macro, zero
0013d8 9220 2890                 	sts pulse2_hi_pitch_macro+1, zero
0013da 9220 2894                 	sts pulse2_duty_macro, zero
0013dc 9220 2895                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0013de e02f                      	ldi pulse2_volume_divider, 0x0F
0013df 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0013e1 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0013e2 91d0 2808                 	lds r29, pulse2_param
0013e4 73d0                      	andi r29, 0b00110000
0013e5 62d0                      	sbr r29, 0b0100000 //set start flag
0013e6 95d2                      	swap r29
0013e7 2b9d                      	or pulse_channel_flags, r29
0013e8 9220 280e                 	sts pulse2_output_volume, zero
0013ea 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0013ec 2ebc                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0013ed e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0013ee 2eac                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0013ef 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0013f1 94c2                      	swap pulse2_sweep //swap data from high byte and low byte
0013f2 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0013f3 efcf                      	ldi r28, 0xFF
0013f4 9220 2899                 	sts pulse2_fx_0xy_sequence, zero
0013f6 9220 289a                 	sts pulse2_fx_0xy_sequence+1, zero
0013f8 9220 289b                 	sts pulse2_fx_1xx, zero
0013fa 9220 289c                 	sts pulse2_fx_1xx+1, zero
0013fc 9220 289d                 	sts pulse2_fx_1xx_total, zero
0013fe 9220 289e                 	sts pulse2_fx_1xx_total+1, zero
001400 9220 289f                 	sts pulse2_fx_2xx, zero
001402 9220 28a0                 	sts pulse2_fx_2xx+1, zero
001404 9220 28a1                 	sts pulse2_fx_2xx_total, zero
001406 9220 28a2                 	sts pulse2_fx_2xx_total+1, zero
001408 9220 28a3                 	sts pulse2_fx_3xx_start, zero
00140a 9220 28a4                 	sts pulse2_fx_3xx_start+1, zero
00140c 9220 28a5                 	sts pulse2_fx_3xx_target, zero
00140e 9220 28a6                 	sts pulse2_fx_3xx_target+1, zero
001410 9220 28a7                 	sts pulse2_fx_3xx_speed, zero
001412 9220 28a8                 	sts pulse2_fx_3xx_speed+1, zero
001414 9220 28a9                 	sts pulse2_fx_3xx_total_offset, zero
001416 9220 28aa                 	sts pulse2_fx_3xx_total_offset+1, zero
001418 9220 28ab                 	sts pulse2_fx_4xy_speed, zero
00141a 9220 28ac                 	sts pulse2_fx_4xy_depth, zero
00141c 9220 28ad                 	sts pulse2_fx_4xy_phase, zero
00141e 9220 28ae                 	sts pulse2_fx_7xy_speed, zero
001420 9220 28af                 	sts pulse2_fx_7xy_depth, zero
001422 9220 28b0                 	sts pulse2_fx_7xy_phase, zero
001424 9220 28b1                 	sts pulse2_fx_7xy_value, zero
001426 9220 28b2                 	sts pulse2_fx_Axy, zero
001428 93c0 28b3                 	sts pulse2_fx_Gxx_pre, r28
00142a 93c0 28b4                 	sts pulse2_fx_Gxx_post, r28
00142c 9220 28b5                 	sts pulse2_fx_Pxx_total, zero
00142e 9220 28b6                 	sts pulse2_fx_Pxx_total+1, zero
001430 9220 28b7                 	sts pulse2_fx_Qxy_target_note, zero
001432 9220 28b8                 	sts pulse2_fx_Qxy_target, zero
001434 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
001436 9220 28ba                 	sts pulse2_fx_Qxy_speed, zero
001438 9220 28bb                 	sts pulse2_fx_Qxy_speed+1, zero
00143a 9220 28bc                 	sts pulse2_fx_Qxy_total_offset, zero
00143c 9220 28bd                 	sts pulse2_fx_Qxy_total_offset+1, zero
00143e 9220 28be                 	sts pulse2_fx_Rxy_target_note, zero
001440 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
001442 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
001444 9220 28c1                 	sts pulse2_fx_Rxy_speed, zero
001446 9220 28c2                 	sts pulse2_fx_Rxy_speed+1, zero
001448 9220 28c3                 	sts pulse2_fx_Rxy_total_offset, zero
00144a 9220 28c4                 	sts pulse2_fx_Rxy_total_offset+1, zero
00144c 93c0 28c5                 	sts pulse2_fx_Sxx_pre, r28
00144e 93c0 28c6                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001450 efcf                      	ldi r28, 0xFF
001451 9220 28cf                 	sts triangle_volume_macro_offset, zero
001453 93c0 28d0                 	sts triangle_volume_macro_loop, r28
001455 93c0 28d1                 	sts triangle_volume_macro_release, r28
001457 9220 28d4                 	sts triangle_arpeggio_macro_offset, zero
001459 93c0 28d5                 	sts triangle_arpeggio_macro_loop, r28
00145b 93c0 28d6                 	sts triangle_arpeggio_macro_release, r28
00145d 93c0 28d7                 	sts triangle_arpeggio_macro_mode, r28
00145f 9220 28dc                 	sts triangle_pitch_macro_offset, zero
001461 93c0 28dd                 	sts triangle_pitch_macro_loop, r28
001463 93c0 28de                 	sts triangle_pitch_macro_release, r28
001465 9220 28e2                 	sts triangle_hi_pitch_macro_offset, zero
001467 93c0 28e3                 	sts triangle_hi_pitch_macro_loop, r28
001469 93c0 28e4                 	sts triangle_hi_pitch_macro_release, r28
00146b 9220 28e7                 	sts triangle_duty_macro_offset, zero
00146d 93c0 28e8                 	sts triangle_duty_macro_loop, r28
00146f 93c0 28e9                 	sts triangle_duty_macro_release, r28
                                 
001471 9220 28cd                 	sts triangle_volume_macro, zero
001473 9220 28ce                 	sts triangle_volume_macro+1, zero
001475 9220 28d2                 	sts triangle_arpeggio_macro, zero
001477 9220 28d3                 	sts triangle_arpeggio_macro+1, zero
001479 9220 28d8                 	sts triangle_total_pitch_offset, zero
00147b 9220 28d9                 	sts triangle_total_pitch_offset+1, zero
00147d 9220 28da                 	sts triangle_pitch_macro, zero
00147f 9220 28db                 	sts triangle_pitch_macro+1, zero
001481 9220 28df                 	sts triangle_total_hi_pitch_offset, zero
001483 9220 28e0                 	sts triangle_hi_pitch_macro, zero
001485 9220 28e1                 	sts triangle_hi_pitch_macro+1, zero
001487 9220 28e5                 	sts triangle_duty_macro, zero
001489 9220 28e6                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
00148b e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
00148c 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
00148d efcf                      	ldi r28, 0xFF
00148e 9220 28ea                 	sts triangle_fx_0xy_sequence, zero
001490 9220 28eb                 	sts triangle_fx_0xy_sequence+1, zero
001492 9220 28ec                 	sts triangle_fx_1xx, zero
001494 9220 28ed                 	sts triangle_fx_1xx+1, zero
001496 9220 28ee                 	sts triangle_fx_1xx_total, zero
001498 9220 28ef                 	sts triangle_fx_1xx_total+1, zero
00149a 9220 28f0                 	sts triangle_fx_2xx, zero
00149c 9220 28f1                 	sts triangle_fx_2xx+1, zero
00149e 9220 28f2                 	sts triangle_fx_2xx_total, zero
0014a0 9220 28f3                 	sts triangle_fx_2xx_total+1, zero
0014a2 9220 28f4                 	sts triangle_fx_3xx_start, zero
0014a4 9220 28f5                 	sts triangle_fx_3xx_start+1, zero
0014a6 9220 28f6                 	sts triangle_fx_3xx_target, zero
0014a8 9220 28f7                 	sts triangle_fx_3xx_target+1, zero
0014aa 9220 28f8                 	sts triangle_fx_3xx_speed, zero
0014ac 9220 28f9                 	sts triangle_fx_3xx_speed+1, zero
0014ae 9220 28fa                 	sts triangle_fx_3xx_total_offset, zero
0014b0 9220 28fb                 	sts triangle_fx_3xx_total_offset+1, zero
0014b2 9220 28fc                 	sts triangle_fx_4xy_speed, zero
0014b4 9220 28fd                 	sts triangle_fx_4xy_depth, zero
0014b6 9220 28fe                 	sts triangle_fx_4xy_phase, zero
0014b8 93c0 28ff                 	sts triangle_fx_Gxx_pre, r28
0014ba 93c0 2900                 	sts triangle_fx_Gxx_post, r28
0014bc 9220 2901                 	sts triangle_fx_Pxx_total, zero
0014be 9220 2902                 	sts triangle_fx_Pxx_total+1, zero
0014c0 9220 2903                 	sts triangle_fx_Qxy_target_note, zero
0014c2 9220 2904                 	sts triangle_fx_Qxy_target, zero
0014c4 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
0014c6 9220 2906                 	sts triangle_fx_Qxy_speed, zero
0014c8 9220 2907                 	sts triangle_fx_Qxy_speed+1, zero
0014ca 9220 2908                 	sts triangle_fx_Qxy_total_offset, zero
0014cc 9220 2909                 	sts triangle_fx_Qxy_total_offset+1, zero
0014ce 9220 290a                 	sts triangle_fx_Rxy_target_note, zero
0014d0 9220 290b                 	sts triangle_fx_Rxy_target, zero
0014d2 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
0014d4 9220 290d                 	sts triangle_fx_Rxy_speed, zero
0014d6 9220 290e                 	sts triangle_fx_Rxy_speed+1, zero
0014d8 9220 290f                 	sts triangle_fx_Rxy_total_offset, zero
0014da 9220 2910                 	sts triangle_fx_Rxy_total_offset+1, zero
0014dc 93c0 2911                 	sts triangle_fx_Sxx_pre, r28
0014de 93c0 2912                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0014e0 efcf                      	ldi r28, 0xFF
0014e1 9220 291b                 	sts noise_volume_macro_offset, zero
0014e3 93c0 291c                 	sts noise_volume_macro_loop, r28
0014e5 93c0 291d                 	sts noise_volume_macro_release, r28
0014e7 9220 2920                 	sts noise_arpeggio_macro_offset, zero
0014e9 93c0 2921                 	sts noise_arpeggio_macro_loop, r28
0014eb 93c0 2922                 	sts noise_arpeggio_macro_release, r28
0014ed 93c0 2923                 	sts noise_arpeggio_macro_mode, r28
0014ef 9220 2928                 	sts noise_pitch_macro_offset, zero
0014f1 93c0 2929                 	sts noise_pitch_macro_loop, r28
0014f3 93c0 292a                 	sts noise_pitch_macro_release, r28
0014f5 9220 292e                 	sts noise_hi_pitch_macro_offset, zero
0014f7 93c0 292f                 	sts noise_hi_pitch_macro_loop, r28
0014f9 93c0 2930                 	sts noise_hi_pitch_macro_release, r28
0014fb 9220 2933                 	sts noise_duty_macro_offset, zero
0014fd 93c0 2934                 	sts noise_duty_macro_loop, r28
0014ff 93c0 2935                 	sts noise_duty_macro_release, r28
                                 
001501 9220 2919                 	sts noise_volume_macro, zero
001503 9220 291a                 	sts noise_volume_macro+1, zero
001505 9220 291e                 	sts noise_arpeggio_macro, zero
001507 9220 291f                 	sts noise_arpeggio_macro+1, zero
001509 9220 2924                 	sts noise_total_pitch_offset, zero
00150b 9220 2925                 	sts noise_total_pitch_offset+1, zero
00150d 9220 2926                 	sts noise_pitch_macro, zero
00150f 9220 2927                 	sts noise_pitch_macro+1, zero
001511 9220 292b                 	sts noise_total_hi_pitch_offset, zero
001513 9220 292c                 	sts noise_hi_pitch_macro, zero
001515 9220 292d                 	sts noise_hi_pitch_macro+1, zero
001517 9220 2931                 	sts noise_duty_macro, zero
001519 9220 2932                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
00151b 9220 2816                 	sts noise_output_volume, zero
00151d 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
00151f e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001520 2f5c                      	mov noise_sequence_LOW, r28
001521 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
001522 efcf                      	ldi r28, 0xFF
001523 9220 2936                 	sts noise_fx_0xy_sequence, zero
001525 9220 2937                 	sts noise_fx_0xy_sequence+1, zero
001527 9220 2938                 	sts noise_fx_1xx, zero
001529 9220 2939                 	sts noise_fx_1xx_total, zero
00152b 9220 293a                 	sts noise_fx_2xx, zero
00152d 9220 293b                 	sts noise_fx_2xx_total, zero
00152f 9220 293c                 	sts noise_fx_4xy_speed, zero
001531 9220 293d                 	sts noise_fx_4xy_depth, zero
001533 9220 293e                 	sts noise_fx_4xy_phase, zero
001535 9220 293f                 	sts noise_fx_4xy_offset, zero
001537 9220 2940                 	sts noise_fx_7xy_speed, zero
001539 9220 2941                 	sts noise_fx_7xy_depth, zero
00153b 9220 2942                 	sts noise_fx_7xy_phase, zero
00153d 9220 2943                 	sts noise_fx_7xy_value, zero
00153f 9220 2944                 	sts noise_fx_Axy, zero
001541 93c0 2945                 	sts noise_fx_Gxx_pre, r28
001543 93c0 2946                 	sts noise_fx_Gxx_post, r28
001545 9220 2947                 	sts noise_fx_Pxx_total, zero
001547 93c0 2948                 	sts noise_fx_Sxx_pre, r28
001549 93c0 2949                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 4 SAMPLE
00154b 9220 2950                 	sts dpcm_sample, zero
00154d 9220 2951                 	sts dpcm_sample+1, zero
00154f 9220 2952                 	sts dpcm_sample_offset, zero
001551 9220 2953                 	sts dpcm_sample_offset+1, zero
001553 2cd2                      	mov dpcm_shift, zero
001554 2ce2                      	mov dpcm_bit_counter, zero
001555 2cf2                      	mov dpcm_period, zero
001556 2d72                      	mov dpcm_length_LOW, zero
001557 2d82                      	mov dpcm_length_HIGH, zero
                                 
                                 	//CHANNEL 4 FX
001558 93c0 2945                 	sts noise_fx_Gxx_pre, r28
00155a 93c0 2946                 	sts noise_fx_Gxx_post, r28
00155c 93c0 2948                 	sts noise_fx_Sxx_pre, r28
00155e 93c0 2949                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
001560 efcf                      	ldi r28, 0xFF
001561 b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
001562 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
001563 93c0 0a81                 	sts TCB0_CTRLB, r28
001565 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
001566 93c0 0a85                 	sts TCB0_INTCTRL, r28
001568 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
00156a 93c0 0a8c                 	sts TCB0_CCMPL, r28
00156c 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
00156e 93c0 0a8d                 	sts TCB0_CCMPH, r28
001570 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001571 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001573 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001574 93b0 0a91                 	sts TCB1_CTRLB, r27
001576 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001577 93b0 0a95                 	sts TCB1_INTCTRL, r27
001579 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00157b 93b0 0a9c                 	sts TCB1_CCMPL, r27
00157d 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
00157f 93b0 0a9d                 	sts TCB1_CCMPH, r27
001581 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001582 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001584 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001585 93b0 0aa1                 	sts TCB2_CTRLB, r27
001587 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
001588 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
00158a 93b0 0aac                 	sts TCB2_CCMPL, r27
00158c 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
00158e 93b0 0aad                 	sts TCB2_CCMPH, r27
001590 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001591 93b0 0aa0                 	sts TCB2_CTRLA, r27
001593 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
001594 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001595 93b0 0ab1                 	sts TCB3_CTRLB, r27
001597 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001598 93b0 0ab5                 	sts TCB3_INTCTRL, r27
00159a 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00159c 93b0 0abc                 	sts TCB3_CCMPL, r27
00159e 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
0015a0 93b0 0abd                 	sts TCB3_CCMPH, r27
0015a2 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0015a3 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 	//DPCM
                                 /*	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
                                 	sts TCA0_SINGLE_CTRLB, r28
                                 	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
                                 	sts TCA0_SINGLE_INTCTRL, r28
                                 	ldi r28, 0x15 //set the period for CMP0
                                 	sts TCA0_SINGLE_CMP0, r28
                                 	ldi r28, 0x05
                                 	sts TCA0_SINGLE_CMP0 + 1, r28
                                 	ldi r28, 0x2B //set the period for CMP1
                                 	sts TCA0_SINGLE_CMP1, r28
                                 	ldi r28, 0x0A
                                 	sts TCA0_SINGLE_CMP1 + 1, r28
                                 	ldi r28, 0x41 //set the period for CMP2
                                 	sts TCA0_SINGLE_CMP2, r28
                                 	ldi r28, 0x0F
                                 	sts TCA0_SINGLE_CMP2 + 1, r28
                                 	ldi r28, 0x57 //set the period for OVF
                                 	sts TCA0_SINGLE_PER, r28
                                 	ldi r28, 0x14
                                 	sts TCA0_SINGLE_PER + 1, r28
                                 	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
                                 	sts TCA0_SINGLE_CTRLA, r28*/
                                 
                                 	//RTC
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Interrupts will be setup to interrupt every 240 Hz clock
                                 	//The 4th consecutive interrupt will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//1st and 2nd interrupt will execute sequence 0 and 2. 3rd and 4th interrupt will execute sequence 1 and 3.
                                 	//Timer period Calculation: (0.00416666666 * 32768/16)-1 = 7.53333333333 = 0x0007
                                 	//The RTC timer is clocked at 32768 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /8 comes from the prescaler divider used
0015a5 e0b0                      	ldi r27, RTC_CLKSEL_INT32K_gc //internal 32kHz oscillator
0015a6 93b0 0147                 	sts RTC_CLKSEL, r27
0015a8 91b0 281f                 	lds r27, song_tempo
0015aa 91c0 2820                 	lds r28, song_tempo+1
0015ac 93b0 014a                 	sts RTC_PER, r27
0015ae 93c0 014b                 	sts RTC_PER + 1, r28
0015b0 e0b1                      	ldi r27, RTC_OVF_bm //overflow interrupts
0015b1 93b0 0142                 	sts RTC_INTCTRL, r27
0015b3 e0b9                      	ldi r27, RTC_PRESCALER_DIV2_gc | RTC_PITEN_bm //use prescaler divider of 16 and enable RTC
0015b4 93b0 0140                 	sts RTC_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
0015b6 91c0 2806                 	lds r28, pulse1_output_volume
0015b8 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
0015ba fe70                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0015bb c015                      	rjmp volume_mixer_pulse1_off
                                 
0015bc 1482                      	cp pulse1_length_counter, zero //if length is zero, return
0015bd f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
0015be 91e0 0a8c                 	lds r30, TCB0_CCMPL
0015c0 e5f9                      	ldi r31, 0x59
0015c1 17ef                      	cp r30, r31
0015c2 91e0 0a8d                 	lds r30, TCB0_CCMPH
0015c4 e0f0                      	ldi r31, 0x00
0015c5 07ef                      	cpc r30, r31
0015c6 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $595A
0015c7 91e0 0a8c                 	lds r30, TCB0_CCMPL
0015c9 e5fa                      	ldi r31, 0x5A
0015ca 17ef                      	cp r30, r31
0015cb 91e0 0a8d                 	lds r30, TCB0_CCMPH
0015cd e5f9                      	ldi r31, 0x59
0015ce 07ef                      	cpc r30, r31
0015cf f408                      	brsh volume_mixer_pulse1_off
0015d0 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0015d1 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0015d2 fea0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0015d3 c015                      	rjmp volume_mixer_pulse2_off
                                 
0015d4 14b2                      	cp pulse2_length_counter, zero //if length is zero, return
0015d5 f099                      	breq volume_mixer_pulse2_off
                                 
0015d6 91e0 0a9c                 	lds r30, TCB1_CCMPL
0015d8 e5f9                      	ldi r31, 0x59
0015d9 17ef                      	cp r30, r31
0015da 91e0 0a9d                 	lds r30, TCB1_CCMPH
0015dc e0f0                      	ldi r31, 0x00
0015dd 07ef                      	cpc r30, r31
0015de f050                      	brlo volume_mixer_pulse2_off
                                 
0015df 91e0 0a9c                 	lds r30, TCB1_CCMPL
0015e1 e5fa                      	ldi r31, 0x5A
0015e2 17ef                      	cp r30, r31
0015e3 91e0 0a9d                 	lds r30, TCB1_CCMPH
0015e5 e5f9                      	ldi r31, 0x59
0015e6 07ef                      	cpc r30, r31
0015e7 f408                      	brsh volume_mixer_pulse2_off
0015e8 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
0015e9 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
0015ea 0fcd                      	add r28, r29
0015eb e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
0015ec e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
0015ed 0fec                      	add ZL, r28
0015ee 1df2                      	adc ZH, zero
0015ef 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
0015f0 2fd4                      	mov r29, triangle_sequence
0015f1 fdd4                      	sbrc r29, 4 //check 5th bit
0015f2 95d0                      	com r29
0015f3 70df                      	andi r29, 0x0F
0015f4 2fed                      	mov r30, r29
0015f5 0fde                      	add r29, r30 //multiply the triangle volume by 3
0015f6 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
0015f7 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
0015f8 c004                      	rjmp volume_mixer_tnd_out
0015f9 91e0 2816                 	lds r30, noise_output_volume
0015fb 0fee                      	lsl r30 //multiply noise volume by 2
0015fc 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
0015fd e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
0015fe e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
0015ff 0fed                      	add ZL, r29
001600 1df2                      	adc ZH, zero
001601 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001602 0fcd                      	add r28, r29
001603 b9c1                      	out VPORTA_OUT, r28
001604 cfb1                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 frame_counter_routine:
001605 b7bf                      	in r27, CPU_SREG
001606 93bf                      	push r27
001607 94f8                      	cli
                                 
001608 2da4                      	mov r26, frame_sequence
001609 0c43                      	add frame_sequence, one
00160a 30a0                      	cpi r26, 0x00
00160b f029                      	breq sequence_0_2
00160c 30a1                      	cpi r26, 0x01
00160d f059                      	breq sequence_1_3
00160e 30a2                      	cpi r26, 0x02
00160f f009                      	breq sequence_0_2
001610 c0f3                      	rjmp sound_driver
                                 
                                 sequence_0_2:
                                 	//ENVELOPE
001611 d050                      	rcall pulse1_envelope_routine
001612 d09c                      	rcall pulse2_envelope_routine
                                 
001613 e0b3                      	ldi r27, RTC_CMP_bm | RTC_OVF_bm //clear OVF flag
001614 93b0 0143                 	sts RTC_INTFLAGS, r27
001616 91bf                      	pop r27
001617 bfbf                      	out CPU_SREG, r27
001618 9518                      	reti
                                 
                                 sequence_1_3:
                                 	//ENVELOPE
001619 d048                      	rcall pulse1_envelope_routine
00161a d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
00161b fc93                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
00161c d01b                      	rcall pulse1_sweep_routine
00161d fcc3                      	sbrc pulse2_sweep, 3
00161e d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
00161f fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001620 c002                      	rjmp sequence_1_3_pulse2_length
001621 1082                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001622 948a                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001623 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001624 c002                      	rjmp sequence_1_3_exit
001625 10b2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001626 94ba                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001627 e0b1                      	ldi r27, RTC_OVF_bm //clear OVF flag
001628 93b0 0143                 	sts RTC_INTFLAGS, r27
00162a 91bf                      	pop r27
00162b bfbf                      	out CPU_SREG, r27
00162c 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
00162d b7bf                      	in r27, CPU_SREG
00162e 93bf                      	push r27
00162f 94f8                      	cli
                                 
001630 0c77                      	lsl pulse1_sequence //shifts sequence to the left
001631 1c72                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001632 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001633 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001635 91bf                      	pop r27
001636 bfbf                      	out CPU_SREG, r27
001637 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001638 2db9                      	mov r27, pulse1_sweep
001639 70b7                      	andi r27, 0x07 //mask for period divider bits
00163a f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
00163b 93df                      	push r29
00163c 2dd9                      	mov r29, pulse1_sweep
00163d 95d2                      	swap r29
00163e 70d7                      	andi r29, 0x07 //mask for shift bits
00163f f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001640 91df                      	pop r29
001641 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001642 91a0 0a8c                 	lds r26, TCB0_CCMPL
001644 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001646 95b6                      	lsr r27
001647 95a7                      	ror r26
001648 95da                      	dec r29
001649 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
00164a fe97                      	sbrs pulse1_sweep, 7 //check the negate flag
00164b c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
00164c 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
00164d 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
00164e 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001650 0fad                      	add r26, r29
001651 91d0 0a8d                 	lds r29, TCB0_CCMPH
001653 1fbd                      	adc r27, r29
                                 
001654 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001656 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001658 91df                      	pop r29
001659 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
00165a 949a                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
00165b ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
00165c 9508                      	ret
                                 
                                 pulse1_sweep_reload:
00165d 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
00165f 9492                      	swap pulse1_sweep //bring data from high byte to low byte
001660 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
001661 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001662 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
001663 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001664 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001665 f011                      	breq PC+3 //if the divider == 0, check loop flag
001666 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001667 9508                      	ret
                                 
001668 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
00166a 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00166b ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
00166c c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
00166d e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
00166e 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
00166f 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001670 f409                      	brne PC+2 //if decay != 0, go decrement
001671 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001672 951a                      	dec pulse1_volume_decay
001673 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001674 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
001675 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001677 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001678 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001679 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
00167a b7bf                      	in r27, CPU_SREG
00167b 93bf                      	push r27
00167c 94f8                      	cli
                                 
00167d 0caa                      	lsl pulse2_sequence //shifts sequence to the left
00167e 1ca2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00167f e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001680 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001682 91bf                      	pop r27
001683 bfbf                      	out CPU_SREG, r27
001684 9518                      	reti
                                 
                                 pulse2_sweep_routine:
001685 2dbc                      	mov r27, pulse2_sweep
001686 70b7                      	andi r27, 0x07 //mask for period divider bits
001687 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001688 93df                      	push r29
001689 2ddc                      	mov r29, pulse2_sweep
00168a 95d2                      	swap r29
00168b 70d7                      	andi r29, 0x07 //mask for shift bits
00168c f411                      	brne pulse2_sweep_routine_action_main //shift != 0
00168d 91df                      	pop r29
00168e c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
00168f 91a0 0a9c                 	lds r26, TCB1_CCMPL
001691 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
001693 95b6                      	lsr r27
001694 95a7                      	ror r26
001695 95da                      	dec r29
001696 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001697 fec7                      	sbrs pulse2_sweep, 7 //check the negate flag
001698 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001699 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
00169a 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
00169b 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
00169d 0fad                      	add r26, r29
00169e 91d0 0a9d                 	lds r29, TCB1_CCMPH
0016a0 1fbd                      	adc r27, r29
                                 
0016a1 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
0016a3 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
0016a5 91df                      	pop r29
0016a6 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
0016a7 94ca                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
0016a8 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
0016a9 9508                      	ret
                                 
                                 pulse2_sweep_reload:
0016aa 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
0016ac 94c2                      	swap pulse2_sweep //bring data from high byte to low byte
0016ad 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
0016ae 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
0016af fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
0016b0 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
0016b1 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
0016b2 f011                      	breq PC+3 //if the divider == 0, check loop flag
0016b3 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
0016b4 9508                      	ret
                                 
0016b5 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
0016b7 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0016b8 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
0016b9 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0016ba e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0016bb 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
0016bc 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
0016bd f409                      	brne PC+2 //if decay != 0, go decrement
0016be 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0016bf 953a                      	dec pulse2_volume_decay
0016c0 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
0016c1 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
0016c2 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0016c4 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0016c5 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0016c6 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0016c7 b7bf                      	in r27, CPU_SREG
0016c8 93bf                      	push r27
0016c9 94f8                      	cli
                                 
0016ca 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0016cb 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0016cc e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0016cd 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0016cf 91bf                      	pop r27
0016d0 bfbf                      	out CPU_SREG, r27
0016d1 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0016d2 b7bf                      	in r27, CPU_SREG
0016d3 93bf                      	push r27
0016d4 94f8                      	cli
                                 
0016d5 2fa5                      	mov r26, noise_sequence_LOW
0016d6 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0016d7 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0016d8 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0016d9 27a5                      	eor r26, noise_sequence_LOW
0016da fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0016db c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0016dc 9566                      	lsr noise_sequence_HIGH
0016dd 9557                      	ror noise_sequence_LOW
0016de c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
0016df 9566                      	lsr noise_sequence_HIGH
0016e0 9557                      	ror noise_sequence_LOW
0016e1 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
0016e2 c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
0016e3 0faa                      	lsl r26
0016e4 1faa                      	rol r26
0016e5 1faa                      	rol r26 //move the 6th bit to the 0th bit place
0016e6 27a5                      	eor r26, noise_sequence_LOW
0016e7 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0016e8 c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
0016e9 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
0016ea 9566                      	lsr noise_sequence_HIGH
0016eb 9557                      	ror noise_sequence_LOW
0016ec 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0016ed c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
0016ee 9566                      	lsr noise_sequence_HIGH
0016ef 9557                      	ror noise_sequence_LOW
0016f0 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0016f1 c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
0016f2 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0016f3 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
0016f5 91bf                      	pop r27
0016f6 bfbf                      	out CPU_SREG, r27
0016f7 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0016f8 e9e4                      	ldi ZL, LOW(length << 1)
0016f9 e6f1                      	ldi ZH, HIGH(length << 1)
0016fa 0fed                      	add ZL, r29
0016fb 1df2                      	adc ZH, zero
0016fc 91d4                      	lpm r29, Z
0016fd 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0016fe ebe4                      	ldi ZL, LOW(sequences << 1)
0016ff e6f1                      	ldi ZH, HIGH(sequences << 1)
001700 0fed                      	add ZL, r29
001701 1df2                      	adc ZH, zero
001702 91d4                      	lpm r29, Z
001703 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
001704 2c42                      	mov frame_sequence, zero
001705 93cf                      	push r28
001706 93df                      	push r29
001707 93ef                      	push r30
001708 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
001709 91a0 2822                 	lds r26, song_fx_Bxx
00170b 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
00170c f4a9                      	brne sound_driver_fx_Bxx_routine
00170d 91a0 2823                 	lds r26, song_fx_Cxx
00170f 11a2                      	cpse r26, zero
001710 c0a3                      	rjmp sound_driver_fx_Cxx_routine
001711 91a0 2824                 	lds r26, song_fx_Dxx
001713 11a2                      	cpse r26, zero
001714 c0ae                      	rjmp sound_driver_fx_Dxx_routine
                                 
001715 91a0 281b                 	lds r26, song_frame_offset
001717 91b0 281c                 	lds r27, song_frame_offset+1
001719 91c0 281d                 	lds r28, song_size
00171b 91d0 281e                 	lds r29, song_size+1
00171d 17ac                      	cp r26, r28
00171e 07bd                      	cpc r27, r29
00171f f408                      	brsh sound_driver_fx_song_loop
001720 c131                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
001721 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001722 91e0 2819                 	lds ZL, song_frames
001724 91f0 281a                 	lds ZH, song_frames+1
001726 27cc                      	clr r28 //initialize r29:r28 to 0
001727 27dd                      	clr r29
001728 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001729 95aa                      	dec r26
00172a f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
00172b 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
00172c cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
00172d 9624                      	adiw r29:r28, 4 //add 4 to skip the first 4 bytes (first 4 bytes is the song size and tempo)
00172e 93c0 281b                 	sts song_frame_offset, r28
001730 93d0 281c                 	sts song_frame_offset+1, r29
001732 0fec                      	add ZL, r28
001733 1ffd                      	adc ZH, r29
                                 
001734 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
001735 91b5                      	lpm r27, Z+
001736 0faa                      	lsl r26
001737 1fbb                      	rol r27
001738 93a0 2825                 	sts pulse1_pattern, r26
00173a 93b0 2826                 	sts pulse1_pattern+1, r27
00173c 91a5                      	lpm r26, Z+
00173d 91b5                      	lpm r27, Z+
00173e 0faa                      	lsl r26
00173f 1fbb                      	rol r27
001740 93a0 2876                 	sts pulse2_pattern, r26
001742 93b0 2877                 	sts pulse2_pattern+1, r27
001744 91a5                      	lpm r26, Z+
001745 91b5                      	lpm r27, Z+
001746 0faa                      	lsl r26
001747 1fbb                      	rol r27
001748 93a0 28c7                 	sts triangle_pattern, r26
00174a 93b0 28c8                 	sts triangle_pattern+1, r27
00174c 91a5                      	lpm r26, Z+
00174d 91b5                      	lpm r27, Z+
00174e 0faa                      	lsl r26
00174f 1fbb                      	rol r27
001750 93a0 2913                 	sts noise_pattern, r26
001752 93b0 2914                 	sts noise_pattern+1, r27
001754 91a5                      	lpm r26, Z+
001755 91b5                      	lpm r27, Z+
001756 0faa                      	lsl r26
001757 1fbb                      	rol r27
001758 93a0 294a                 	sts dpcm_pattern, r26
00175a 93b0 294b                 	sts dpcm_pattern+1, r27
                                 
00175c 9220 2829                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00175e 9220 282a                 	sts pulse1_pattern_offset+1, zero
001760 9220 2827                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001762 9230 2828                 	sts pulse1_pattern_delay_frames, one
001764 9220 287a                 	sts pulse2_pattern_offset, zero
001766 9220 287b                 	sts pulse2_pattern_offset+1, zero
001768 9220 2878                 	sts pulse2_pattern_delay_rows, zero
00176a 9230 2879                 	sts pulse2_pattern_delay_frames, one
00176c 9220 28cb                 	sts triangle_pattern_offset, zero
00176e 9220 28cc                 	sts triangle_pattern_offset+1, zero
001770 9220 28c9                 	sts triangle_pattern_delay_rows, zero
001772 9230 28ca                 	sts triangle_pattern_delay_frames, one
001774 9220 2917                 	sts noise_pattern_offset, zero
001776 9220 2918                 	sts noise_pattern_offset+1, zero
001778 9220 2915                 	sts noise_pattern_delay_rows, zero
00177a 9230 2916                 	sts noise_pattern_delay_frames, one
00177c 9220 294e                 	sts dpcm_pattern_offset, zero
00177e 9220 294e                 	sts dpcm_pattern_offset, zero
001780 9220 294c                 	sts dpcm_pattern_delay_rows, zero
001782 9230 294d                 	sts dpcm_pattern_delay_frames, one
                                 
001784 efaf                      	ldi r26, 0xFF
001785 93a0 2862                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001787 93a0 2863                 	sts pulse1_fx_Gxx_post, r26
001789 93a0 2874                 	sts pulse1_fx_Sxx_pre, r26
00178b 93a0 2875                 	sts pulse1_fx_Sxx_post, r26
00178d 93a0 28b3                 	sts pulse2_fx_Gxx_pre, r26
00178f 93a0 28b4                 	sts pulse2_fx_Gxx_post, r26
001791 93a0 28c5                 	sts pulse2_fx_Sxx_pre, r26
001793 93a0 28c6                 	sts pulse2_fx_Sxx_post, r26
001795 93a0 28ff                 	sts triangle_fx_Gxx_pre, r26
001797 93a0 2900                 	sts triangle_fx_Gxx_post, r26
001799 93a0 2911                 	sts triangle_fx_Sxx_pre, r26
00179b 93a0 2912                 	sts triangle_fx_Sxx_post, r26
00179d 93a0 2945                 	sts noise_fx_Gxx_pre, r26
00179f 93a0 2946                 	sts noise_fx_Gxx_post, r26
0017a1 93a0 2948                 	sts noise_fx_Sxx_pre, r26
0017a3 93a0 2949                 	sts noise_fx_Sxx_post, r26
0017a5 93a0 2954                 	sts dpcm_fx_Gxx_pre, r26
0017a7 93a0 2955                 	sts dpcm_fx_Gxx_post, r26
0017a9 93a0 2956                 	sts dpcm_fx_Sxx_pre, r26
0017ab 93a0 2957                 	sts dpcm_fx_Sxx_post, r26
                                 
0017ad 93a0 2822                 	sts song_fx_Bxx, r26 //reset all song effects
0017af 9220 2823                 	sts song_fx_Cxx, zero
0017b1 9220 2824                 	sts song_fx_Dxx, zero
0017b3 c09e                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
0017b4 91ff                      	pop r31
0017b5 91ef                      	pop r30
0017b6 91df                      	pop r29
0017b7 91cf                      	pop r28
0017b8 91bf                      	pop r27
0017b9 bfbf                      	out CPU_SREG, r27
0017ba 94f8                      	cli //disable global interrupts
                                 		
0017bb efaf                      	ldi r26, 0xFF
0017bc 93a0 2822                 	sts song_fx_Bxx, r26 //reset all song effects
0017be 9220 2823                 	sts song_fx_Cxx, zero
0017c0 9220 2824                 	sts song_fx_Dxx, zero
0017c2 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
0017c3 91e0 2819                 	lds ZL, song_frames
0017c5 91f0 281a                 	lds ZH, song_frames+1
0017c7 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0017c9 91b0 281c                 	lds r27, song_frame_offset+1
0017cb 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0017cc 93a0 281b                 	sts song_frame_offset, r26
0017ce 93b0 281c                 	sts song_frame_offset+1, r27
0017d0 0fea                      	add ZL, r26
0017d1 1ffb                      	adc ZH, r27
                                 
0017d2 91a5                      	lpm r26, Z+ //load the address of the next pattern
0017d3 91b5                      	lpm r27, Z+
0017d4 0faa                      	lsl r26
0017d5 1fbb                      	rol r27
0017d6 93a0 2825                 	sts pulse1_pattern, r26
0017d8 93b0 2826                 	sts pulse1_pattern+1, r27
0017da 91a5                      	lpm r26, Z+
0017db 91b5                      	lpm r27, Z+
0017dc 0faa                      	lsl r26
0017dd 1fbb                      	rol r27
0017de 93a0 2876                 	sts pulse2_pattern, r26
0017e0 93b0 2877                 	sts pulse2_pattern+1, r27
0017e2 91a5                      	lpm r26, Z+
0017e3 91b5                      	lpm r27, Z+
0017e4 0faa                      	lsl r26
0017e5 1fbb                      	rol r27
0017e6 93a0 28c7                 	sts triangle_pattern, r26
0017e8 93b0 28c8                 	sts triangle_pattern+1, r27
0017ea 91a5                      	lpm r26, Z+
0017eb 91b5                      	lpm r27, Z+
0017ec 0faa                      	lsl r26
0017ed 1fbb                      	rol r27
0017ee 93a0 2913                 	sts noise_pattern, r26
0017f0 93b0 2914                 	sts noise_pattern+1, r27
0017f2 91a5                      	lpm r26, Z+
0017f3 91b5                      	lpm r27, Z+
0017f4 0faa                      	lsl r26
0017f5 1fbb                      	rol r27
0017f6 93a0 294a                 	sts dpcm_pattern, r26
0017f8 93b0 294b                 	sts dpcm_pattern+1, r27
                                 
0017fa 9220 2829                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0017fc 9220 282a                 	sts pulse1_pattern_offset+1, zero
0017fe 9220 2827                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001800 9230 2828                 	sts pulse1_pattern_delay_frames, one
001802 9220 287a                 	sts pulse2_pattern_offset, zero
001804 9220 287b                 	sts pulse2_pattern_offset+1, zero
001806 9220 2878                 	sts pulse2_pattern_delay_rows, zero
001808 9230 2879                 	sts pulse2_pattern_delay_frames, one
00180a 9220 28cb                 	sts triangle_pattern_offset, zero
00180c 9220 28cc                 	sts triangle_pattern_offset+1, zero
00180e 9220 28c9                 	sts triangle_pattern_delay_rows, zero
001810 9230 28ca                 	sts triangle_pattern_delay_frames, one
001812 9220 2917                 	sts noise_pattern_offset, zero
001814 9220 2918                 	sts noise_pattern_offset+1, zero
001816 9220 2915                 	sts noise_pattern_delay_rows, zero
001818 9230 2916                 	sts noise_pattern_delay_frames, one
00181a 9220 294e                 	sts dpcm_pattern_offset, zero
00181c 9220 294e                 	sts dpcm_pattern_offset, zero
00181e 9220 294c                 	sts dpcm_pattern_delay_rows, zero
001820 9230 294d                 	sts dpcm_pattern_delay_frames, one
                                 
001822 efaf                      	ldi r26, 0xFF
001823 93a0 2862                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001825 93a0 2863                 	sts pulse1_fx_Gxx_post, r26
001827 93a0 2874                 	sts pulse1_fx_Sxx_pre, r26
001829 93a0 2875                 	sts pulse1_fx_Sxx_post, r26
00182b 93a0 28b3                 	sts pulse2_fx_Gxx_pre, r26
00182d 93a0 28b4                 	sts pulse2_fx_Gxx_post, r26
00182f 93a0 28c5                 	sts pulse2_fx_Sxx_pre, r26
001831 93a0 28c6                 	sts pulse2_fx_Sxx_post, r26
001833 93a0 28ff                 	sts triangle_fx_Gxx_pre, r26
001835 93a0 2900                 	sts triangle_fx_Gxx_post, r26
001837 93a0 2911                 	sts triangle_fx_Sxx_pre, r26
001839 93a0 2912                 	sts triangle_fx_Sxx_post, r26
00183b 93a0 2945                 	sts noise_fx_Gxx_pre, r26
00183d 93a0 2946                 	sts noise_fx_Gxx_post, r26
00183f 93a0 2948                 	sts noise_fx_Sxx_pre, r26
001841 93a0 2949                 	sts noise_fx_Sxx_post, r26
001843 93a0 2954                 	sts dpcm_fx_Gxx_pre, r26
001845 93a0 2955                 	sts dpcm_fx_Gxx_post, r26
001847 93a0 2956                 	sts dpcm_fx_Sxx_pre, r26
001849 93a0 2957                 	sts dpcm_fx_Sxx_post, r26
                                 
00184b 93a0 2822                 	sts song_fx_Bxx, r26 //reset all song effects
00184d 9220 2823                 	sts song_fx_Cxx, zero
00184f 9220 2824                 	sts song_fx_Dxx, zero
001851 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001852 91a0 2827                 	lds r26, pulse1_pattern_delay_rows
001854 91b0 2828                 	lds r27, pulse1_pattern_delay_frames
                                 sound_driver_channel0_decrement_frame_delay:
001856 95ba                      	dec r27
001857 93b0 2828                 	sts pulse1_pattern_delay_frames, r27
                                 
001859 9610                      	adiw r27:r26, 0
00185a f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
00185b c2e4                      	rjmp sound_driver_channel0_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel0_main:
00185c 91e0 2825                 	lds ZL, pulse1_pattern //current pattern for pulse 1
00185e 91f0 2826                 	lds ZH, pulse1_pattern+1
001860 91a0 2829                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
001862 91b0 282a                 	lds r27, pulse1_pattern_offset+1
001864 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001865 1ffb                      	adc ZH, r27
001866 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
001867 35b7                      	cpi r27, 0x57
001868 f408                      	brsh sound_driver_channel0_check_if_volume
001869 c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
00186a 36b7                      	cpi r27, 0x67
00186b f408                      	brsh sound_driver_channel0_check_if_delay
00186c c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
00186d 3eb3                      	cpi r27, 0xE3
00186e f408                      	brsh sound_driver_channel0_check_if_instrument
00186f c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001870 f409                      	brne sound_driver_channel0_check_if_release
001871 c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
001872 3eb4                      	cpi r27, 0xE4
001873 f409                      	brne sound_driver_channel0_check_if_end
001874 c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001875 3fbf                      	cpi r27, 0xFF
001876 f409                      	brne sound_driver_channel0_check_if_fx
001877 c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001878 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001879 91a4                      	lpm r26, Z //load the fx data into r26
00187a d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
00187b 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
00187c ebe8                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
00187d e6f1                      	ldi ZH, HIGH(channel0_fx << 1)
00187e 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00187f 0feb                      	add ZL, r27 //add offset
001880 1df2                      	adc ZH, zero
001881 91c5                      	lpm r28, Z+ //load address bytes
001882 91d4                      	lpm r29, Z
001883 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001884 2ffd                      	mov ZH, r29
001885 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001886 93a0 2848                 	sts pulse1_fx_0xy_sequence, r26
001888 9220 2849                 	sts pulse1_fx_0xy_sequence+1, zero
00188a cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00188b 9220 284e                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
00188d 9220 284f                 	sts pulse1_fx_2xx+1, zero
00188f 9220 2848                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001891 9220 2849                 	sts pulse1_fx_0xy_sequence+1, zero
001893 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001894 937f                      	push r23
001895 2f6a                      	mov r22, r26 //store the rate into r22
001896 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001897 9f67                      	mul r22, r23
001898 917f                      	pop r23
001899 916f                      	pop r22
                                 
00189a 9416                      	lsr r1 //shift out the fractional bits
00189b 9407                      	ror r0
00189c 9416                      	lsr r1
00189d 9407                      	ror r0
00189e 9416                      	lsr r1
00189f 9407                      	ror r0
0018a0 9416                      	lsr r1
0018a1 9407                      	ror r0
0018a2 9200 284a                 	sts pulse1_fx_1xx, r0
0018a4 9210 284b                 	sts pulse1_fx_1xx+1, r1
0018a6 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
0018a7 9220 284a                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0018a9 9220 284b                 	sts pulse1_fx_1xx+1, zero
0018ab 9220 2848                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0018ad 9220 2849                 	sts pulse1_fx_0xy_sequence+1, zero
0018af 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018b0 937f                      	push r23
0018b1 2f6a                      	mov r22, r26 //store the rate into r22
0018b2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018b3 9f67                      	mul r22, r23
0018b4 917f                      	pop r23
0018b5 916f                      	pop r22
                                 
0018b6 9416                      	lsr r1 //shift out the fractional bits
0018b7 9407                      	ror r0
0018b8 9416                      	lsr r1
0018b9 9407                      	ror r0
0018ba 9416                      	lsr r1
0018bb 9407                      	ror r0
0018bc 9416                      	lsr r1
0018bd 9407                      	ror r0
0018be 9200 284e                 	sts pulse1_fx_2xx, r0
0018c0 9210 284f                 	sts pulse1_fx_2xx+1, r1
0018c2 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0018c3 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0018c4 937f                      	push r23
0018c5 2f6a                      	mov r22, r26 //store the rate into r22
0018c6 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018c7 9f67                      	mul r22, r23
0018c8 917f                      	pop r23
0018c9 916f                      	pop r22
                                 
0018ca 9416                      	lsr r1 //shift out the fractional bits
0018cb 9407                      	ror r0
0018cc 9416                      	lsr r1
0018cd 9407                      	ror r0
0018ce 9416                      	lsr r1
0018cf 9407                      	ror r0
0018d0 9416                      	lsr r1
0018d1 9407                      	ror r0
0018d2 9200 2856                 	sts pulse1_fx_3xx_speed, r0
0018d4 9210 2857                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0018d6 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0018d7 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0018d8 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0018d9 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0018db 91b0 0a8d                 	lds r27, TCB0_CCMPH
0018dd 93a0 2852                 	sts pulse1_fx_3xx_start, r26
0018df 93b0 2853                 	sts pulse1_fx_3xx_start+1, r27
                                 
0018e1 9220 2858                 	sts pulse1_fx_3xx_total_offset, zero
0018e3 9220 2859                 	sts pulse1_fx_3xx_total_offset+1, zero
0018e5 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0018e6 2fba                      	mov r27, r26
0018e7 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0018e8 95a2                      	swap r26
0018e9 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0018ea 93a0 285a                 	sts pulse1_fx_4xy_speed, r26
0018ec 93b0 285b                 	sts pulse1_fx_4xy_depth, r27
0018ee 9220 285c                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0018f0 cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0018f1 2fba                      	mov r27, r26
0018f2 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0018f3 95a2                      	swap r26
0018f4 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0018f5 93a0 285d                 	sts pulse1_fx_7xy_speed, r26
0018f7 93b0 285e                 	sts pulse1_fx_7xy_depth, r27
0018f9 9220 285f                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0018fb 9220 2860                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0018fd cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0018fe 93a0 2861                 	sts pulse1_fx_Axy, r26
001900 cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
001901 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001903 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
001904 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001906 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
001907 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001909 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
00190a 91b0 2800                 	lds r27, pulse1_param
00190c 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
00190d 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
00190e 93b0 2800                 	sts pulse1_param, r27
001910 6096                      	sbr pulse_channel_flags, 6
001911 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
001912 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001914 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
001915 15a2                      	cp r26, zero
001916 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
001917 91b0 2821                 	lds r27, song_speed
001919 17ab                      	cp r26, r27
00191a f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
00191b 93a0 2862                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00191d e0b1                      	ldi r27, 0x01
00191e 93b0 2827                 	sts pulse1_pattern_delay_rows, r27
001920 c22e                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
001921 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001922 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
001923 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
001924 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
001925 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
001926 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001927 937f                      	push r23
001928 2f6a                      	mov r22, r26
001929 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00192a 0367                      	mulsu r22, r23
00192b 917f                      	pop r23
00192c 916f                      	pop r22
00192d 9416                      	lsr r1 //shift out the fractional bits
00192e 9407                      	ror r0
00192f 9416                      	lsr r1
001930 9407                      	ror r0
001931 9416                      	lsr r1
001932 9407                      	ror r0
001933 9416                      	lsr r1
001934 9407                      	ror r0
001935 fe13                      	sbrs r1, 3 //check if result was a negative number
001936 c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
001937 efb0                      	ldi r27, 0xF0
001938 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
001939 9200 2864                 	sts pulse1_fx_Pxx_total, r0
00193b 9210 2865                 	sts pulse1_fx_Pxx_total+1, r1
00193d cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
00193e 91e0 2830                 	lds ZL, pulse1_arpeggio_macro
001940 91f0 2831                 	lds ZH, pulse1_arpeggio_macro+1
001942 9630                      	adiw Z, 0
001943 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001944 cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001945 91e0 2838                 	lds ZL, pulse1_pitch_macro
001947 91f0 2839                 	lds ZH, pulse1_pitch_macro+1
001949 9630                      	adiw Z, 0
00194a f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
00194b cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
00194c 91e0 283e                 	lds ZL, pulse1_hi_pitch_macro
00194e 91f0 283f                 	lds ZH, pulse1_hi_pitch_macro+1
001950 9630                      	adiw Z, 0
001951 f009                      	breq sound_driver_channel0_fx_Qxy_process
001952 cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001953 2fba                      	mov r27, r26 //copy fx parameters into r27
001954 70bf                      	andi r27, 0x0F //mask note index offset
001955 91c0 2866                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
001957 0fbc                      	add r27, r28
001958 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001959 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
00195a e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
00195b 93b0 2866                 	sts pulse1_fx_Qxy_target_note, r27
00195d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00195e e0f0                      	ldi ZH, HIGH(note_table << 1)
00195f 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001960 0feb                      	add ZL, r27 //add offset
001961 1df2                      	adc ZH, zero
001962 91c5                      	lpm r28, Z+ //load bytes
001963 91d4                      	lpm r29, Z
001964 93c0 2867                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001966 93d0 2868                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
001968 95a2                      	swap r26
001969 70af                      	andi r26, 0x0F //mask effect speed
00196a 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00196b 95a3                      	inc r26 //increment the speed by 1
                                 
00196c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00196d 937f                      	push r23
00196e 2f6a                      	mov r22, r26 //store the speed data into r27
00196f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001970 9f67                      	mul r22, r23
001971 917f                      	pop r23
001972 916f                      	pop r22
                                 
001973 9416                      	lsr r1 //shift out the fractional bits
001974 9407                      	ror r0
001975 9416                      	lsr r1
001976 9407                      	ror r0
001977 9416                      	lsr r1
001978 9407                      	ror r0
001979 9416                      	lsr r1
00197a 9407                      	ror r0
                                 
00197b 9200 2869                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
00197d 9210 286a                 	sts pulse1_fx_Qxy_speed+1, r1
00197f cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001980 91e0 2830                 	lds ZL, pulse1_arpeggio_macro
001982 91f0 2831                 	lds ZH, pulse1_arpeggio_macro+1
001984 9630                      	adiw Z, 0
001985 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001986 ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001987 91e0 2838                 	lds ZL, pulse1_pitch_macro
001989 91f0 2839                 	lds ZH, pulse1_pitch_macro+1
00198b 9630                      	adiw Z, 0
00198c f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
00198d cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
00198e 91e0 283e                 	lds ZL, pulse1_hi_pitch_macro
001990 91f0 283f                 	lds ZH, pulse1_hi_pitch_macro+1
001992 9630                      	adiw Z, 0
001993 f009                      	breq sound_driver_channel0_fx_Rxy_process
001994 cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001995 2fba                      	mov r27, r26 //copy fx parameters into r27
001996 70bf                      	andi r27, 0x0F //mask note index offset
001997 91c0 286d                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
001999 1bcb                      	sub r28, r27
00199a f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
00199b e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
00199c 93c0 286d                 	sts pulse1_fx_Rxy_target_note, r28
00199e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00199f e0f0                      	ldi ZH, HIGH(note_table << 1)
0019a0 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
0019a1 0fec                      	add ZL, r28 //add offset
0019a2 1df2                      	adc ZH, zero
0019a3 91c5                      	lpm r28, Z+ //load bytes
0019a4 91d4                      	lpm r29, Z
0019a5 93c0 286e                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
0019a7 93d0 286f                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
0019a9 95a2                      	swap r26
0019aa 70af                      	andi r26, 0x0F //mask effect speed
0019ab 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0019ac 95a3                      	inc r26 //increment the speed by 1
                                 
0019ad 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0019ae 937f                      	push r23
0019af 2f6a                      	mov r22, r26 //store the speed data into r27
0019b0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0019b1 9f67                      	mul r22, r23
0019b2 917f                      	pop r23
0019b3 916f                      	pop r22
                                 
0019b4 9416                      	lsr r1 //shift out the fractional bits
0019b5 9407                      	ror r0
0019b6 9416                      	lsr r1
0019b7 9407                      	ror r0
0019b8 9416                      	lsr r1
0019b9 9407                      	ror r0
0019ba 9416                      	lsr r1
0019bb 9407                      	ror r0
                                 
0019bc 9200 2870                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
0019be 9210 2871                 	sts pulse1_fx_Rxy_speed+1, r1
0019c0 ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
0019c1 15a2                      	cp r26, zero
0019c2 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
0019c3 91b0 2821                 	lds r27, song_speed
0019c5 17ab                      	cp r26, r27
0019c6 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
0019c7 93a0 2874                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0019c9 e0b1                      	ldi r27, 0x01
0019ca 93b0 2827                 	sts pulse1_pattern_delay_rows, r27
0019cc c182                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
0019cd ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
0019ce ebe4                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0019cf e6f1                      	ldi ZH, HIGH(sequences << 1)
0019d0 0fea                      	add ZL, r26 //offset the pointer
0019d1 1df2                      	adc ZH, zero
                                 
0019d2 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0019d3 95a7                      	ror r26
0019d4 95a7                      	ror r26
0019d5 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0019d7 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0019d8 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0019d9 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0019da c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0019db ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0019dc 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
0019dd 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0019de 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0019df 93c0 2800                 	sts pulse1_param, r28
0019e1 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0019e2 ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
0019e3 ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
0019e4 ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
0019e5 ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
0019e6 93b0 2807                 	sts pulse1_note, r27 //store the note index
0019e8 93b0 2866                 	sts pulse1_fx_Qxy_target_note, r27
0019ea 93b0 286d                 	sts pulse1_fx_Rxy_target_note, r27
0019ec e0a3                      	ldi r26, 0x03
0019ed e0b2                      	ldi r27, 0x02
0019ee 93b0 282d                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0019f0 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26
0019f2 93b0 283a                 	sts pulse1_pitch_macro_offset, r27
0019f4 93b0 2840                 	sts pulse1_hi_pitch_macro_offset, r27
0019f6 93b0 2845                 	sts pulse1_duty_macro_offset, r27
0019f8 9220 2836                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0019fa 9220 2837                 	sts pulse1_total_pitch_offset+1, zero
0019fc 9220 283d                 	sts pulse1_total_hi_pitch_offset, zero
0019fe 9220 284c                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001a00 9220 284d                 	sts pulse1_fx_1xx_total+1, zero
001a02 9220 2850                 	sts pulse1_fx_2xx_total, zero
001a04 9220 2851                 	sts pulse1_fx_2xx_total+1, zero
001a06 9220 2858                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
001a08 9220 2859                 	sts pulse1_fx_3xx_total_offset+1, zero
001a0a 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001a0c 91b0 0a8d                 	lds r27, TCB0_CCMPH
001a0e 93a0 2852                 	sts pulse1_fx_3xx_start, r26
001a10 93b0 2853                 	sts pulse1_fx_3xx_start+1, r27
001a12 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
001a14 6097                      	sbr pulse_channel_flags, 7 //set reload flag
001a15 9220 2867                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a17 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
001a19 9220 286b                 	sts pulse1_fx_Qxy_total_offset, zero
001a1b 9220 286c                 	sts pulse1_fx_Qxy_total_offset+1, zero
001a1d 9220 286e                 	sts pulse1_fx_Rxy_target, zero
001a1f 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
001a21 9220 2872                 	sts pulse1_fx_Rxy_total_offset, zero
001a23 9220 2873                 	sts pulse1_fx_Rxy_total_offset+1, zero
001a25 d106                      	rcall sound_driver_channel0_increment_offset
001a26 ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
001a27 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
001a28 91a0 2800                 	lds r26, pulse1_param
001a2a 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001a2b 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
001a2c 93a0 2800                 	sts pulse1_param, r26
001a2e 6096                      	sbr pulse_channel_flags, 6
001a2f d0fc                      	rcall sound_driver_channel0_increment_offset
001a30 ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001a31 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001a32 93b0 2827                 	sts pulse1_pattern_delay_rows, r27
001a34 d0f7                      	rcall sound_driver_channel0_increment_offset
001a35 c10a                      	rjmp sound_driver_channel0_end
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001a36 9220 282b                 	sts pulse1_volume_macro, zero //reset all macro addresses
001a38 9220 282c                 	sts pulse1_volume_macro+1, zero
001a3a 9220 2830                 	sts pulse1_arpeggio_macro, zero
001a3c 9220 2831                 	sts pulse1_arpeggio_macro+1, zero
001a3e 9220 2838                 	sts pulse1_pitch_macro, zero
001a40 9220 2839                 	sts pulse1_pitch_macro+1, zero
001a42 9220 283e                 	sts pulse1_hi_pitch_macro, zero
001a44 9220 283f                 	sts pulse1_hi_pitch_macro+1, zero
001a46 9220 2843                 	sts pulse1_duty_macro, zero
001a48 9220 2844                 	sts pulse1_duty_macro+1, zero
001a4a 9220 2836                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
001a4c 9220 2837                 	sts pulse1_total_pitch_offset+1, zero
001a4e 9220 283d                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001a50 9631                      	adiw Z, 1 //point to the byte next to the flag
001a51 91b4                      	lpm r27, Z //store the instrument offset into r27
001a52 eae0                      	ldi ZL, LOW(instruments) //point Z to instruments table
001a53 e1f1                      	ldi ZH, HIGH(instruments)
001a54 0feb                      	add ZL, r27 //point Z to offsetted instrument
001a55 1df2                      	adc ZH, zero
001a56 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001a57 1fff                      	rol ZH
001a58 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001a59 91b4                      	lpm r27, Z
                                 
001a5a 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001a5b 1fbb                      	rol r27
001a5c 2fea                      	mov ZL, r26
001a5d 2ffb                      	mov ZH, r27
001a5e 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001a5f 9632                      	adiw Z, 2 //point Z to the address of the macro
001a60 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001a61 95aa                      	dec r26
001a62 f019                      	breq sound_driver_channel0_instrument_change_exit
001a63 95b6                      	lsr r27
001a64 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001a65 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001a66 e0a3                      	ldi r26, 0x03
001a67 e0b2                      	ldi r27, 0x02
001a68 93b0 282d                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001a6a 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26
001a6c 93b0 283a                 	sts pulse1_pitch_macro_offset, r27
001a6e 93b0 2840                 	sts pulse1_hi_pitch_macro_offset, r27
001a70 93b0 2845                 	sts pulse1_duty_macro_offset, r27
001a72 d0c3                      	rcall sound_driver_channel0_increment_offset_twice
001a73 cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001a74 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001a75 91d5                      	lpm r29, Z+
                                 
001a76 30a5                      	cpi r26, 5
001a77 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001a78 30a4                      	cpi r26, 4
001a79 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001a7a 30a3                      	cpi r26, 3
001a7b f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001a7c 30a2                      	cpi r26, 2
001a7d f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001a7e c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001a7f 93c0 282b                 	sts pulse1_volume_macro, r28
001a81 93d0 282c                 	sts pulse1_volume_macro+1, r29
001a83 d041                      	rcall sound_driver_channel0_instrument_change_read_header
001a84 93c0 282f                 	sts pulse1_volume_macro_release, r28
001a86 93d0 282e                 	sts pulse1_volume_macro_loop, r29
001a88 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001a89 93c0 2830                 	sts pulse1_arpeggio_macro, r28
001a8b 93d0 2831                 	sts pulse1_arpeggio_macro+1, r29
001a8d 9220 2867                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a8f 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
001a91 9220 286e                 	sts pulse1_fx_Rxy_target, zero
001a93 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
001a95 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001a96 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001a97 93c0 2838                 	sts pulse1_pitch_macro, r28
001a99 93d0 2839                 	sts pulse1_pitch_macro+1, r29
001a9b 9220 2867                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001a9d 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
001a9f 9220 286e                 	sts pulse1_fx_Rxy_target, zero
001aa1 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
001aa3 d021                      	rcall sound_driver_channel0_instrument_change_read_header
001aa4 93c0 283c                 	sts pulse1_pitch_macro_release, r28
001aa6 93d0 283b                 	sts pulse1_pitch_macro_loop, r29
001aa8 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001aa9 93c0 283e                 	sts pulse1_hi_pitch_macro, r28
001aab 93d0 283f                 	sts pulse1_hi_pitch_macro+1, r29
001aad 9220 2867                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001aaf 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
001ab1 9220 286e                 	sts pulse1_fx_Rxy_target, zero
001ab3 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
001ab5 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001ab6 93c0 2842                 	sts pulse1_hi_pitch_macro_release, r28
001ab8 93d0 2841                 	sts pulse1_hi_pitch_macro_loop, r29
001aba cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001abb 93c0 2843                 	sts pulse1_duty_macro, r28
001abd 93d0 2844                 	sts pulse1_duty_macro+1, r29
001abf d005                      	rcall sound_driver_channel0_instrument_change_read_header
001ac0 93c0 2847                 	sts pulse1_duty_macro_release, r28
001ac2 93d0 2846                 	sts pulse1_duty_macro_loop, r29
001ac4 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001ac5 93ef                      	push ZL
001ac6 93ff                      	push ZH
001ac7 2fec                      	mov ZL, r28
001ac8 2ffd                      	mov ZH, r29
001ac9 0fee                      	lsl ZL
001aca 1fff                      	rol ZH
001acb 91c5                      	lpm r28, Z+
001acc 91d4                      	lpm r29, Z
001acd 91ff                      	pop ZH
001ace 91ef                      	pop ZL
001acf 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001ad0 93ef                      	push ZL
001ad1 93ff                      	push ZH
001ad2 2fec                      	mov ZL, r28
001ad3 2ffd                      	mov ZH, r29
001ad4 0fee                      	lsl ZL
001ad5 1fff                      	rol ZH
001ad6 91c5                      	lpm r28, Z+
001ad7 91d5                      	lpm r29, Z+
001ad8 93c0 2834                 	sts pulse1_arpeggio_macro_release, r28
001ada 93d0 2833                 	sts pulse1_arpeggio_macro_loop, r29
001adc 91c4                      	lpm r28, Z
001add 93c0 2835                 	sts pulse1_arpeggio_macro_mode, r28
001adf 91ff                      	pop ZH
001ae0 91ef                      	pop ZL
001ae1 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001ae2 91b0 282f                 	lds r27, pulse1_volume_macro_release
001ae4 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001ae5 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001ae6 95b3                      	inc r27
001ae7 93b0 282d                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001ae9 91b0 2834                 	lds r27, pulse1_arpeggio_macro_release
001aeb 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001aec f019                      	breq sound_driver_channel0_release_pitch
001aed 95b3                      	inc r27
001aee 93b0 2832                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001af0 91b0 283c                 	lds r27, pulse1_pitch_macro_release
001af2 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001af3 f019                      	breq sound_driver_channel0_release_hi_pitch
001af4 95b3                      	inc r27
001af5 93b0 283a                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001af7 91b0 2842                 	lds r27, pulse1_hi_pitch_macro_release
001af9 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001afa f019                      	breq sound_driver_channel0_release_duty
001afb 95b3                      	inc r27
001afc 93b0 2840                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
001afe 91b0 2847                 	lds r27, pulse1_duty_macro_release
001b00 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001b01 f019                      	breq sound_driver_channel0_release_exit
001b02 95b3                      	inc r27
001b03 93b0 2845                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
001b05 d026                      	rcall sound_driver_channel0_increment_offset
001b06 cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
001b07 91e0 2819                 	lds ZL, song_frames
001b09 91f0 281a                 	lds ZH, song_frames+1
001b0b 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001b0d 91b0 281c                 	lds r27, song_frame_offset+1
001b0f 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001b10 93a0 281b                 	sts song_frame_offset, r26
001b12 93b0 281c                 	sts song_frame_offset+1, r27
                                 
001b14 91c0 281d                 	lds r28, song_size
001b16 91d0 281e                 	lds r29, song_size+1
001b18 17ac                      	cp r26, r28
001b19 07bd                      	cpc r27, r29
001b1a f010                      	brlo sound_driver_channel0_next_pattern_exists
001b1b 940c 30c4                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
001b1d 0fea                      	add ZL, r26
001b1e 1ffb                      	adc ZH, r27
                                 
001b1f 91a5                      	lpm r26, Z+ //load the address of the next pattern
001b20 91b4                      	lpm r27, Z
001b21 0faa                      	lsl r26
001b22 1fbb                      	rol r27
001b23 93a0 2825                 	sts pulse1_pattern, r26
001b25 93b0 2826                 	sts pulse1_pattern+1, r27
                                 
001b27 9220 2829                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001b29 9220 282a                 	sts pulse1_pattern_offset+1, zero
001b2b cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
001b2c 91e0 2829                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001b2e 91f0 282a                 	lds ZH, pulse1_pattern_offset+1
001b30 9631                      	adiw Z, 1
001b31 93e0 2829                 	sts pulse1_pattern_offset, ZL
001b33 93f0 282a                 	sts pulse1_pattern_offset+1, ZH
001b35 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001b36 91e0 2829                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
001b38 91f0 282a                 	lds ZH, pulse1_pattern_offset+1
001b3a 9632                      	adiw Z, 2 //increment the pointer twice
001b3b 93e0 2829                 	sts pulse1_pattern_offset, ZL
001b3d 93f0 282a                 	sts pulse1_pattern_offset+1, ZH
001b3f 9508                      	ret
                                 
                                 sound_driver_channel0_end:
                                 sound_driver_channel0_check_Sxx_invalid:
001b40 efbf                      	ldi r27, 0xFF
001b41 91a0 2875                 	lds r26, pulse1_fx_Sxx_post
001b43 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
001b44 f419                      	brne sound_driver_channel0_check_Gxx_invalid
001b45 93b0 2875                 	sts pulse1_fx_Sxx_post, r27
001b47 9508                      	ret
                                 sound_driver_channel0_check_Gxx_invalid:
001b48 91a0 2863                 	lds r26, pulse1_fx_Gxx_post
001b4a 15a2                      	cp r26, zero
001b4b f419                      	brne sound_driver_channel1
001b4c 93b0 2863                 	sts pulse1_fx_Gxx_post, r27
001b4e 9508                      	ret
                                 
                                 
                                 sound_driver_channel1:
001b4f 91a0 2878                 	lds r26, pulse2_pattern_delay_rows
001b51 91b0 2879                 	lds r27, pulse2_pattern_delay_frames
                                 sound_driver_channel1_decrement_frame_delay:
001b53 95ba                      	dec r27
001b54 93b0 2879                 	sts pulse2_pattern_delay_frames, r27
                                 
001b56 9610                      	adiw r27:r26, 0
001b57 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
001b58 c2d7                      	rjmp sound_driver_channel1_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel1_main:
001b59 91e0 2876                 	lds ZL, pulse2_pattern //current pattern for pulse 2
001b5b 91f0 2877                 	lds ZH, pulse2_pattern+1
001b5d 91a0 287a                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
001b5f 91b0 287b                 	lds r27, pulse2_pattern_offset+1
001b61 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001b62 1ffb                      	adc ZH, r27
001b63 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001b64 35b7                      	cpi r27, 0x57
001b65 f408                      	brsh sound_driver_channel1_check_if_volume
001b66 c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001b67 36b7                      	cpi r27, 0x67
001b68 f408                      	brsh sound_driver_channel1_check_if_delay
001b69 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001b6a 3eb3                      	cpi r27, 0xE3
001b6b f408                      	brsh sound_driver_channel1_check_if_instrument
001b6c c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001b6d f409                      	brne sound_driver_channel1_check_if_release
001b6e c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001b6f 3eb4                      	cpi r27, 0xE4
001b70 f409                      	brne sound_driver_channel1_check_if_end
001b71 c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001b72 3fbf                      	cpi r27, 0xFF
001b73 f409                      	brne sound_driver_channel1_check_if_fx
001b74 c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001b75 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001b76 91a4                      	lpm r26, Z //load the fx data into r26
001b77 d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001b78 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001b79 eeec                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001b7a e6f1                      	ldi ZH, HIGH(channel1_fx << 1)
001b7b 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001b7c 0feb                      	add ZL, r27 //add offset
001b7d 1df2                      	adc ZH, zero
001b7e 91c5                      	lpm r28, Z+ //load address bytes
001b7f 91d4                      	lpm r29, Z
001b80 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001b81 2ffd                      	mov ZH, r29
001b82 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001b83 93a0 2899                 	sts pulse2_fx_0xy_sequence, r26
001b85 9220 289a                 	sts pulse2_fx_0xy_sequence+1, zero
001b87 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001b88 9220 289f                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001b8a 9220 28a0                 	sts pulse2_fx_2xx+1, zero
001b8c 9220 2899                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001b8e 9220 289a                 	sts pulse2_fx_0xy_sequence+1, zero
001b90 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b91 937f                      	push r23
001b92 2f6a                      	mov r22, r26 //store the rate into r22
001b93 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b94 9f67                      	mul r22, r23
001b95 917f                      	pop r23
001b96 916f                      	pop r22
                                 
001b97 9416                      	lsr r1 //shift out the fractional bits
001b98 9407                      	ror r0
001b99 9416                      	lsr r1
001b9a 9407                      	ror r0
001b9b 9416                      	lsr r1
001b9c 9407                      	ror r0
001b9d 9416                      	lsr r1
001b9e 9407                      	ror r0
001b9f 9200 289b                 	sts pulse2_fx_1xx, r0
001ba1 9210 289c                 	sts pulse2_fx_1xx+1, r1
001ba3 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001ba4 9220 289b                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001ba6 9220 289c                 	sts pulse2_fx_1xx+1, zero
001ba8 9220 2899                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001baa 9220 289a                 	sts pulse2_fx_0xy_sequence+1, zero
001bac 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001bad 937f                      	push r23
001bae 2f6a                      	mov r22, r26 //store the rate into r22
001baf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001bb0 9f67                      	mul r22, r23
001bb1 917f                      	pop r23
001bb2 916f                      	pop r22
                                 
001bb3 9416                      	lsr r1 //shift out the fractional bits
001bb4 9407                      	ror r0
001bb5 9416                      	lsr r1
001bb6 9407                      	ror r0
001bb7 9416                      	lsr r1
001bb8 9407                      	ror r0
001bb9 9416                      	lsr r1
001bba 9407                      	ror r0
001bbb 9200 289f                 	sts pulse2_fx_2xx, r0
001bbd 9210 28a0                 	sts pulse2_fx_2xx+1, r1
001bbf cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001bc0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001bc1 937f                      	push r23
001bc2 2f6a                      	mov r22, r26 //store the rate into r22
001bc3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001bc4 9f67                      	mul r22, r23
001bc5 917f                      	pop r23
001bc6 916f                      	pop r22
                                 
001bc7 9416                      	lsr r1 //shift out the fractional bits
001bc8 9407                      	ror r0
001bc9 9416                      	lsr r1
001bca 9407                      	ror r0
001bcb 9416                      	lsr r1
001bcc 9407                      	ror r0
001bcd 9416                      	lsr r1
001bce 9407                      	ror r0
001bcf 9200 28a7                 	sts pulse2_fx_3xx_speed, r0
001bd1 9210 28a8                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001bd3 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001bd4 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001bd5 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001bd6 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001bd8 91b0 0a9d                 	lds r27, TCB1_CCMPH
001bda 93a0 28a3                 	sts pulse2_fx_3xx_start, r26
001bdc 93b0 28a4                 	sts pulse2_fx_3xx_start+1, r27
                                 
001bde 9220 28a9                 	sts pulse2_fx_3xx_total_offset, zero
001be0 9220 28aa                 	sts pulse2_fx_3xx_total_offset+1, zero
001be2 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001be3 2fba                      	mov r27, r26
001be4 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001be5 95a2                      	swap r26
001be6 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001be7 93a0 28ab                 	sts pulse2_fx_4xy_speed, r26
001be9 93b0 28ac                 	sts pulse2_fx_4xy_depth, r27
001beb 9220 28ad                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001bed cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001bee 2fba                      	mov r27, r26
001bef 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001bf0 95a2                      	swap r26
001bf1 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001bf2 93a0 28ae                 	sts pulse2_fx_7xy_speed, r26
001bf4 93b0 28af                 	sts pulse2_fx_7xy_depth, r27
001bf6 9220 28b0                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001bf8 9220 28b1                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001bfa cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001bfb 93a0 28b2                 	sts pulse2_fx_Axy, r26
001bfd cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001bfe 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001c00 cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001c01 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001c03 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001c04 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001c06 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001c07 91b0 2808                 	lds r27, pulse2_param
001c09 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001c0a 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001c0b 93b0 2808                 	sts pulse2_param, r27
001c0d 6092                      	sbr pulse_channel_flags, 2
001c0e cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001c0f 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001c11 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001c12 15a2                      	cp r26, zero
001c13 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001c14 91b0 2821                 	lds r27, song_speed
001c16 17ab                      	cp r26, r27
001c17 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001c18 93a0 28b3                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001c1a e0b1                      	ldi r27, 0x01
001c1b 93b0 2878                 	sts pulse2_pattern_delay_rows, r27
001c1d c221                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001c1e cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001c1f cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001c20 cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001c21 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001c22 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001c23 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c24 937f                      	push r23
001c25 2f6a                      	mov r22, r26
001c26 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c27 0367                      	mulsu r22, r23
001c28 917f                      	pop r23
001c29 916f                      	pop r22
001c2a 9416                      	lsr r1 //shift out the fractional bits
001c2b 9407                      	ror r0
001c2c 9416                      	lsr r1
001c2d 9407                      	ror r0
001c2e 9416                      	lsr r1
001c2f 9407                      	ror r0
001c30 9416                      	lsr r1
001c31 9407                      	ror r0
001c32 fe13                      	sbrs r1, 3 //check if result was a negative number
001c33 c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
001c34 efb0                      	ldi r27, 0xF0
001c35 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001c36 9200 28b5                 	sts pulse2_fx_Pxx_total, r0
001c38 9210 28b6                 	sts pulse2_fx_Pxx_total+1, r1
001c3a cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001c3b 91e0 2881                 	lds ZL, pulse2_arpeggio_macro
001c3d 91f0 2882                 	lds ZH, pulse2_arpeggio_macro+1
001c3f 9630                      	adiw Z, 0
001c40 f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001c41 cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001c42 91e0 2889                 	lds ZL, pulse2_pitch_macro
001c44 91f0 288a                 	lds ZH, pulse2_pitch_macro+1
001c46 9630                      	adiw Z, 0
001c47 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001c48 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001c49 91e0 288f                 	lds ZL, pulse2_hi_pitch_macro
001c4b 91f0 2890                 	lds ZH, pulse2_hi_pitch_macro+1
001c4d 9630                      	adiw Z, 0
001c4e f009                      	breq sound_driver_channel1_fx_Qxy_process
001c4f cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001c50 2fba                      	mov r27, r26 //copy fx parameters into r27
001c51 70bf                      	andi r27, 0x0F //mask note index offset
001c52 91c0 28b7                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
001c54 0fbc                      	add r27, r28
001c55 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001c56 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001c57 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001c58 93b0 28b7                 	sts pulse2_fx_Qxy_target_note, r27
001c5a e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001c5b e0f0                      	ldi ZH, HIGH(note_table << 1)
001c5c 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001c5d 0feb                      	add ZL, r27 //add offset
001c5e 1df2                      	adc ZH, zero
001c5f 91c5                      	lpm r28, Z+ //load bytes
001c60 91d4                      	lpm r29, Z
001c61 93c0 28b8                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001c63 93d0 28b9                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
001c65 95a2                      	swap r26
001c66 70af                      	andi r26, 0x0F //mask effect speed
001c67 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001c68 95a3                      	inc r26 //increment the speed by 1
                                 
001c69 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001c6a 937f                      	push r23
001c6b 2f6a                      	mov r22, r26 //store the speed data into r27
001c6c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001c6d 9f67                      	mul r22, r23
001c6e 917f                      	pop r23
001c6f 916f                      	pop r22
                                 
001c70 9416                      	lsr r1 //shift out the fractional bits
001c71 9407                      	ror r0
001c72 9416                      	lsr r1
001c73 9407                      	ror r0
001c74 9416                      	lsr r1
001c75 9407                      	ror r0
001c76 9416                      	lsr r1
001c77 9407                      	ror r0
                                 
001c78 9200 28ba                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001c7a 9210 28bb                 	sts pulse2_fx_Qxy_speed+1, r1
001c7c cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001c7d 91e0 2881                 	lds ZL, pulse2_arpeggio_macro
001c7f 91f0 2882                 	lds ZH, pulse2_arpeggio_macro+1
001c81 9630                      	adiw Z, 0
001c82 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001c83 ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001c84 91e0 2889                 	lds ZL, pulse2_pitch_macro
001c86 91f0 288a                 	lds ZH, pulse2_pitch_macro+1
001c88 9630                      	adiw Z, 0
001c89 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001c8a cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001c8b 91e0 288f                 	lds ZL, pulse2_hi_pitch_macro
001c8d 91f0 2890                 	lds ZH, pulse2_hi_pitch_macro+1
001c8f 9630                      	adiw Z, 0
001c90 f009                      	breq sound_driver_channel1_fx_Rxy_process
001c91 cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001c92 2fba                      	mov r27, r26 //copy fx parameters into r27
001c93 70bf                      	andi r27, 0x0F //mask note index offset
001c94 91c0 28be                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
001c96 1bcb                      	sub r28, r27
001c97 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001c98 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001c99 93c0 28be                 	sts pulse2_fx_Rxy_target_note, r28
001c9b e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001c9c e0f0                      	ldi ZH, HIGH(note_table << 1)
001c9d 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001c9e 0fec                      	add ZL, r28 //add offset
001c9f 1df2                      	adc ZH, zero
001ca0 91c5                      	lpm r28, Z+ //load bytes
001ca1 91d4                      	lpm r29, Z
001ca2 93c0 28bf                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001ca4 93d0 28c0                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
001ca6 95a2                      	swap r26
001ca7 70af                      	andi r26, 0x0F //mask effect speed
001ca8 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001ca9 95a3                      	inc r26 //increment the speed by 1
                                 
001caa 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001cab 937f                      	push r23
001cac 2f6a                      	mov r22, r26 //store the speed data into r27
001cad eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001cae 9f67                      	mul r22, r23
001caf 917f                      	pop r23
001cb0 916f                      	pop r22
                                 
001cb1 9416                      	lsr r1 //shift out the fractional bits
001cb2 9407                      	ror r0
001cb3 9416                      	lsr r1
001cb4 9407                      	ror r0
001cb5 9416                      	lsr r1
001cb6 9407                      	ror r0
001cb7 9416                      	lsr r1
001cb8 9407                      	ror r0
                                 
001cb9 9200 28c1                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001cbb 9210 28c2                 	sts pulse2_fx_Rxy_speed+1, r1
001cbd ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001cbe 15a2                      	cp r26, zero
001cbf f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001cc0 91b0 2821                 	lds r27, song_speed
001cc2 17ab                      	cp r26, r27
001cc3 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001cc4 93a0 28c5                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001cc6 e0b1                      	ldi r27, 0x01
001cc7 93b0 2878                 	sts pulse2_pattern_delay_rows, r27
001cc9 c175                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001cca ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001ccb ebe4                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001ccc e6f1                      	ldi ZH, HIGH(sequences << 1)
001ccd 0fea                      	add ZL, r26 //offset the pointer
001cce 1df2                      	adc ZH, zero
                                 
001ccf 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001cd0 95a7                      	ror r26
001cd1 95a7                      	ror r26
001cd2 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001cd4 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001cd5 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001cd6 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001cd7 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001cd8 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001cd9 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001cda 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001cdb 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001cdc 93c0 2808                 	sts pulse2_param, r28
001cde ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001cdf ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001ce0 ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001ce1 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001ce2 ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001ce3 93b0 280f                 	sts pulse2_note, r27 //store the note index
001ce5 93b0 28b7                 	sts pulse2_fx_Qxy_target_note, r27
001ce7 93b0 28be                 	sts pulse2_fx_Rxy_target_note, r27
001ce9 e0a3                      	ldi r26, 0x03
001cea e0b2                      	ldi r27, 0x02
001ceb 93b0 287e                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001ced 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26
001cef 93b0 288b                 	sts pulse2_pitch_macro_offset, r27
001cf1 93b0 2891                 	sts pulse2_hi_pitch_macro_offset, r27
001cf3 93b0 2896                 	sts pulse2_duty_macro_offset, r27
001cf5 9220 2887                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001cf7 9220 2888                 	sts pulse2_total_pitch_offset+1, zero
001cf9 9220 288e                 	sts pulse2_total_hi_pitch_offset, zero
001cfb 9220 289d                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001cfd 9220 289e                 	sts pulse2_fx_1xx_total+1, zero
001cff 9220 28a1                 	sts pulse2_fx_2xx_total, zero
001d01 9220 28a2                 	sts pulse2_fx_2xx_total+1, zero
001d03 9220 28a9                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001d05 9220 28aa                 	sts pulse2_fx_3xx_total_offset+1, zero
001d07 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001d09 91b0 0a9d                 	lds r27, TCB1_CCMPH
001d0b 93a0 28a3                 	sts pulse2_fx_3xx_start, r26
001d0d 93b0 28a4                 	sts pulse2_fx_3xx_start+1, r27
001d0f 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001d11 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001d12 9220 28b8                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d14 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
001d16 9220 28bc                 	sts pulse2_fx_Qxy_total_offset, zero
001d18 9220 28bd                 	sts pulse2_fx_Qxy_total_offset+1, zero
001d1a 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
001d1c 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
001d1e 9220 28c3                 	sts pulse2_fx_Rxy_total_offset, zero
001d20 9220 28c4                 	sts pulse2_fx_Rxy_total_offset+1, zero
001d22 d0f9                      	rcall sound_driver_channel1_increment_offset
001d23 ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001d24 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
001d25 91a0 2808                 	lds r26, pulse2_param
001d27 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001d28 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001d29 93a0 2808                 	sts pulse2_param, r26
001d2b 6092                      	sbr pulse_channel_flags, 2
001d2c d0ef                      	rcall sound_driver_channel1_increment_offset
001d2d ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001d2e 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001d2f 93b0 2878                 	sts pulse2_pattern_delay_rows, r27
001d31 d0ea                      	rcall sound_driver_channel1_increment_offset
001d32 c0fd                      	rjmp sound_driver_channel1_end
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001d33 9220 287c                 	sts pulse2_volume_macro, zero //reset all macro addresses
001d35 9220 287d                 	sts pulse2_volume_macro+1, zero
001d37 9220 2881                 	sts pulse2_arpeggio_macro, zero
001d39 9220 2882                 	sts pulse2_arpeggio_macro+1, zero
001d3b 9220 2889                 	sts pulse2_pitch_macro, zero
001d3d 9220 288a                 	sts pulse2_pitch_macro+1, zero
001d3f 9220 288f                 	sts pulse2_hi_pitch_macro, zero
001d41 9220 2890                 	sts pulse2_hi_pitch_macro+1, zero
001d43 9220 2894                 	sts pulse2_duty_macro, zero
001d45 9220 2895                 	sts pulse2_duty_macro+1, zero
001d47 9220 2887                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001d49 9220 2888                 	sts pulse2_total_pitch_offset+1, zero
001d4b 9220 288e                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001d4d 9631                      	adiw Z, 1 //point to the byte next to the flag
001d4e 91b4                      	lpm r27, Z //store the instrument offset into r27
001d4f eae0                      	ldi ZL, LOW(instruments) //point Z to instruments table
001d50 e1f1                      	ldi ZH, HIGH(instruments)
001d51 0feb                      	add ZL, r27 //point Z to offsetted instrument
001d52 1df2                      	adc ZH, zero
001d53 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001d54 1fff                      	rol ZH
001d55 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001d56 91b4                      	lpm r27, Z
                                 
001d57 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001d58 1fbb                      	rol r27
001d59 2fea                      	mov ZL, r26
001d5a 2ffb                      	mov ZH, r27
001d5b 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001d5c 9632                      	adiw Z, 2 //point Z to the address of the macro
001d5d e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001d5e 95aa                      	dec r26
001d5f f019                      	breq sound_driver_channel1_instrument_change_exit
001d60 95b6                      	lsr r27
001d61 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001d62 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001d63 e0a3                      	ldi r26, 0x03
001d64 e0b2                      	ldi r27, 0x02
001d65 93b0 287e                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001d67 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26
001d69 93b0 288b                 	sts pulse2_pitch_macro_offset, r27
001d6b 93b0 2891                 	sts pulse2_hi_pitch_macro_offset, r27
001d6d 93b0 2896                 	sts pulse2_duty_macro_offset, r27
001d6f d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001d70 cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001d71 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001d72 91d5                      	lpm r29, Z+
                                 
001d73 30a5                      	cpi r26, 5
001d74 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001d75 30a4                      	cpi r26, 4
001d76 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001d77 30a3                      	cpi r26, 3
001d78 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001d79 30a2                      	cpi r26, 2
001d7a f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001d7b c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001d7c 93c0 287c                 	sts pulse2_volume_macro, r28
001d7e 93d0 287d                 	sts pulse2_volume_macro+1, r29
001d80 d041                      	rcall sound_driver_channel1_instrument_change_read_header
001d81 93c0 2880                 	sts pulse2_volume_macro_release, r28
001d83 93d0 287f                 	sts pulse2_volume_macro_loop, r29
001d85 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001d86 93c0 2881                 	sts pulse2_arpeggio_macro, r28
001d88 93d0 2882                 	sts pulse2_arpeggio_macro+1, r29
001d8a 9220 28b8                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d8c 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
001d8e 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
001d90 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
001d92 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001d93 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001d94 93c0 2889                 	sts pulse2_pitch_macro, r28
001d96 93d0 288a                 	sts pulse2_pitch_macro+1, r29
001d98 9220 28b8                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001d9a 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
001d9c 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
001d9e 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
001da0 d021                      	rcall sound_driver_channel1_instrument_change_read_header
001da1 93c0 288d                 	sts pulse2_pitch_macro_release, r28
001da3 93d0 288c                 	sts pulse2_pitch_macro_loop, r29
001da5 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001da6 93c0 288f                 	sts pulse2_hi_pitch_macro, r28
001da8 93d0 2890                 	sts pulse2_hi_pitch_macro+1, r29
001daa 9220 28b8                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001dac 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
001dae 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
001db0 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
001db2 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001db3 93c0 2893                 	sts pulse2_hi_pitch_macro_release, r28
001db5 93d0 2892                 	sts pulse2_hi_pitch_macro_loop, r29
001db7 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001db8 93c0 2894                 	sts pulse2_duty_macro, r28
001dba 93d0 2895                 	sts pulse2_duty_macro+1, r29
001dbc d005                      	rcall sound_driver_channel1_instrument_change_read_header
001dbd 93c0 2898                 	sts pulse2_duty_macro_release, r28
001dbf 93d0 2897                 	sts pulse2_duty_macro_loop, r29
001dc1 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001dc2 93ef                      	push ZL
001dc3 93ff                      	push ZH
001dc4 2fec                      	mov ZL, r28
001dc5 2ffd                      	mov ZH, r29
001dc6 0fee                      	lsl ZL
001dc7 1fff                      	rol ZH
001dc8 91c5                      	lpm r28, Z+
001dc9 91d4                      	lpm r29, Z
001dca 91ff                      	pop ZH
001dcb 91ef                      	pop ZL
001dcc 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001dcd 93ef                      	push ZL
001dce 93ff                      	push ZH
001dcf 2fec                      	mov ZL, r28
001dd0 2ffd                      	mov ZH, r29
001dd1 0fee                      	lsl ZL
001dd2 1fff                      	rol ZH
001dd3 91c5                      	lpm r28, Z+
001dd4 91d5                      	lpm r29, Z+
001dd5 93c0 2885                 	sts pulse2_arpeggio_macro_release, r28
001dd7 93d0 2884                 	sts pulse2_arpeggio_macro_loop, r29
001dd9 91c4                      	lpm r28, Z
001dda 93c0 2886                 	sts pulse2_arpeggio_macro_mode, r28
001ddc 91ff                      	pop ZH
001ddd 91ef                      	pop ZL
001dde 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001ddf 91b0 2880                 	lds r27, pulse2_volume_macro_release
001de1 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001de2 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001de3 95b3                      	inc r27
001de4 93b0 287e                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001de6 91b0 2885                 	lds r27, pulse2_arpeggio_macro_release
001de8 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001de9 f019                      	breq sound_driver_channel1_release_pitch
001dea 95b3                      	inc r27
001deb 93b0 2883                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001ded 91b0 288d                 	lds r27, pulse2_pitch_macro_release
001def 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001df0 f019                      	breq sound_driver_channel1_release_hi_pitch
001df1 95b3                      	inc r27
001df2 93b0 288b                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001df4 91b0 2893                 	lds r27, pulse2_hi_pitch_macro_release
001df6 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001df7 f019                      	breq sound_driver_channel1_release_duty
001df8 95b3                      	inc r27
001df9 93b0 2891                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001dfb 91b0 2898                 	lds r27, pulse2_duty_macro_release
001dfd 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001dfe f019                      	breq sound_driver_channel1_release_exit
001dff 95b3                      	inc r27
001e00 93b0 2896                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001e02 d019                      	rcall sound_driver_channel1_increment_offset
001e03 cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001e04 91e0 2819                 	lds ZL, song_frames
001e06 91f0 281a                 	lds ZH, song_frames+1
001e08 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001e0a 91b0 281c                 	lds r27, song_frame_offset+1
001e0c 9612                      	adiw r27:r26, 2 //offset for channel 1
001e0d 0fea                      	add ZL, r26
001e0e 1ffb                      	adc ZH, r27
                                 
001e0f 91a5                      	lpm r26, Z+ //load the address of the next pattern
001e10 91b4                      	lpm r27, Z
001e11 0faa                      	lsl r26
001e12 1fbb                      	rol r27
001e13 93a0 2876                 	sts pulse2_pattern, r26
001e15 93b0 2877                 	sts pulse2_pattern+1, r27
                                 
001e17 9220 287a                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001e19 9220 287b                 	sts pulse2_pattern_offset+1, zero
001e1b cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001e1c 91e0 287a                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001e1e 91f0 287b                 	lds ZH, pulse2_pattern_offset+1
001e20 9631                      	adiw Z, 1
001e21 93e0 287a                 	sts pulse2_pattern_offset, ZL
001e23 93f0 287b                 	sts pulse2_pattern_offset+1, ZH
001e25 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001e26 91e0 287a                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001e28 91f0 287b                 	lds ZH, pulse2_pattern_offset+1
001e2a 9632                      	adiw Z, 2 //increment the pointer twice
001e2b 93e0 287a                 	sts pulse2_pattern_offset, ZL
001e2d 93f0 287b                 	sts pulse2_pattern_offset+1, ZH
001e2f 9508                      	ret
                                 
                                 sound_driver_channel1_end:
                                 sound_driver_channel1_check_Sxx_invalid:
001e30 efbf                      	ldi r27, 0xFF
001e31 91a0 28c6                 	lds r26, pulse2_fx_Sxx_post
001e33 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
001e34 f419                      	brne sound_driver_channel1_check_Gxx_invalid
001e35 93b0 28c6                 	sts pulse2_fx_Sxx_post, r27
001e37 9508                      	ret
                                 sound_driver_channel1_check_Gxx_invalid:
001e38 91a0 28b4                 	lds r26, pulse2_fx_Gxx_post
001e3a 15a2                      	cp r26, zero
001e3b f419                      	brne sound_driver_channel2
001e3c 93b0 28b4                 	sts pulse2_fx_Gxx_post, r27
001e3e 9508                      	ret
                                 
                                 
                                 sound_driver_channel2:
001e3f 91a0 28c9                 	lds r26, triangle_pattern_delay_rows
001e41 91b0 28ca                 	lds r27, triangle_pattern_delay_frames
                                 sound_driver_channel2_decrement_frame_delay:
001e43 95ba                      	dec r27
001e44 93b0 28ca                 	sts triangle_pattern_delay_frames, r27
                                 
001e46 9610                      	adiw r27:r26, 0
001e47 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001e48 c2bf                      	rjmp sound_driver_channel2_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel2_main:
001e49 91e0 28c7                 	lds ZL, triangle_pattern //current pattern for triangle
001e4b 91f0 28c8                 	lds ZH, triangle_pattern+1
001e4d 91a0 28cb                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001e4f 91b0 28cc                 	lds r27, triangle_pattern_offset+1
001e51 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001e52 1ffb                      	adc ZH, r27
001e53 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001e54 35b7                      	cpi r27, 0x57
001e55 f408                      	brsh sound_driver_channel2_check_if_volume
001e56 c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001e57 36b7                      	cpi r27, 0x67
001e58 f408                      	brsh sound_driver_channel2_check_if_delay
001e59 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001e5a 3eb3                      	cpi r27, 0xE3
001e5b f408                      	brsh sound_driver_channel2_check_if_instrument
001e5c c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001e5d f409                      	brne sound_driver_channel2_check_if_release
001e5e c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001e5f 3eb4                      	cpi r27, 0xE4
001e60 f409                      	brne sound_driver_channel2_check_if_end
001e61 c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001e62 3fbf                      	cpi r27, 0xFF
001e63 f409                      	brne sound_driver_channel2_check_if_fx
001e64 c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001e65 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001e66 91a4                      	lpm r26, Z //load the fx data into r26
001e67 d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001e68 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001e69 e2e0                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001e6a e6f2                      	ldi ZH, HIGH(channel2_fx << 1)
001e6b 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001e6c 0feb                      	add ZL, r27 //add offset
001e6d 1df2                      	adc ZH, zero
001e6e 91c5                      	lpm r28, Z+ //load address bytes
001e6f 91d4                      	lpm r29, Z
001e70 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001e71 2ffd                      	mov ZH, r29
001e72 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001e73 93a0 28ea                 	sts triangle_fx_0xy_sequence, r26
001e75 9220 28eb                 	sts triangle_fx_0xy_sequence+1, zero
001e77 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001e78 9220 28f0                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001e7a 9220 28f1                 	sts triangle_fx_2xx+1, zero
001e7c 9220 28ea                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001e7e 9220 28eb                 	sts triangle_fx_0xy_sequence+1, zero
001e80 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e81 937f                      	push r23
001e82 2f6a                      	mov r22, r26 //store the rate into r22
001e83 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e84 9f67                      	mul r22, r23
001e85 917f                      	pop r23
001e86 916f                      	pop r22
                                 
001e87 9416                      	lsr r1 //shift out the fractional bits
001e88 9407                      	ror r0
001e89 9416                      	lsr r1
001e8a 9407                      	ror r0
001e8b 9416                      	lsr r1
001e8c 9407                      	ror r0
001e8d 9416                      	lsr r1
001e8e 9407                      	ror r0
001e8f 9200 28ec                 	sts triangle_fx_1xx, r0
001e91 9210 28ed                 	sts triangle_fx_1xx+1, r1
001e93 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001e94 9220 28ec                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001e96 9220 28ed                 	sts triangle_fx_1xx+1, zero
001e98 9220 28ea                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001e9a 9220 28eb                 	sts triangle_fx_0xy_sequence+1, zero
001e9c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e9d 937f                      	push r23
001e9e 2f6a                      	mov r22, r26 //store the rate into r22
001e9f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ea0 9f67                      	mul r22, r23
001ea1 917f                      	pop r23
001ea2 916f                      	pop r22
                                 
001ea3 9416                      	lsr r1 //shift out the fractional bits
001ea4 9407                      	ror r0
001ea5 9416                      	lsr r1
001ea6 9407                      	ror r0
001ea7 9416                      	lsr r1
001ea8 9407                      	ror r0
001ea9 9416                      	lsr r1
001eaa 9407                      	ror r0
001eab 9200 28f0                 	sts triangle_fx_2xx, r0
001ead 9210 28f1                 	sts triangle_fx_2xx+1, r1
001eaf cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001eb0 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001eb1 937f                      	push r23
001eb2 2f6a                      	mov r22, r26 //store the rate into r22
001eb3 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001eb4 9f67                      	mul r22, r23
001eb5 917f                      	pop r23
001eb6 916f                      	pop r22
                                 
001eb7 9416                      	lsr r1 //shift out the fractional bits
001eb8 9407                      	ror r0
001eb9 9416                      	lsr r1
001eba 9407                      	ror r0
001ebb 9416                      	lsr r1
001ebc 9407                      	ror r0
001ebd 9416                      	lsr r1
001ebe 9407                      	ror r0
001ebf 9200 28f8                 	sts triangle_fx_3xx_speed, r0
001ec1 9210 28f9                 	sts triangle_fx_3xx_speed+1, r1
                                 
001ec3 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001ec4 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001ec5 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001ec6 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ec8 91b0 0aad                 	lds r27, TCB2_CCMPH
001eca 93a0 28f4                 	sts triangle_fx_3xx_start, r26
001ecc 93b0 28f5                 	sts triangle_fx_3xx_start+1, r27
                                 
001ece 9220 28fa                 	sts triangle_fx_3xx_total_offset, zero
001ed0 9220 28fb                 	sts triangle_fx_3xx_total_offset+1, zero
001ed2 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001ed3 2fba                      	mov r27, r26
001ed4 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001ed5 95a2                      	swap r26
001ed6 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001ed7 93a0 28fc                 	sts triangle_fx_4xy_speed, r26
001ed9 93b0 28fd                 	sts triangle_fx_4xy_depth, r27
001edb 9220 28fe                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001edd cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001ede cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001edf cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001ee0 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001ee2 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001ee3 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001ee5 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001ee6 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001ee8 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001ee9 15a2                      	cp r26, zero
001eea f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001eeb e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001eec 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001eee cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001eef 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001ef1 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001ef3 9220 0aad                 	sts TCB2_CCMPH, zero
001ef5 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001ef6 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001ef8 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001ef9 15a2                      	cp r26, zero
001efa f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001efb 91b0 2821                 	lds r27, song_speed
001efd 17ab                      	cp r26, r27
001efe f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001eff 93a0 28ff                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001f01 e0b1                      	ldi r27, 0x01
001f02 93b0 28c9                 	sts triangle_pattern_delay_rows, r27
001f04 c212                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001f05 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001f06 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001f07 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001f08 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001f09 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001f0a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f0b 937f                      	push r23
001f0c 2f6a                      	mov r22, r26
001f0d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f0e 0367                      	mulsu r22, r23
001f0f 917f                      	pop r23
001f10 916f                      	pop r22
001f11 9416                      	lsr r1 //shift out the fractional bits
001f12 9407                      	ror r0
001f13 9416                      	lsr r1
001f14 9407                      	ror r0
001f15 9416                      	lsr r1
001f16 9407                      	ror r0
001f17 9416                      	lsr r1
001f18 9407                      	ror r0
001f19 fe13                      	sbrs r1, 3 //check if result was a negative number
001f1a c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001f1b efb0                      	ldi r27, 0xF0
001f1c 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001f1d 9200 2901                 	sts triangle_fx_Pxx_total, r0
001f1f 9210 2902                 	sts triangle_fx_Pxx_total+1, r1
001f21 cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001f22 91e0 28d2                 	lds ZL, triangle_arpeggio_macro
001f24 91f0 28d3                 	lds ZH, triangle_arpeggio_macro+1
001f26 9630                      	adiw Z, 0
001f27 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001f28 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001f29 91e0 28da                 	lds ZL, triangle_pitch_macro
001f2b 91f0 28db                 	lds ZH, triangle_pitch_macro+1
001f2d 9630                      	adiw Z, 0
001f2e f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001f2f cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001f30 91e0 28e0                 	lds ZL, triangle_hi_pitch_macro
001f32 91f0 28e1                 	lds ZH, triangle_hi_pitch_macro+1
001f34 9630                      	adiw Z, 0
001f35 f009                      	breq sound_driver_channel2_fx_Qxy_process
001f36 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001f37 2fba                      	mov r27, r26 //copy fx parameters into r27
001f38 70bf                      	andi r27, 0x0F //mask note index offset
001f39 91c0 2903                 	lds r28, triangle_fx_Qxy_target_note //load current note index
001f3b 0fbc                      	add r27, r28
001f3c 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001f3d f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001f3e e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001f3f 93b0 2903                 	sts triangle_fx_Qxy_target_note, r27
001f41 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001f42 e0f0                      	ldi ZH, HIGH(note_table << 1)
001f43 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001f44 0feb                      	add ZL, r27 //add offset
001f45 1df2                      	adc ZH, zero
001f46 91c5                      	lpm r28, Z+ //load bytes
001f47 91d4                      	lpm r29, Z
001f48 93c0 2904                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001f4a 93d0 2905                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
001f4c 95a2                      	swap r26
001f4d 70af                      	andi r26, 0x0F //mask effect speed
001f4e 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001f4f 95a3                      	inc r26 //increment the speed by 1
                                 
001f50 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f51 937f                      	push r23
001f52 2f6a                      	mov r22, r26 //store the speed data into r27
001f53 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f54 9f67                      	mul r22, r23
001f55 917f                      	pop r23
001f56 916f                      	pop r22
                                 
001f57 9416                      	lsr r1 //shift out the fractional bits
001f58 9407                      	ror r0
001f59 9416                      	lsr r1
001f5a 9407                      	ror r0
001f5b 9416                      	lsr r1
001f5c 9407                      	ror r0
001f5d 9416                      	lsr r1
001f5e 9407                      	ror r0
                                 
001f5f 9200 2906                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001f61 9210 2907                 	sts triangle_fx_Qxy_speed+1, r1
001f63 cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001f64 91e0 28d2                 	lds ZL, triangle_arpeggio_macro
001f66 91f0 28d3                 	lds ZH, triangle_arpeggio_macro+1
001f68 9630                      	adiw Z, 0
001f69 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001f6a cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001f6b 91e0 28da                 	lds ZL, triangle_pitch_macro
001f6d 91f0 28db                 	lds ZH, triangle_pitch_macro+1
001f6f 9630                      	adiw Z, 0
001f70 f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001f71 ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001f72 91e0 28e0                 	lds ZL, triangle_hi_pitch_macro
001f74 91f0 28e1                 	lds ZH, triangle_hi_pitch_macro+1
001f76 9630                      	adiw Z, 0
001f77 f009                      	breq sound_driver_channel2_fx_Rxy_process
001f78 ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001f79 2fba                      	mov r27, r26 //copy fx parameters into r27
001f7a 70bf                      	andi r27, 0x0F //mask note index offset
001f7b 91c0 290a                 	lds r28, triangle_fx_Rxy_target_note //load current note index
001f7d 1bcb                      	sub r28, r27
001f7e f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001f7f e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001f80 93c0 290a                 	sts triangle_fx_Rxy_target_note, r28
001f82 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001f83 e0f0                      	ldi ZH, HIGH(note_table << 1)
001f84 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001f85 0fec                      	add ZL, r28 //add offset
001f86 1df2                      	adc ZH, zero
001f87 91c5                      	lpm r28, Z+ //load bytes
001f88 91d4                      	lpm r29, Z
001f89 93c0 290b                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001f8b 93d0 290c                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
001f8d 95a2                      	swap r26
001f8e 70af                      	andi r26, 0x0F //mask effect speed
001f8f 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001f90 95a3                      	inc r26 //increment the speed by 1
                                 
001f91 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001f92 937f                      	push r23
001f93 2f6a                      	mov r22, r26 //store the speed data into r27
001f94 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001f95 9f67                      	mul r22, r23
001f96 917f                      	pop r23
001f97 916f                      	pop r22
                                 
001f98 9416                      	lsr r1 //shift out the fractional bits
001f99 9407                      	ror r0
001f9a 9416                      	lsr r1
001f9b 9407                      	ror r0
001f9c 9416                      	lsr r1
001f9d 9407                      	ror r0
001f9e 9416                      	lsr r1
001f9f 9407                      	ror r0
                                 
001fa0 9200 290d                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001fa2 9210 290e                 	sts triangle_fx_Rxy_speed+1, r1
001fa4 cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001fa5 15a2                      	cp r26, zero
001fa6 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001fa7 91b0 2821                 	lds r27, song_speed
001fa9 17ab                      	cp r26, r27
001faa f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001fab 93a0 2911                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001fad e0b1                      	ldi r27, 0x01
001fae 93b0 28c9                 	sts triangle_pattern_delay_rows, r27
001fb0 c166                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
001fb1 ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001fb2 ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001fb3 ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001fb4 ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001fb5 ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001fb6 ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001fb7 93b0 2812                 	sts triangle_note, r27 //store the note index
001fb9 93b0 2903                 	sts triangle_fx_Qxy_target_note, r27
001fbb 93b0 290a                 	sts triangle_fx_Rxy_target_note, r27
001fbd e0a3                      	ldi r26, 0x03
001fbe e0b2                      	ldi r27, 0x02
001fbf 93b0 28cf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001fc1 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26
001fc3 93b0 28dc                 	sts triangle_pitch_macro_offset, r27
001fc5 93b0 28e2                 	sts triangle_hi_pitch_macro_offset, r27
001fc7 93b0 28e7                 	sts triangle_duty_macro_offset, r27
001fc9 9220 28d8                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001fcb 9220 28d9                 	sts triangle_total_pitch_offset+1, zero
001fcd 9220 28df                 	sts triangle_total_hi_pitch_offset, zero
001fcf 9220 28ee                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001fd1 9220 28ef                 	sts triangle_fx_1xx_total+1, zero
001fd3 9220 28f2                 	sts triangle_fx_2xx_total, zero
001fd5 9220 28f3                 	sts triangle_fx_2xx_total+1, zero
001fd7 9220 28fa                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001fd9 9220 28fb                 	sts triangle_fx_3xx_total_offset+1, zero
001fdb 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001fdd 91b0 0aad                 	lds r27, TCB2_CCMPH
001fdf 93a0 28f4                 	sts triangle_fx_3xx_start, r26
001fe1 93b0 28f5                 	sts triangle_fx_3xx_start+1, r27
001fe3 9220 2904                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001fe5 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
001fe7 9220 2908                 	sts triangle_fx_Qxy_total_offset, zero
001fe9 9220 2909                 	sts triangle_fx_Qxy_total_offset+1, zero
001feb 9220 290b                 	sts triangle_fx_Rxy_target, zero
001fed 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
001fef 9220 290f                 	sts triangle_fx_Rxy_total_offset, zero
001ff1 9220 2910                 	sts triangle_fx_Rxy_total_offset+1, zero
001ff3 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ff4 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001ff6 d0fd                      	rcall sound_driver_channel2_increment_offset
001ff7 ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001ff8 d0fb                      	rcall sound_driver_channel2_increment_offset
001ff9 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
001ffa f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001ffb e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ffc 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001ffe ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001fff 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
002001 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002003 9220 0aad                 	sts TCB2_CCMPH, zero
002005 ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
002006 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002007 93b0 28c9                 	sts triangle_pattern_delay_rows, r27
002009 d0ea                      	rcall sound_driver_channel2_increment_offset
00200a c0fd                      	rjmp sound_driver_channel2_end
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
00200b 9220 28cd                 	sts triangle_volume_macro, zero //reset all macro addresses
00200d 9220 28ce                 	sts triangle_volume_macro+1, zero
00200f 9220 28d2                 	sts triangle_arpeggio_macro, zero
002011 9220 28d3                 	sts triangle_arpeggio_macro+1, zero
002013 9220 28da                 	sts triangle_pitch_macro, zero
002015 9220 28db                 	sts triangle_pitch_macro+1, zero
002017 9220 28e0                 	sts triangle_hi_pitch_macro, zero
002019 9220 28e1                 	sts triangle_hi_pitch_macro+1, zero
00201b 9220 28e5                 	sts triangle_duty_macro, zero
00201d 9220 28e6                 	sts triangle_duty_macro+1, zero
00201f 9220 28d8                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
002021 9220 28d9                 	sts triangle_total_pitch_offset+1, zero
002023 9220 28df                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
002025 9631                      	adiw Z, 1 //point to the byte next to the flag
002026 91b4                      	lpm r27, Z //store the instrument offset into r27
002027 eae0                      	ldi ZL, LOW(instruments) //point Z to instruments table
002028 e1f1                      	ldi ZH, HIGH(instruments)
002029 0feb                      	add ZL, r27 //point Z to offsetted instrument
00202a 1df2                      	adc ZH, zero
00202b 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
00202c 1fff                      	rol ZH
00202d 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
00202e 91b4                      	lpm r27, Z
                                 
00202f 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
002030 1fbb                      	rol r27
002031 2fea                      	mov ZL, r26
002032 2ffb                      	mov ZH, r27
002033 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
002034 9632                      	adiw Z, 2 //point Z to the address of the macro
002035 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
002036 95aa                      	dec r26
002037 f019                      	breq sound_driver_channel2_instrument_change_exit
002038 95b6                      	lsr r27
002039 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
00203a cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
00203b e0a3                      	ldi r26, 0x03
00203c e0b2                      	ldi r27, 0x02
00203d 93b0 28cf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
00203f 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26
002041 93b0 28dc                 	sts triangle_pitch_macro_offset, r27
002043 93b0 28e2                 	sts triangle_hi_pitch_macro_offset, r27
002045 93b0 28e7                 	sts triangle_duty_macro_offset, r27
002047 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
002048 ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
002049 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
00204a 91d5                      	lpm r29, Z+
                                 
00204b 30a5                      	cpi r26, 5
00204c f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
00204d 30a4                      	cpi r26, 4
00204e f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
00204f 30a3                      	cpi r26, 3
002050 f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
002051 30a2                      	cpi r26, 2
002052 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
002053 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
002054 93c0 28cd                 	sts triangle_volume_macro, r28
002056 93d0 28ce                 	sts triangle_volume_macro+1, r29
002058 d041                      	rcall sound_driver_channel2_instrument_change_read_header
002059 93c0 28d1                 	sts triangle_volume_macro_release, r28
00205b 93d0 28d0                 	sts triangle_volume_macro_loop, r29
00205d cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
00205e 93c0 28d2                 	sts triangle_arpeggio_macro, r28
002060 93d0 28d3                 	sts triangle_arpeggio_macro+1, r29
002062 9220 2904                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002064 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
002066 9220 290b                 	sts triangle_fx_Rxy_target, zero
002068 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
00206a d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
00206b cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
00206c 93c0 28da                 	sts triangle_pitch_macro, r28
00206e 93d0 28db                 	sts triangle_pitch_macro+1, r29
002070 9220 2904                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002072 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
002074 9220 290b                 	sts triangle_fx_Rxy_target, zero
002076 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
002078 d021                      	rcall sound_driver_channel2_instrument_change_read_header
002079 93c0 28de                 	sts triangle_pitch_macro_release, r28
00207b 93d0 28dd                 	sts triangle_pitch_macro_loop, r29
00207d cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
00207e 93c0 28e0                 	sts triangle_hi_pitch_macro, r28
002080 93d0 28e1                 	sts triangle_hi_pitch_macro+1, r29
002082 9220 2904                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002084 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
002086 9220 290b                 	sts triangle_fx_Rxy_target, zero
002088 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
00208a d00f                      	rcall sound_driver_channel2_instrument_change_read_header
00208b 93c0 28e4                 	sts triangle_hi_pitch_macro_release, r28
00208d 93d0 28e3                 	sts triangle_hi_pitch_macro_loop, r29
00208f cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
002090 93c0 28e5                 	sts triangle_duty_macro, r28
002092 93d0 28e6                 	sts triangle_duty_macro+1, r29
002094 d005                      	rcall sound_driver_channel2_instrument_change_read_header
002095 93c0 28e9                 	sts triangle_duty_macro_release, r28
002097 93d0 28e8                 	sts triangle_duty_macro_loop, r29
002099 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
00209a 93ef                      	push ZL
00209b 93ff                      	push ZH
00209c 2fec                      	mov ZL, r28
00209d 2ffd                      	mov ZH, r29
00209e 0fee                      	lsl ZL
00209f 1fff                      	rol ZH
0020a0 91c5                      	lpm r28, Z+
0020a1 91d4                      	lpm r29, Z
0020a2 91ff                      	pop ZH
0020a3 91ef                      	pop ZL
0020a4 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
0020a5 93ef                      	push ZL
0020a6 93ff                      	push ZH
0020a7 2fec                      	mov ZL, r28
0020a8 2ffd                      	mov ZH, r29
0020a9 0fee                      	lsl ZL
0020aa 1fff                      	rol ZH
0020ab 91c5                      	lpm r28, Z+
0020ac 91d5                      	lpm r29, Z+
0020ad 93c0 28d6                 	sts triangle_arpeggio_macro_release, r28
0020af 93d0 28d5                 	sts triangle_arpeggio_macro_loop, r29
0020b1 91c4                      	lpm r28, Z
0020b2 93c0 28d7                 	sts triangle_arpeggio_macro_mode, r28
0020b4 91ff                      	pop ZH
0020b5 91ef                      	pop ZL
0020b6 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
0020b7 91b0 28d1                 	lds r27, triangle_volume_macro_release
0020b9 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0020ba f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
0020bb 95b3                      	inc r27
0020bc 93b0 28cf                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
0020be 91b0 28d6                 	lds r27, triangle_arpeggio_macro_release
0020c0 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
0020c1 f019                      	breq sound_driver_channel2_release_pitch
0020c2 95b3                      	inc r27
0020c3 93b0 28d4                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
0020c5 91b0 28de                 	lds r27, triangle_pitch_macro_release
0020c7 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
0020c8 f019                      	breq sound_driver_channel2_release_hi_pitch
0020c9 95b3                      	inc r27
0020ca 93b0 28dc                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
0020cc 91b0 28e4                 	lds r27, triangle_hi_pitch_macro_release
0020ce 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
0020cf f019                      	breq sound_driver_channel2_release_duty
0020d0 95b3                      	inc r27
0020d1 93b0 28e2                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
0020d3 91b0 28e9                 	lds r27, triangle_duty_macro_release
0020d5 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0020d6 f019                      	breq sound_driver_channel2_release_exit
0020d7 95b3                      	inc r27
0020d8 93b0 28e7                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
0020da d019                      	rcall sound_driver_channel2_increment_offset
0020db cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
0020dc 91e0 2819                 	lds ZL, song_frames
0020de 91f0 281a                 	lds ZH, song_frames+1
0020e0 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0020e2 91b0 281c                 	lds r27, song_frame_offset+1
0020e4 9614                      	adiw r27:r26, 4 //offset for channel 2
0020e5 0fea                      	add ZL, r26
0020e6 1ffb                      	adc ZH, r27
                                 
0020e7 91a5                      	lpm r26, Z+ //load the address of the next pattern
0020e8 91b4                      	lpm r27, Z
0020e9 0faa                      	lsl r26
0020ea 1fbb                      	rol r27
0020eb 93a0 28c7                 	sts triangle_pattern, r26
0020ed 93b0 28c8                 	sts triangle_pattern+1, r27
                                 
0020ef 9220 28cb                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0020f1 9220 28cc                 	sts triangle_pattern_offset+1, zero
0020f3 cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
0020f4 91e0 28cb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
0020f6 91f0 28cc                 	lds ZH, triangle_pattern_offset+1
0020f8 9631                      	adiw Z, 1
0020f9 93e0 28cb                 	sts triangle_pattern_offset, ZL
0020fb 93f0 28cc                 	sts triangle_pattern_offset+1, ZH
0020fd 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0020fe 91e0 28cb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
002100 91f0 28cc                 	lds ZH, triangle_pattern_offset+1
002102 9632                      	adiw Z, 2 //increment the pointer twice
002103 93e0 28cb                 	sts triangle_pattern_offset, ZL
002105 93f0 28cc                 	sts triangle_pattern_offset+1, ZH
002107 9508                      	ret
                                 
                                 sound_driver_channel2_end:
                                 sound_driver_channel2_check_Sxx_invalid:
002108 efbf                      	ldi r27, 0xFF
002109 91a0 2912                 	lds r26, triangle_fx_Sxx_post
00210b 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
00210c f419                      	brne sound_driver_channel2_check_Gxx_invalid
00210d 93b0 2912                 	sts triangle_fx_Sxx_post, r27
00210f 9508                      	ret
                                 sound_driver_channel2_check_Gxx_invalid:
002110 91a0 2900                 	lds r26, triangle_fx_Gxx_post
002112 15a2                      	cp r26, zero
002113 f419                      	brne sound_driver_channel3
002114 93b0 2900                 	sts triangle_fx_Gxx_post, r27
002116 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3:
002117 91a0 2915                 	lds r26, noise_pattern_delay_rows
002119 91b0 2916                 	lds r27, noise_pattern_delay_frames
                                 sound_driver_channel3_decrement_frame_delay:
00211b 95ba                      	dec r27
00211c 93b0 2916                 	sts noise_pattern_delay_frames, r27
                                 
00211e 9610                      	adiw r27:r26, 0
00211f f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
002120 c1b9                      	rjmp sound_driver_channel3_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel3_main:
002121 91e0 2913                 	lds ZL, noise_pattern //current pattern for noise
002123 91f0 2914                 	lds ZH, noise_pattern+1
002125 91a0 2917                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
002127 91b0 2918                 	lds r27, noise_pattern_offset+1
002129 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00212a 1ffb                      	adc ZH, r27
00212b 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
00212c 35b7                      	cpi r27, 0x57
00212d f408                      	brsh sound_driver_channel3_check_if_volume
00212e c096                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
00212f 36b7                      	cpi r27, 0x67
002130 f408                      	brsh sound_driver_channel3_check_if_delay
002131 c0b1                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
002132 3eb3                      	cpi r27, 0xE3
002133 f408                      	brsh sound_driver_channel3_check_if_instrument
002134 c0b7                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
002135 f409                      	brne sound_driver_channel3_check_if_release
002136 c0ba                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
002137 3eb4                      	cpi r27, 0xE4
002138 f409                      	brne sound_driver_channel3_check_if_end
002139 c14b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
00213a 3fbf                      	cpi r27, 0xFF
00213b f409                      	brne sound_driver_channel3_check_if_fx
00213c c16d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
00213d 9631                      	adiw Z, 1 //point Z to the byte next to the flag
00213e 91a4                      	lpm r26, Z //load the fx data into r26
00213f d190                      	rcall sound_driver_channel3_increment_offset_twice
                                 
002140 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
002141 e5e4                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
002142 e6f2                      	ldi ZH, HIGH(channel3_fx << 1)
002143 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
002144 0feb                      	add ZL, r27 //add offset
002145 1df2                      	adc ZH, zero
002146 91c5                      	lpm r28, Z+ //load address bytes
002147 91d4                      	lpm r29, Z
002148 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002149 2ffd                      	mov ZH, r29
00214a 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
00214b 93a0 2936                 	sts noise_fx_0xy_sequence, r26
00214d 9220 2937                 	sts noise_fx_0xy_sequence+1, zero
00214f cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
002150 9220 293a                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
002152 9220 2936                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002154 9220 2937                 	sts noise_fx_0xy_sequence+1, zero
002156 93a0 2938                 	sts noise_fx_1xx, r26
002158 cfc8                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
002159 9220 2938                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
00215b 9220 2936                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
00215d 9220 2937                 	sts noise_fx_0xy_sequence+1, zero
00215f 93a0 293a                 	sts noise_fx_2xx, r26
002161 cfbf                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
002162 cfbe                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
002163 2fba                      	mov r27, r26
002164 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002165 95a2                      	swap r26
002166 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002167 93a0 293c                 	sts noise_fx_4xy_speed, r26
002169 93b0 293d                 	sts noise_fx_4xy_depth, r27
00216b 9220 293e                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
00216d 9220 293f                 	sts noise_fx_4xy_offset, zero
00216f cfb1                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
002170 2fba                      	mov r27, r26
002171 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002172 95a2                      	swap r26
002173 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002174 93a0 2940                 	sts noise_fx_7xy_speed, r26
002176 93b0 2941                 	sts noise_fx_7xy_depth, r27
002178 9220 2942                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
00217a 9220 2943                 	sts noise_fx_7xy_value, zero //reset the tremelo value
00217c cfa4                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
00217d 93a0 2944                 	sts noise_fx_Axy, r26
00217f cfa1                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002180 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002182 cf9e                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
002183 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002185 cf9b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
002186 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002188 cf98                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
002189 91b0 2813                 	lds r27, noise_param
00218b 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
00218c 2bba                      	or r27, r26 //move new VVVV bits into noise_param
00218d 93b0 2813                 	sts noise_param, r27
00218f cf91                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002190 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002192 cf8e                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
002193 15a2                      	cp r26, zero
002194 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
002195 91b0 2821                 	lds r27, song_speed
002197 17ab                      	cp r26, r27
002198 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
002199 93a0 2945                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00219b e0b1                      	ldi r27, 0x01
00219c 93b0 2915                 	sts noise_pattern_delay_rows, r27
00219e c14a                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
00219f cf81                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
0021a0 cf80                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
0021a1 cf7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
0021a2 cf7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
0021a3 cf7d                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
0021a4 93a0 2947                 	sts noise_fx_Pxx_total, r26
0021a6 cf7a                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Qxy: //note slide up
0021a7 cf79                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Rxy: //note slide down
0021a8 cf78                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
0021a9 15a2                      	cp r26, zero
0021aa f051                      	breq sound_driver_channel3_fx_Sxx_invalid
0021ab 91b0 2821                 	lds r27, song_speed
0021ad 17ab                      	cp r26, r27
0021ae f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
0021af 93a0 2948                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0021b1 e0b1                      	ldi r27, 0x01
0021b2 93b0 2915                 	sts noise_pattern_delay_rows, r27
0021b4 c134                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
0021b5 cf6b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
0021b6 95a6                      	lsr r26
0021b7 95a7                      	ror r26 //move mode bit to bit 7
0021b8 91b0 2814                 	lds r27, noise_period
0021ba 77bf                      	andi r27, 0b01111111
0021bb 2bba                      	or r27, r26 //store the new noise mode
0021bc 93b0 2813                 	sts noise_param, r27
                                 
0021be 776f                      	andi noise_sequence_HIGH, 0b01111111
0021bf 2b6a                      	or noise_sequence_HIGH, r26
0021c0 cf60                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
0021c1 cf5f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
0021c2 cf5e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
0021c3 cf5d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
0021c4 cf5c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
0021c5 93b0 2817                 	sts noise_note, r27
0021c7 93b0 2818                 	sts noise_adjusted_note, r27
0021c9 e0a3                      	ldi r26, 0x03
0021ca e0b2                      	ldi r27, 0x02
0021cb 93b0 291b                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0021cd 93a0 2920                 	sts noise_arpeggio_macro_offset, r26
0021cf 93b0 2928                 	sts noise_pitch_macro_offset, r27
0021d1 93b0 292e                 	sts noise_hi_pitch_macro_offset, r27
0021d3 93b0 2933                 	sts noise_duty_macro_offset, r27
0021d5 9220 2924                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
0021d7 9220 2925                 	sts noise_total_pitch_offset+1, zero
0021d9 9220 292b                 	sts noise_total_hi_pitch_offset, zero
0021db 9220 2939                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0021dd 9220 293b                 	sts noise_fx_2xx_total, zero
0021df 9220 293f                 	sts noise_fx_4xy_offset, zero
0021e1 d0e4                      	rcall sound_driver_channel3_increment_offset
0021e2 cf3e                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
0021e3 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
0021e4 91a0 2813                 	lds r26, noise_param
0021e6 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0021e7 2bab                      	or r26, r27 //move new VVVV bits into noise_param
0021e8 93a0 2813                 	sts noise_param, r26
0021ea d0db                      	rcall sound_driver_channel3_increment_offset
0021eb cf35                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
0021ec 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0021ed 93b0 2915                 	sts noise_pattern_delay_rows, r27
0021ef d0d6                      	rcall sound_driver_channel3_increment_offset
0021f0 c0e9                      	rjmp sound_driver_channel3_end
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
0021f1 9220 2919                 	sts noise_volume_macro, zero //reset all macro addresses
0021f3 9220 291a                 	sts noise_volume_macro+1, zero
0021f5 9220 291e                 	sts noise_arpeggio_macro, zero
0021f7 9220 291f                 	sts noise_arpeggio_macro+1, zero
0021f9 9220 2926                 	sts noise_pitch_macro, zero
0021fb 9220 2927                 	sts noise_pitch_macro+1, zero
0021fd 9220 292c                 	sts noise_hi_pitch_macro, zero
0021ff 9220 292d                 	sts noise_hi_pitch_macro+1, zero
002201 9220 2931                 	sts noise_duty_macro, zero
002203 9220 2932                 	sts noise_duty_macro+1, zero
002205 9220 2924                 	sts noise_total_pitch_offset, zero //reset the pitch offset
002207 9220 2925                 	sts noise_total_pitch_offset+1, zero
002209 9220 292b                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
00220b 9631                      	adiw Z, 1 //point to the byte next to the flag
00220c 91b4                      	lpm r27, Z //store the instrument offset into r27
00220d eae0                      	ldi ZL, LOW(instruments) //point Z to instruments table
00220e e1f1                      	ldi ZH, HIGH(instruments)
00220f 0feb                      	add ZL, r27 //point Z to offsetted instrument
002210 1df2                      	adc ZH, zero
002211 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
002212 1fff                      	rol ZH
002213 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
002214 91b4                      	lpm r27, Z
                                 
002215 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
002216 1fbb                      	rol r27
002217 2fea                      	mov ZL, r26
002218 2ffb                      	mov ZH, r27
002219 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
00221a 9632                      	adiw Z, 2 //point Z to the address of the macro
00221b e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
00221c 95aa                      	dec r26
00221d f019                      	breq sound_driver_channel3_instrument_change_exit
00221e 95b6                      	lsr r27
00221f f078                      	brcs sound_driver_channel3_instrument_change_load_macro
002220 cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
002221 e0a3                      	ldi r26, 0x03
002222 e0b2                      	ldi r27, 0x02
002223 93b0 291b                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002225 93a0 2920                 	sts noise_arpeggio_macro_offset, r26
002227 93b0 2928                 	sts noise_pitch_macro_offset, r27
002229 93b0 292e                 	sts noise_hi_pitch_macro_offset, r27
00222b 93b0 2933                 	sts noise_duty_macro_offset, r27
00222d d0a2                      	rcall sound_driver_channel3_increment_offset_twice
00222e cef2                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
00222f 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
002230 91d5                      	lpm r29, Z+
                                 
002231 30a5                      	cpi r26, 5
002232 f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
002233 30a4                      	cpi r26, 4
002234 f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
002235 30a3                      	cpi r26, 3
002236 f099                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
002237 30a2                      	cpi r26, 2
002238 f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
002239 c024                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
00223a 93c0 2919                 	sts noise_volume_macro, r28
00223c 93d0 291a                 	sts noise_volume_macro+1, r29
00223e d029                      	rcall sound_driver_channel3_instrument_change_read_header
00223f 93c0 291d                 	sts noise_volume_macro_release, r28
002241 93d0 291c                 	sts noise_volume_macro_loop, r29
002243 cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
002244 93c0 291e                 	sts noise_arpeggio_macro, r28
002246 93d0 291f                 	sts noise_arpeggio_macro+1, r29
002248 d02a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
002249 cfd2                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
00224a 93c0 2926                 	sts noise_pitch_macro, r28
00224c 93d0 2927                 	sts noise_pitch_macro+1, r29
00224e d019                      	rcall sound_driver_channel3_instrument_change_read_header
00224f 93c0 292a                 	sts noise_pitch_macro_release, r28
002251 93d0 2929                 	sts noise_pitch_macro_loop, r29
002253 cfc8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
002254 93c0 292c                 	sts noise_hi_pitch_macro, r28
002256 93d0 292d                 	sts noise_hi_pitch_macro+1, r29
002258 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
002259 93c0 2930                 	sts noise_hi_pitch_macro_release, r28
00225b 93d0 292f                 	sts noise_hi_pitch_macro_loop, r29
00225d cfbe                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
00225e 93c0 2931                 	sts noise_duty_macro, r28
002260 93d0 2932                 	sts noise_duty_macro+1, r29
002262 d005                      	rcall sound_driver_channel3_instrument_change_read_header
002263 93c0 2935                 	sts noise_duty_macro_release, r28
002265 93d0 2934                 	sts noise_duty_macro_loop, r29
002267 cfb4                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
002268 93ef                      	push ZL
002269 93ff                      	push ZH
00226a 2fec                      	mov ZL, r28
00226b 2ffd                      	mov ZH, r29
00226c 0fee                      	lsl ZL
00226d 1fff                      	rol ZH
00226e 91c5                      	lpm r28, Z+
00226f 91d4                      	lpm r29, Z
002270 91ff                      	pop ZH
002271 91ef                      	pop ZL
002272 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
002273 93ef                      	push ZL
002274 93ff                      	push ZH
002275 2fec                      	mov ZL, r28
002276 2ffd                      	mov ZH, r29
002277 0fee                      	lsl ZL
002278 1fff                      	rol ZH
002279 91c5                      	lpm r28, Z+
00227a 91d5                      	lpm r29, Z+
00227b 93c0 2922                 	sts noise_arpeggio_macro_release, r28
00227d 93d0 2921                 	sts noise_arpeggio_macro_loop, r29
00227f 91c4                      	lpm r28, Z
002280 93c0 2923                 	sts noise_arpeggio_macro_mode, r28
002282 91ff                      	pop ZH
002283 91ef                      	pop ZL
002284 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
002285 91b0 291d                 	lds r27, noise_volume_macro_release
002287 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002288 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
002289 95b3                      	inc r27
00228a 93b0 291b                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
00228c 91b0 2922                 	lds r27, noise_arpeggio_macro_release
00228e 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00228f f019                      	breq sound_driver_channel3_release_pitch
002290 95b3                      	inc r27
002291 93b0 2920                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
002293 91b0 292a                 	lds r27, noise_pitch_macro_release
002295 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002296 f019                      	breq sound_driver_channel3_release_hi_pitch
002297 95b3                      	inc r27
002298 93b0 2928                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
00229a 91b0 2930                 	lds r27, noise_hi_pitch_macro_release
00229c 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00229d f019                      	breq sound_driver_channel3_release_duty
00229e 95b3                      	inc r27
00229f 93b0 292e                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
0022a1 91b0 2935                 	lds r27, noise_duty_macro_release
0022a3 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0022a4 f019                      	breq sound_driver_channel3_release_exit
0022a5 95b3                      	inc r27
0022a6 93b0 2933                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
0022a8 d01d                      	rcall sound_driver_channel3_increment_offset
0022a9 ce77                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
0022aa 91e0 2819                 	lds ZL, song_frames
0022ac 91f0 281a                 	lds ZH, song_frames+1
0022ae 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0022b0 91b0 281c                 	lds r27, song_frame_offset+1
0022b2 93a0 281b                 	sts song_frame_offset, r26
0022b4 93b0 281c                 	sts song_frame_offset+1, r27
0022b6 9616                      	adiw r27:r26, 6 //offset for channel 3
0022b7 0fea                      	add ZL, r26
0022b8 1ffb                      	adc ZH, r27
                                 
0022b9 91a5                      	lpm r26, Z+ //load the address of the next pattern
0022ba 91b4                      	lpm r27, Z
0022bb 0faa                      	lsl r26
0022bc 1fbb                      	rol r27
0022bd 93a0 2913                 	sts noise_pattern, r26
0022bf 93b0 2914                 	sts noise_pattern+1, r27
                                 
0022c1 9220 2917                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0022c3 9220 2918                 	sts noise_pattern_offset+1, zero
0022c5 ce5b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
0022c6 91e0 2917                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
0022c8 91f0 2918                 	lds ZH, noise_pattern_offset+1
0022ca 9631                      	adiw Z, 1
0022cb 93e0 2917                 	sts noise_pattern_offset, ZL
0022cd 93f0 2918                 	sts noise_pattern_offset+1, ZH
0022cf 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0022d0 91e0 2917                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
0022d2 91f0 2918                 	lds ZH, noise_pattern_offset+1
0022d4 9632                      	adiw Z, 2 //increment the pointer twice
0022d5 93e0 2917                 	sts noise_pattern_offset, ZL
0022d7 93f0 2918                 	sts noise_pattern_offset+1, ZH
0022d9 9508                      	ret
                                 
                                 sound_driver_channel3_end:
                                 sound_driver_channel3_check_Sxx_invalid:
0022da efbf                      	ldi r27, 0xFF
0022db 91a0 2949                 	lds r26, noise_fx_Sxx_post
0022dd 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
0022de f419                      	brne sound_driver_channel3_check_Gxx_invalid
0022df 93b0 2949                 	sts noise_fx_Sxx_post, r27
0022e1 9508                      	ret
                                 sound_driver_channel3_check_Gxx_invalid:
0022e2 91a0 2946                 	lds r26, noise_fx_Gxx_post
0022e4 15a2                      	cp r26, zero
0022e5 f419                      	brne sound_driver_channel4
0022e6 93b0 2946                 	sts noise_fx_Gxx_post, r27
0022e8 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel4:
0022e9 91a0 294c                 	lds r26, dpcm_pattern_delay_rows
0022eb 91b0 294d                 	lds r27, dpcm_pattern_delay_frames
                                 sound_driver_channel4_decrement_frame_delay:
0022ed 95ba                      	dec r27
0022ee 93b0 294d                 	sts dpcm_pattern_delay_frames, r27
                                 
0022f0 9610                      	adiw r27:r26, 0
0022f1 f009                      	breq sound_driver_channel4_main //if the pattern delay is 0, proceed with sound driver procedures
0022f2 c0bd                      	rjmp sound_driver_channel4_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel4_main:
0022f3 91e0 294a                 	lds ZL, dpcm_pattern //current pattern for dpcm
0022f5 91f0 294b                 	lds ZH, dpcm_pattern+1
0022f7 91a0 294e                 	lds r26, dpcm_pattern_offset //current offset in the pattern for dpcm
0022f9 91b0 294f                 	lds r27, dpcm_pattern_offset+1
0022fb 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0022fc 1ffb                      	adc ZH, r27
0022fd 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel4_check_if_note: //check if data is a note (0x00 - 0x56)
0022fe 35b7                      	cpi r27, 0x57
0022ff f408                      	brsh sound_driver_channel4_check_if_volume
002300 c056                      	rjmp sound_driver_channel4_note
                                 sound_driver_channel4_check_if_volume: //check if data is volume (0x57-0x66)
002301 36b7                      	cpi r27, 0x67
002302 f408                      	brsh sound_driver_channel4_check_if_delay
002303 c071                      	rjmp sound_driver_channel4_volume
                                 sound_driver_channel4_check_if_delay: //check if data is a delay (0x67 - 0xE2)
002304 3eb3                      	cpi r27, 0xE3
002305 f408                      	brsh sound_driver_channel4_check_if_instrument
002306 c070                      	rjmp sound_driver_channel4_delay
                                 sound_driver_channel4_check_if_instrument: //check for instrument flag (0xE3)
002307 f409                      	brne sound_driver_channel4_check_if_release
002308 c073                      	rjmp sound_driver_channel4_instrument_change 
                                 sound_driver_channel4_check_if_release: //check for note release flag (0xE4)
002309 3eb4                      	cpi r27, 0xE4
00230a f409                      	brne sound_driver_channel4_check_if_end
00230b c072                      	rjmp sound_driver_channel4_release
                                 sound_driver_channel4_check_if_end:
00230c 3fbf                      	cpi r27, 0xFF
00230d f409                      	brne sound_driver_channel4_check_if_fx
00230e c071                      	rjmp sound_driver_channel4_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel4_check_if_fx: //fx flags (0xE5 - 0xFE)
00230f 9631                      	adiw Z, 1 //point Z to the byte next to the flag
002310 91a4                      	lpm r26, Z //load the fx data into r26
002311 d094                      	rcall sound_driver_channel4_increment_offset_twice
                                 
002312 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
002313 e8e8                      	ldi ZL, LOW(channel4_fx << 1) //load in note table
002314 e6f2                      	ldi ZH, HIGH(channel4_fx << 1)
002315 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
002316 0feb                      	add ZL, r27 //add offset
002317 1df2                      	adc ZH, zero
002318 91c5                      	lpm r28, Z+ //load address bytes
002319 91d4                      	lpm r29, Z
00231a 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00231b 2ffd                      	mov ZH, r29
00231c 9409                      	ijmp
                                 
                                 
                                 
                                 sound_driver_channel4_fx_0xy: //arpeggio
00231d cfd5                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_1xx: //pitch slide up
00231e cfd4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_2xx: //pitch slide down
00231f cfd3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_3xx: //automatic portamento
002320 cfd2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_4xy: //vibrato
002321 cfd1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_7xy: //tremelo
002322 cfd0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Axy: //volume slide
002323 cfcf                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel4_fx_Bxx:
002324 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002326 cfcc                      	rjmp sound_driver_channel4_main
                                 
                                 //HALT
                                 sound_driver_channel4_fx_Cxx:
002327 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002329 cfc9                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel4_fx_Dxx:
00232a 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
00232c cfc6                      	rjmp sound_driver_channel4_main
                                 
                                 sound_driver_channel4_fx_Exx: //volume
00232d cfc5                      	rjmp sound_driver_channel4_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel4_fx_Fxx:
00232e 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002330 cfc2                      	rjmp sound_driver_channel4_main
                                 
                                 //DELAY
                                 sound_driver_channel4_fx_Gxx:
002331 15a2                      	cp r26, zero
002332 f051                      	breq sound_driver_channel4_fx_Gxx_invalid
002333 91b0 2821                 	lds r27, song_speed
002335 17ab                      	cp r26, r27
002336 f430                      	brsh sound_driver_channel4_fx_Gxx_invalid
002337 93a0 2954                 	sts dpcm_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002339 e0b1                      	ldi r27, 0x01
00233a 93b0 294c                 	sts dpcm_pattern_delay_rows, r27
00233c c082                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Gxx_invalid:
00233d cfb5                      	rjmp sound_driver_channel4_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Hxy: //hardware sweep up
00233e cfb4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixy: //hardware sweep down
00233f cfb3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Hxx: //FDS modulation depth
002340 cfb2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixx: //FDS modulation speed
002341 cfb1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Pxx: //fine pitch
002342 cfb0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Qxy: //note slide up
002343 cfaf                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Rxy: //note slide down
002344 cfae                      	rjmp sound_driver_channel4_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel4_fx_Sxx:
002345 15a2                      	cp r26, zero
002346 f051                      	breq sound_driver_channel4_fx_Sxx_invalid
002347 91b0 2821                 	lds r27, song_speed
002349 17ab                      	cp r26, r27
00234a f430                      	brsh sound_driver_channel4_fx_Sxx_invalid
00234b 93a0 2956                 	sts dpcm_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00234d e0b1                      	ldi r27, 0x01
00234e 93b0 294c                 	sts dpcm_pattern_delay_rows, r27
002350 c06e                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Sxx_invalid:
002351 cfa1                      	rjmp sound_driver_channel4_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Vxx: //duty
002352 cfa0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Wxx: //DPCM sample speed
002353 cf9f                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Xxx: //DPCM sample retrigger
002354 cf9e                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Yxx: //DPCM sample offset
002355 cf9d                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Zxx: //DPCM sample delta counter
002356 cf9c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_note:
002357 9631                      	adiw Z, 1 //point to the byte next to the flag
002358 90f4                      	lpm dpcm_period, Z //store the DPCM sample rate
002359 e3ec                      	ldi ZL, LOW(dpcm_samples) //point Z to dpcm_samples table
00235a e1f0                      	ldi ZH, HIGH(dpcm_samples)
00235b 0feb                      	add ZL, r27 //point Z to offsetted sample
00235c 1df2                      	adc ZH, zero
00235d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the samples's address
00235e 1fff                      	rol ZH
00235f 91a5                      	lpm r26, Z+ //r26:r27 now points to the sample
002360 91b4                      	lpm r27, Z
                                 
002361 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the sample's data
002362 1fbb                      	rol r27
002363 2fea                      	mov ZL, r26
002364 2ffb                      	mov ZH, r27
002365 91b4                      	lpm r27, Z //get sample length
002366 ef70                      	ldi dpcm_length_LOW, 0b11110000
002367 e08f                      	ldi dpcm_length_HIGH, 0b00001111
002368 95b2                      	swap r27
002369 237b                      	and dpcm_length_LOW, r27
00236a 238b                      	and dpcm_length_HIGH, r27
                                 
00236b 93e0 2950                 	sts dpcm_sample, ZL //store address to sample
00236d 93f0 2951                 	sts dpcm_sample+1, ZH
00236f 9230 2952                 	sts dpcm_sample_offset, one //start sample offset at 1 (0th byte was used for sample length)
002371 9220 2953                 	sts dpcm_sample_offset+1, zero
                                 
002373 d032                      	rcall sound_driver_channel4_increment_offset_twice
002374 cf7e                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_volume:
002375 d026                      	rcall sound_driver_channel4_increment_offset
002376 cf7c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_delay:
002377 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002378 93b0 294c                 	sts dpcm_pattern_delay_rows, r27
00237a d021                      	rcall sound_driver_channel4_increment_offset
00237b c034                      	rjmp sound_driver_channel4_end
                                 
                                 
                                 
                                 sound_driver_channel4_instrument_change:
00237c d029                      	rcall sound_driver_channel4_increment_offset_twice
00237d cf75                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_release:
00237e d01d                      	rcall sound_driver_channel4_increment_offset
00237f cf73                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_next_pattern:
002380 91e0 2819                 	lds ZL, song_frames
002382 91f0 281a                 	lds ZH, song_frames+1
002384 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002386 91b0 281c                 	lds r27, song_frame_offset+1
002388 93a0 281b                 	sts song_frame_offset, r26
00238a 93b0 281c                 	sts song_frame_offset+1, r27
00238c 9618                      	adiw r27:r26, 8 //offset for channel 4
00238d 0fea                      	add ZL, r26
00238e 1ffb                      	adc ZH, r27
                                 
00238f 91a5                      	lpm r26, Z+ //load the address of the next pattern
002390 91b4                      	lpm r27, Z
002391 0faa                      	lsl r26
002392 1fbb                      	rol r27
002393 93a0 294a                 	sts dpcm_pattern, r26
002395 93b0 294b                 	sts dpcm_pattern+1, r27
                                 
002397 9220 294e                 	sts dpcm_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002399 9220 294f                 	sts dpcm_pattern_offset+1, zero
00239b cf57                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_increment_offset:
00239c 91e0 294e                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
00239e 91f0 294f                 	lds ZH, dpcm_pattern_offset+1
0023a0 9631                      	adiw Z, 1
0023a1 93e0 294e                 	sts dpcm_pattern_offset, ZL
0023a3 93f0 294f                 	sts dpcm_pattern_offset+1, ZH
0023a5 9508                      	ret
                                 
                                 sound_driver_channel4_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0023a6 91e0 294e                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
0023a8 91f0 294f                 	lds ZH, dpcm_pattern_offset+1
0023aa 9632                      	adiw Z, 2 //increment the pointer twice
0023ab 93e0 294e                 	sts dpcm_pattern_offset, ZL
0023ad 93f0 294f                 	sts dpcm_pattern_offset+1, ZH
0023af 9508                      	ret
                                 
                                 sound_driver_channel4_end:
                                 sound_driver_channel4_check_Sxx_invalid:
0023b0 efbf                      	ldi r27, 0xFF
0023b1 91a0 2957                 	lds r26, dpcm_fx_Sxx_post
0023b3 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
0023b4 f419                      	brne sound_driver_channel4_check_Gxx_invalid
0023b5 93b0 2957                 	sts dpcm_fx_Sxx_post, r27
0023b7 9508                      	ret
                                 sound_driver_channel4_check_Gxx_invalid:
0023b8 91a0 2955                 	lds r26, dpcm_fx_Gxx_post
0023ba 15a2                      	cp r26, zero
0023bb f419                      	brne sound_driver_calculate_delays
0023bc 93b0 2955                 	sts dpcm_fx_Gxx_post, r27
0023be 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
0023bf 91f0 2821                 	lds r31, song_speed
                                 
                                 sound_driver_calculate_delays_pulse1:
0023c1 91a0 2828                 	lds r26, pulse1_pattern_delay_frames
0023c3 11a2                      	cpse r26, zero
0023c4 c044                      	rjmp sound_driver_calculate_delays_pulse2
0023c5 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
0023c6 2faf                      	mov r26, r31 //move speed into r26
0023c7 91b0 2827                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
0023c9 15b2                      	cp r27, zero
0023ca f409                      	brne PC+2
0023cb c03d                      	rjmp sound_driver_calculate_delays_pulse2
0023cc 95ba                      	dec r27
0023cd 93b0 2827                 	sts pulse1_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
0023cf efbf                      	ldi r27, 0xFF
0023d0 91c0 2874                 	lds r28, pulse1_fx_Sxx_pre
0023d2 91d0 2875                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
0023d4 17cb                      	cp r28, r27
0023d5 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
0023d6 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
0023d7 17db                      	cp r29, r27
0023d8 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
0023d9 c014                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
0023da 91c0 2862                 	lds r28, pulse1_fx_Gxx_pre
0023dc 91d0 2863                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
0023de 17cb                      	cp r28, r27
0023df f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
0023e0 c011                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
0023e1 17db                      	cp r29, r27
0023e2 f121                      	breq sound_driver_calculate_delays_pulse1_store
0023e3 c018                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
0023e4 93b0 2874                 	sts pulse1_fx_Sxx_pre, r27
0023e6 1bac                      	sub r26, r28 //(song speed)-Sxx
0023e7 93a0 2875                 	sts pulse1_fx_Sxx_post, r26
0023e9 93c0 2828                 	sts pulse1_pattern_delay_frames, r28
0023eb 11a2                      	cpse r26, zero
0023ec c01c                      	rjmp sound_driver_calculate_delays_pulse2
0023ed c012                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
0023ee 93b0 2875                 	sts pulse1_fx_Sxx_post, r27
0023f0 2fad                      	mov r26, r29
0023f1 c015                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
0023f2 93b0 2862                 	sts pulse1_fx_Gxx_pre, r27
0023f4 1bac                      	sub r26, r28 //(song speed)-Gxx
0023f5 93a0 2863                 	sts pulse1_fx_Gxx_post, r26
0023f7 93c0 2828                 	sts pulse1_pattern_delay_frames, r28
0023f9 11a2                      	cpse r26, zero
0023fa c00e                      	rjmp sound_driver_calculate_delays_pulse2
0023fb c004                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
0023fc 93b0 2863                 	sts pulse1_fx_Gxx_post, r27
0023fe 2fad                      	mov r26, r29
0023ff c007                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid:
002400 9220 2828                 	sts pulse1_pattern_delay_frames, zero
002402 940e 185c                 	call sound_driver_channel0_main
002404 91f0 2821                 	lds r31, song_speed
002406 cfba                      	rjmp sound_driver_calculate_delays_pulse1
                                 
                                 sound_driver_calculate_delays_pulse1_store:
002407 93a0 2828                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
002409 91a0 2879                 	lds r26, pulse2_pattern_delay_frames
00240b 11a2                      	cpse r26, zero
00240c c044                      	rjmp sound_driver_calculate_delays_triangle
00240d c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
00240e 2faf                      	mov r26, r31 //move the speed to r26
00240f 91b0 2878                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
002411 15b2                      	cp r27, zero
002412 f409                      	brne PC+2
002413 c03d                      	rjmp sound_driver_calculate_delays_triangle
002414 95ba                      	dec r27
002415 93b0 2878                 	sts pulse2_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
002417 efbf                      	ldi r27, 0xFF
002418 91c0 28c5                 	lds r28, pulse2_fx_Sxx_pre
00241a 91d0 28c6                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
00241c 17cb                      	cp r28, r27
00241d f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
00241e c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
00241f 17db                      	cp r29, r27
002420 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
002421 c014                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
002422 91c0 28b3                 	lds r28, pulse2_fx_Gxx_pre
002424 91d0 28b4                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
002426 17cb                      	cp r28, r27
002427 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
002428 c011                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
002429 17db                      	cp r29, r27
00242a f121                      	breq sound_driver_calculate_delays_pulse2_store
00242b c018                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
00242c 93b0 28c5                 	sts pulse2_fx_Sxx_pre, r27
00242e 1bac                      	sub r26, r28 //(song speed)-Sxx
00242f 93a0 28c6                 	sts pulse2_fx_Sxx_post, r26
002431 93c0 2879                 	sts pulse2_pattern_delay_frames, r28
002433 11a2                      	cpse r26, zero
002434 c01c                      	rjmp sound_driver_calculate_delays_triangle
002435 c012                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
002436 93b0 28c6                 	sts pulse2_fx_Sxx_post, r27
002438 2fad                      	mov r26, r29
002439 c015                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
00243a 93b0 28b3                 	sts pulse2_fx_Gxx_pre, r27
00243c 1bac                      	sub r26, r28 //(song speed)-1-Gxx
00243d 93a0 28b4                 	sts pulse2_fx_Gxx_post, r26
00243f 93c0 2879                 	sts pulse2_pattern_delay_frames, r28
002441 11a2                      	cpse r26, zero
002442 c00e                      	rjmp sound_driver_calculate_delays_triangle
002443 c004                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
002444 93b0 28b4                 	sts pulse2_fx_Gxx_post, r27
002446 2fad                      	mov r26, r29
002447 c007                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid:
002448 9220 2879                 	sts pulse2_pattern_delay_frames, zero
00244a 940e 1b59                 	call sound_driver_channel1_main
00244c 91f0 2821                 	lds r31, song_speed
00244e cfba                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_store:
00244f 93a0 2879                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
002451 91a0 28ca                 	lds r26, triangle_pattern_delay_frames
002453 11a2                      	cpse r26, zero
002454 c044                      	rjmp sound_driver_calculate_delays_noise
002455 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
002456 2faf                      	mov r26, r31 //move the speed to r26
002457 91b0 28c9                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
002459 15b2                      	cp r27, zero
00245a f409                      	brne PC+2
00245b c03d                      	rjmp sound_driver_calculate_delays_noise
00245c 95ba                      	dec r27
00245d 93b0 28c9                 	sts triangle_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
00245f efbf                      	ldi r27, 0xFF
002460 91c0 2911                 	lds r28, triangle_fx_Sxx_pre
002462 91d0 2912                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
002464 17cb                      	cp r28, r27
002465 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
002466 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
002467 17db                      	cp r29, r27
002468 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
002469 c014                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
00246a 91c0 28ff                 	lds r28, triangle_fx_Gxx_pre
00246c 91d0 2900                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
00246e 17cb                      	cp r28, r27
00246f f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
002470 c011                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
002471 17db                      	cp r29, r27
002472 f121                      	breq sound_driver_calculate_delays_triangle_store
002473 c018                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
002474 93b0 2911                 	sts triangle_fx_Sxx_pre, r27
002476 1bac                      	sub r26, r28 //(song speed)-Sxx
002477 93a0 2912                 	sts triangle_fx_Sxx_post, r26
002479 93c0 28ca                 	sts triangle_pattern_delay_frames, r28
00247b 11a2                      	cpse r26, zero
00247c c01c                      	rjmp sound_driver_calculate_delays_noise
00247d c012                      	rjmp sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
00247e 93b0 2912                 	sts triangle_fx_Sxx_post, r27
002480 2fad                      	mov r26, r29
002481 c015                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002482 93b0 28ff                 	sts triangle_fx_Gxx_pre, r27
002484 1bac                      	sub r26, r28 //(song speed)-Gxx
002485 93a0 2900                 	sts triangle_fx_Gxx_post, r26
002487 93c0 28ca                 	sts triangle_pattern_delay_frames, r28
002489 11a2                      	cpse r26, zero
00248a c00e                      	rjmp sound_driver_calculate_delays_noise
00248b c004                      	rjmp sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
00248c 93b0 2900                 	sts triangle_fx_Gxx_post, r27
00248e 2fad                      	mov r26, r29
00248f c007                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid:
002490 9220 28ca                 	sts triangle_pattern_delay_frames, zero
002492 940e 1e49                 	call sound_driver_channel2_main
002494 91f0 2821                 	lds r31, song_speed
002496 cfba                      	rjmp sound_driver_calculate_delays_triangle
                                 
                                 sound_driver_calculate_delays_triangle_store:
002497 93a0 28ca                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
002499 91a0 2916                 	lds r26, noise_pattern_delay_frames
00249b 11a2                      	cpse r26, zero
00249c c044                      	rjmp sound_driver_calculate_delays_dpcm
00249d c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
00249e 2faf                      	mov r26, r31 //move the speed to r26
00249f 91b0 2915                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
0024a1 15b2                      	cp r27, zero
0024a2 f409                      	brne PC+2
0024a3 c03d                      	rjmp sound_driver_calculate_delays_dpcm
0024a4 95ba                      	dec r27
0024a5 93b0 2915                 	sts noise_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
0024a7 efbf                      	ldi r27, 0xFF
0024a8 91c0 2948                 	lds r28, noise_fx_Sxx_pre
0024aa 91d0 2949                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
0024ac 17cb                      	cp r28, r27
0024ad f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
0024ae c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
0024af 17db                      	cp r29, r27
0024b0 f009                      	breq sound_driver_calculate_delays_noise_Gxx
0024b1 c014                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
0024b2 91c0 2945                 	lds r28, noise_fx_Gxx_pre
0024b4 91d0 2946                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
0024b6 17cb                      	cp r28, r27
0024b7 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
0024b8 c011                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
0024b9 17db                      	cp r29, r27
0024ba f121                      	breq sound_driver_calculate_delays_noise_store
0024bb c018                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
0024bc 93b0 2948                 	sts noise_fx_Sxx_pre, r27
0024be 1bac                      	sub r26, r28 //(song speed)-Sxx
0024bf 93a0 2949                 	sts noise_fx_Sxx_post, r26
0024c1 93c0 2916                 	sts noise_pattern_delay_frames, r28
0024c3 11a2                      	cpse r26, zero
0024c4 c01c                      	rjmp sound_driver_calculate_delays_dpcm
0024c5 c012                      	rjmp sound_driver_calculate_delays_noise_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
0024c6 93b0 2949                 	sts noise_fx_Sxx_post, r27
0024c8 2fad                      	mov r26, r29
0024c9 c015                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
0024ca 93b0 2945                 	sts noise_fx_Gxx_pre, r27
0024cc 1bac                      	sub r26, r28 //(song speed)-Gxx
0024cd 93a0 2946                 	sts noise_fx_Gxx_post, r26
0024cf 93c0 2916                 	sts noise_pattern_delay_frames, r28
0024d1 11a2                      	cpse r26, zero
0024d2 c00e                      	rjmp sound_driver_calculate_delays_dpcm
0024d3 c004                      	rjmp sound_driver_calculate_delays_noise_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
0024d4 93b0 2946                 	sts noise_fx_Gxx_post, r27
0024d6 2fad                      	mov r26, r29
0024d7 c007                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Sxx_Gxx_invalid:
0024d8 9220 2916                 	sts noise_pattern_delay_frames, zero
0024da 940e 2121                 	call sound_driver_channel3_main
0024dc 91f0 2821                 	lds r31, song_speed
0024de cfba                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_noise_store:
0024df 93a0 2916                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
0024e1 91a0 294d                 	lds r26, dpcm_pattern_delay_frames
0024e3 11a2                      	cpse r26, zero
0024e4 c044                      	rjmp sound_driver_instrument_fx_routine
0024e5 c000                      	rjmp sound_driver_calculate_delays_dpcm_main
                                 
                                 sound_driver_calculate_delays_dpcm_main:
0024e6 2faf                      	mov r26, r31 //move the speed to r26
0024e7 91b0 294c                 	lds r27, dpcm_pattern_delay_rows //decrement the delay rows
0024e9 15b2                      	cp r27, zero
0024ea f409                      	brne PC+2
0024eb c03d                      	rjmp sound_driver_instrument_fx_routine
0024ec 95ba                      	dec r27
0024ed 93b0 294c                 	sts dpcm_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx:
0024ef efbf                      	ldi r27, 0xFF
0024f0 91c0 2956                 	lds r28, dpcm_fx_Sxx_pre
0024f2 91d0 2957                 	lds r29, dpcm_fx_Sxx_post
                                 sound_driver_calculate_delays_dpcm_Sxx_check_pre:
0024f4 17cb                      	cp r28, r27
0024f5 f009                      	breq sound_driver_calculate_delays_dpcm_Sxx_check_post
0024f6 c00d                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_pre
                                 sound_driver_calculate_delays_dpcm_Sxx_check_post:
0024f7 17db                      	cp r29, r27
0024f8 f009                      	breq sound_driver_calculate_delays_dpcm_Gxx
0024f9 c014                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx:
0024fa 91c0 2954                 	lds r28, dpcm_fx_Gxx_pre
0024fc 91d0 2955                 	lds r29, dpcm_fx_Gxx_post
                                 sound_driver_calculate_delays_dpcm_Gxx_check_pre:
0024fe 17cb                      	cp r28, r27
0024ff f009                      	breq sound_driver_calculate_delays_dpcm_Gxx_check_post
002500 c011                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_pre
                                 sound_driver_calculate_delays_dpcm_Gxx_check_post:
002501 17db                      	cp r29, r27
002502 f121                      	breq sound_driver_calculate_delays_dpcm_store
002503 c018                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_pre:
002504 93b0 2956                 	sts dpcm_fx_Sxx_pre, r27
002506 1bac                      	sub r26, r28 //(song speed)-Sxx
002507 93a0 2957                 	sts dpcm_fx_Sxx_post, r26
002509 93c0 294d                 	sts dpcm_pattern_delay_frames, r28
00250b 11a2                      	cpse r26, zero
00250c c01c                      	rjmp sound_driver_instrument_fx_routine
00250d c012                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_post:
00250e 93b0 2957                 	sts dpcm_fx_Sxx_post, r27
002510 2fad                      	mov r26, r29
002511 c015                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx_pre:
002512 93b0 2954                 	sts dpcm_fx_Gxx_pre, r27
002514 1bac                      	sub r26, r28 //(song speed)-Gxx
002515 93a0 2955                 	sts dpcm_fx_Gxx_post, r26
002517 93c0 294d                 	sts dpcm_pattern_delay_frames, r28
002519 11a2                      	cpse r26, zero
00251a c00e                      	rjmp sound_driver_instrument_fx_routine
00251b c004                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_dpcm_Gxx_post:
00251c 93b0 2955                 	sts dpcm_fx_Gxx_post, r27
00251e 2fad                      	mov r26, r29
00251f c007                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid:
002520 9220 294d                 	sts dpcm_pattern_delay_frames, zero
002522 940e 22f3                 	call sound_driver_channel4_main
002524 91f0 2821                 	lds r31, song_speed
002526 cfba                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_dpcm_store:
002527 93a0 294d                 	sts dpcm_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002529 91e0 282b                 	lds ZL, pulse1_volume_macro
00252b 91f0 282c                 	lds ZH, pulse1_volume_macro+1
00252d 9630                      	adiw Z, 0
00252e f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
00252f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002530 1fff                      	rol ZH
002531 91a0 282d                 	lds r26, pulse1_volume_macro_offset
002533 0fea                      	add ZL, r26
002534 1df2                      	adc ZH, zero
                                 
002535 91b0 282f                 	lds r27, pulse1_volume_macro_release
002537 17ba                      	cp r27, r26
002538 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
002539 91a0 282e                 	lds r26, pulse1_volume_macro_loop
00253b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00253c f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00253d c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
00253e 95a3                      	inc r26 //increment the macro offset
00253f 93a0 282d                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
002541 91b4                      	lpm r27, Z //load volume data into r27
002542 3fbf                      	cpi r27, 0xFF //check for macro end flag
002543 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
002544 91b0 282f                 	lds r27, pulse1_volume_macro_release
002546 3fbf                      	cpi r27, 0xFF
002547 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
002548 91b0 282e                 	lds r27, pulse1_volume_macro_loop //load the loop index
00254a 93b0 282d                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00254c cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
00254d 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00254e 93a0 282d                 	sts pulse1_volume_macro_offset, r26
002550 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
002551 ebec                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002552 e6f2                      	ldi ZH, HIGH(volumes << 1)
002553 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002554 0feb                      	add ZL, r27 //add offset to the table
002555 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
002556 91b0 2800                 	lds r27, pulse1_param //load main volume
002558 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002559 91a0 2860                 	lds r26, pulse1_fx_7xy_value
00255b 30a0                      	cpi r26, 0x00
00255c f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
00255d 0feb                      	add ZL, r27 //offset the volume table by the main volume
00255e 1df2                      	adc ZH, zero
00255f 91b4                      	lpm r27, Z
002560 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002562 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002563 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002565 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002566 91a0 2860                 	lds r26, pulse1_fx_7xy_value
002568 30a0                      	cpi r26, 0x00
002569 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
00256a 93b0 2806                 	sts pulse1_output_volume, r27
00256c c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
00256d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00256e f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00256f f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
002570 0feb                      	add ZL, r27 //offset the volume table by the main volume
002571 1df2                      	adc ZH, zero
002572 91b4                      	lpm r27, Z
002573 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002575 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002576 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002577 0feb                      	add ZL, r27 //offset the volume table by the main volume
002578 1df2                      	adc ZH, zero
002579 91b4                      	lpm r27, Z
00257a 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00257c c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
00257d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00257e f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
00257f f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002580 93b0 2806                 	sts pulse1_output_volume, r27
002582 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002583 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002584 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002586 91e0 2830                 	lds ZL, pulse1_arpeggio_macro
002588 91f0 2831                 	lds ZH, pulse1_arpeggio_macro+1
00258a 9630                      	adiw Z, 0
00258b f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00258c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00258d 1fff                      	rol ZH
00258e 91a0 2832                 	lds r26, pulse1_arpeggio_macro_offset
002590 0fea                      	add ZL, r26
002591 1df2                      	adc ZH, zero
                                 
002592 91b0 2834                 	lds r27, pulse1_arpeggio_macro_release
002594 17ba                      	cp r27, r26
002595 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002596 91a0 2833                 	lds r26, pulse1_arpeggio_macro_loop
002598 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002599 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00259a c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00259b 95a3                      	inc r26 //increment the macro offset
00259c 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00259e 91b4                      	lpm r27, Z //load arpeggio data into r27
00259f 38b0                      	cpi r27, 0x80 //check for macro end flag
0025a0 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
0025a1 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0025a2 50a1                      	subi r26, 1 //keep the offset at the end flag
0025a3 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26
0025a5 91b0 2835                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0025a7 30b1                      	cpi r27, 0x01
0025a8 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0025a9 91b0 2834                 	lds r27, pulse1_arpeggio_macro_release
0025ab 3fbf                      	cpi r27, 0xFF
0025ac f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0025ad 91b0 2833                 	lds r27, pulse1_arpeggio_macro_loop
0025af 3fbf                      	cpi r27, 0xFF
0025b0 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0025b1 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0025b2 91b0 2834                 	lds r27, pulse1_arpeggio_macro_release
0025b4 3fbf                      	cpi r27, 0xFF
0025b5 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0025b6 91b0 2833                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0025b8 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0025b9 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0025ba 91c0 2848                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0025bc 91d0 2849                 	lds r29, pulse1_fx_0xy_sequence+1
0025be 9620                      	adiw r29:r28, 0
0025bf f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0025c0 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0025c1 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0025c3 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0025c4 93b0 2832                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0025c6 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0025c7 91c0 2848                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0025c9 91d0 2849                 	lds r29, pulse1_fx_0xy_sequence+1
0025cb 9620                      	adiw r29:r28, 0 //check for 0xy effect
0025cc f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
0025cd 95d6                      	lsr r29
0025ce 95c7                      	ror r28
0025cf 95d7                      	ror r29
0025d0 95c7                      	ror r28
0025d1 95d7                      	ror r29
0025d2 95c7                      	ror r28
0025d3 95d7                      	ror r29
0025d4 95c7                      	ror r28
0025d5 95d7                      	ror r29
0025d6 95d2                      	swap r29
                                 
0025d7 93c0 2848                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0025d9 93d0 2849                 	sts pulse1_fx_0xy_sequence+1, r29
0025db 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0025dc 91a0 2807                 	lds r26, pulse1_note //load the current note index
0025de 0fac                      	add r26, r28 //add the note offset
0025df c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0025e0 91a0 2807                 	lds r26, pulse1_note //load the current note index
0025e2 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0025e3 9220 2836                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0025e5 9220 2837                 	sts pulse1_total_pitch_offset+1, zero
0025e7 9220 283d                 	sts pulse1_total_hi_pitch_offset, zero
0025e9 91a0 2835                 	lds r26, pulse1_arpeggio_macro_mode
0025eb 30a1                      	cpi r26, 0x01 //absolute mode
0025ec f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0025ed f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0025ee c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0025ef 91a0 2807                 	lds r26, pulse1_note //load the current note index
0025f1 0fab                      	add r26, r27 //offset the note with the arpeggio data
0025f2 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0025f3 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0025f4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0025f5 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0025f6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0025f7 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0025f8 fda7                      	sbrc r26, 7 //check if result is negative
0025f9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0025fa c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0025fb 2fab                      	mov r26, r27 //move the arpeggio data into r26
0025fc c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0025fd 91a0 2807                 	lds r26, pulse1_note //load the current note index
0025ff 0fab                      	add r26, r27 //offset the note with the arpeggio data
002600 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002601 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002602 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002604 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002605 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002606 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002607 93a0 2807                 	sts pulse1_note, r26
002609 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
00260a fda7                      	sbrc r26, 7 //check if result is negative
00260b e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00260c 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
00260e e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00260f e0f0                      	ldi ZH, HIGH(note_table << 1)
002610 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002611 0fea                      	add ZL, r26 //add offset
002612 1df2                      	adc ZH, zero
002613 91a5                      	lpm r26, Z+ //load bytes
002614 91b4                      	lpm r27, Z
002615 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002617 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002619 93a0 2854                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00261b 93b0 2855                 	sts pulse1_fx_3xx_target+1, r27
00261d c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
00261e 91e0 2838                 	lds ZL, pulse1_pitch_macro
002620 91f0 2839                 	lds ZH, pulse1_pitch_macro+1
002622 9630                      	adiw Z, 0
002623 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002624 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002625 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002626 1fff                      	rol ZH
002627 91a0 283a                 	lds r26, pulse1_pitch_macro_offset
002629 0fea                      	add ZL, r26
00262a 1df2                      	adc ZH, zero
                                 
00262b 91b0 283c                 	lds r27, pulse1_pitch_macro_release
00262d 17ba                      	cp r27, r26
00262e f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
00262f 91a0 283b                 	lds r26, pulse1_pitch_macro_loop
002631 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002632 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002633 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
002634 95a3                      	inc r26 //increment the macro offset
002635 93a0 283a                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
002637 91b4                      	lpm r27, Z //load pitch data into r27
002638 38b0                      	cpi r27, 0x80 //check for macro end flag
002639 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
00263a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00263b 93a0 283a                 	sts pulse1_pitch_macro_offset, r26
00263d 91b0 283c                 	lds r27, pulse1_pitch_macro_release
00263f 3fbf                      	cpi r27, 0xFF
002640 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
002641 91b0 283b                 	lds r27, pulse1_pitch_macro_loop //load the loop index
002643 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002644 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002645 93b0 283a                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
002647 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002648 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002649 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00264a 937f                      	push r23
00264b 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00264c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00264d 0367                      	mulsu r22, r23
00264e 917f                      	pop r23
00264f 916f                      	pop r22
                                 
002650 9416                      	lsr r1 //shift out the fractional bits
002651 9407                      	ror r0
002652 9416                      	lsr r1
002653 9407                      	ror r0
002654 9416                      	lsr r1
002655 9407                      	ror r0
002656 9416                      	lsr r1
002657 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
002658 fe13                      	sbrs r1, 3 //check if result was a negative number
002659 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
00265a efc0                      	ldi r28, 0xF0
00265b 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
00265c 70b7                      	andi r27, 0b00000111
00265d f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
00265e e0b1                      	ldi r27, 0x01
00265f 0e0b                      	add r0, r27
002660 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002661 91a0 2836                 	lds r26, pulse1_total_pitch_offset
002663 91b0 2837                 	lds r27, pulse1_total_pitch_offset+1
002665 0e0a                      	add r0, r26
002666 1e1b                      	adc r1, r27
002667 9200 2836                 	sts pulse1_total_pitch_offset, r0
002669 9210 2837                 	sts pulse1_total_pitch_offset+1, r1
00266b 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00266d 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00266f 0da0                      	add r26, r0 //offset the timer values
002670 1db1                      	adc r27, r1
                                 	
002671 91c0 284c                 	lds r28, pulse1_fx_1xx_total
002673 91d0 284d                 	lds r29, pulse1_fx_1xx_total+1
002675 1bac                      	sub r26, r28
002676 0bbd                      	sbc r27, r29
002677 91c0 2850                 	lds r28, pulse1_fx_2xx_total
002679 91d0 2851                 	lds r29, pulse1_fx_2xx_total+1
00267b 0fac                      	add r26, r28
00267c 1fbd                      	adc r27, r29
00267d 91c0 2864                 	lds r28, pulse1_fx_Pxx_total
00267f 91d0 2865                 	lds r29, pulse1_fx_Pxx_total+1
002681 0fac                      	add r26, r28
002682 1fbd                      	adc r27, r29
002683 91c0 286b                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002685 91d0 286c                 	lds r29, pulse1_fx_Qxy_total_offset+1
002687 1bac                      	sub r26, r28
002688 0bbd                      	sbc r27, r29
002689 91c0 2872                 	lds r28, pulse1_fx_Rxy_total_offset
00268b 91d0 2873                 	lds r29, pulse1_fx_Rxy_total_offset+1
00268d 0fac                      	add r26, r28
00268e 1fbd                      	adc r27, r29
                                 
00268f e5c9                      	ldi r28, 0x59
002690 e0d0                      	ldi r29, 0x00
002691 17ac                      	cp r26, r28
002692 07bd                      	cpc r27, r29
002693 f030                      	brlo sound_driver_instrument_routine_channel0_pitch_min
                                 
002694 e5ca                      	ldi r28, 0x5A
002695 e5d9                      	ldi r29, 0x59
002696 17ac                      	cp r26, r28
002697 07bd                      	cpc r27, r29
002698 f420                      	brsh sound_driver_instrument_routine_channel0_pitch_max
002699 c006                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_min:
00269a e5c9                      	ldi r28, 0x59
00269b e0d0                      	ldi r29, 0x00
00269c c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_max:
00269d e5c9                      	ldi r28, 0x59
00269e e5d9                      	ldi r29, 0x59
00269f c000                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_store:
0026a0 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0026a2 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
0026a4 91e0 283e                 	lds ZL, pulse1_hi_pitch_macro
0026a6 91f0 283f                 	lds ZH, pulse1_hi_pitch_macro+1
0026a8 9630                      	adiw Z, 0
0026a9 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
0026aa c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
0026ab 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0026ac 1fff                      	rol ZH
0026ad 91a0 2840                 	lds r26, pulse1_hi_pitch_macro_offset
0026af 0fea                      	add ZL, r26
0026b0 1df2                      	adc ZH, zero
                                 
0026b1 91b0 2842                 	lds r27, pulse1_hi_pitch_macro_release
0026b3 17ba                      	cp r27, r26
0026b4 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0026b5 91a0 2841                 	lds r26, pulse1_hi_pitch_macro_loop
0026b7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026b8 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026b9 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
0026ba 95a3                      	inc r26 //increment the macro offset
0026bb 93a0 2840                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
0026bd 91b4                      	lpm r27, Z //load hi pitch data into r27
0026be 38b0                      	cpi r27, 0x80 //check for macro end flag
0026bf f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
0026c0 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0026c1 93a0 2840                 	sts pulse1_hi_pitch_macro_offset, r26
0026c3 91b0 2842                 	lds r27, pulse1_hi_pitch_macro_release
0026c5 3fbf                      	cpi r27, 0xFF
0026c6 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
0026c7 91b0 2841                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0026c9 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0026ca f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0026cb 93b0 2840                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0026cd cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0026ce 91b0 283d                 	lds r27, pulse1_total_hi_pitch_offset
0026d0 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0026d1 91a0 283d                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0026d3 0fba                      	add r27, r26
0026d4 93b0 283d                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0026d6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026d7 937f                      	push r23
0026d8 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0026d9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026da 0367                      	mulsu r22, r23
0026db 917f                      	pop r23
0026dc 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0026dd 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0026df 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0026e1 0da0                      	add r26, r0 //offset the timer values
0026e2 1db1                      	adc r27, r1
0026e3 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0026e5 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0026e7 91e0 2843                 	lds ZL, pulse1_duty_macro
0026e9 91f0 2844                 	lds ZH, pulse1_duty_macro+1
0026eb 9630                      	adiw Z, 0
0026ec f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0026ed 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0026ee 1fff                      	rol ZH
0026ef 91a0 2845                 	lds r26, pulse1_duty_macro_offset
0026f1 0fea                      	add ZL, r26
0026f2 1df2                      	adc ZH, zero
                                 
0026f3 91b0 2847                 	lds r27, pulse1_duty_macro_release
0026f5 17ba                      	cp r27, r26
0026f6 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0026f7 91a0 2846                 	lds r26, pulse1_duty_macro_loop
0026f9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026fa f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026fb c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0026fc 95a3                      	inc r26 //increment the macro offset
0026fd 93a0 2845                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0026ff 91b4                      	lpm r27, Z //load pitch data into r27
002700 3fbf                      	cpi r27, 0xFF //check for macro end flag
002701 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
002702 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002703 93a0 2845                 	sts pulse1_duty_macro_offset, r26
002705 91b0 2847                 	lds r27, pulse1_duty_macro_release
002707 3fbf                      	cpi r27, 0xFF
002708 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
002709 91b0 2846                 	lds r27, pulse1_duty_macro_loop //load the loop index
00270b 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00270c f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00270d 93b0 2845                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
00270f cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
002710 ebe4                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002711 e6f1                      	ldi ZH, HIGH(sequences << 1)
002712 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002713 1df2                      	adc ZH, zero
                                 
002714 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
002715 95b7                      	ror r27
002716 95b7                      	ror r27
002717 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
002719 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
00271a 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00271b 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
00271c c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
00271d c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
00271e 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
00271f 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002720 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002721 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
002723 91e0 284a                 	lds ZL, pulse1_fx_1xx
002725 91f0 284b                 	lds ZH, pulse1_fx_1xx+1
002727 9630                      	adiw Z, 0
002728 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
002729 91a0 284c                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
00272b 91b0 284d                 	lds r27, pulse1_fx_1xx_total+1
00272d 0fae                      	add r26, ZL //increase the total offset by the rate
00272e 1fbf                      	adc r27, ZH
00272f 93a0 284c                 	sts pulse1_fx_1xx_total, r26
002731 93b0 284d                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
002733 91e0 284e                 	lds ZL, pulse1_fx_2xx
002735 91f0 284f                 	lds ZH, pulse1_fx_2xx+1
002737 9630                      	adiw Z, 0
002738 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
002739 91a0 2850                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
00273b 91b0 2851                 	lds r27, pulse1_fx_2xx_total+1
00273d 0fae                      	add r26, ZL //increase the total offset by the rate
00273e 1fbf                      	adc r27, ZH
00273f 93a0 2850                 	sts pulse1_fx_2xx_total, r26
002741 93b0 2851                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
002743 91e0 2856                 	lds ZL, pulse1_fx_3xx_speed
002745 91f0 2857                 	lds ZH, pulse1_fx_3xx_speed+1
002747 9630                      	adiw Z, 0
002748 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
002749 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
00274a 91a0 2852                 	lds r26, pulse1_fx_3xx_start
00274c 91b0 2853                 	lds r27, pulse1_fx_3xx_start+1
00274e 9610                      	adiw r26:r27, 0
00274f f409                      	brne sound_driver_channel0_fx_3xx_routine_main
002750 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
002751 91c0 2854                 	lds r28, pulse1_fx_3xx_target
002753 91d0 2855                 	lds r29, pulse1_fx_3xx_target+1
                                 
002755 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002756 07bd                      	cpc r27, r29
002757 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
002758 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002759 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
00275a 9220 2852                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00275c 9220 2853                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
00275e c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
00275f 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002760 0bdb                      	sbc r29, r27
002761 91a0 2858                 	lds r26, pulse1_fx_3xx_total_offset
002763 91b0 2859                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
002765 0fae                      	add r26, ZL //add the speed to the total offset
002766 1fbf                      	adc r27, ZH
002767 1bca                      	sub r28, r26 //invert the total difference with the total offset
002768 0bdb                      	sbc r29, r27
002769 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00276a 93a0 2858                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
00276c 93b0 2859                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
00276e 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
002770 91b0 0a8d                 	lds r27, TCB0_CCMPH
002772 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002773 0bbd                      	sbc r27, r29
002774 93a0 0a8c                 	sts TCB0_CCMPL, r26
002776 93b0 0a8d                 	sts TCB0_CCMPH, r27
002778 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
002779 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00277a 0bbd                      	sbc r27, r29
00277b 91c0 2858                 	lds r28, pulse1_fx_3xx_total_offset
00277d 91d0 2859                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
00277f 0fce                      	add r28, ZL //add the speed to the total offset
002780 1fdf                      	adc r29, ZH
002781 1bac                      	sub r26, r28 //invert the total difference with the total offset
002782 0bbd                      	sbc r27, r29
002783 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002784 93c0 2858                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
002786 93d0 2859                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
002788 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
00278a 91d0 0a8d                 	lds r29, TCB0_CCMPH
00278c 0fca                      	add r28, r26 //offset the current timer period with the total offset
00278d 1fdb                      	adc r29, r27
00278e 93c0 0a8c                 	sts TCB0_CCMPL, r28
002790 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
002792 91a0 285a                 	lds r26, pulse1_fx_4xy_speed
002794 15a2                      	cp r26, zero
002795 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
002796 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
002797 91b0 285b                 	lds r27, pulse1_fx_4xy_depth
002799 91c0 285c                 	lds r28, pulse1_fx_4xy_phase
00279b 0fca                      	add r28, r26 //increase the phase by the speed
00279c 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00279d f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00279e e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
00279f 93c0 285c                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
0027a1 31c0                      	cpi r28, 16
0027a2 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
0027a3 32c0                      	cpi r28, 32
0027a4 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
0027a5 33c0                      	cpi r28, 48
0027a6 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
0027a7 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
0027a8 70cf                      	andi r28, 0x0F //mask for values 0-15
0027a9 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
0027aa 6fc0                      	ori r28, 0xF0
0027ab 95c0                      	com r28 //invert values 0-15
0027ac c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
0027ad 70cf                      	andi r28, 0x0F //mask for values 0-15
0027ae c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
0027af 6fc0                      	ori r28, 0xF0
0027b0 95c0                      	com r28 //invert values 0-15
0027b1 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
0027b2 95b2                      	swap r27 //multiply depth by 16
0027b3 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0027b4 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0027b5 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0027b6 0fec                      	add ZL, r28 //offset the table by the depth+phase
0027b7 1df2                      	adc ZH, zero
0027b8 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0027b9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0027ba 937f                      	push r23
0027bb 2f6c                      	mov r22, r28 //store the vibrato value into r22
0027bc eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0027bd 9f67                      	mul r22, r23
0027be 917f                      	pop r23
0027bf 916f                      	pop r22
                                 
0027c0 9416                      	lsr r1 //shift out the fractional bits
0027c1 9407                      	ror r0
0027c2 9416                      	lsr r1
0027c3 9407                      	ror r0
0027c4 9416                      	lsr r1
0027c5 9407                      	ror r0
0027c6 9416                      	lsr r1
0027c7 9407                      	ror r0
                                 	
0027c8 91a0 0a8c                 	lds r26, TCB0_CCMPL
0027ca 91b0 0a8d                 	lds r27, TCB0_CCMPH
0027cc 0da0                      	add r26, r0
0027cd 1db1                      	adc r27, r1
0027ce 93a0 0a8c                 	sts TCB0_CCMPL, r26
0027d0 93b0 0a8d                 	sts TCB0_CCMPH, r27
0027d2 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
0027d3 95b2                      	swap r27 //multiply depth by 16
0027d4 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0027d5 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0027d6 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0027d7 0fec                      	add ZL, r28 //offset the table by the depth+phase
0027d8 1df2                      	adc ZH, zero
0027d9 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0027da 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0027db 937f                      	push r23
0027dc 2f6c                      	mov r22, r28 //store the vibrato value into r22
0027dd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0027de 9f67                      	mul r22, r23
0027df 917f                      	pop r23
0027e0 916f                      	pop r22
                                 
0027e1 9416                      	lsr r1 //shift out the fractional bits
0027e2 9407                      	ror r0
0027e3 9416                      	lsr r1
0027e4 9407                      	ror r0
0027e5 9416                      	lsr r1
0027e6 9407                      	ror r0
0027e7 9416                      	lsr r1
0027e8 9407                      	ror r0
                                 
0027e9 91a0 0a8c                 	lds r26, TCB0_CCMPL
0027eb 91b0 0a8d                 	lds r27, TCB0_CCMPH
0027ed 19a0                      	sub r26, r0
0027ee 09b1                      	sbc r27, r1
0027ef 93a0 0a8c                 	sts TCB0_CCMPL, r26
0027f1 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0027f3 91a0 285d                 	lds r26, pulse1_fx_7xy_speed
0027f5 15a2                      	cp r26, zero
0027f6 f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0027f7 91b0 285e                 	lds r27, pulse1_fx_7xy_depth
0027f9 91c0 285f                 	lds r28, pulse1_fx_7xy_phase
0027fb 0fca                      	add r28, r26 //increase the phase by the speed
0027fc 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0027fd f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0027fe e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0027ff 93c0 285f                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
002801 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002802 ffc4                      	sbrs r28, 4
002803 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
002804 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
002805 70cf                      	andi r28, 0x0F //mask for values 0-15
002806 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
002807 6fc0                      	ori r28, 0xF0
002808 95c0                      	com r28 //invert values 0-15
002809 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
00280a 95b2                      	swap r27 //multiply depth by 16
00280b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00280c e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00280d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00280e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00280f 1df2                      	adc ZH, zero
002810 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002811 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002812 93c0 2860                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
002814 91b0 2861                 	lds r27, pulse1_fx_Axy
002816 15b2                      	cp r27, zero
002817 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002818 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
00281a 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
00281c 2fda                      	mov r29, r26 //copy fractional volume into r29
00281d 2fec                      	mov r30, r28 //copy the pulse1_param into r30
00281e 95e2                      	swap r30
00281f 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002820 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002821 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002822 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
002823 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
002824 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002825 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
002826 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002827 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002828 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002829 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
00282a 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00282b f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00282c e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
00282d 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
00282f 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002830 95a2                      	swap r26
002831 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002832 2bca                      	or r28, r26 //store the new volume back into pulse1_param
002833 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
002835 91e0 2867                 	lds ZL, pulse1_fx_Qxy_target
002837 91f0 2868                 	lds ZH, pulse1_fx_Qxy_target+1
002839 9630                      	adiw Z, 0
00283a f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00283b 91a0 286b                 	lds r26, pulse1_fx_Qxy_total_offset
00283d 91b0 286c                 	lds r27, pulse1_fx_Qxy_total_offset+1
00283f 91c0 0a8c                 	lds r28, TCB0_CCMPL
002841 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002843 1bec                      	sub ZL, r28 //calculate the difference to the target
002844 0bfd                      	sbc ZH, r29
002845 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
002846 f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
002847 9220 286b                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
002849 9220 286c                 	sts pulse1_fx_Qxy_total_offset+1, zero
00284b 9220 2867                 	sts pulse1_fx_Qxy_target, zero
00284d 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
00284f 91b0 2866                 	lds r27, pulse1_fx_Qxy_target_note
002851 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
002853 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
002854 91c0 2869                 	lds r28, pulse1_fx_Qxy_speed
002856 91d0 286a                 	lds r29, pulse1_fx_Qxy_speed+1
002858 0fac                      	add r26, r28 //increase the total offset by the speed
002859 1fbd                      	adc r27, r29
00285a 93a0 286b                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
00285c 93b0 286c                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
00285e 91e0 286e                 	lds ZL, pulse1_fx_Rxy_target
002860 91f0 286f                 	lds ZH, pulse1_fx_Rxy_target+1
002862 9630                      	adiw Z, 0
002863 f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
002864 91a0 2872                 	lds r26, pulse1_fx_Rxy_total_offset
002866 91b0 2873                 	lds r27, pulse1_fx_Rxy_total_offset+1
002868 91c0 0a8c                 	lds r28, TCB0_CCMPL
00286a 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
00286c 1bce                      	sub r28, ZL //calculate the difference to the target
00286d 0bdf                      	sbc r29, ZH
00286e f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
00286f f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
002870 9220 2872                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
002872 9220 2873                 	sts pulse1_fx_Rxy_total_offset+1, zero
002874 9220 286e                 	sts pulse1_fx_Rxy_target, zero
002876 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
002878 91b0 286d                 	lds r27, pulse1_fx_Rxy_target_note
00287a 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
00287c c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
00287d 91c0 2870                 	lds r28, pulse1_fx_Rxy_speed
00287f 91d0 2871                 	lds r29, pulse1_fx_Rxy_speed+1
002881 0fac                      	add r26, r28 //increase the total offset by the speed
002882 1fbd                      	adc r27, r29
002883 93a0 2872                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
002885 93b0 2873                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
002887 91e0 287c                 	lds ZL, pulse2_volume_macro
002889 91f0 287d                 	lds ZH, pulse2_volume_macro+1
00288b 9630                      	adiw Z, 0
00288c f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
00288d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00288e 1fff                      	rol ZH
00288f 91a0 287e                 	lds r26, pulse2_volume_macro_offset
002891 0fea                      	add ZL, r26
002892 1df2                      	adc ZH, zero
                                 
002893 91b0 2880                 	lds r27, pulse2_volume_macro_release
002895 17ba                      	cp r27, r26
002896 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
002897 91a0 287f                 	lds r26, pulse2_volume_macro_loop
002899 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00289a f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00289b c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
00289c 95a3                      	inc r26 //increment the macro offset
00289d 93a0 287e                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
00289f 91b4                      	lpm r27, Z //load volume data into r27
0028a0 3fbf                      	cpi r27, 0xFF //check for macro end flag
0028a1 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
0028a2 91b0 2880                 	lds r27, pulse2_volume_macro_release
0028a4 3fbf                      	cpi r27, 0xFF
0028a5 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
0028a6 91b0 287f                 	lds r27, pulse2_volume_macro_loop //load the loop index
0028a8 93b0 287e                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
0028aa cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
0028ab 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0028ac 93a0 287e                 	sts pulse2_volume_macro_offset, r26
0028ae cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
0028af ebec                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0028b0 e6f2                      	ldi ZH, HIGH(volumes << 1)
0028b1 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0028b2 0feb                      	add ZL, r27 //add offset to the table
0028b3 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
0028b4 91b0 2808                 	lds r27, pulse2_param //load main volume
0028b6 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0028b7 91a0 28b1                 	lds r26, pulse2_fx_7xy_value
0028b9 30a0                      	cpi r26, 0x00
0028ba f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
0028bb 0feb                      	add ZL, r27 //offset the volume table by the main volume
0028bc 1df2                      	adc ZH, zero
0028bd 91b4                      	lpm r27, Z
0028be 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0028c0 c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
0028c1 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0028c3 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0028c4 91a0 28b1                 	lds r26, pulse2_fx_7xy_value
0028c6 30a0                      	cpi r26, 0x00
0028c7 f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
0028c8 93b0 280e                 	sts pulse2_output_volume, r27
0028ca c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
0028cb 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0028cc f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
0028cd f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
0028ce 0feb                      	add ZL, r27 //offset the volume table by the main volume
0028cf 1df2                      	adc ZH, zero
0028d0 91b4                      	lpm r27, Z
0028d1 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0028d3 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
0028d4 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0028d5 0feb                      	add ZL, r27 //offset the volume table by the main volume
0028d6 1df2                      	adc ZH, zero
0028d7 91b4                      	lpm r27, Z
0028d8 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
0028da c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
0028db 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0028dc f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0028dd f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
0028de 93b0 280e                 	sts pulse2_output_volume, r27
0028e0 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
0028e1 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0028e2 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0028e4 91e0 2881                 	lds ZL, pulse2_arpeggio_macro
0028e6 91f0 2882                 	lds ZH, pulse2_arpeggio_macro+1
0028e8 9630                      	adiw Z, 0
0028e9 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0028ea 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0028eb 1fff                      	rol ZH
0028ec 91a0 2883                 	lds r26, pulse2_arpeggio_macro_offset
0028ee 0fea                      	add ZL, r26
0028ef 1df2                      	adc ZH, zero
                                 
0028f0 91b0 2885                 	lds r27, pulse2_arpeggio_macro_release
0028f2 17ba                      	cp r27, r26
0028f3 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0028f4 91a0 2884                 	lds r26, pulse2_arpeggio_macro_loop
0028f6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0028f7 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0028f8 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
0028f9 95a3                      	inc r26 //increment the macro offset
0028fa 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
0028fc 91b4                      	lpm r27, Z //load arpeggio data into r27
0028fd 38b0                      	cpi r27, 0x80 //check for macro end flag
0028fe f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
0028ff c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
002900 50a1                      	subi r26, 1 //keep the offset at the end flag
002901 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26
002903 91b0 2886                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002905 30b1                      	cpi r27, 0x01
002906 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
002907 91b0 2885                 	lds r27, pulse2_arpeggio_macro_release
002909 3fbf                      	cpi r27, 0xFF
00290a f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
00290b 91b0 2884                 	lds r27, pulse2_arpeggio_macro_loop
00290d 3fbf                      	cpi r27, 0xFF
00290e f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00290f c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
002910 91b0 2885                 	lds r27, pulse2_arpeggio_macro_release
002912 3fbf                      	cpi r27, 0xFF
002913 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
002914 91b0 2884                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
002916 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002917 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
002918 91c0 2899                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
00291a 91d0 289a                 	lds r29, pulse2_fx_0xy_sequence+1
00291c 9620                      	adiw r29:r28, 0
00291d f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00291e 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00291f 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
002921 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002922 93b0 2883                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
002924 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
002925 91c0 2899                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
002927 91d0 289a                 	lds r29, pulse2_fx_0xy_sequence+1
002929 9620                      	adiw r29:r28, 0 //check for 0xy effect
00292a f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
00292b 95d6                      	lsr r29
00292c 95c7                      	ror r28
00292d 95d7                      	ror r29
00292e 95c7                      	ror r28
00292f 95d7                      	ror r29
002930 95c7                      	ror r28
002931 95d7                      	ror r29
002932 95c7                      	ror r28
002933 95d7                      	ror r29
002934 95d2                      	swap r29
                                 
002935 93c0 2899                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
002937 93d0 289a                 	sts pulse2_fx_0xy_sequence+1, r29
002939 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00293a 91a0 280f                 	lds r26, pulse2_note //load the current note index
00293c 0fac                      	add r26, r28 //add the note offset
00293d c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00293e 91a0 280f                 	lds r26, pulse2_note //load the current note index
002940 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
002941 9220 2887                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002943 9220 2888                 	sts pulse2_total_pitch_offset+1, zero
002945 9220 288e                 	sts pulse2_total_hi_pitch_offset, zero
002947 91a0 2886                 	lds r26, pulse2_arpeggio_macro_mode
002949 30a1                      	cpi r26, 0x01 //absolute mode
00294a f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
00294b f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
00294c c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
00294d 91a0 280f                 	lds r26, pulse2_note //load the current note index
00294f 0fab                      	add r26, r27 //offset the note with the arpeggio data
002950 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002951 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
002952 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002953 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002954 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002955 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
002956 fda7                      	sbrc r26, 7 //check if result is negative
002957 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002958 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
002959 2fab                      	mov r26, r27 //move the arpeggio data into r26
00295a c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
00295b 91a0 280f                 	lds r26, pulse2_note //load the current note index
00295d 0fab                      	add r26, r27 //offset the note with the arpeggio data
00295e fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00295f c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
002960 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
002962 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002963 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
002964 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002965 93a0 280f                 	sts pulse2_note, r26
002967 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
002968 fda7                      	sbrc r26, 7 //check if result is negative
002969 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00296a 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
00296c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00296d e0f0                      	ldi ZH, HIGH(note_table << 1)
00296e 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00296f 0fea                      	add ZL, r26 //add offset
002970 1df2                      	adc ZH, zero
002971 91a5                      	lpm r26, Z+ //load bytes
002972 91b4                      	lpm r27, Z
002973 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
002975 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
002977 93a0 28a5                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002979 93b0 28a6                 	sts pulse2_fx_3xx_target+1, r27
00297b c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
00297c 91e0 2889                 	lds ZL, pulse2_pitch_macro
00297e 91f0 288a                 	lds ZH, pulse2_pitch_macro+1
002980 9630                      	adiw Z, 0
002981 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
002982 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
002983 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002984 1fff                      	rol ZH
002985 91a0 288b                 	lds r26, pulse2_pitch_macro_offset
002987 0fea                      	add ZL, r26
002988 1df2                      	adc ZH, zero
                                 
002989 91b0 288d                 	lds r27, pulse2_pitch_macro_release
00298b 17ba                      	cp r27, r26
00298c f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
00298d 91a0 288c                 	lds r26, pulse2_pitch_macro_loop
00298f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002990 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002991 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
002992 95a3                      	inc r26 //increment the macro offset
002993 93a0 288b                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
002995 91b4                      	lpm r27, Z //load pitch data into r27
002996 38b0                      	cpi r27, 0x80 //check for macro end flag
002997 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
002998 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002999 93a0 288b                 	sts pulse2_pitch_macro_offset, r26
00299b 91b0 288d                 	lds r27, pulse2_pitch_macro_release
00299d 3fbf                      	cpi r27, 0xFF
00299e f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
00299f 91b0 288c                 	lds r27, pulse2_pitch_macro_loop //load the loop index
0029a1 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0029a2 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0029a3 93b0 288b                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
0029a5 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
0029a6 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
0029a7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0029a8 937f                      	push r23
0029a9 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0029aa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0029ab 0367                      	mulsu r22, r23
0029ac 917f                      	pop r23
0029ad 916f                      	pop r22
                                 
0029ae 9416                      	lsr r1 //shift out the fractional bits
0029af 9407                      	ror r0
0029b0 9416                      	lsr r1
0029b1 9407                      	ror r0
0029b2 9416                      	lsr r1
0029b3 9407                      	ror r0
0029b4 9416                      	lsr r1
0029b5 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
0029b6 fe13                      	sbrs r1, 3 //check if result was a negative number
0029b7 c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
0029b8 efc0                      	ldi r28, 0xF0
0029b9 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
0029ba 70b7                      	andi r27, 0b00000111
0029bb f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
0029bc e0b1                      	ldi r27, 0x01
0029bd 0e0b                      	add r0, r27
0029be 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
0029bf 91a0 2887                 	lds r26, pulse2_total_pitch_offset
0029c1 91b0 2888                 	lds r27, pulse2_total_pitch_offset+1
0029c3 0e0a                      	add r0, r26
0029c4 1e1b                      	adc r1, r27
0029c5 9200 2887                 	sts pulse2_total_pitch_offset, r0
0029c7 9210 2888                 	sts pulse2_total_pitch_offset+1, r1
0029c9 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0029cb 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0029cd 0da0                      	add r26, r0 //offset the timer values
0029ce 1db1                      	adc r27, r1
                                 	
0029cf 91c0 289d                 	lds r28, pulse2_fx_1xx_total
0029d1 91d0 289e                 	lds r29, pulse2_fx_1xx_total+1
0029d3 1bac                      	sub r26, r28
0029d4 0bbd                      	sbc r27, r29
0029d5 91c0 28a1                 	lds r28, pulse2_fx_2xx_total
0029d7 91d0 28a2                 	lds r29, pulse2_fx_2xx_total+1
0029d9 0fac                      	add r26, r28
0029da 1fbd                      	adc r27, r29
0029db 91c0 28b5                 	lds r28, pulse2_fx_Pxx_total
0029dd 91d0 28b6                 	lds r29, pulse2_fx_Pxx_total+1
0029df 0fac                      	add r26, r28
0029e0 1fbd                      	adc r27, r29
0029e1 91c0 28bc                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0029e3 91d0 28bd                 	lds r29, pulse2_fx_Qxy_total_offset+1
0029e5 1bac                      	sub r26, r28
0029e6 0bbd                      	sbc r27, r29
0029e7 91c0 28c3                 	lds r28, pulse2_fx_Rxy_total_offset
0029e9 91d0 28c4                 	lds r29, pulse2_fx_Rxy_total_offset+1
0029eb 0fac                      	add r26, r28
0029ec 1fbd                      	adc r27, r29
                                 
0029ed e5c9                      	ldi r28, 0x59
0029ee e0d0                      	ldi r29, 0x00
0029ef 17ac                      	cp r26, r28
0029f0 07bd                      	cpc r27, r29
0029f1 f030                      	brlo sound_driver_instrument_routine_channel1_pitch_min
                                 
0029f2 e5ca                      	ldi r28, 0x5A
0029f3 e5d9                      	ldi r29, 0x59
0029f4 17ac                      	cp r26, r28
0029f5 07bd                      	cpc r27, r29
0029f6 f420                      	brsh sound_driver_instrument_routine_channel1_pitch_max
0029f7 c006                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_min:
0029f8 e5c9                      	ldi r28, 0x59
0029f9 e0d0                      	ldi r29, 0x00
0029fa c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_max:
0029fb e5c9                      	ldi r28, 0x59
0029fc e5d9                      	ldi r29, 0x59
0029fd c000                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_store:
0029fe 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a00 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002a02 91e0 288f                 	lds ZL, pulse2_hi_pitch_macro
002a04 91f0 2890                 	lds ZH, pulse2_hi_pitch_macro+1
002a06 9630                      	adiw Z, 0
002a07 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002a08 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002a09 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a0a 1fff                      	rol ZH
002a0b 91a0 2891                 	lds r26, pulse2_hi_pitch_macro_offset
002a0d 0fea                      	add ZL, r26
002a0e 1df2                      	adc ZH, zero
                                 
002a0f 91b0 2893                 	lds r27, pulse2_hi_pitch_macro_release
002a11 17ba                      	cp r27, r26
002a12 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a13 91a0 2892                 	lds r26, pulse2_hi_pitch_macro_loop
002a15 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a16 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a17 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002a18 95a3                      	inc r26 //increment the macro offset
002a19 93a0 2891                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002a1b 91b4                      	lpm r27, Z //load hi pitch data into r27
002a1c 38b0                      	cpi r27, 0x80 //check for macro end flag
002a1d f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
002a1e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a1f 93a0 2891                 	sts pulse2_hi_pitch_macro_offset, r26
002a21 91b0 2893                 	lds r27, pulse2_hi_pitch_macro_release
002a23 3fbf                      	cpi r27, 0xFF
002a24 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002a25 91b0 2892                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002a27 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a28 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002a29 93b0 2891                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002a2b cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
002a2c 91b0 288e                 	lds r27, pulse2_total_hi_pitch_offset
002a2e c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
002a2f 91a0 288e                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
002a31 0fba                      	add r27, r26
002a32 93b0 288e                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002a34 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a35 937f                      	push r23
002a36 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002a37 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a38 0367                      	mulsu r22, r23
002a39 917f                      	pop r23
002a3a 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002a3b 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002a3d 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
002a3f 0da0                      	add r26, r0 //offset the timer values
002a40 1db1                      	adc r27, r1
002a41 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002a43 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002a45 91e0 2894                 	lds ZL, pulse2_duty_macro
002a47 91f0 2895                 	lds ZH, pulse2_duty_macro+1
002a49 9630                      	adiw Z, 0
002a4a f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002a4b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a4c 1fff                      	rol ZH
002a4d 91a0 2896                 	lds r26, pulse2_duty_macro_offset
002a4f 0fea                      	add ZL, r26
002a50 1df2                      	adc ZH, zero
                                 
002a51 91b0 2898                 	lds r27, pulse2_duty_macro_release
002a53 17ba                      	cp r27, r26
002a54 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
002a55 91a0 2897                 	lds r26, pulse2_duty_macro_loop
002a57 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a58 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a59 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
002a5a 95a3                      	inc r26 //increment the macro offset
002a5b 93a0 2896                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
002a5d 91b4                      	lpm r27, Z //load pitch data into r27
002a5e 3fbf                      	cpi r27, 0xFF //check for macro end flag
002a5f f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
002a60 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a61 93a0 2896                 	sts pulse2_duty_macro_offset, r26
002a63 91b0 2898                 	lds r27, pulse2_duty_macro_release
002a65 3fbf                      	cpi r27, 0xFF
002a66 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
002a67 91b0 2897                 	lds r27, pulse2_duty_macro_loop //load the loop index
002a69 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a6a f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002a6b 93b0 2896                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
002a6d cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
002a6e ebe4                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
002a6f e6f1                      	ldi ZH, HIGH(sequences << 1)
002a70 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002a71 1df2                      	adc ZH, zero
                                 
002a72 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
002a73 95b7                      	ror r27
002a74 95b7                      	ror r27
002a75 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
002a77 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
002a78 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002a79 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
002a7a c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
002a7b c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
002a7c 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002a7d 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
002a7e 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
002a7f 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
002a81 91e0 289b                 	lds ZL, pulse2_fx_1xx
002a83 91f0 289c                 	lds ZH, pulse2_fx_1xx+1
002a85 9630                      	adiw Z, 0
002a86 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
002a87 91a0 289d                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
002a89 91b0 289e                 	lds r27, pulse2_fx_1xx_total+1
002a8b 0fae                      	add r26, ZL //increase the total offset by the rate
002a8c 1fbf                      	adc r27, ZH
002a8d 93a0 289d                 	sts pulse2_fx_1xx_total, r26
002a8f 93b0 289e                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
002a91 91e0 289f                 	lds ZL, pulse2_fx_2xx
002a93 91f0 28a0                 	lds ZH, pulse2_fx_2xx+1
002a95 9630                      	adiw Z, 0
002a96 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
002a97 91a0 28a1                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
002a99 91b0 28a2                 	lds r27, pulse2_fx_2xx_total+1
002a9b 0fae                      	add r26, ZL //increase the total offset by the rate
002a9c 1fbf                      	adc r27, ZH
002a9d 93a0 28a1                 	sts pulse2_fx_2xx_total, r26
002a9f 93b0 28a2                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
002aa1 91e0 28a7                 	lds ZL, pulse2_fx_3xx_speed
002aa3 91f0 28a8                 	lds ZH, pulse2_fx_3xx_speed+1
002aa5 9630                      	adiw Z, 0
002aa6 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
002aa7 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
002aa8 91a0 28a3                 	lds r26, pulse2_fx_3xx_start
002aaa 91b0 28a4                 	lds r27, pulse2_fx_3xx_start+1
002aac 9610                      	adiw r26:r27, 0
002aad f409                      	brne sound_driver_channel1_fx_3xx_routine_main
002aae c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
002aaf 91c0 28a5                 	lds r28, pulse2_fx_3xx_target
002ab1 91d0 28a6                 	lds r29, pulse2_fx_3xx_target+1
                                 
002ab3 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002ab4 07bd                      	cpc r27, r29
002ab5 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002ab6 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002ab7 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002ab8 9220 28a3                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002aba 9220 28a4                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002abc c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
002abd 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002abe 0bdb                      	sbc r29, r27
002abf 91a0 28a9                 	lds r26, pulse2_fx_3xx_total_offset
002ac1 91b0 28aa                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002ac3 0fae                      	add r26, ZL //add the speed to the total offset
002ac4 1fbf                      	adc r27, ZH
002ac5 1bca                      	sub r28, r26 //invert the total difference with the total offset
002ac6 0bdb                      	sbc r29, r27
002ac7 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002ac8 93a0 28a9                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002aca 93b0 28aa                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
002acc 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
002ace 91b0 0a9d                 	lds r27, TCB1_CCMPH
002ad0 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002ad1 0bbd                      	sbc r27, r29
002ad2 93a0 0a9c                 	sts TCB1_CCMPL, r26
002ad4 93b0 0a9d                 	sts TCB1_CCMPH, r27
002ad6 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002ad7 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002ad8 0bbd                      	sbc r27, r29
002ad9 91c0 28a9                 	lds r28, pulse2_fx_3xx_total_offset
002adb 91d0 28aa                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
002add 0fce                      	add r28, ZL //add the speed to the total offset
002ade 1fdf                      	adc r29, ZH
002adf 1bac                      	sub r26, r28 //invert the total difference with the total offset
002ae0 0bbd                      	sbc r27, r29
002ae1 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002ae2 93c0 28a9                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002ae4 93d0 28aa                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002ae6 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002ae8 91d0 0a9d                 	lds r29, TCB1_CCMPH
002aea 0fca                      	add r28, r26 //offset the current timer period with the total offset
002aeb 1fdb                      	adc r29, r27
002aec 93c0 0a9c                 	sts TCB1_CCMPL, r28
002aee 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
002af0 91a0 28ab                 	lds r26, pulse2_fx_4xy_speed
002af2 15a2                      	cp r26, zero
002af3 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002af4 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002af5 91b0 28ac                 	lds r27, pulse2_fx_4xy_depth
002af7 91c0 28ad                 	lds r28, pulse2_fx_4xy_phase
002af9 0fca                      	add r28, r26 //increase the phase by the speed
002afa 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002afb f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002afc e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
002afd 93c0 28ad                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
002aff 31c0                      	cpi r28, 16
002b00 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
002b01 32c0                      	cpi r28, 32
002b02 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002b03 33c0                      	cpi r28, 48
002b04 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002b05 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002b06 70cf                      	andi r28, 0x0F //mask for values 0-15
002b07 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002b08 6fc0                      	ori r28, 0xF0
002b09 95c0                      	com r28 //invert values 0-15
002b0a c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002b0b 70cf                      	andi r28, 0x0F //mask for values 0-15
002b0c c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
002b0d 6fc0                      	ori r28, 0xF0
002b0e 95c0                      	com r28 //invert values 0-15
002b0f c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
002b10 95b2                      	swap r27 //multiply depth by 16
002b11 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b12 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b13 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b14 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b15 1df2                      	adc ZH, zero
002b16 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002b17 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b18 937f                      	push r23
002b19 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b1a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b1b 9f67                      	mul r22, r23
002b1c 917f                      	pop r23
002b1d 916f                      	pop r22
                                 
002b1e 9416                      	lsr r1 //shift out the fractional bits
002b1f 9407                      	ror r0
002b20 9416                      	lsr r1
002b21 9407                      	ror r0
002b22 9416                      	lsr r1
002b23 9407                      	ror r0
002b24 9416                      	lsr r1
002b25 9407                      	ror r0
                                 	
002b26 91a0 0a9c                 	lds r26, TCB1_CCMPL
002b28 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b2a 0da0                      	add r26, r0
002b2b 1db1                      	adc r27, r1
002b2c 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b2e 93b0 0a9d                 	sts TCB1_CCMPH, r27
002b30 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
002b31 95b2                      	swap r27 //multiply depth by 16
002b32 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002b33 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b34 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b35 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b36 1df2                      	adc ZH, zero
002b37 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002b38 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b39 937f                      	push r23
002b3a 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b3b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b3c 9f67                      	mul r22, r23
002b3d 917f                      	pop r23
002b3e 916f                      	pop r22
                                 
002b3f 9416                      	lsr r1 //shift out the fractional bits
002b40 9407                      	ror r0
002b41 9416                      	lsr r1
002b42 9407                      	ror r0
002b43 9416                      	lsr r1
002b44 9407                      	ror r0
002b45 9416                      	lsr r1
002b46 9407                      	ror r0
                                 
002b47 91a0 0a9c                 	lds r26, TCB1_CCMPL
002b49 91b0 0a9d                 	lds r27, TCB1_CCMPH
002b4b 19a0                      	sub r26, r0
002b4c 09b1                      	sbc r27, r1
002b4d 93a0 0a9c                 	sts TCB1_CCMPL, r26
002b4f 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
002b51 91a0 28ae                 	lds r26, pulse2_fx_7xy_speed
002b53 15a2                      	cp r26, zero
002b54 f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002b55 91b0 28af                 	lds r27, pulse2_fx_7xy_depth
002b57 91c0 28b0                 	lds r28, pulse2_fx_7xy_phase
002b59 0fca                      	add r28, r26 //increase the phase by the speed
002b5a 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002b5b f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002b5c e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
002b5d 93c0 28b0                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
002b5f 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002b60 ffc4                      	sbrs r28, 4
002b61 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
002b62 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
002b63 70cf                      	andi r28, 0x0F //mask for values 0-15
002b64 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
002b65 6fc0                      	ori r28, 0xF0
002b66 95c0                      	com r28 //invert values 0-15
002b67 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
002b68 95b2                      	swap r27 //multiply depth by 16
002b69 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b6a e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b6b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b6c 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b6d 1df2                      	adc ZH, zero
002b6e 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002b6f 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002b70 93c0 28b1                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
002b72 91b0 28b2                 	lds r27, pulse2_fx_Axy
002b74 15b2                      	cp r27, zero
002b75 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002b76 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
002b78 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
002b7a 2fda                      	mov r29, r26 //copy fractional volume into r29
002b7b 2fec                      	mov r30, r28 //copy the pulse2_param into r30
002b7c 95e2                      	swap r30
002b7d 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002b7e 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002b7f 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002b80 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
002b81 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
002b82 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002b83 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
002b84 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002b85 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002b86 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002b87 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
002b88 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002b89 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002b8a e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
002b8b 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
002b8d 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002b8e 95a2                      	swap r26
002b8f 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002b90 2bca                      	or r28, r26 //store the new volume back into pulse2_param
002b91 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
002b93 91e0 28b8                 	lds ZL, pulse2_fx_Qxy_target
002b95 91f0 28b9                 	lds ZH, pulse2_fx_Qxy_target+1
002b97 9630                      	adiw Z, 0
002b98 f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002b99 91a0 28bc                 	lds r26, pulse2_fx_Qxy_total_offset
002b9b 91b0 28bd                 	lds r27, pulse2_fx_Qxy_total_offset+1
002b9d 91c0 0a9c                 	lds r28, TCB1_CCMPL
002b9f 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002ba1 1bec                      	sub ZL, r28 //calculate the difference to the target
002ba2 0bfd                      	sbc ZH, r29
002ba3 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
002ba4 f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
002ba5 9220 28bc                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
002ba7 9220 28bd                 	sts pulse2_fx_Qxy_total_offset+1, zero
002ba9 9220 28b8                 	sts pulse2_fx_Qxy_target, zero
002bab 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
002bad 91b0 28b7                 	lds r27, pulse2_fx_Qxy_target_note
002baf 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002bb1 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002bb2 91c0 28ba                 	lds r28, pulse2_fx_Qxy_speed
002bb4 91d0 28bb                 	lds r29, pulse2_fx_Qxy_speed+1
002bb6 0fac                      	add r26, r28 //increase the total offset by the speed
002bb7 1fbd                      	adc r27, r29
002bb8 93a0 28bc                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002bba 93b0 28bd                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
002bbc 91e0 28bf                 	lds ZL, pulse2_fx_Rxy_target
002bbe 91f0 28c0                 	lds ZH, pulse2_fx_Rxy_target+1
002bc0 9630                      	adiw Z, 0
002bc1 f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002bc2 91a0 28c3                 	lds r26, pulse2_fx_Rxy_total_offset
002bc4 91b0 28c4                 	lds r27, pulse2_fx_Rxy_total_offset+1
002bc6 91c0 0a9c                 	lds r28, TCB1_CCMPL
002bc8 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002bca 1bce                      	sub r28, ZL //calculate the difference to the target
002bcb 0bdf                      	sbc r29, ZH
002bcc f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
002bcd f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
002bce 9220 28c3                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
002bd0 9220 28c4                 	sts pulse2_fx_Rxy_total_offset+1, zero
002bd2 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
002bd4 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
002bd6 91b0 28be                 	lds r27, pulse2_fx_Rxy_target_note
002bd8 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002bda c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002bdb 91c0 28c1                 	lds r28, pulse2_fx_Rxy_speed
002bdd 91d0 28c2                 	lds r29, pulse2_fx_Rxy_speed+1
002bdf 0fac                      	add r26, r28 //increase the total offset by the speed
002be0 1fbd                      	adc r27, r29
002be1 93a0 28c3                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002be3 93b0 28c4                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002be5 91e0 28cd                 	lds ZL, triangle_volume_macro
002be7 91f0 28ce                 	lds ZH, triangle_volume_macro+1
002be9 9630                      	adiw Z, 0
002bea f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002beb 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002bec 1fff                      	rol ZH
002bed 91a0 28cf                 	lds r26, triangle_volume_macro_offset
002bef 0fea                      	add ZL, r26
002bf0 1df2                      	adc ZH, zero
                                 
002bf1 91b0 28d1                 	lds r27, triangle_volume_macro_release
002bf3 17ba                      	cp r27, r26
002bf4 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002bf5 91a0 28d0                 	lds r26, triangle_volume_macro_loop
002bf7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002bf8 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002bf9 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002bfa 95a3                      	inc r26 //increment the macro offset
002bfb 93a0 28cf                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
002bfd 91b4                      	lpm r27, Z //load volume data into r27
002bfe 3fbf                      	cpi r27, 0xFF //check for macro end flag
002bff f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
002c00 91b0 28d1                 	lds r27, triangle_volume_macro_release
002c02 3fbf                      	cpi r27, 0xFF
002c03 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002c04 91b0 28d0                 	lds r27, triangle_volume_macro_loop //load the loop index
002c06 93b0 28cf                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002c08 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002c09 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002c0a 93a0 28cf                 	sts triangle_volume_macro_offset, r26
002c0c cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
002c0d 15b2                      	cp r27, zero
002c0e f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
002c0f 91b0 0aa5                 	lds r27, TCB2_INTCTRL
002c11 30b1                      	cpi r27, TCB_CAPT_bm
002c12 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002c13 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002c14 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002c16 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002c17 9220 0aa5                 	sts TCB2_INTCTRL, zero
002c19 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002c1b 9220 0aad                 	sts TCB2_CCMPH, zero
002c1d c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002c1e 91e0 28d2                 	lds ZL, triangle_arpeggio_macro
002c20 91f0 28d3                 	lds ZH, triangle_arpeggio_macro+1
002c22 9630                      	adiw Z, 0
002c23 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002c24 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c25 1fff                      	rol ZH
002c26 91a0 28d4                 	lds r26, triangle_arpeggio_macro_offset
002c28 0fea                      	add ZL, r26
002c29 1df2                      	adc ZH, zero
                                 
002c2a 91b0 28d6                 	lds r27, triangle_arpeggio_macro_release
002c2c 17ba                      	cp r27, r26
002c2d f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002c2e 91a0 28d5                 	lds r26, triangle_arpeggio_macro_loop
002c30 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c31 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002c32 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002c33 95a3                      	inc r26 //increment the macro offset
002c34 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002c36 91b4                      	lpm r27, Z //load arpeggio data into r27
002c37 38b0                      	cpi r27, 0x80 //check for macro end flag
002c38 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002c39 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002c3a 50a1                      	subi r26, 1 //keep the offset at the end flag
002c3b 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26
002c3d 91b0 28d7                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002c3f 30b1                      	cpi r27, 0x01
002c40 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
002c41 91b0 28d6                 	lds r27, triangle_arpeggio_macro_release
002c43 3fbf                      	cpi r27, 0xFF
002c44 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002c45 91b0 28d5                 	lds r27, triangle_arpeggio_macro_loop
002c47 3fbf                      	cpi r27, 0xFF
002c48 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002c49 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002c4a 91b0 28d6                 	lds r27, triangle_arpeggio_macro_release
002c4c 3fbf                      	cpi r27, 0xFF
002c4d f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
002c4e 91b0 28d5                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
002c50 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002c51 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
002c52 91c0 28ea                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
002c54 91d0 28eb                 	lds r29, triangle_fx_0xy_sequence+1
002c56 9620                      	adiw r29:r28, 0
002c57 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002c58 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002c59 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
002c5b cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
002c5c 93b0 28d4                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
002c5e cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
002c5f 91c0 28ea                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
002c61 91d0 28eb                 	lds r29, triangle_fx_0xy_sequence+1
002c63 9620                      	adiw r29:r28, 0 //check for 0xy effect
002c64 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
002c65 95d6                      	lsr r29
002c66 95c7                      	ror r28
002c67 95d7                      	ror r29
002c68 95c7                      	ror r28
002c69 95d7                      	ror r29
002c6a 95c7                      	ror r28
002c6b 95d7                      	ror r29
002c6c 95c7                      	ror r28
002c6d 95d7                      	ror r29
002c6e 95d2                      	swap r29
                                 
002c6f 93c0 28ea                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
002c71 93d0 28eb                 	sts triangle_fx_0xy_sequence+1, r29
002c73 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002c74 91a0 2812                 	lds r26, triangle_note //load the current note index
002c76 0fac                      	add r26, r28 //add the note offset
002c77 c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002c78 91a0 2812                 	lds r26, triangle_note //load the current note index
002c7a c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
002c7b 9220 28d8                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002c7d 9220 28d9                 	sts triangle_total_pitch_offset+1, zero
002c7f 9220 28df                 	sts triangle_total_hi_pitch_offset, zero
002c81 91a0 28d7                 	lds r26, triangle_arpeggio_macro_mode
002c83 30a1                      	cpi r26, 0x01 //absolute mode
002c84 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
002c85 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
002c86 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
002c87 91a0 2812                 	lds r26, triangle_note //load the current note index
002c89 0fab                      	add r26, r27 //offset the note with the arpeggio data
002c8a fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002c8b c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
002c8c 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002c8d f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002c8e e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002c8f c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
002c90 fda7                      	sbrc r26, 7 //check if result is negative
002c91 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002c92 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
002c93 2fab                      	mov r26, r27 //move the arpeggio data into r26
002c94 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
002c95 91a0 2812                 	lds r26, triangle_note //load the current note index
002c97 0fab                      	add r26, r27 //offset the note with the arpeggio data
002c98 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002c99 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
002c9a 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
002c9c 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002c9d f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
002c9e e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002c9f 93a0 2812                 	sts triangle_note, r26
002ca1 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
002ca2 fda7                      	sbrc r26, 7 //check if result is negative
002ca3 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002ca4 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
002ca6 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002ca7 e0f0                      	ldi ZH, HIGH(note_table << 1)
002ca8 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002ca9 0fea                      	add ZL, r26 //add offset
002caa 1df2                      	adc ZH, zero
002cab 91a5                      	lpm r26, Z+ //load bytes
002cac 91b4                      	lpm r27, Z
002cad 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
002caf 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
002cb1 93a0 28f6                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002cb3 93b0 28f7                 	sts triangle_fx_3xx_target+1, r27
002cb5 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002cb6 91e0 28da                 	lds ZL, triangle_pitch_macro
002cb8 91f0 28db                 	lds ZH, triangle_pitch_macro+1
002cba 9630                      	adiw Z, 0
002cbb f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002cbc c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002cbd 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002cbe 1fff                      	rol ZH
002cbf 91a0 28dc                 	lds r26, triangle_pitch_macro_offset
002cc1 0fea                      	add ZL, r26
002cc2 1df2                      	adc ZH, zero
                                 
002cc3 91b0 28de                 	lds r27, triangle_pitch_macro_release
002cc5 17ba                      	cp r27, r26
002cc6 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002cc7 91a0 28dd                 	lds r26, triangle_pitch_macro_loop
002cc9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002cca f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ccb c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002ccc 95a3                      	inc r26 //increment the macro offset
002ccd 93a0 28dc                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002ccf 91b4                      	lpm r27, Z //load pitch data into r27
002cd0 38b0                      	cpi r27, 0x80 //check for macro end flag
002cd1 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002cd2 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002cd3 93a0 28dc                 	sts triangle_pitch_macro_offset, r26
002cd5 91b0 28de                 	lds r27, triangle_pitch_macro_release
002cd7 3fbf                      	cpi r27, 0xFF
002cd8 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002cd9 91b0 28dd                 	lds r27, triangle_pitch_macro_loop //load the loop index
002cdb 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002cdc f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002cdd 93b0 28dc                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002cdf cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002ce0 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002ce1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ce2 937f                      	push r23
002ce3 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002ce4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ce5 0367                      	mulsu r22, r23
002ce6 917f                      	pop r23
002ce7 916f                      	pop r22
                                 
002ce8 9416                      	lsr r1 //shift out the fractional bits
002ce9 9407                      	ror r0
002cea 9416                      	lsr r1
002ceb 9407                      	ror r0
002cec 9416                      	lsr r1
002ced 9407                      	ror r0
002cee 9416                      	lsr r1
002cef 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
002cf0 fe13                      	sbrs r1, 3 //check if result was a negative number
002cf1 c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002cf2 efc0                      	ldi r28, 0xF0
002cf3 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
002cf4 70b7                      	andi r27, 0b00000111
002cf5 f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
002cf6 e0b1                      	ldi r27, 0x01
002cf7 0e0b                      	add r0, r27
002cf8 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002cf9 91a0 28d8                 	lds r26, triangle_total_pitch_offset
002cfb 91b0 28d9                 	lds r27, triangle_total_pitch_offset+1
002cfd 0e0a                      	add r0, r26
002cfe 1e1b                      	adc r1, r27
002cff 9200 28d8                 	sts triangle_total_pitch_offset, r0
002d01 9210 28d9                 	sts triangle_total_pitch_offset+1, r1
002d03 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002d05 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002d07 0da0                      	add r26, r0 //offset the timer values
002d08 1db1                      	adc r27, r1
                                 	
002d09 91c0 28ee                 	lds r28, triangle_fx_1xx_total
002d0b 91d0 28ef                 	lds r29, triangle_fx_1xx_total+1
002d0d 1bac                      	sub r26, r28
002d0e 0bbd                      	sbc r27, r29
002d0f 91c0 28f2                 	lds r28, triangle_fx_2xx_total
002d11 91d0 28f3                 	lds r29, triangle_fx_2xx_total+1
002d13 0fac                      	add r26, r28
002d14 1fbd                      	adc r27, r29
002d15 91c0 2901                 	lds r28, triangle_fx_Pxx_total
002d17 91d0 2902                 	lds r29, triangle_fx_Pxx_total+1
002d19 0fac                      	add r26, r28
002d1a 1fbd                      	adc r27, r29
002d1b 91c0 2908                 	lds r28, triangle_fx_Qxy_total_offset
002d1d 91d0 2909                 	lds r29, triangle_fx_Qxy_total_offset+1
002d1f 1bac                      	sub r26, r28
002d20 0bbd                      	sbc r27, r29
002d21 91c0 290f                 	lds r28, triangle_fx_Rxy_total_offset
002d23 91d0 2910                 	lds r29, triangle_fx_Rxy_total_offset+1
002d25 0fac                      	add r26, r28
002d26 1fbd                      	adc r27, r29
                                 
002d27 e5c9                      	ldi r28, 0x59
002d28 e0d0                      	ldi r29, 0x00
002d29 17ac                      	cp r26, r28
002d2a 07bd                      	cpc r27, r29
002d2b f030                      	brlo sound_driver_instrument_routine_channel2_pitch_min
                                 
002d2c e5ca                      	ldi r28, 0x5A
002d2d e5d9                      	ldi r29, 0x59
002d2e 17ac                      	cp r26, r28
002d2f 07bd                      	cpc r27, r29
002d30 f420                      	brsh sound_driver_instrument_routine_channel2_pitch_max
002d31 c006                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_min:
002d32 e5c9                      	ldi r28, 0x59
002d33 e0d0                      	ldi r29, 0x00
002d34 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_max:
002d35 e5c9                      	ldi r28, 0x59
002d36 e5d9                      	ldi r29, 0x59
002d37 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_store:
002d38 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002d3a 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002d3c 91e0 28e0                 	lds ZL, triangle_hi_pitch_macro
002d3e 91f0 28e1                 	lds ZH, triangle_hi_pitch_macro+1
002d40 9630                      	adiw Z, 0
002d41 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002d42 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002d43 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d44 1fff                      	rol ZH
002d45 91a0 28e2                 	lds r26, triangle_hi_pitch_macro_offset
002d47 0fea                      	add ZL, r26
002d48 1df2                      	adc ZH, zero
                                 
002d49 91b0 28e4                 	lds r27, triangle_hi_pitch_macro_release
002d4b 17ba                      	cp r27, r26
002d4c f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d4d 91a0 28e3                 	lds r26, triangle_hi_pitch_macro_loop
002d4f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d50 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d51 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002d52 95a3                      	inc r26 //increment the macro offset
002d53 93a0 28e2                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002d55 91b4                      	lpm r27, Z //load hi pitch data into r27
002d56 38b0                      	cpi r27, 0x80 //check for macro end flag
002d57 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002d58 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d59 93a0 28e2                 	sts triangle_hi_pitch_macro_offset, r26
002d5b 91b0 28e4                 	lds r27, triangle_hi_pitch_macro_release
002d5d 3fbf                      	cpi r27, 0xFF
002d5e f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002d5f 91b0 28e3                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002d61 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d62 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002d63 93b0 28e2                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002d65 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002d66 91b0 28df                 	lds r27, triangle_total_hi_pitch_offset
002d68 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002d69 91a0 28df                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002d6b 0fba                      	add r27, r26
002d6c 93b0 28df                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002d6e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d6f 937f                      	push r23
002d70 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002d71 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d72 0367                      	mulsu r22, r23
002d73 917f                      	pop r23
002d74 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002d75 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002d77 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002d79 0da0                      	add r26, r0 //offset the timer values
002d7a 1db1                      	adc r27, r1
002d7b 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002d7d 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002d7f 91e0 28ec                 	lds ZL, triangle_fx_1xx
002d81 91f0 28ed                 	lds ZH, triangle_fx_1xx+1
002d83 9630                      	adiw Z, 0
002d84 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002d85 91a0 28ee                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002d87 91b0 28ef                 	lds r27, triangle_fx_1xx_total+1
002d89 0fae                      	add r26, ZL //increase the total offset by the rate
002d8a 1fbf                      	adc r27, ZH
002d8b 93a0 28ee                 	sts triangle_fx_1xx_total, r26
002d8d 93b0 28ef                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002d8f 91e0 28f0                 	lds ZL, triangle_fx_2xx
002d91 91f0 28f1                 	lds ZH, triangle_fx_2xx+1
002d93 9630                      	adiw Z, 0
002d94 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002d95 91a0 28f2                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002d97 91b0 28f3                 	lds r27, triangle_fx_2xx_total+1
002d99 0fae                      	add r26, ZL //increase the total offset by the rate
002d9a 1fbf                      	adc r27, ZH
002d9b 93a0 28f2                 	sts triangle_fx_2xx_total, r26
002d9d 93b0 28f3                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002d9f 91e0 28f8                 	lds ZL, triangle_fx_3xx_speed
002da1 91f0 28f9                 	lds ZH, triangle_fx_3xx_speed+1
002da3 9630                      	adiw Z, 0
002da4 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002da5 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002da6 91a0 28f4                 	lds r26, triangle_fx_3xx_start
002da8 91b0 28f5                 	lds r27, triangle_fx_3xx_start+1
002daa 9610                      	adiw r26:r27, 0
002dab f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002dac c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002dad 91c0 28f6                 	lds r28, triangle_fx_3xx_target
002daf 91d0 28f7                 	lds r29, triangle_fx_3xx_target+1
                                 
002db1 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002db2 07bd                      	cpc r27, r29
002db3 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002db4 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002db5 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002db6 9220 28f4                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002db8 9220 28f5                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002dba c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002dbb 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002dbc 0bdb                      	sbc r29, r27
002dbd 91a0 28fa                 	lds r26, triangle_fx_3xx_total_offset
002dbf 91b0 28fb                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002dc1 0fae                      	add r26, ZL //add the speed to the total offset
002dc2 1fbf                      	adc r27, ZH
002dc3 1bca                      	sub r28, r26 //invert the total difference with the total offset
002dc4 0bdb                      	sbc r29, r27
002dc5 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002dc6 93a0 28fa                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002dc8 93b0 28fb                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002dca 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002dcc 91b0 0aad                 	lds r27, TCB2_CCMPH
002dce 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002dcf 0bbd                      	sbc r27, r29
002dd0 93a0 0aac                 	sts TCB2_CCMPL, r26
002dd2 93b0 0aad                 	sts TCB2_CCMPH, r27
002dd4 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002dd5 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002dd6 0bbd                      	sbc r27, r29
002dd7 91c0 28fa                 	lds r28, triangle_fx_3xx_total_offset
002dd9 91d0 28fb                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002ddb 0fce                      	add r28, ZL //add the speed to the total offset
002ddc 1fdf                      	adc r29, ZH
002ddd 1bac                      	sub r26, r28 //invert the total difference with the total offset
002dde 0bbd                      	sbc r27, r29
002ddf f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002de0 93c0 28fa                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002de2 93d0 28fb                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002de4 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002de6 91d0 0aad                 	lds r29, TCB2_CCMPH
002de8 0fca                      	add r28, r26 //offset the current timer period with the total offset
002de9 1fdb                      	adc r29, r27
002dea 93c0 0aac                 	sts TCB2_CCMPL, r28
002dec 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002dee 91a0 28fc                 	lds r26, triangle_fx_4xy_speed
002df0 15a2                      	cp r26, zero
002df1 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002df2 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002df3 91b0 28fd                 	lds r27, triangle_fx_4xy_depth
002df5 91c0 28fe                 	lds r28, triangle_fx_4xy_phase
002df7 0fca                      	add r28, r26 //increase the phase by the speed
002df8 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002df9 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002dfa e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002dfb 93c0 28fe                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002dfd 31c0                      	cpi r28, 16
002dfe f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002dff 32c0                      	cpi r28, 32
002e00 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002e01 33c0                      	cpi r28, 48
002e02 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002e03 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002e04 70cf                      	andi r28, 0x0F //mask for values 0-15
002e05 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002e06 6fc0                      	ori r28, 0xF0
002e07 95c0                      	com r28 //invert values 0-15
002e08 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002e09 70cf                      	andi r28, 0x0F //mask for values 0-15
002e0a c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002e0b 6fc0                      	ori r28, 0xF0
002e0c 95c0                      	com r28 //invert values 0-15
002e0d c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002e0e 95b2                      	swap r27 //multiply depth by 16
002e0f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002e10 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e11 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e12 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e13 1df2                      	adc ZH, zero
002e14 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002e15 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e16 937f                      	push r23
002e17 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e18 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e19 9f67                      	mul r22, r23
002e1a 917f                      	pop r23
002e1b 916f                      	pop r22
                                 
002e1c 9416                      	lsr r1 //shift out the fractional bits
002e1d 9407                      	ror r0
002e1e 9416                      	lsr r1
002e1f 9407                      	ror r0
002e20 9416                      	lsr r1
002e21 9407                      	ror r0
002e22 9416                      	lsr r1
002e23 9407                      	ror r0
                                 	
002e24 91a0 0aac                 	lds r26, TCB2_CCMPL
002e26 91b0 0aad                 	lds r27, TCB2_CCMPH
002e28 0da0                      	add r26, r0
002e29 1db1                      	adc r27, r1
002e2a 93a0 0aac                 	sts TCB2_CCMPL, r26
002e2c 93b0 0aad                 	sts TCB2_CCMPH, r27
002e2e c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002e2f 95b2                      	swap r27 //multiply depth by 16
002e30 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002e31 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002e32 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002e33 0fec                      	add ZL, r28 //offset the table by the depth+phase
002e34 1df2                      	adc ZH, zero
002e35 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002e36 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002e37 937f                      	push r23
002e38 2f6c                      	mov r22, r28 //store the vibrato value into r22
002e39 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002e3a 9f67                      	mul r22, r23
002e3b 917f                      	pop r23
002e3c 916f                      	pop r22
                                 
002e3d 9416                      	lsr r1 //shift out the fractional bits
002e3e 9407                      	ror r0
002e3f 9416                      	lsr r1
002e40 9407                      	ror r0
002e41 9416                      	lsr r1
002e42 9407                      	ror r0
002e43 9416                      	lsr r1
002e44 9407                      	ror r0
                                 
002e45 91a0 0aac                 	lds r26, TCB2_CCMPL
002e47 91b0 0aad                 	lds r27, TCB2_CCMPH
002e49 19a0                      	sub r26, r0
002e4a 09b1                      	sbc r27, r1
002e4b 93a0 0aac                 	sts TCB2_CCMPL, r26
002e4d 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002e4f 91e0 2904                 	lds ZL, triangle_fx_Qxy_target
002e51 91f0 2905                 	lds ZH, triangle_fx_Qxy_target+1
002e53 9630                      	adiw Z, 0
002e54 f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002e55 91a0 2908                 	lds r26, triangle_fx_Qxy_total_offset
002e57 91b0 2909                 	lds r27, triangle_fx_Qxy_total_offset+1
002e59 91c0 0aac                 	lds r28, TCB2_CCMPL
002e5b 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002e5d 1bec                      	sub ZL, r28 //calculate the difference to the target
002e5e 0bfd                      	sbc ZH, r29
002e5f f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002e60 f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002e61 9220 2908                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
002e63 9220 2909                 	sts triangle_fx_Qxy_total_offset+1, zero
002e65 9220 2904                 	sts triangle_fx_Qxy_target, zero
002e67 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
002e69 91b0 2903                 	lds r27, triangle_fx_Qxy_target_note
002e6b 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002e6d c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002e6e 91c0 2906                 	lds r28, triangle_fx_Qxy_speed
002e70 91d0 2907                 	lds r29, triangle_fx_Qxy_speed+1
002e72 0fac                      	add r26, r28 //increase the total offset by the speed
002e73 1fbd                      	adc r27, r29
002e74 93a0 2908                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002e76 93b0 2909                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002e78 91e0 290b                 	lds ZL, triangle_fx_Rxy_target
002e7a 91f0 290c                 	lds ZH, triangle_fx_Rxy_target+1
002e7c 9630                      	adiw Z, 0
002e7d f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002e7e 91a0 290f                 	lds r26, triangle_fx_Rxy_total_offset
002e80 91b0 2910                 	lds r27, triangle_fx_Rxy_total_offset+1
002e82 91c0 0aac                 	lds r28, TCB2_CCMPL
002e84 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002e86 1bce                      	sub r28, ZL //calculate the difference to the target
002e87 0bdf                      	sbc r29, ZH
002e88 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002e89 f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002e8a 9220 290f                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002e8c 9220 2910                 	sts triangle_fx_Rxy_total_offset+1, zero
002e8e 9220 290b                 	sts triangle_fx_Rxy_target, zero
002e90 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
002e92 91b0 290a                 	lds r27, triangle_fx_Rxy_target_note
002e94 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002e96 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002e97 91c0 290d                 	lds r28, triangle_fx_Rxy_speed
002e99 91d0 290e                 	lds r29, triangle_fx_Rxy_speed+1
002e9b 0fac                      	add r26, r28 //increase the total offset by the speed
002e9c 1fbd                      	adc r27, r29
002e9d 93a0 290f                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002e9f 93b0 2910                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002ea1 91e0 2919                 	lds ZL, noise_volume_macro
002ea3 91f0 291a                 	lds ZH, noise_volume_macro+1
002ea5 9630                      	adiw Z, 0
002ea6 f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002ea7 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002ea8 1fff                      	rol ZH
002ea9 91a0 291b                 	lds r26, noise_volume_macro_offset
002eab 0fea                      	add ZL, r26
002eac 1df2                      	adc ZH, zero
                                 
002ead 91b0 291d                 	lds r27, noise_volume_macro_release
002eaf 17ba                      	cp r27, r26
002eb0 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002eb1 91a0 291c                 	lds r26, noise_volume_macro_loop
002eb3 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002eb4 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002eb5 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002eb6 95a3                      	inc r26 //increment the macro offset
002eb7 93a0 291b                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002eb9 91b4                      	lpm r27, Z //load volume data into r27
002eba 3fbf                      	cpi r27, 0xFF //check for macro end flag
002ebb f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002ebc 91b0 291d                 	lds r27, noise_volume_macro_release
002ebe 3fbf                      	cpi r27, 0xFF
002ebf f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002ec0 91b0 291c                 	lds r27, noise_volume_macro_loop //load the loop index
002ec2 93b0 291b                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002ec4 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002ec5 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002ec6 93a0 291b                 	sts noise_volume_macro_offset, r26
002ec8 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002ec9 ebec                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002eca e6f2                      	ldi ZH, HIGH(volumes << 1)
002ecb 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002ecc 0feb                      	add ZL, r27 //add offset to the table
002ecd 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002ece 91b0 2813                 	lds r27, noise_param //load main volume
002ed0 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002ed1 91a0 2943                 	lds r26, noise_fx_7xy_value
002ed3 30a0                      	cpi r26, 0x00
002ed4 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002ed5 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ed6 1df2                      	adc ZH, zero
002ed7 91b4                      	lpm r27, Z
002ed8 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002eda c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002edb 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002edd 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002ede 91a0 2943                 	lds r26, noise_fx_7xy_value
002ee0 30a0                      	cpi r26, 0x00
002ee1 f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002ee2 93b0 2816                 	sts noise_output_volume, r27
002ee4 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002ee5 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002ee6 f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002ee7 f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002ee8 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ee9 1df2                      	adc ZH, zero
002eea 91b4                      	lpm r27, Z
002eeb 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002eed c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002eee e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002eef 0feb                      	add ZL, r27 //offset the volume table by the main volume
002ef0 1df2                      	adc ZH, zero
002ef1 91b4                      	lpm r27, Z
002ef2 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002ef4 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002ef5 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002ef6 f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002ef7 f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002ef8 93b0 2816                 	sts noise_output_volume, r27
002efa c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002efb e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002efc 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002efe 91e0 291e                 	lds ZL, noise_arpeggio_macro
002f00 91f0 291f                 	lds ZH, noise_arpeggio_macro+1
002f02 9630                      	adiw Z, 0
002f03 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002f04 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f05 1fff                      	rol ZH
002f06 91a0 2920                 	lds r26, noise_arpeggio_macro_offset
002f08 0fea                      	add ZL, r26
002f09 1df2                      	adc ZH, zero
                                 
002f0a 91b0 2922                 	lds r27, noise_arpeggio_macro_release
002f0c 17ba                      	cp r27, r26
002f0d f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002f0e 91a0 2921                 	lds r26, noise_arpeggio_macro_loop
002f10 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f11 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002f12 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002f13 95a3                      	inc r26 //increment the macro offset
002f14 93a0 2920                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002f16 91b4                      	lpm r27, Z //load arpeggio data into r27
002f17 38b0                      	cpi r27, 0x80 //check for macro end flag
002f18 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002f19 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002f1a 50a1                      	subi r26, 1 //keep the offset at the end flag
002f1b 93a0 2920                 	sts noise_arpeggio_macro_offset, r26
002f1d 91b0 2923                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002f1f 30b1                      	cpi r27, 0x01
002f20 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002f21 91b0 2922                 	lds r27, noise_arpeggio_macro_release
002f23 3fbf                      	cpi r27, 0xFF
002f24 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002f25 91b0 2921                 	lds r27, noise_arpeggio_macro_loop
002f27 3fbf                      	cpi r27, 0xFF
002f28 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002f29 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002f2a 91b0 2922                 	lds r27, noise_arpeggio_macro_release
002f2c 3fbf                      	cpi r27, 0xFF
002f2d f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002f2e 91b0 2921                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002f30 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002f31 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002f32 91c0 2936                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002f34 91d0 2937                 	lds r29, noise_fx_0xy_sequence+1
002f36 9620                      	adiw r29:r28, 0
002f37 f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002f38 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002f39 93a0 2920                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002f3b cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002f3c 93b0 2920                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002f3e cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002f3f 91c0 2936                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002f41 91d0 2937                 	lds r29, noise_fx_0xy_sequence+1
002f43 9620                      	adiw r29:r28, 0 //check for 0xy effect
002f44 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
002f45 95d6                      	lsr r29
002f46 95c7                      	ror r28
002f47 95d7                      	ror r29
002f48 95c7                      	ror r28
002f49 95d7                      	ror r29
002f4a 95c7                      	ror r28
002f4b 95d7                      	ror r29
002f4c 95c7                      	ror r28
002f4d 95d7                      	ror r29
002f4e 95d2                      	swap r29
                                 
002f4f 93c0 2936                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002f51 93d0 2937                 	sts noise_fx_0xy_sequence+1, r29
002f53 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002f54 91a0 2817                 	lds r26, noise_note //load the current note index
002f56 0fac                      	add r26, r28 //add the note offset
002f57 c01c                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002f58 91a0 2817                 	lds r26, noise_note //load the current note index
002f5a c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002f5b 9220 2924                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002f5d 9220 2925                 	sts noise_total_pitch_offset+1, zero
002f5f 9220 292b                 	sts noise_total_hi_pitch_offset, zero
002f61 91a0 2923                 	lds r26, noise_arpeggio_macro_mode
002f63 30a1                      	cpi r26, 0x01 //absolute mode
002f64 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002f65 f031                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002f66 c007                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002f67 91a0 2817                 	lds r26, noise_note //load the current note index
002f69 0fab                      	add r26, r27 //offset the note with the arpeggio data
002f6a 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002f6b c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002f6c 2fab                      	mov r26, r27 //move the arpeggio data into r26
002f6d c006                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002f6e 91a0 2817                 	lds r26, noise_note //load the current note index
002f70 0fab                      	add r26, r27 //offset the note with the arpeggio data
002f71 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002f72 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002f74 93a0 2818                 	sts noise_adjusted_note, r26
002f76 c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002f77 91e0 2926                 	lds ZL, noise_pitch_macro
002f79 91f0 2927                 	lds ZH, noise_pitch_macro+1
002f7b 9630                      	adiw Z, 0
002f7c f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002f7d c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002f7e 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002f7f 1fff                      	rol ZH
002f80 91a0 2928                 	lds r26, noise_pitch_macro_offset
002f82 0fea                      	add ZL, r26
002f83 1df2                      	adc ZH, zero
                                 
002f84 91b0 292a                 	lds r27, noise_pitch_macro_release
002f86 17ba                      	cp r27, r26
002f87 f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002f88 91a0 2929                 	lds r26, noise_pitch_macro_loop
002f8a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f8b f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002f8c c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002f8d 95a3                      	inc r26 //increment the macro offset
002f8e 93a0 2928                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002f90 91b4                      	lpm r27, Z //load pitch data into r27
002f91 38b0                      	cpi r27, 0x80 //check for macro end flag
002f92 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002f93 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002f94 93a0 2928                 	sts noise_pitch_macro_offset, r26
002f96 91b0 292a                 	lds r27, noise_pitch_macro_release
002f98 3fbf                      	cpi r27, 0xFF
002f99 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002f9a 91b0 2929                 	lds r27, noise_pitch_macro_loop //load the loop index
002f9c 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002f9d f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002f9e 93b0 2928                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
002fa0 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
002fa1 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
002fa2 91a0 2924                 	lds r26, noise_total_pitch_offset
002fa4 0fba                      	add r27, r26
002fa5 93b0 2924                 	sts noise_total_pitch_offset, r27
002fa7 91a0 2818                 	lds r26, noise_adjusted_note
002fa9 1bab                      	sub r26, r27
                                 	
002faa 91b0 2939                 	lds r27, noise_fx_1xx_total
002fac 0fab                      	add r26, r27
002fad 91b0 293b                 	lds r27, noise_fx_2xx_total
002faf 1bab                      	sub r26, r27
002fb0 91b0 293f                 	lds r27, noise_fx_4xy_offset
002fb2 1bab                      	sub r26, r27
002fb3 91b0 2947                 	lds r27, noise_fx_Pxx_total
002fb5 1bab                      	sub r26, r27
                                 
002fb6 70af                      	andi r26, 0x0F
                                 
002fb7 e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002fb8 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002fb9 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002fba 0fea                      	add ZL, r26 //add offset
002fbb 1df2                      	adc ZH, zero
002fbc 91a5                      	lpm r26, Z+ //load bytes
002fbd 91b4                      	lpm r27, Z
002fbe 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002fc0 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
002fc2 91e0 292c                 	lds ZL, noise_hi_pitch_macro
002fc4 91f0 292d                 	lds ZH, noise_hi_pitch_macro+1
002fc6 9630                      	adiw Z, 0
002fc7 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
002fc8 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
002fc9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002fca 1fff                      	rol ZH
002fcb 91a0 292e                 	lds r26, noise_hi_pitch_macro_offset
002fcd 0fea                      	add ZL, r26
002fce 1df2                      	adc ZH, zero
                                 
002fcf 91b0 2930                 	lds r27, noise_hi_pitch_macro_release
002fd1 17ba                      	cp r27, r26
002fd2 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002fd3 91a0 292f                 	lds r26, noise_hi_pitch_macro_loop
002fd5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002fd6 f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002fd7 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
002fd8 95a3                      	inc r26 //increment the macro offset
002fd9 93a0 292e                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
002fdb 91b4                      	lpm r27, Z //load hi pitch data into r27
002fdc 38b0                      	cpi r27, 0x80 //check for macro end flag
002fdd f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
002fde 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002fdf 93a0 292e                 	sts noise_hi_pitch_macro_offset, r26
002fe1 91b0 2930                 	lds r27, noise_hi_pitch_macro_release
002fe3 3fbf                      	cpi r27, 0xFF
002fe4 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
002fe5 91b0 292f                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
002fe7 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002fe8 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002fe9 93b0 292e                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
002feb cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
002fec 91b0 292b                 	lds r27, noise_total_hi_pitch_offset
002fee c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
002fef 91a0 292b                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
002ff1 0fba                      	add r27, r26
002ff2 93b0 292b                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
002ff4 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002ff5 937f                      	push r23
002ff6 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002ff7 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ff8 0367                      	mulsu r22, r23
002ff9 917f                      	pop r23
002ffa 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
002ffb 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002ffd 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002fff 0da0                      	add r26, r0 //offset the timer values
003000 1db1                      	adc r27, r1
003001 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
003003 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
003005 91e0 2931                 	lds ZL, noise_duty_macro
003007 91f0 2932                 	lds ZH, noise_duty_macro+1
003009 9630                      	adiw Z, 0
00300a f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
00300b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00300c 1fff                      	rol ZH
00300d 91a0 2933                 	lds r26, noise_duty_macro_offset
00300f 0fea                      	add ZL, r26
003010 1df2                      	adc ZH, zero
                                 
003011 91b0 2935                 	lds r27, noise_duty_macro_release
003013 17ba                      	cp r27, r26
003014 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
003015 91a0 2934                 	lds r26, noise_duty_macro_loop
003017 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003018 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003019 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
00301a 95a3                      	inc r26 //increment the macro offset
00301b 93a0 2933                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
00301d 91b4                      	lpm r27, Z //load pitch data into r27
00301e 3fbf                      	cpi r27, 0xFF //check for macro end flag
00301f f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
003020 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003021 93a0 2933                 	sts noise_duty_macro_offset, r26
003023 91b0 2935                 	lds r27, noise_duty_macro_release
003025 3fbf                      	cpi r27, 0xFF
003026 f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
003027 91b0 2934                 	lds r27, noise_duty_macro_loop //load the loop index
003029 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00302a f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00302b 93b0 2933                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
00302d cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
00302e 95b6                      	lsr r27
00302f 95b7                      	ror r27 //move mode bit to bit 7
003030 91c0 2814                 	lds r28, noise_period
003032 77cf                      	andi r28, 0b01111111
003033 2bcb                      	or r28, r27 //store the new noise mode
003034 93c0 2814                 	sts noise_period, r28
                                 
003036 776f                      	andi noise_sequence_HIGH, 0b01111111
003037 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
003038 91e0 2938                 	lds ZL, noise_fx_1xx
00303a 30e0                      	cpi ZL, 0
00303b f029                      	breq sound_driver_channel3_fx_2xx_routine
                                 
00303c 91a0 2939                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
00303e 0fae                      	add r26, ZL //increase the total offset by the rate
00303f 93a0 2939                 	sts noise_fx_1xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
003041 91e0 293a                 	lds ZL, noise_fx_2xx
003043 30e0                      	cpi ZL, 0
003044 f029                      	breq sound_driver_channel3_fx_3xx_routine
                                 
003045 91a0 293b                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
003047 0fae                      	add r26, ZL //increase the total offset by the rate
003048 93a0 293b                 	sts noise_fx_2xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
00304a 91a0 293c                 	lds r26, noise_fx_4xy_speed
00304c 15a2                      	cp r26, zero
00304d f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
00304e c033                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
00304f 91b0 293d                 	lds r27, noise_fx_4xy_depth
003051 91c0 293e                 	lds r28, noise_fx_4xy_phase
003053 0fca                      	add r28, r26 //increase the phase by the speed
003054 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
003055 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
003056 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
003057 93c0 293e                 	sts noise_fx_4xy_phase, r28 //store the new phase
003059 31c0                      	cpi r28, 16
00305a f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
00305b 32c0                      	cpi r28, 32
00305c f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
00305d 33c0                      	cpi r28, 48
00305e f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
00305f c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
003060 70cf                      	andi r28, 0x0F //mask for values 0-15
003061 c014                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
003062 6fc0                      	ori r28, 0xF0
003063 95c0                      	com r28 //invert values 0-15
003064 c011                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
003065 70cf                      	andi r28, 0x0F //mask for values 0-15
003066 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
003067 6fc0                      	ori r28, 0xF0
003068 95c0                      	com r28 //invert values 0-15
003069 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
00306a 95b2                      	swap r27 //multiply depth by 16
00306b 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00306c e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00306d e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00306e 0fec                      	add ZL, r28 //offset the table by the depth+phase
00306f 1df2                      	adc ZH, zero
003070 91c4                      	lpm r28, Z //load the tremelo value into r28
003071 95c2                      	swap r28
003072 70cf                      	andi r28, 0x0F
                                 
003073 93c0 293f                 	sts noise_fx_4xy_offset, r28
003075 c00c                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
003076 95b2                      	swap r27 //multiply depth by 16
003077 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
003078 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003079 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00307a 0fec                      	add ZL, r28 //offset the table by the depth+phase
00307b 1df2                      	adc ZH, zero
00307c 91c4                      	lpm r28, Z //load the vibrato value into r28
00307d 95c2                      	swap r28
00307e 70cf                      	andi r28, 0x0F
                                 
00307f 95c1                      	neg r28
003080 93c0 293f                 	sts noise_fx_4xy_offset, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
003082 91a0 2940                 	lds r26, noise_fx_7xy_speed
003084 15a2                      	cp r26, zero
003085 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
003086 91b0 2941                 	lds r27, noise_fx_7xy_depth
003088 91c0 2942                 	lds r28, noise_fx_7xy_phase
00308a 0fca                      	add r28, r26 //increase the phase by the speed
00308b 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00308c f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00308d e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
00308e 93c0 2942                 	sts noise_fx_7xy_phase, r28 //store the new phase
003090 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
003091 ffc4                      	sbrs r28, 4
003092 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
003093 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
003094 70cf                      	andi r28, 0x0F //mask for values 0-15
003095 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
003096 6fc0                      	ori r28, 0xF0
003097 95c0                      	com r28 //invert values 0-15
003098 c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
003099 95b2                      	swap r27 //multiply depth by 16
00309a 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00309b e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00309c e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00309d 0fec                      	add ZL, r28 //offset the table by the depth+phase
00309e 1df2                      	adc ZH, zero
00309f 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0030a0 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0030a1 93c0 2943                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
0030a3 91b0 2944                 	lds r27, noise_fx_Axy
0030a5 15b2                      	cp r27, zero
0030a6 f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0030a7 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
0030a9 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
0030ab 2fda                      	mov r29, r26 //copy fractional volume into r29
0030ac 2fec                      	mov r30, r28 //copy the noise_param into r30
0030ad 95e2                      	swap r30
0030ae 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0030af 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0030b0 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0030b1 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
0030b2 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
0030b3 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0030b4 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
0030b5 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0030b6 f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0030b7 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0030b8 c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
0030b9 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0030ba f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0030bb e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
0030bc 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
0030be 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0030bf 95a2                      	swap r26
0030c0 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0030c1 2bca                      	or r28, r26 //store the new volume back into noise_param
0030c2 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Qxy_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
                                 
                                 
                                 
                                 sound_driver_exit:
0030c4 91ff                      	pop r31
0030c5 91ef                      	pop r30
0030c6 91df                      	pop r29
0030c7 91cf                      	pop r28
0030c8 940c 1619                 	jmp sequence_1_3
                                 
                                 
                                 
                                 //TABLES
0030ca 7f05
0030cb 010a
0030cc 0214
0030cd 0328
0030ce 0450
0030cf 051e
0030d0 0607
0030d1 070d
0030d2 0806
0030d3 090c
0030d4 0a18
0030d5 0b30
0030d6 0c60
0030d7 0d24
0030d8 0e08
0030d9 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
0030da 0301
0030db fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
0030dc 1886
0030dd 188b
0030de 18a7
0030df 18c3
0030e0 18e6                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
0030e1 18f1
0030e2 18fe
0030e3 1901
0030e4 1904
0030e5 1907                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
0030e6 190a
0030e7 1912
0030e8 1915
0030e9 1922
0030ea 1923                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
0030eb 1924
0030ec 1925
0030ed 1926
0030ee 193e
0030ef 1980                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
0030f0 19c1
0030f1 19ce
0030f2 19e2
0030f3 19e3
0030f4 19e4                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
0030f5 19e5                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
0030f6 1b83
0030f7 1b88
0030f8 1ba4
0030f9 1bc0
0030fa 1be3                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
0030fb 1bee
0030fc 1bfb
0030fd 1bfe
0030fe 1c01
0030ff 1c04                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
003100 1c07
003101 1c0f
003102 1c12
003103 1c1f
003104 1c20                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
003105 1c21
003106 1c22
003107 1c23
003108 1c3b
003109 1c7d                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
00310a 1cbe
00310b 1ccb
00310c 1cdf
00310d 1ce0
00310e 1ce1                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
00310f 1ce2                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
003110 1e73
003111 1e78
003112 1e94
003113 1eb0
003114 1ed3                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
003115 1ede
003116 1edf
003117 1ee0
003118 1ee3
003119 1ee6                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
00311a 1ee9
00311b 1ef6
00311c 1ef9
00311d 1f06
00311e 1f07                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
00311f 1f08
003120 1f09
003121 1f0a
003122 1f22
003123 1f64                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
003124 1fa5
003125 1fb2
003126 1fb3
003127 1fb4
003128 1fb5                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
003129 1fb6                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
00312a 214b
00312b 2150
00312c 2159
00312d 2162
00312e 2163                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
00312f 2170
003130 217d
003131 2180
003132 2183
003133 2186                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
003134 2189
003135 2190
003136 2193
003137 21a0
003138 21a1                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
003139 21a2
00313a 21a3
00313b 21a4
00313c 21a7
00313d 21a8                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
00313e 21a9
00313f 21b6
003140 21c1
003141 21c2
003142 21c3                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
003143 21c4                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 channel4_fx:
003144 231d
003145 231e
003146 231f
003147 2320
003148 2321                      	.dw sound_driver_channel4_fx_0xy, sound_driver_channel4_fx_1xx, sound_driver_channel4_fx_2xx, sound_driver_channel4_fx_3xx, sound_driver_channel4_fx_4xy
003149 2322
00314a 2323
00314b 2324
00314c 2327
00314d 232a                      	.dw sound_driver_channel4_fx_7xy, sound_driver_channel4_fx_Axy, sound_driver_channel4_fx_Bxx, sound_driver_channel4_fx_Cxx, sound_driver_channel4_fx_Dxx
00314e 232d
00314f 232e
003150 2331
003151 233e
003152 233f                      	.dw sound_driver_channel4_fx_Exx, sound_driver_channel4_fx_Fxx, sound_driver_channel4_fx_Gxx, sound_driver_channel4_fx_Hxy, sound_driver_channel4_fx_Ixy
003153 2340
003154 2341
003155 2342
003156 2343
003157 2344                      	.dw sound_driver_channel4_fx_Hxx, sound_driver_channel4_fx_Ixx, sound_driver_channel4_fx_Pxx, sound_driver_channel4_fx_Qxy, sound_driver_channel4_fx_Rxy
003158 2345
003159 2352
00315a 2353
00315b 2354
00315c 2355                      	.dw sound_driver_channel4_fx_Sxx, sound_driver_channel4_fx_Vxx, sound_driver_channel4_fx_Wxx, sound_driver_channel4_fx_Xxx, sound_driver_channel4_fx_Yxx
00315d 2356                      	.dw sound_driver_channel4_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
00315e 0000
00315f 0000
003160 0000
003161 0000
003162 0000
003163 0000
003164 0000
003165 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
003166 0100
003167 0101
003168 0101
003169 0101
00316a 0101
00316b 0101
00316c 0101
00316d 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
00316e 0100
00316f 0101
003170 0101
003171 0101
003172 0101
003173 0101
003174 0101
003175 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
003176 0100
003177 0101
003178 0101
003179 0101
00317a 0101
00317b 0202
00317c 0202
00317d 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
00317e 0100
00317f 0101
003180 0101
003181 0101
003182 0202
003183 0202
003184 0303
003185 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
003186 0100
003187 0101
003188 0101
003189 0202
00318a 0302
00318b 0303
00318c 0404
00318d 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
00318e 0100
00318f 0101
003190 0201
003191 0202
003192 0303
003193 0404
003194 0504
003195 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
003196 0100
003197 0101
003198 0201
003199 0302
00319a 0403
00319b 0504
00319c 0605
00319d 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
00319e 0100
00319f 0101
0031a0 0202
0031a1 0303
0031a2 0404
0031a3 0505
0031a4 0606
0031a5 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
0031a6 0100
0031a7 0101
0031a8 0302
0031a9 0403
0031aa 0504
0031ab 0606
0031ac 0707
0031ad 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
0031ae 0100
0031af 0201
0031b0 0302
0031b1 0404
0031b2 0605
0031b3 0706
0031b4 0808
0031b5 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
0031b6 0100
0031b7 0201
0031b8 0302
0031b9 0504
0031ba 0605
0031bb 0807
0031bc 0908
0031bd 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
0031be 0100
0031bf 0201
0031c0 0403
0031c1 0504
0031c2 0706
0031c3 0808
0031c4 0a09
0031c5 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
0031c6 0100
0031c7 0201
0031c8 0403
0031c9 0605
0031ca 0706
0031cb 0908
0031cc 0b0a
0031cd 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
0031ce 0100
0031cf 0201
0031d0 0403
0031d1 0605
0031d2 0807
0031d3 0a09
0031d4 0c0b
0031d5 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
0031d6 0100
0031d7 0302
0031d8 0504
0031d9 0706
0031da 0908
0031db 0b0a
0031dc 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 255 r0 : 148 r1 : 160 r2 : 681 r3 :  18 r4 :   4 
r5 :   0 r6 :   0 r7 :   6 r8 :   4 r9 :   9 r10:   6 r11:   4 r12:   9 
r13:   1 r14:   1 r15:   2 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 138 r23: 127 r24:   3 r25:  24 r26:1001 r27:1219 r28: 658 
r29: 352 r30: 341 r31: 325 
Registers used: 31 out of 35 (88.6%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 132 add   : 183 adiw  : 100 and   :   2 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   6 brcs  :  13 break :   0 breq  : 173 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  76 brlt  :   0 brmi  :   0 
brne  : 133 brpl  :   0 brsh  :  37 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   5 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   6 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 125 cpc   :  15 
cpi   : 175 cpse  :  26 dec   :  25 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   5 in    :   5 inc   :  46 
jmp   :   8 ld    :   0 ldd   :   0 ldi   : 303 lds   : 692 lpm   : 279 
lsl   :  82 lsr   : 135 mov   : 135 movw  :   0 mul   :  21 muls  :   0 
mulsu :  10 neg   :   1 nop   :   0 or    :  24 ori   :  12 out   :   9 
pop   :  97 push  :  89 rcall :  56 ret   :  44 reti  :   7 rjmp  : 570 
rol   :  59 ror   : 156 sbc   :  30 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  25 sbrs  :  18 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1386 sub   :  53 subi  :  38 swap  :  47 tst   :   0 wdr   :   0 

Instructions used: 55 out of 114 (48.2%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0063bc  15610   9798  25408   49152  51.7%
[.dseg] 0x002800 0x002958      0    344    344    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 50 warnings
