
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Mon May 24 22:36:58 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of noise
002817                           noise_note: .byte 1 //the current note index in the period table
002818                           noise_adjusted_note: .byte 1 //the resultant note index after the arpeggio macro
                                 
002819                           song_frames: .byte 2
00281b                           song_frame_offset: .byte 2
00281d                           song_size: .byte 2
00281f                           song_tempo: .byte 2
002821                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002822                           song_fx_Bxx: .byte 1
002823                           song_fx_Cxx: .byte 1
002824                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002825                           pulse1_pattern: .byte 2
002827                           pulse1_pattern_delay_rows: .byte 1
002828                           pulse1_pattern_delay_frames: .byte 1
002829                           pulse1_pattern_offset: .byte 2
                                 
00282b                           pulse1_volume_macro: .byte 2
00282d                           pulse1_volume_macro_offset: .byte 1
00282e                           pulse1_volume_macro_loop: .byte 1
00282f                           pulse1_volume_macro_release: .byte 1
                                 
002830                           pulse1_arpeggio_macro: .byte 2
002832                           pulse1_arpeggio_macro_offset: .byte 1
002833                           pulse1_arpeggio_macro_loop: .byte 1
002834                           pulse1_arpeggio_macro_release: .byte 1
002835                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002836                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002838                           pulse1_pitch_macro: .byte 2
00283a                           pulse1_pitch_macro_offset: .byte 1
00283b                           pulse1_pitch_macro_loop: .byte 1
00283c                           pulse1_pitch_macro_release: .byte 1
                                 
00283d                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283e                           pulse1_hi_pitch_macro: .byte 2
002840                           pulse1_hi_pitch_macro_offset: .byte 1
002841                           pulse1_hi_pitch_macro_loop: .byte 1
002842                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002843                           pulse1_duty_macro: .byte 2
002845                           pulse1_duty_macro_offset: .byte 1
002846                           pulse1_duty_macro_loop: .byte 1
002847                           pulse1_duty_macro_release: .byte 1
                                 
002848                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00284a                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00284c                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284e                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002850                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002852                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002854                           pulse1_fx_3xx_target: .byte 2 //target note period
002856                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002858                           pulse1_fx_3xx_total_offset: .byte 2
00285a                           pulse1_fx_4xy_speed: .byte 1
00285b                           pulse1_fx_4xy_depth: .byte 1
00285c                           pulse1_fx_4xy_phase: .byte 1
00285d                           pulse1_fx_7xy_speed: .byte 1
00285e                           pulse1_fx_7xy_depth: .byte 1
00285f                           pulse1_fx_7xy_phase: .byte 1
002860                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002861                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002862                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002863                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002864                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002866                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002867                           pulse1_fx_Qxy_target: .byte 2 //target note period
002869                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00286b                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286d                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286e                           pulse1_fx_Rxy_target: .byte 2 //target note period
002870                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002872                           pulse1_fx_Rxy_total_offset: .byte 2
002874                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002875                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002876                           pulse2_pattern: .byte 2
002878                           pulse2_pattern_delay_rows: .byte 1
002879                           pulse2_pattern_delay_frames: .byte 1
00287a                           pulse2_pattern_offset: .byte 2
                                 
00287c                           pulse2_volume_macro: .byte 2
00287e                           pulse2_volume_macro_offset: .byte 1
00287f                           pulse2_volume_macro_loop: .byte 1
002880                           pulse2_volume_macro_release: .byte 1
                                 
002881                           pulse2_arpeggio_macro: .byte 2
002883                           pulse2_arpeggio_macro_offset: .byte 1
002884                           pulse2_arpeggio_macro_loop: .byte 1
002885                           pulse2_arpeggio_macro_release: .byte 1
002886                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002887                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002889                           pulse2_pitch_macro: .byte 2
00288b                           pulse2_pitch_macro_offset: .byte 1
00288c                           pulse2_pitch_macro_loop: .byte 1
00288d                           pulse2_pitch_macro_release: .byte 1
                                 
00288e                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288f                           pulse2_hi_pitch_macro: .byte 2
002891                           pulse2_hi_pitch_macro_offset: .byte 1
002892                           pulse2_hi_pitch_macro_loop: .byte 1
002893                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002894                           pulse2_duty_macro: .byte 2
002896                           pulse2_duty_macro_offset: .byte 1
002897                           pulse2_duty_macro_loop: .byte 1
002898                           pulse2_duty_macro_release: .byte 1
                                 
002899                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
00289b                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289d                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289f                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028a1                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a3                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a5                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a7                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a9                           pulse2_fx_3xx_total_offset: .byte 2
0028ab                           pulse2_fx_4xy_speed: .byte 1
0028ac                           pulse2_fx_4xy_depth: .byte 1
0028ad                           pulse2_fx_4xy_phase: .byte 1
0028ae                           pulse2_fx_7xy_speed: .byte 1
0028af                           pulse2_fx_7xy_depth: .byte 1
0028b0                           pulse2_fx_7xy_phase: .byte 1
0028b1                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028b2                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b3                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b4                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b5                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b7                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b8                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028ba                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028bc                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028be                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bf                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028c1                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c3                           pulse2_fx_Rxy_total_offset: .byte 2
0028c5                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c6                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c7                           triangle_pattern: .byte 2
0028c9                           triangle_pattern_delay_rows: .byte 1
0028ca                           triangle_pattern_delay_frames: .byte 1
0028cb                           triangle_pattern_offset: .byte 2
                                 
0028cd                           triangle_volume_macro: .byte 2
0028cf                           triangle_volume_macro_offset: .byte 1
0028d0                           triangle_volume_macro_loop: .byte 1
0028d1                           triangle_volume_macro_release: .byte 1
                                 
0028d2                           triangle_arpeggio_macro: .byte 2
0028d4                           triangle_arpeggio_macro_offset: .byte 1
0028d5                           triangle_arpeggio_macro_loop: .byte 1
0028d6                           triangle_arpeggio_macro_release: .byte 1
0028d7                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d8                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028da                           triangle_pitch_macro: .byte 2
0028dc                           triangle_pitch_macro_offset: .byte 1
0028dd                           triangle_pitch_macro_loop: .byte 1
0028de                           triangle_pitch_macro_release: .byte 1
                                 
0028df                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028e0                           triangle_hi_pitch_macro: .byte 2
0028e2                           triangle_hi_pitch_macro_offset: .byte 1
0028e3                           triangle_hi_pitch_macro_loop: .byte 1
0028e4                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e5                           triangle_duty_macro: .byte 2
0028e7                           triangle_duty_macro_offset: .byte 1
0028e8                           triangle_duty_macro_loop: .byte 1
0028e9                           triangle_duty_macro_release: .byte 1
                                 
0028ea                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028ec                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028ee                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028f0                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028f2                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f4                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f6                           triangle_fx_3xx_target: .byte 2 //target note period
0028f8                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028fa                           triangle_fx_3xx_total_offset: .byte 2
0028fc                           triangle_fx_4xy_speed: .byte 1
0028fd                           triangle_fx_4xy_depth: .byte 1
0028fe                           triangle_fx_4xy_phase: .byte 1
0028ff                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002900                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002901                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002903                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002904                           triangle_fx_Qxy_target: .byte 2 //target note period
002906                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002908                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00290a                           triangle_fx_Rxy_target_note: .byte 1 //target note index
00290b                           triangle_fx_Rxy_target: .byte 2 //target note period
00290d                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290f                           triangle_fx_Rxy_total_offset: .byte 2
002911                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002912                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002913                           noise_pattern: .byte 2
002915                           noise_pattern_delay_rows: .byte 1
002916                           noise_pattern_delay_frames: .byte 1
002917                           noise_pattern_offset: .byte 2
                                 
002919                           noise_volume_macro: .byte 2
00291b                           noise_volume_macro_offset: .byte 1
00291c                           noise_volume_macro_loop: .byte 1
00291d                           noise_volume_macro_release: .byte 1
                                 
00291e                           noise_arpeggio_macro: .byte 2
002920                           noise_arpeggio_macro_offset: .byte 1
002921                           noise_arpeggio_macro_loop: .byte 1
002922                           noise_arpeggio_macro_release: .byte 1
002923                           noise_arpeggio_macro_mode: .byte 1
                                 
002924                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002926                           noise_pitch_macro: .byte 2
002928                           noise_pitch_macro_offset: .byte 1
002929                           noise_pitch_macro_loop: .byte 1
00292a                           noise_pitch_macro_release: .byte 1
                                 
00292b                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00292c                           noise_hi_pitch_macro: .byte 2
00292e                           noise_hi_pitch_macro_offset: .byte 1
00292f                           noise_hi_pitch_macro_loop: .byte 1
002930                           noise_hi_pitch_macro_release: .byte 1
                                 
002931                           noise_duty_macro: .byte 2
002933                           noise_duty_macro_offset: .byte 1
002934                           noise_duty_macro_loop: .byte 1
002935                           noise_duty_macro_release: .byte 1
                                 
002936                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002938                           noise_fx_1xx: .byte 1 //refers to the rate in which to subtract the pitch from by the 1xx
002939                           noise_fx_1xx_total: .byte 1 //the total pitch offset for 1xx
00293a                           noise_fx_2xx: .byte 1 //refers to the rate in which to add to the pitch by the 2xx
00293b                           noise_fx_2xx_total: .byte 1 //the total pitch offset for 2xx
00293c                           noise_fx_4xy_speed: .byte 1
00293d                           noise_fx_4xy_depth: .byte 1
00293e                           noise_fx_4xy_phase: .byte 1
00293f                           noise_fx_4xy_offset: .byte 1
002940                           noise_fx_7xy_speed: .byte 1
002941                           noise_fx_7xy_depth: .byte 1
002942                           noise_fx_7xy_phase: .byte 1
002943                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002944                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002945                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002946                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002947                           noise_fx_Pxx_total: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002948                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002949                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
00294a                           dpcm_pattern: .byte 2
00294c                           dpcm_pattern_delay_rows: .byte 1
00294d                           dpcm_pattern_delay_frames: .byte 1
00294e                           dpcm_pattern_offset: .byte 2
                                 
002950                           dpcm_sample: .byte 2
002952                           dpcm_sample_offset: .byte 2
                                 
002954                           dpcm_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002955                           dpcm_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002956                           dpcm_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002957                           dpcm_fx_Sxx_post: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 //NOTE: same idea with one
                                 .def zero = r2
                                 .def one = r3
                                 .def frame_sequence = r4
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r7
                                 .def pulse1_length_counter = r8
                                 .def pulse1_sweep = r9 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r10
                                 .def pulse2_length_counter = r11
                                 .def pulse2_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 .def dpcm_shift = r13
                                 .def dpcm_bit_counter = r14
                                 .def dpcm_period = r15
                                 .def dpcm_length_LOW = r23
                                 .def dpcm_length_HIGH = r24
                                 .def dpcm_output_volume = r5
                                 
                                 
                                 reset:
000000 940c 1b91                 	jmp init
                                 
                                 .org RTC_CNT_vect
000006 940c 1f48                 	jmp frame_counter_routine
                                 
                                 .org TCA0_OVF_vect
00000e 940c 203b                 	jmp dpcm_sequence_routine
                                 
                                 .org TCB0_INT_vect
000018 940c 1f70                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 1fbd                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 200a                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 2015                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(35): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(50): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(81): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(84): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(92): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(98): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(105): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(114): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(121): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(126): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(140): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(142): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(155): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(201): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(202): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(203): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(204): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(205): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(206): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(207): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(209): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(212): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(362): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
001b91 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
001b92 93c0 0034                 	sts CPU_CCP, r28
001b94 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
001b95 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
001b97 2422                      	clr zero
                                 	//ONE
001b98 e0c1                      	ldi r28, 1
001b99 2e3c                      	mov one, r28
                                 	//FRAME SEQUENCE
001b9a 2c42                      	mov frame_sequence, zero
                                 
                                 	//MEMORY
001b9b e3c0                      	ldi r28, 0b00110000
001b9c 93c0 2800                 	sts pulse1_param, r28
001b9e e8c0                      	ldi r28, 0b10000000
001b9f 93c0 2801                 	sts pulse1_sweep_param, r28
001ba1 efcf                      	ldi r28, 0xFF
001ba2 93c0 2802                 	sts pulse1_timerL, r28
001ba4 93c0 2803                 	sts pulse1_timerH, r28
001ba6 93c0 2804                 	sts pulse1_length, r28
                                 
001ba8 e3c0                      	ldi r28, 0b00110000
001ba9 93c0 2808                 	sts pulse2_param, r28
001bab e8c0                      	ldi r28, 0b10000000
001bac 93c0 2809                 	sts pulse2_sweep_param, r28
001bae efcf                      	ldi r28, 0xFF
001baf 93c0 280a                 	sts pulse2_timerL, r28
001bb1 93c0 280b                 	sts pulse2_timerH, r28
001bb3 93c0 280c                 	sts pulse2_length, r28
                                 
001bb5 efcf                      	ldi r28, 0xFF
001bb6 93c0 2810                 	sts triangle_timerL, r28
001bb8 93c0 2811                 	sts triangle_timerH, r28
                                 
001bba e3c0                      	ldi r28, 0b00110000
001bbb 93c0 2813                 	sts noise_param, r28
001bbd e0cf                      	ldi r28, 0b00001111
001bbe 93c0 2814                 	sts noise_period, r28
                                 
001bc0 e0c4                      	ldi r28, 0x04
001bc1 93c0 281b                 	sts song_frame_offset, r28
001bc3 9220 281c                 	sts song_frame_offset+1, zero
001bc5 efcf                      	ldi r28, 0xFF
001bc6 93c0 2822                 	sts song_fx_Bxx, r28
001bc8 9220 2823                 	sts song_fx_Cxx, zero
001bca 9220 2824                 	sts song_fx_Dxx, zero
001bcc e6ee                      	ldi ZL, LOW(song0_frames << 1)
001bcd e0f3                      	ldi ZH, HIGH(song0_frames << 1)
001bce 93e0 2819                 	sts song_frames, ZL
001bd0 93f0 281a                 	sts song_frames+1, ZH
001bd2 91c5                      	lpm r28, Z+ //load the song size
001bd3 91d5                      	lpm r29, Z+
001bd4 93c0 281d                 	sts song_size, r28
001bd6 93d0 281e                 	sts song_size+1, r29
001bd8 91c5                      	lpm r28, Z+ //load the song tempo
001bd9 91d5                      	lpm r29, Z+
001bda 93c0 281f                 	sts song_tempo, r28
001bdc 93d0 2820                 	sts song_tempo+1, r29
001bde 9220 2821                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
001be0 91c5                      	lpm r28, Z+
001be1 91d5                      	lpm r29, Z+
001be2 0fcc                      	lsl r28
001be3 1fdd                      	rol r29
001be4 93c0 2825                 	sts pulse1_pattern, r28
001be6 93d0 2826                 	sts pulse1_pattern+1, r29
001be8 9220 2827                 	sts pulse1_pattern_delay_rows, zero
001bea 9230 2828                 	sts pulse1_pattern_delay_frames, one
001bec 9220 2829                 	sts pulse1_pattern_offset, zero
001bee 9220 282a                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
001bf0 91c5                      	lpm r28, Z+
001bf1 91d5                      	lpm r29, Z+
001bf2 0fcc                      	lsl r28
001bf3 1fdd                      	rol r29
001bf4 93c0 2876                 	sts pulse2_pattern, r28
001bf6 93d0 2877                 	sts pulse2_pattern+1, r29
001bf8 9220 2878                 	sts pulse2_pattern_delay_rows, zero
001bfa 9230 2879                 	sts pulse2_pattern_delay_frames, one
001bfc 9220 287a                 	sts pulse2_pattern_offset, zero
001bfe 9220 287b                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
001c00 91c5                      	lpm r28, Z+
001c01 91d5                      	lpm r29, Z+
001c02 0fcc                      	lsl r28
001c03 1fdd                      	rol r29
001c04 93c0 28c7                 	sts triangle_pattern, r28
001c06 93d0 28c8                 	sts triangle_pattern+1, r29
001c08 9220 28c9                 	sts triangle_pattern_delay_rows, zero
001c0a 9230 28ca                 	sts triangle_pattern_delay_frames, one
001c0c 9220 28cb                 	sts triangle_pattern_offset, zero
001c0e 9220 28cc                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
001c10 91c5                      	lpm r28, Z+
001c11 91d5                      	lpm r29, Z+
001c12 0fcc                      	lsl r28
001c13 1fdd                      	rol r29
001c14 93c0 2913                 	sts noise_pattern, r28
001c16 93d0 2914                 	sts noise_pattern+1, r29
001c18 9220 2915                 	sts noise_pattern_delay_rows, zero
001c1a 9230 2916                 	sts noise_pattern_delay_frames, one
001c1c 9220 2917                 	sts noise_pattern_offset, zero
001c1e 9220 2918                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 4
001c20 91c5                      	lpm r28, Z+
001c21 91d5                      	lpm r29, Z+
001c22 0fcc                      	lsl r28
001c23 1fdd                      	rol r29
001c24 93c0 294a                 	sts dpcm_pattern, r28
001c26 93d0 294b                 	sts dpcm_pattern+1, r29
001c28 9220 294c                 	sts dpcm_pattern_delay_rows, zero
001c2a 9230 294d                 	sts dpcm_pattern_delay_frames, one
001c2c 9220 294e                 	sts dpcm_pattern_offset, zero
001c2e 9220 294f                 	sts dpcm_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
001c30 efcf                      	ldi r28, 0xFF
001c31 9220 282d                 	sts pulse1_volume_macro_offset, zero
001c33 93c0 282e                 	sts pulse1_volume_macro_loop, r28
001c35 93c0 282f                 	sts pulse1_volume_macro_release, r28
001c37 9220 2832                 	sts pulse1_arpeggio_macro_offset, zero
001c39 93c0 2833                 	sts pulse1_arpeggio_macro_loop, r28
001c3b 93c0 2834                 	sts pulse1_arpeggio_macro_release, r28
001c3d 93c0 2835                 	sts pulse1_arpeggio_macro_mode, r28
001c3f 9220 283a                 	sts pulse1_pitch_macro_offset, zero
001c41 93c0 283b                 	sts pulse1_pitch_macro_loop, r28
001c43 93c0 283c                 	sts pulse1_pitch_macro_release, r28
001c45 9220 2840                 	sts pulse1_hi_pitch_macro_offset, zero
001c47 93c0 2841                 	sts pulse1_hi_pitch_macro_loop, r28
001c49 93c0 2842                 	sts pulse1_hi_pitch_macro_release, r28
001c4b 9220 2845                 	sts pulse1_duty_macro_offset, zero
001c4d 93c0 2846                 	sts pulse1_duty_macro_loop, r28
001c4f 93c0 2847                 	sts pulse1_duty_macro_release, r28
                                 
001c51 9220 282b                 	sts pulse1_volume_macro, zero
001c53 9220 282c                 	sts pulse1_volume_macro+1, zero
001c55 9220 2830                 	sts pulse1_arpeggio_macro, zero
001c57 9220 2831                 	sts pulse1_arpeggio_macro+1, zero
001c59 9220 2836                 	sts pulse1_total_pitch_offset, zero
001c5b 9220 2837                 	sts pulse1_total_pitch_offset+1, zero
001c5d 9220 2838                 	sts pulse1_pitch_macro, zero
001c5f 9220 2839                 	sts pulse1_pitch_macro+1, zero
001c61 9220 283d                 	sts pulse1_total_hi_pitch_offset, zero
001c63 9220 283e                 	sts pulse1_hi_pitch_macro, zero
001c65 9220 283f                 	sts pulse1_hi_pitch_macro+1, zero
001c67 9220 2843                 	sts pulse1_duty_macro, zero
001c69 9220 2844                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001c6b e00f                      	ldi pulse1_volume_divider, 0x0F
001c6c 9110 2800                 	lds pulse1_volume_decay, pulse1_param
001c6e 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001c6f 9190 2800                 	lds pulse_channel_flags, pulse1_param
001c71 7390                      	andi pulse_channel_flags, 0b00110000
001c72 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
001c73 9220 2806                 	sts pulse1_output_volume, zero
001c75 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001c77 2e8c                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001c78 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001c79 2e7c                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001c7a 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param
001c7c 9492                      	swap pulse1_sweep //swap data from high byte and low byte
001c7d 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
001c7e efcf                      	ldi r28, 0xFF
001c7f 9220 2848                 	sts pulse1_fx_0xy_sequence, zero
001c81 9220 2849                 	sts pulse1_fx_0xy_sequence+1, zero
001c83 9220 284a                 	sts pulse1_fx_1xx, zero
001c85 9220 284b                 	sts pulse1_fx_1xx+1, zero
001c87 9220 284c                 	sts pulse1_fx_1xx_total, zero
001c89 9220 284d                 	sts pulse1_fx_1xx_total+1, zero
001c8b 9220 284e                 	sts pulse1_fx_2xx, zero
001c8d 9220 284f                 	sts pulse1_fx_2xx+1, zero
001c8f 9220 2850                 	sts pulse1_fx_2xx_total, zero
001c91 9220 2851                 	sts pulse1_fx_2xx_total+1, zero
001c93 9220 2852                 	sts pulse1_fx_3xx_start, zero
001c95 9220 2853                 	sts pulse1_fx_3xx_start+1, zero
001c97 9220 2854                 	sts pulse1_fx_3xx_target, zero
001c99 9220 2855                 	sts pulse1_fx_3xx_target+1, zero
001c9b 9220 2856                 	sts pulse1_fx_3xx_speed, zero
001c9d 9220 2857                 	sts pulse1_fx_3xx_speed+1, zero
001c9f 9220 2858                 	sts pulse1_fx_3xx_total_offset, zero
001ca1 9220 2859                 	sts pulse1_fx_3xx_total_offset+1, zero
001ca3 9220 285a                 	sts pulse1_fx_4xy_speed, zero
001ca5 9220 285b                 	sts pulse1_fx_4xy_depth, zero
001ca7 9220 285c                 	sts pulse1_fx_4xy_phase, zero
001ca9 9220 285d                 	sts pulse1_fx_7xy_speed, zero
001cab 9220 285e                 	sts pulse1_fx_7xy_depth, zero
001cad 9220 285f                 	sts pulse1_fx_7xy_phase, zero
001caf 9220 2860                 	sts pulse1_fx_7xy_value, zero
001cb1 9220 2861                 	sts pulse1_fx_Axy, zero
001cb3 93c0 2862                 	sts pulse1_fx_Gxx_pre, r28
001cb5 93c0 2863                 	sts pulse1_fx_Gxx_post, r28
001cb7 9220 2864                 	sts pulse1_fx_Pxx_total, zero
001cb9 9220 2865                 	sts pulse1_fx_Pxx_total+1, zero
001cbb 9220 2866                 	sts pulse1_fx_Qxy_target_note, zero
001cbd 9220 2867                 	sts pulse1_fx_Qxy_target, zero
001cbf 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
001cc1 9220 2869                 	sts pulse1_fx_Qxy_speed, zero
001cc3 9220 286a                 	sts pulse1_fx_Qxy_speed+1, zero
001cc5 9220 286b                 	sts pulse1_fx_Qxy_total_offset, zero
001cc7 9220 286c                 	sts pulse1_fx_Qxy_total_offset+1, zero
001cc9 9220 286d                 	sts pulse1_fx_Rxy_target_note, zero
001ccb 9220 286e                 	sts pulse1_fx_Rxy_target, zero
001ccd 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
001ccf 9220 2870                 	sts pulse1_fx_Rxy_speed, zero
001cd1 9220 2871                 	sts pulse1_fx_Rxy_speed+1, zero
001cd3 9220 2872                 	sts pulse1_fx_Rxy_total_offset, zero
001cd5 9220 2873                 	sts pulse1_fx_Rxy_total_offset+1, zero
001cd7 93c0 2874                 	sts pulse1_fx_Sxx_pre, r28
001cd9 93c0 2875                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
001cdb efcf                      	ldi r28, 0xFF
001cdc 9220 287e                 	sts pulse2_volume_macro_offset, zero
001cde 93c0 287f                 	sts pulse2_volume_macro_loop, r28
001ce0 93c0 2880                 	sts pulse2_volume_macro_release, r28
001ce2 9220 2883                 	sts pulse2_arpeggio_macro_offset, zero
001ce4 93c0 2884                 	sts pulse2_arpeggio_macro_loop, r28
001ce6 93c0 2885                 	sts pulse2_arpeggio_macro_release, r28
001ce8 93c0 2886                 	sts pulse2_arpeggio_macro_mode, r28
001cea 9220 288b                 	sts pulse2_pitch_macro_offset, zero
001cec 93c0 288c                 	sts pulse2_pitch_macro_loop, r28
001cee 93c0 288d                 	sts pulse2_pitch_macro_release, r28
001cf0 9220 2891                 	sts pulse2_hi_pitch_macro_offset, zero
001cf2 93c0 2892                 	sts pulse2_hi_pitch_macro_loop, r28
001cf4 93c0 2893                 	sts pulse2_hi_pitch_macro_release, r28
001cf6 9220 2896                 	sts pulse2_duty_macro_offset, zero
001cf8 93c0 2897                 	sts pulse2_duty_macro_loop, r28
001cfa 93c0 2898                 	sts pulse2_duty_macro_release, r28
                                 
001cfc 9220 287c                 	sts pulse2_volume_macro, zero
001cfe 9220 287d                 	sts pulse2_volume_macro+1, zero
001d00 9220 2881                 	sts pulse2_arpeggio_macro, zero
001d02 9220 2882                 	sts pulse2_arpeggio_macro+1, zero
001d04 9220 2887                 	sts pulse2_total_pitch_offset, zero
001d06 9220 2888                 	sts pulse2_total_pitch_offset+1, zero
001d08 9220 2889                 	sts pulse2_pitch_macro, zero
001d0a 9220 288a                 	sts pulse2_pitch_macro+1, zero
001d0c 9220 288e                 	sts pulse2_total_hi_pitch_offset, zero
001d0e 9220 288f                 	sts pulse2_hi_pitch_macro, zero
001d10 9220 2890                 	sts pulse2_hi_pitch_macro+1, zero
001d12 9220 2894                 	sts pulse2_duty_macro, zero
001d14 9220 2895                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
001d16 e02f                      	ldi pulse2_volume_divider, 0x0F
001d17 9130 2808                 	lds pulse2_volume_decay, pulse2_param
001d19 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
001d1a 91d0 2808                 	lds r29, pulse2_param
001d1c 73d0                      	andi r29, 0b00110000
001d1d 62d0                      	sbr r29, 0b0100000 //set start flag
001d1e 95d2                      	swap r29
001d1f 2b9d                      	or pulse_channel_flags, r29
001d20 9220 280e                 	sts pulse2_output_volume, zero
001d22 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
001d24 2ebc                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
001d25 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001d26 2eac                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
001d27 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param
001d29 94c2                      	swap pulse2_sweep //swap data from high byte and low byte
001d2a 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
001d2b efcf                      	ldi r28, 0xFF
001d2c 9220 2899                 	sts pulse2_fx_0xy_sequence, zero
001d2e 9220 289a                 	sts pulse2_fx_0xy_sequence+1, zero
001d30 9220 289b                 	sts pulse2_fx_1xx, zero
001d32 9220 289c                 	sts pulse2_fx_1xx+1, zero
001d34 9220 289d                 	sts pulse2_fx_1xx_total, zero
001d36 9220 289e                 	sts pulse2_fx_1xx_total+1, zero
001d38 9220 289f                 	sts pulse2_fx_2xx, zero
001d3a 9220 28a0                 	sts pulse2_fx_2xx+1, zero
001d3c 9220 28a1                 	sts pulse2_fx_2xx_total, zero
001d3e 9220 28a2                 	sts pulse2_fx_2xx_total+1, zero
001d40 9220 28a3                 	sts pulse2_fx_3xx_start, zero
001d42 9220 28a4                 	sts pulse2_fx_3xx_start+1, zero
001d44 9220 28a5                 	sts pulse2_fx_3xx_target, zero
001d46 9220 28a6                 	sts pulse2_fx_3xx_target+1, zero
001d48 9220 28a7                 	sts pulse2_fx_3xx_speed, zero
001d4a 9220 28a8                 	sts pulse2_fx_3xx_speed+1, zero
001d4c 9220 28a9                 	sts pulse2_fx_3xx_total_offset, zero
001d4e 9220 28aa                 	sts pulse2_fx_3xx_total_offset+1, zero
001d50 9220 28ab                 	sts pulse2_fx_4xy_speed, zero
001d52 9220 28ac                 	sts pulse2_fx_4xy_depth, zero
001d54 9220 28ad                 	sts pulse2_fx_4xy_phase, zero
001d56 9220 28ae                 	sts pulse2_fx_7xy_speed, zero
001d58 9220 28af                 	sts pulse2_fx_7xy_depth, zero
001d5a 9220 28b0                 	sts pulse2_fx_7xy_phase, zero
001d5c 9220 28b1                 	sts pulse2_fx_7xy_value, zero
001d5e 9220 28b2                 	sts pulse2_fx_Axy, zero
001d60 93c0 28b3                 	sts pulse2_fx_Gxx_pre, r28
001d62 93c0 28b4                 	sts pulse2_fx_Gxx_post, r28
001d64 9220 28b5                 	sts pulse2_fx_Pxx_total, zero
001d66 9220 28b6                 	sts pulse2_fx_Pxx_total+1, zero
001d68 9220 28b7                 	sts pulse2_fx_Qxy_target_note, zero
001d6a 9220 28b8                 	sts pulse2_fx_Qxy_target, zero
001d6c 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
001d6e 9220 28ba                 	sts pulse2_fx_Qxy_speed, zero
001d70 9220 28bb                 	sts pulse2_fx_Qxy_speed+1, zero
001d72 9220 28bc                 	sts pulse2_fx_Qxy_total_offset, zero
001d74 9220 28bd                 	sts pulse2_fx_Qxy_total_offset+1, zero
001d76 9220 28be                 	sts pulse2_fx_Rxy_target_note, zero
001d78 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
001d7a 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
001d7c 9220 28c1                 	sts pulse2_fx_Rxy_speed, zero
001d7e 9220 28c2                 	sts pulse2_fx_Rxy_speed+1, zero
001d80 9220 28c3                 	sts pulse2_fx_Rxy_total_offset, zero
001d82 9220 28c4                 	sts pulse2_fx_Rxy_total_offset+1, zero
001d84 93c0 28c5                 	sts pulse2_fx_Sxx_pre, r28
001d86 93c0 28c6                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001d88 efcf                      	ldi r28, 0xFF
001d89 9220 28cf                 	sts triangle_volume_macro_offset, zero
001d8b 93c0 28d0                 	sts triangle_volume_macro_loop, r28
001d8d 93c0 28d1                 	sts triangle_volume_macro_release, r28
001d8f 9220 28d4                 	sts triangle_arpeggio_macro_offset, zero
001d91 93c0 28d5                 	sts triangle_arpeggio_macro_loop, r28
001d93 93c0 28d6                 	sts triangle_arpeggio_macro_release, r28
001d95 93c0 28d7                 	sts triangle_arpeggio_macro_mode, r28
001d97 9220 28dc                 	sts triangle_pitch_macro_offset, zero
001d99 93c0 28dd                 	sts triangle_pitch_macro_loop, r28
001d9b 93c0 28de                 	sts triangle_pitch_macro_release, r28
001d9d 9220 28e2                 	sts triangle_hi_pitch_macro_offset, zero
001d9f 93c0 28e3                 	sts triangle_hi_pitch_macro_loop, r28
001da1 93c0 28e4                 	sts triangle_hi_pitch_macro_release, r28
001da3 9220 28e7                 	sts triangle_duty_macro_offset, zero
001da5 93c0 28e8                 	sts triangle_duty_macro_loop, r28
001da7 93c0 28e9                 	sts triangle_duty_macro_release, r28
                                 
001da9 9220 28cd                 	sts triangle_volume_macro, zero
001dab 9220 28ce                 	sts triangle_volume_macro+1, zero
001dad 9220 28d2                 	sts triangle_arpeggio_macro, zero
001daf 9220 28d3                 	sts triangle_arpeggio_macro+1, zero
001db1 9220 28d8                 	sts triangle_total_pitch_offset, zero
001db3 9220 28d9                 	sts triangle_total_pitch_offset+1, zero
001db5 9220 28da                 	sts triangle_pitch_macro, zero
001db7 9220 28db                 	sts triangle_pitch_macro+1, zero
001db9 9220 28df                 	sts triangle_total_hi_pitch_offset, zero
001dbb 9220 28e0                 	sts triangle_hi_pitch_macro, zero
001dbd 9220 28e1                 	sts triangle_hi_pitch_macro+1, zero
001dbf 9220 28e5                 	sts triangle_duty_macro, zero
001dc1 9220 28e6                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
001dc3 e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
001dc4 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
001dc5 efcf                      	ldi r28, 0xFF
001dc6 9220 28ea                 	sts triangle_fx_0xy_sequence, zero
001dc8 9220 28eb                 	sts triangle_fx_0xy_sequence+1, zero
001dca 9220 28ec                 	sts triangle_fx_1xx, zero
001dcc 9220 28ed                 	sts triangle_fx_1xx+1, zero
001dce 9220 28ee                 	sts triangle_fx_1xx_total, zero
001dd0 9220 28ef                 	sts triangle_fx_1xx_total+1, zero
001dd2 9220 28f0                 	sts triangle_fx_2xx, zero
001dd4 9220 28f1                 	sts triangle_fx_2xx+1, zero
001dd6 9220 28f2                 	sts triangle_fx_2xx_total, zero
001dd8 9220 28f3                 	sts triangle_fx_2xx_total+1, zero
001dda 9220 28f4                 	sts triangle_fx_3xx_start, zero
001ddc 9220 28f5                 	sts triangle_fx_3xx_start+1, zero
001dde 9220 28f6                 	sts triangle_fx_3xx_target, zero
001de0 9220 28f7                 	sts triangle_fx_3xx_target+1, zero
001de2 9220 28f8                 	sts triangle_fx_3xx_speed, zero
001de4 9220 28f9                 	sts triangle_fx_3xx_speed+1, zero
001de6 9220 28fa                 	sts triangle_fx_3xx_total_offset, zero
001de8 9220 28fb                 	sts triangle_fx_3xx_total_offset+1, zero
001dea 9220 28fc                 	sts triangle_fx_4xy_speed, zero
001dec 9220 28fd                 	sts triangle_fx_4xy_depth, zero
001dee 9220 28fe                 	sts triangle_fx_4xy_phase, zero
001df0 93c0 28ff                 	sts triangle_fx_Gxx_pre, r28
001df2 93c0 2900                 	sts triangle_fx_Gxx_post, r28
001df4 9220 2901                 	sts triangle_fx_Pxx_total, zero
001df6 9220 2902                 	sts triangle_fx_Pxx_total+1, zero
001df8 9220 2903                 	sts triangle_fx_Qxy_target_note, zero
001dfa 9220 2904                 	sts triangle_fx_Qxy_target, zero
001dfc 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
001dfe 9220 2906                 	sts triangle_fx_Qxy_speed, zero
001e00 9220 2907                 	sts triangle_fx_Qxy_speed+1, zero
001e02 9220 2908                 	sts triangle_fx_Qxy_total_offset, zero
001e04 9220 2909                 	sts triangle_fx_Qxy_total_offset+1, zero
001e06 9220 290a                 	sts triangle_fx_Rxy_target_note, zero
001e08 9220 290b                 	sts triangle_fx_Rxy_target, zero
001e0a 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
001e0c 9220 290d                 	sts triangle_fx_Rxy_speed, zero
001e0e 9220 290e                 	sts triangle_fx_Rxy_speed+1, zero
001e10 9220 290f                 	sts triangle_fx_Rxy_total_offset, zero
001e12 9220 2910                 	sts triangle_fx_Rxy_total_offset+1, zero
001e14 93c0 2911                 	sts triangle_fx_Sxx_pre, r28
001e16 93c0 2912                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
001e18 efcf                      	ldi r28, 0xFF
001e19 9220 291b                 	sts noise_volume_macro_offset, zero
001e1b 93c0 291c                 	sts noise_volume_macro_loop, r28
001e1d 93c0 291d                 	sts noise_volume_macro_release, r28
001e1f 9220 2920                 	sts noise_arpeggio_macro_offset, zero
001e21 93c0 2921                 	sts noise_arpeggio_macro_loop, r28
001e23 93c0 2922                 	sts noise_arpeggio_macro_release, r28
001e25 93c0 2923                 	sts noise_arpeggio_macro_mode, r28
001e27 9220 2928                 	sts noise_pitch_macro_offset, zero
001e29 93c0 2929                 	sts noise_pitch_macro_loop, r28
001e2b 93c0 292a                 	sts noise_pitch_macro_release, r28
001e2d 9220 292e                 	sts noise_hi_pitch_macro_offset, zero
001e2f 93c0 292f                 	sts noise_hi_pitch_macro_loop, r28
001e31 93c0 2930                 	sts noise_hi_pitch_macro_release, r28
001e33 9220 2933                 	sts noise_duty_macro_offset, zero
001e35 93c0 2934                 	sts noise_duty_macro_loop, r28
001e37 93c0 2935                 	sts noise_duty_macro_release, r28
                                 
001e39 9220 2919                 	sts noise_volume_macro, zero
001e3b 9220 291a                 	sts noise_volume_macro+1, zero
001e3d 9220 291e                 	sts noise_arpeggio_macro, zero
001e3f 9220 291f                 	sts noise_arpeggio_macro+1, zero
001e41 9220 2924                 	sts noise_total_pitch_offset, zero
001e43 9220 2925                 	sts noise_total_pitch_offset+1, zero
001e45 9220 2926                 	sts noise_pitch_macro, zero
001e47 9220 2927                 	sts noise_pitch_macro+1, zero
001e49 9220 292b                 	sts noise_total_hi_pitch_offset, zero
001e4b 9220 292c                 	sts noise_hi_pitch_macro, zero
001e4d 9220 292d                 	sts noise_hi_pitch_macro+1, zero
001e4f 9220 2931                 	sts noise_duty_macro, zero
001e51 9220 2932                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
001e53 9220 2816                 	sts noise_output_volume, zero
001e55 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001e57 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001e58 2f5c                      	mov noise_sequence_LOW, r28
001e59 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
001e5a efcf                      	ldi r28, 0xFF
001e5b 9220 2936                 	sts noise_fx_0xy_sequence, zero
001e5d 9220 2937                 	sts noise_fx_0xy_sequence+1, zero
001e5f 9220 2938                 	sts noise_fx_1xx, zero
001e61 9220 2939                 	sts noise_fx_1xx_total, zero
001e63 9220 293a                 	sts noise_fx_2xx, zero
001e65 9220 293b                 	sts noise_fx_2xx_total, zero
001e67 9220 293c                 	sts noise_fx_4xy_speed, zero
001e69 9220 293d                 	sts noise_fx_4xy_depth, zero
001e6b 9220 293e                 	sts noise_fx_4xy_phase, zero
001e6d 9220 293f                 	sts noise_fx_4xy_offset, zero
001e6f 9220 2940                 	sts noise_fx_7xy_speed, zero
001e71 9220 2941                 	sts noise_fx_7xy_depth, zero
001e73 9220 2942                 	sts noise_fx_7xy_phase, zero
001e75 9220 2943                 	sts noise_fx_7xy_value, zero
001e77 9220 2944                 	sts noise_fx_Axy, zero
001e79 93c0 2945                 	sts noise_fx_Gxx_pre, r28
001e7b 93c0 2946                 	sts noise_fx_Gxx_post, r28
001e7d 9220 2947                 	sts noise_fx_Pxx_total, zero
001e7f 93c0 2948                 	sts noise_fx_Sxx_pre, r28
001e81 93c0 2949                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 4 VOLUME
001e83 2c52                      	mov dpcm_output_volume, zero
                                 
                                 	//CHANNEL 4 SAMPLE
001e84 9220 2950                 	sts dpcm_sample, zero
001e86 9220 2951                 	sts dpcm_sample+1, zero
001e88 9220 2952                 	sts dpcm_sample_offset, zero
001e8a 9220 2953                 	sts dpcm_sample_offset+1, zero
001e8c 2cd2                      	mov dpcm_shift, zero
001e8d 2ce2                      	mov dpcm_bit_counter, zero
001e8e 2cf2                      	mov dpcm_period, zero
001e8f 2d72                      	mov dpcm_length_LOW, zero
001e90 2d82                      	mov dpcm_length_HIGH, zero
                                 
                                 	//CHANNEL 4 FX
001e91 93c0 2945                 	sts noise_fx_Gxx_pre, r28
001e93 93c0 2946                 	sts noise_fx_Gxx_post, r28
001e95 93c0 2948                 	sts noise_fx_Sxx_pre, r28
001e97 93c0 2949                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
001e99 efcf                      	ldi r28, 0xFF
001e9a b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
001e9b e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
001e9c 93c0 0a81                 	sts TCB0_CTRLB, r28
001e9e e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
001e9f 93c0 0a85                 	sts TCB0_INTCTRL, r28
001ea1 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001ea3 93c0 0a8c                 	sts TCB0_CCMPL, r28
001ea5 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
001ea7 93c0 0a8d                 	sts TCB0_CCMPH, r28
001ea9 e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001eaa 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001eac e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001ead 93b0 0a91                 	sts TCB1_CTRLB, r27
001eaf e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001eb0 93b0 0a95                 	sts TCB1_INTCTRL, r27
001eb2 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001eb4 93b0 0a9c                 	sts TCB1_CCMPL, r27
001eb6 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001eb8 93b0 0a9d                 	sts TCB1_CCMPH, r27
001eba e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001ebb 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001ebd e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001ebe 93b0 0aa1                 	sts TCB2_CTRLB, r27
001ec0 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
001ec1 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
001ec3 93b0 0aac                 	sts TCB2_CCMPL, r27
001ec5 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
001ec7 93b0 0aad                 	sts TCB2_CCMPH, r27
001ec9 e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001eca 93b0 0aa0                 	sts TCB2_CTRLA, r27
001ecc 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
001ecd e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001ece 93b0 0ab1                 	sts TCB3_CTRLB, r27
001ed0 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001ed1 93b0 0ab5                 	sts TCB3_INTCTRL, r27
001ed3 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
001ed5 93b0 0abc                 	sts TCB3_CCMPL, r27
001ed7 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
001ed9 93b0 0abd                 	sts TCB3_CCMPH, r27
001edb e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001edc 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 	//DPCM
001ede e0c0                      	ldi r28, TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
001edf 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
001ee1 e0c1                      	ldi r28, TCA_SINGLE_OVF_bm //enable overflow interrupts
001ee2 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001ee4 e0c2                      	ldi r28, TCA_SINGLE_CLKSEL_DIV2_gc //use prescaler divider of 2
001ee5 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//RTC
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Interrupts will be setup to interrupt every 240 Hz clock
                                 	//The 4th consecutive interrupt will clock the sound driver every 60 Hz, in which new audio data is read and written to the registers
                                 	//1st and 2nd interrupt will execute sequence 0 and 2. 3rd and 4th interrupt will execute sequence 1 and 3.
                                 	//Timer period Calculation: ((1/(tempo*4)) * 32768/2)
                                 	//The RTC timer is clocked at 32768 Hz
                                 	//The /2 comes from the prescaler divider used
                                 	//NOTE: The frame counter clock will not always be 60 Hz, and will depend on the song_tempo.
001ee7 e0b0                      	ldi r27, RTC_CLKSEL_INT32K_gc //internal 32kHz oscillator
001ee8 93b0 0147                 	sts RTC_CLKSEL, r27
001eea 91b0 281f                 	lds r27, song_tempo
001eec 91c0 2820                 	lds r28, song_tempo+1
001eee 93b0 014a                 	sts RTC_PER, r27
001ef0 93c0 014b                 	sts RTC_PER + 1, r28
001ef2 e0b1                      	ldi r27, RTC_OVF_bm //overflow interrupts
001ef3 93b0 0142                 	sts RTC_INTCTRL, r27
001ef5 e0b9                      	ldi r27, RTC_PRESCALER_DIV2_gc | RTC_PITEN_bm //use prescaler divider of 16 and enable RTC
001ef6 93b0 0140                 	sts RTC_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
001ef8 91c0 2806                 	lds r28, pulse1_output_volume
001efa 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
001efc fe70                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
001efd c015                      	rjmp volume_mixer_pulse1_off
                                 
001efe 1482                      	cp pulse1_length_counter, zero //if length is zero, return
001eff f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
001f00 91e0 0a8c                 	lds r30, TCB0_CCMPL
001f02 e5f9                      	ldi r31, 0x59
001f03 17ef                      	cp r30, r31
001f04 91e0 0a8d                 	lds r30, TCB0_CCMPH
001f06 e0f0                      	ldi r31, 0x00
001f07 07ef                      	cpc r30, r31
001f08 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $595A
001f09 91e0 0a8c                 	lds r30, TCB0_CCMPL
001f0b e5fa                      	ldi r31, 0x5A
001f0c 17ef                      	cp r30, r31
001f0d 91e0 0a8d                 	lds r30, TCB0_CCMPH
001f0f e5f9                      	ldi r31, 0x59
001f10 07ef                      	cpc r30, r31
001f11 f408                      	brsh volume_mixer_pulse1_off
001f12 c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
001f13 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
001f14 fea0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
001f15 c015                      	rjmp volume_mixer_pulse2_off
                                 
001f16 14b2                      	cp pulse2_length_counter, zero //if length is zero, return
001f17 f099                      	breq volume_mixer_pulse2_off
                                 
001f18 91e0 0a9c                 	lds r30, TCB1_CCMPL
001f1a e5f9                      	ldi r31, 0x59
001f1b 17ef                      	cp r30, r31
001f1c 91e0 0a9d                 	lds r30, TCB1_CCMPH
001f1e e0f0                      	ldi r31, 0x00
001f1f 07ef                      	cpc r30, r31
001f20 f050                      	brlo volume_mixer_pulse2_off
                                 
001f21 91e0 0a9c                 	lds r30, TCB1_CCMPL
001f23 e5fa                      	ldi r31, 0x5A
001f24 17ef                      	cp r30, r31
001f25 91e0 0a9d                 	lds r30, TCB1_CCMPH
001f27 e5f9                      	ldi r31, 0x59
001f28 07ef                      	cpc r30, r31
001f29 f408                      	brsh volume_mixer_pulse2_off
001f2a c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
001f2b 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
001f2c 0fcd                      	add r28, r29
001f2d e8e2                      	ldi ZL, LOW(pulse_volume_table << 1)
001f2e e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
001f2f 0fec                      	add ZL, r28
001f30 1df2                      	adc ZH, zero
001f31 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
001f32 2fd4                      	mov r29, triangle_sequence
001f33 fdd4                      	sbrc r29, 4 //check 5th bit
001f34 95d0                      	com r29
001f35 70df                      	andi r29, 0x0F
001f36 2fed                      	mov r30, r29
001f37 0fde                      	add r29, r30 //multiply the triangle volume by 3
001f38 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_dpcm:
001f39 0dd5                      	add r29, dpcm_output_volume
                                 
                                 volume_mixer_tnd_noise:
001f3a ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
001f3b c004                      	rjmp volume_mixer_tnd_out
001f3c 91e0 2816                 	lds r30, noise_output_volume
001f3e 0fee                      	lsl r30 //multiply noise volume by 2
001f3f 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
001f40 eae2                      	ldi ZL, LOW(tnd_volume_table << 1)
001f41 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
001f42 0fed                      	add ZL, r29
001f43 1df2                      	adc ZH, zero
001f44 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
001f45 0fcd                      	add r28, r29
001f46 b9c1                      	out VPORTA_OUT, r28
001f47 cfb0                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 frame_counter_routine:
001f48 b7bf                      	in r27, CPU_SREG
001f49 93bf                      	push r27
001f4a 94f8                      	cli
                                 
001f4b 2da4                      	mov r26, frame_sequence
001f4c 0c43                      	add frame_sequence, one
001f4d 30a0                      	cpi r26, 0x00
001f4e f029                      	breq sequence_0_2
001f4f 30a1                      	cpi r26, 0x01
001f50 f059                      	breq sequence_1_3
001f51 30a2                      	cpi r26, 0x02
001f52 f009                      	breq sequence_0_2
001f53 c12f                      	rjmp sound_driver
                                 
                                 sequence_0_2:
                                 	//ENVELOPE
001f54 d050                      	rcall pulse1_envelope_routine
001f55 d09c                      	rcall pulse2_envelope_routine
                                 
001f56 e0b3                      	ldi r27, RTC_CMP_bm | RTC_OVF_bm //clear OVF flag
001f57 93b0 0143                 	sts RTC_INTFLAGS, r27
001f59 91bf                      	pop r27
001f5a bfbf                      	out CPU_SREG, r27
001f5b 9518                      	reti
                                 
                                 sequence_1_3:
                                 	//ENVELOPE
001f5c d048                      	rcall pulse1_envelope_routine
001f5d d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
001f5e fc93                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
001f5f d01b                      	rcall pulse1_sweep_routine
001f60 fcc3                      	sbrc pulse2_sweep, 3
001f61 d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
001f62 fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
001f63 c002                      	rjmp sequence_1_3_pulse2_length
001f64 1082                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001f65 948a                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
001f66 fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001f67 c002                      	rjmp sequence_1_3_exit
001f68 10b2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001f69 94ba                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001f6a e0b1                      	ldi r27, RTC_OVF_bm //clear OVF flag
001f6b 93b0 0143                 	sts RTC_INTFLAGS, r27
001f6d 91bf                      	pop r27
001f6e bfbf                      	out CPU_SREG, r27
001f6f 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001f70 b7bf                      	in r27, CPU_SREG
001f71 93bf                      	push r27
001f72 94f8                      	cli
                                 
001f73 0c77                      	lsl pulse1_sequence //shifts sequence to the left
001f74 1c72                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001f75 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001f76 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001f78 91bf                      	pop r27
001f79 bfbf                      	out CPU_SREG, r27
001f7a 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001f7b 2db9                      	mov r27, pulse1_sweep
001f7c 70b7                      	andi r27, 0x07 //mask for period divider bits
001f7d f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001f7e 93df                      	push r29
001f7f 2dd9                      	mov r29, pulse1_sweep
001f80 95d2                      	swap r29
001f81 70d7                      	andi r29, 0x07 //mask for shift bits
001f82 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001f83 91df                      	pop r29
001f84 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001f85 91a0 0a8c                 	lds r26, TCB0_CCMPL
001f87 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001f89 95b6                      	lsr r27
001f8a 95a7                      	ror r26
001f8b 95da                      	dec r29
001f8c f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001f8d fe97                      	sbrs pulse1_sweep, 7 //check the negate flag
001f8e c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001f8f 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001f90 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001f91 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001f93 0fad                      	add r26, r29
001f94 91d0 0a8d                 	lds r29, TCB0_CCMPH
001f96 1fbd                      	adc r27, r29
                                 
001f97 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001f99 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001f9b 91df                      	pop r29
001f9c c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001f9d 949a                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001f9e ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
001f9f 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001fa0 9090 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001fa2 9492                      	swap pulse1_sweep //bring data from high byte to low byte
001fa3 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
001fa4 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
001fa5 fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
001fa6 c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001fa7 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001fa8 f011                      	breq PC+3 //if the divider == 0, check loop flag
001fa9 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001faa 9508                      	ret
                                 
001fab 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001fad 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001fae ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001faf c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001fb0 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001fb1 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001fb2 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001fb3 f409                      	brne PC+2 //if decay != 0, go decrement
001fb4 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001fb5 951a                      	dec pulse1_volume_decay
001fb6 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001fb7 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
001fb8 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001fba 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001fbb e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001fbc 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
001fbd b7bf                      	in r27, CPU_SREG
001fbe 93bf                      	push r27
001fbf 94f8                      	cli
                                 
001fc0 0caa                      	lsl pulse2_sequence //shifts sequence to the left
001fc1 1ca2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001fc2 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
001fc3 93b0 0a96                 	sts TCB1_INTFLAGS, r27
001fc5 91bf                      	pop r27
001fc6 bfbf                      	out CPU_SREG, r27
001fc7 9518                      	reti
                                 
                                 pulse2_sweep_routine:
001fc8 2dbc                      	mov r27, pulse2_sweep
001fc9 70b7                      	andi r27, 0x07 //mask for period divider bits
001fca f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001fcb 93df                      	push r29
001fcc 2ddc                      	mov r29, pulse2_sweep
001fcd 95d2                      	swap r29
001fce 70d7                      	andi r29, 0x07 //mask for shift bits
001fcf f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001fd0 91df                      	pop r29
001fd1 c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
001fd2 91a0 0a9c                 	lds r26, TCB1_CCMPL
001fd4 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
001fd6 95b6                      	lsr r27
001fd7 95a7                      	ror r26
001fd8 95da                      	dec r29
001fd9 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001fda fec7                      	sbrs pulse2_sweep, 7 //check the negate flag
001fdb c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001fdc 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001fdd 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001fde 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001fe0 0fad                      	add r26, r29
001fe1 91d0 0a9d                 	lds r29, TCB1_CCMPH
001fe3 1fbd                      	adc r27, r29
                                 
001fe4 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
001fe6 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001fe8 91df                      	pop r29
001fe9 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
001fea 94ca                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
001feb ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
001fec 9508                      	ret
                                 
                                 pulse2_sweep_reload:
001fed 90c0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001fef 94c2                      	swap pulse2_sweep //bring data from high byte to low byte
001ff0 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
001ff1 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
001ff2 fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
001ff3 c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
001ff4 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
001ff5 f011                      	breq PC+3 //if the divider == 0, check loop flag
001ff6 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
001ff7 9508                      	ret
                                 
001ff8 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
001ffa 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001ffb ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
001ffc c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001ffd e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001ffe 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001fff 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
002000 f409                      	brne PC+2 //if decay != 0, go decrement
002001 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
002002 953a                      	dec pulse2_volume_decay
002003 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
002004 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
002005 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
002007 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
002008 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
002009 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
00200a b7bf                      	in r27, CPU_SREG
00200b 93bf                      	push r27
00200c 94f8                      	cli
                                 
00200d 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
00200e 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
00200f e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
002010 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
002012 91bf                      	pop r27
002013 bfbf                      	out CPU_SREG, r27
002014 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
002015 b7bf                      	in r27, CPU_SREG
002016 93bf                      	push r27
002017 94f8                      	cli
                                 
002018 2fa5                      	mov r26, noise_sequence_LOW
002019 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
00201a c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
00201b 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
00201c 27a5                      	eor r26, noise_sequence_LOW
00201d fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
00201e c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
00201f 9566                      	lsr noise_sequence_HIGH
002020 9557                      	ror noise_sequence_LOW
002021 c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
002022 9566                      	lsr noise_sequence_HIGH
002023 9557                      	ror noise_sequence_LOW
002024 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
002025 c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
002026 0faa                      	lsl r26
002027 1faa                      	rol r26
002028 1faa                      	rol r26 //move the 6th bit to the 0th bit place
002029 27a5                      	eor r26, noise_sequence_LOW
00202a fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
00202b c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
00202c 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
00202d 9566                      	lsr noise_sequence_HIGH
00202e 9557                      	ror noise_sequence_LOW
00202f 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
002030 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
002031 9566                      	lsr noise_sequence_HIGH
002032 9557                      	ror noise_sequence_LOW
002033 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
002034 c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
002035 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
002036 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
002038 91bf                      	pop r27
002039 bfbf                      	out CPU_SREG, r27
00203a 9518                      	reti
                                 
                                 //DPCM ROUTINES
                                 dpcm_sequence_routine:
00203b b7bf                      	in r27, CPU_SREG
00203c 93bf                      	push r27
00203d 94f8                      	cli
                                 
00203e 91e0 2950                 	lds ZL, dpcm_sample
002040 91f0 2951                 	lds ZH, dpcm_sample+1
                                 
                                 dpcm_check_counter:
002042 14e2                      	cp dpcm_bit_counter, zero
002043 f009                      	breq dpcm_check_length
002044 c004                      	rjmp dpcm_shift_register
                                 dpcm_check_length:
002045 1572                      	cp dpcm_length_LOW, zero
002046 0582                      	cpc dpcm_length_HIGH, zero
002047 f129                      	breq dpcm_stop
002048 c004                      	rjmp dpcm_next_byte
                                 
                                 dpcm_shift_register:
002049 18e3                      	sub dpcm_bit_counter, one
00204a fcd0                      	sbrc dpcm_shift, 0
00204b c013                      	rjmp dpcm_volume_add
00204c c019                      	rjmp dpcm_volume_sub
                                 
                                 dpcm_next_byte:
00204d 91a0 2952                 	lds r26, dpcm_sample_offset
00204f 91b0 2953                 	lds r27, dpcm_sample_offset+1
002051 0da3                      	add r26, one //increment sample offset
002052 1db2                      	adc r27, zero
002053 1973                      	sub dpcm_length_LOW, one //decrement dpcm sample length
002054 0982                      	sbc dpcm_length_HIGH, zero
002055 93a0 2952                 	sts dpcm_sample_offset, r26
002057 93b0 2953                 	sts dpcm_sample_offset+1, r27
                                 
002059 0fea                      	add ZL, r26 //offset data in sample table
00205a 1ffb                      	adc ZH, r27
00205b 90d4                      	lpm dpcm_shift, Z //load data byte into dpcm shift register
00205c e0a8                      	ldi r26, 0x08
00205d 2eea                      	mov dpcm_bit_counter, r26 //reset bit counter to 8
00205e cfea                      	rjmp dpcm_shift_register
                                 
                                 dpcm_volume_add:
00205f 94d6                      	lsr dpcm_shift //right shift
002060 e7ae                      	ldi r26, 0x7E //0x7E + 0x02 is the highest volume DPCM can have
002061 165a                      	cp dpcm_output_volume, r26
002062 f470                      	brsh dpcm_sequence_exit //exit dpcm sequence if needed to prevent overflow
002063 0c53                      	add dpcm_output_volume, one //add 2
002064 0c53                      	add dpcm_output_volume, one
002065 c00b                      	rjmp dpcm_sequence_exit
                                 dpcm_volume_sub:
002066 94d6                      	lsr dpcm_shift //right shift
002067 e0a2                      	ldi r26, 0x02 // 0x02 - 0x02 is the lowest volume DPCM can have
002068 165a                      	cp dpcm_output_volume, r26
002069 f038                      	brlo dpcm_sequence_exit //exit dpcm sequence if needed to prevent overflow
00206a 1853                      	sub dpcm_output_volume, one //subtract 2
00206b 1853                      	sub dpcm_output_volume, one
00206c c004                      	rjmp dpcm_sequence_exit
                                 
                                 dpcm_stop:
00206d e0a2                      	ldi r26, TCA_SINGLE_CLKSEL_DIV2_gc //use prescale divider of 2 and disable timer
00206e 93a0 0a00                 	sts TCA0_SINGLE_CTRLA, r26
002070 c000                      	rjmp dpcm_sequence_exit
                                 
                                 dpcm_sequence_exit:
002071 e0b1                      	ldi r27, TCA_SINGLE_OVF_bm //clear OVF flag
002072 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
002074 91bf                      	pop r27
002075 bfbf                      	out CPU_SREG, r27
002076 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
002077 ece0                      	ldi ZL, LOW(length << 1)
002078 e7f4                      	ldi ZH, HIGH(length << 1)
002079 0fed                      	add ZL, r29
00207a 1df2                      	adc ZH, zero
00207b 91d4                      	lpm r29, Z
00207c 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
00207d eee0                      	ldi ZL, LOW(sequences << 1)
00207e e7f4                      	ldi ZH, HIGH(sequences << 1)
00207f 0fed                      	add ZL, r29
002080 1df2                      	adc ZH, zero
002081 91d4                      	lpm r29, Z
002082 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
002083 2c42                      	mov frame_sequence, zero
002084 93cf                      	push r28
002085 93df                      	push r29
002086 93ef                      	push r30
002087 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
002088 91a0 2822                 	lds r26, song_fx_Bxx
00208a 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
00208b f4a9                      	brne sound_driver_fx_Bxx_routine
00208c 91a0 2823                 	lds r26, song_fx_Cxx
00208e 11a2                      	cpse r26, zero
00208f c0a3                      	rjmp sound_driver_fx_Cxx_routine
002090 91a0 2824                 	lds r26, song_fx_Dxx
002092 11a2                      	cpse r26, zero
002093 c0ae                      	rjmp sound_driver_fx_Dxx_routine
                                 
002094 91a0 281b                 	lds r26, song_frame_offset
002096 91b0 281c                 	lds r27, song_frame_offset+1
002098 91c0 281d                 	lds r28, song_size
00209a 91d0 281e                 	lds r29, song_size+1
00209c 17ac                      	cp r26, r28
00209d 07bd                      	cpc r27, r29
00209e f408                      	brsh sound_driver_fx_song_loop
00209f c131                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
0020a0 e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
0020a1 91e0 2819                 	lds ZL, song_frames
0020a3 91f0 281a                 	lds ZH, song_frames+1
0020a5 27cc                      	clr r28 //initialize r29:r28 to 0
0020a6 27dd                      	clr r29
0020a7 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
0020a8 95aa                      	dec r26
0020a9 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
0020aa 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
0020ab cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
0020ac 9624                      	adiw r29:r28, 4 //add 4 to skip the first 4 bytes (first 4 bytes is the song size and tempo)
0020ad 93c0 281b                 	sts song_frame_offset, r28
0020af 93d0 281c                 	sts song_frame_offset+1, r29
0020b1 0fec                      	add ZL, r28
0020b2 1ffd                      	adc ZH, r29
                                 
0020b3 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
0020b4 91b5                      	lpm r27, Z+
0020b5 0faa                      	lsl r26
0020b6 1fbb                      	rol r27
0020b7 93a0 2825                 	sts pulse1_pattern, r26
0020b9 93b0 2826                 	sts pulse1_pattern+1, r27
0020bb 91a5                      	lpm r26, Z+
0020bc 91b5                      	lpm r27, Z+
0020bd 0faa                      	lsl r26
0020be 1fbb                      	rol r27
0020bf 93a0 2876                 	sts pulse2_pattern, r26
0020c1 93b0 2877                 	sts pulse2_pattern+1, r27
0020c3 91a5                      	lpm r26, Z+
0020c4 91b5                      	lpm r27, Z+
0020c5 0faa                      	lsl r26
0020c6 1fbb                      	rol r27
0020c7 93a0 28c7                 	sts triangle_pattern, r26
0020c9 93b0 28c8                 	sts triangle_pattern+1, r27
0020cb 91a5                      	lpm r26, Z+
0020cc 91b5                      	lpm r27, Z+
0020cd 0faa                      	lsl r26
0020ce 1fbb                      	rol r27
0020cf 93a0 2913                 	sts noise_pattern, r26
0020d1 93b0 2914                 	sts noise_pattern+1, r27
0020d3 91a5                      	lpm r26, Z+
0020d4 91b5                      	lpm r27, Z+
0020d5 0faa                      	lsl r26
0020d6 1fbb                      	rol r27
0020d7 93a0 294a                 	sts dpcm_pattern, r26
0020d9 93b0 294b                 	sts dpcm_pattern+1, r27
                                 
0020db 9220 2829                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0020dd 9220 282a                 	sts pulse1_pattern_offset+1, zero
0020df 9220 2827                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0020e1 9230 2828                 	sts pulse1_pattern_delay_frames, one
0020e3 9220 287a                 	sts pulse2_pattern_offset, zero
0020e5 9220 287b                 	sts pulse2_pattern_offset+1, zero
0020e7 9220 2878                 	sts pulse2_pattern_delay_rows, zero
0020e9 9230 2879                 	sts pulse2_pattern_delay_frames, one
0020eb 9220 28cb                 	sts triangle_pattern_offset, zero
0020ed 9220 28cc                 	sts triangle_pattern_offset+1, zero
0020ef 9220 28c9                 	sts triangle_pattern_delay_rows, zero
0020f1 9230 28ca                 	sts triangle_pattern_delay_frames, one
0020f3 9220 2917                 	sts noise_pattern_offset, zero
0020f5 9220 2918                 	sts noise_pattern_offset+1, zero
0020f7 9220 2915                 	sts noise_pattern_delay_rows, zero
0020f9 9230 2916                 	sts noise_pattern_delay_frames, one
0020fb 9220 294e                 	sts dpcm_pattern_offset, zero
0020fd 9220 294e                 	sts dpcm_pattern_offset, zero
0020ff 9220 294c                 	sts dpcm_pattern_delay_rows, zero
002101 9230 294d                 	sts dpcm_pattern_delay_frames, one
                                 
002103 efaf                      	ldi r26, 0xFF
002104 93a0 2862                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
002106 93a0 2863                 	sts pulse1_fx_Gxx_post, r26
002108 93a0 2874                 	sts pulse1_fx_Sxx_pre, r26
00210a 93a0 2875                 	sts pulse1_fx_Sxx_post, r26
00210c 93a0 28b3                 	sts pulse2_fx_Gxx_pre, r26
00210e 93a0 28b4                 	sts pulse2_fx_Gxx_post, r26
002110 93a0 28c5                 	sts pulse2_fx_Sxx_pre, r26
002112 93a0 28c6                 	sts pulse2_fx_Sxx_post, r26
002114 93a0 28ff                 	sts triangle_fx_Gxx_pre, r26
002116 93a0 2900                 	sts triangle_fx_Gxx_post, r26
002118 93a0 2911                 	sts triangle_fx_Sxx_pre, r26
00211a 93a0 2912                 	sts triangle_fx_Sxx_post, r26
00211c 93a0 2945                 	sts noise_fx_Gxx_pre, r26
00211e 93a0 2946                 	sts noise_fx_Gxx_post, r26
002120 93a0 2948                 	sts noise_fx_Sxx_pre, r26
002122 93a0 2949                 	sts noise_fx_Sxx_post, r26
002124 93a0 2954                 	sts dpcm_fx_Gxx_pre, r26
002126 93a0 2955                 	sts dpcm_fx_Gxx_post, r26
002128 93a0 2956                 	sts dpcm_fx_Sxx_pre, r26
00212a 93a0 2957                 	sts dpcm_fx_Sxx_post, r26
                                 
00212c 93a0 2822                 	sts song_fx_Bxx, r26 //reset all song effects
00212e 9220 2823                 	sts song_fx_Cxx, zero
002130 9220 2824                 	sts song_fx_Dxx, zero
002132 c09e                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
002133 91ff                      	pop r31
002134 91ef                      	pop r30
002135 91df                      	pop r29
002136 91cf                      	pop r28
002137 91bf                      	pop r27
002138 bfbf                      	out CPU_SREG, r27
002139 94f8                      	cli //disable global interrupts
                                 		
00213a efaf                      	ldi r26, 0xFF
00213b 93a0 2822                 	sts song_fx_Bxx, r26 //reset all song effects
00213d 9220 2823                 	sts song_fx_Cxx, zero
00213f 9220 2824                 	sts song_fx_Dxx, zero
002141 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
002142 91e0 2819                 	lds ZL, song_frames
002144 91f0 281a                 	lds ZH, song_frames+1
002146 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002148 91b0 281c                 	lds r27, song_frame_offset+1
00214a 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
00214b 93a0 281b                 	sts song_frame_offset, r26
00214d 93b0 281c                 	sts song_frame_offset+1, r27
00214f 0fea                      	add ZL, r26
002150 1ffb                      	adc ZH, r27
                                 
002151 91a5                      	lpm r26, Z+ //load the address of the next pattern
002152 91b5                      	lpm r27, Z+
002153 0faa                      	lsl r26
002154 1fbb                      	rol r27
002155 93a0 2825                 	sts pulse1_pattern, r26
002157 93b0 2826                 	sts pulse1_pattern+1, r27
002159 91a5                      	lpm r26, Z+
00215a 91b5                      	lpm r27, Z+
00215b 0faa                      	lsl r26
00215c 1fbb                      	rol r27
00215d 93a0 2876                 	sts pulse2_pattern, r26
00215f 93b0 2877                 	sts pulse2_pattern+1, r27
002161 91a5                      	lpm r26, Z+
002162 91b5                      	lpm r27, Z+
002163 0faa                      	lsl r26
002164 1fbb                      	rol r27
002165 93a0 28c7                 	sts triangle_pattern, r26
002167 93b0 28c8                 	sts triangle_pattern+1, r27
002169 91a5                      	lpm r26, Z+
00216a 91b5                      	lpm r27, Z+
00216b 0faa                      	lsl r26
00216c 1fbb                      	rol r27
00216d 93a0 2913                 	sts noise_pattern, r26
00216f 93b0 2914                 	sts noise_pattern+1, r27
002171 91a5                      	lpm r26, Z+
002172 91b5                      	lpm r27, Z+
002173 0faa                      	lsl r26
002174 1fbb                      	rol r27
002175 93a0 294a                 	sts dpcm_pattern, r26
002177 93b0 294b                 	sts dpcm_pattern+1, r27
                                 
002179 9220 2829                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
00217b 9220 282a                 	sts pulse1_pattern_offset+1, zero
00217d 9220 2827                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
00217f 9230 2828                 	sts pulse1_pattern_delay_frames, one
002181 9220 287a                 	sts pulse2_pattern_offset, zero
002183 9220 287b                 	sts pulse2_pattern_offset+1, zero
002185 9220 2878                 	sts pulse2_pattern_delay_rows, zero
002187 9230 2879                 	sts pulse2_pattern_delay_frames, one
002189 9220 28cb                 	sts triangle_pattern_offset, zero
00218b 9220 28cc                 	sts triangle_pattern_offset+1, zero
00218d 9220 28c9                 	sts triangle_pattern_delay_rows, zero
00218f 9230 28ca                 	sts triangle_pattern_delay_frames, one
002191 9220 2917                 	sts noise_pattern_offset, zero
002193 9220 2918                 	sts noise_pattern_offset+1, zero
002195 9220 2915                 	sts noise_pattern_delay_rows, zero
002197 9230 2916                 	sts noise_pattern_delay_frames, one
002199 9220 294e                 	sts dpcm_pattern_offset, zero
00219b 9220 294e                 	sts dpcm_pattern_offset, zero
00219d 9220 294c                 	sts dpcm_pattern_delay_rows, zero
00219f 9230 294d                 	sts dpcm_pattern_delay_frames, one
                                 
0021a1 efaf                      	ldi r26, 0xFF
0021a2 93a0 2862                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0021a4 93a0 2863                 	sts pulse1_fx_Gxx_post, r26
0021a6 93a0 2874                 	sts pulse1_fx_Sxx_pre, r26
0021a8 93a0 2875                 	sts pulse1_fx_Sxx_post, r26
0021aa 93a0 28b3                 	sts pulse2_fx_Gxx_pre, r26
0021ac 93a0 28b4                 	sts pulse2_fx_Gxx_post, r26
0021ae 93a0 28c5                 	sts pulse2_fx_Sxx_pre, r26
0021b0 93a0 28c6                 	sts pulse2_fx_Sxx_post, r26
0021b2 93a0 28ff                 	sts triangle_fx_Gxx_pre, r26
0021b4 93a0 2900                 	sts triangle_fx_Gxx_post, r26
0021b6 93a0 2911                 	sts triangle_fx_Sxx_pre, r26
0021b8 93a0 2912                 	sts triangle_fx_Sxx_post, r26
0021ba 93a0 2945                 	sts noise_fx_Gxx_pre, r26
0021bc 93a0 2946                 	sts noise_fx_Gxx_post, r26
0021be 93a0 2948                 	sts noise_fx_Sxx_pre, r26
0021c0 93a0 2949                 	sts noise_fx_Sxx_post, r26
0021c2 93a0 2954                 	sts dpcm_fx_Gxx_pre, r26
0021c4 93a0 2955                 	sts dpcm_fx_Gxx_post, r26
0021c6 93a0 2956                 	sts dpcm_fx_Sxx_pre, r26
0021c8 93a0 2957                 	sts dpcm_fx_Sxx_post, r26
                                 
0021ca 93a0 2822                 	sts song_fx_Bxx, r26 //reset all song effects
0021cc 9220 2823                 	sts song_fx_Cxx, zero
0021ce 9220 2824                 	sts song_fx_Dxx, zero
0021d0 c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
0021d1 91a0 2827                 	lds r26, pulse1_pattern_delay_rows
0021d3 91b0 2828                 	lds r27, pulse1_pattern_delay_frames
                                 sound_driver_channel0_decrement_frame_delay:
0021d5 95ba                      	dec r27
0021d6 93b0 2828                 	sts pulse1_pattern_delay_frames, r27
                                 
0021d8 9610                      	adiw r27:r26, 0
0021d9 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
0021da c2e4                      	rjmp sound_driver_channel0_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel0_main:
0021db 91e0 2825                 	lds ZL, pulse1_pattern //current pattern for pulse 1
0021dd 91f0 2826                 	lds ZH, pulse1_pattern+1
0021df 91a0 2829                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
0021e1 91b0 282a                 	lds r27, pulse1_pattern_offset+1
0021e3 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0021e4 1ffb                      	adc ZH, r27
0021e5 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
0021e6 35b7                      	cpi r27, 0x57
0021e7 f408                      	brsh sound_driver_channel0_check_if_volume
0021e8 c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
0021e9 36b7                      	cpi r27, 0x67
0021ea f408                      	brsh sound_driver_channel0_check_if_delay
0021eb c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0021ec 3eb3                      	cpi r27, 0xE3
0021ed f408                      	brsh sound_driver_channel0_check_if_instrument
0021ee c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
0021ef f409                      	brne sound_driver_channel0_check_if_release
0021f0 c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
0021f1 3eb4                      	cpi r27, 0xE4
0021f2 f409                      	brne sound_driver_channel0_check_if_end
0021f3 c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
0021f4 3fbf                      	cpi r27, 0xFF
0021f5 f409                      	brne sound_driver_channel0_check_if_fx
0021f6 c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
0021f7 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0021f8 91a4                      	lpm r26, Z //load the fx data into r26
0021f9 d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
0021fa 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0021fb eee4                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
0021fc e7f4                      	ldi ZH, HIGH(channel0_fx << 1)
0021fd 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0021fe 0feb                      	add ZL, r27 //add offset
0021ff 1df2                      	adc ZH, zero
002200 91c5                      	lpm r28, Z+ //load address bytes
002201 91d4                      	lpm r29, Z
002202 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002203 2ffd                      	mov ZH, r29
002204 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
002205 93a0 2848                 	sts pulse1_fx_0xy_sequence, r26
002207 9220 2849                 	sts pulse1_fx_0xy_sequence+1, zero
002209 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
00220a 9220 284e                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
00220c 9220 284f                 	sts pulse1_fx_2xx+1, zero
00220e 9220 2848                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
002210 9220 2849                 	sts pulse1_fx_0xy_sequence+1, zero
002212 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002213 937f                      	push r23
002214 2f6a                      	mov r22, r26 //store the rate into r22
002215 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002216 9f67                      	mul r22, r23
002217 917f                      	pop r23
002218 916f                      	pop r22
                                 
002219 9416                      	lsr r1 //shift out the fractional bits
00221a 9407                      	ror r0
00221b 9416                      	lsr r1
00221c 9407                      	ror r0
00221d 9416                      	lsr r1
00221e 9407                      	ror r0
00221f 9416                      	lsr r1
002220 9407                      	ror r0
002221 9200 284a                 	sts pulse1_fx_1xx, r0
002223 9210 284b                 	sts pulse1_fx_1xx+1, r1
002225 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
002226 9220 284a                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
002228 9220 284b                 	sts pulse1_fx_1xx+1, zero
00222a 9220 2848                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00222c 9220 2849                 	sts pulse1_fx_0xy_sequence+1, zero
00222e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00222f 937f                      	push r23
002230 2f6a                      	mov r22, r26 //store the rate into r22
002231 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002232 9f67                      	mul r22, r23
002233 917f                      	pop r23
002234 916f                      	pop r22
                                 
002235 9416                      	lsr r1 //shift out the fractional bits
002236 9407                      	ror r0
002237 9416                      	lsr r1
002238 9407                      	ror r0
002239 9416                      	lsr r1
00223a 9407                      	ror r0
00223b 9416                      	lsr r1
00223c 9407                      	ror r0
00223d 9200 284e                 	sts pulse1_fx_2xx, r0
00223f 9210 284f                 	sts pulse1_fx_2xx+1, r1
002241 cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
002242 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002243 937f                      	push r23
002244 2f6a                      	mov r22, r26 //store the rate into r22
002245 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002246 9f67                      	mul r22, r23
002247 917f                      	pop r23
002248 916f                      	pop r22
                                 
002249 9416                      	lsr r1 //shift out the fractional bits
00224a 9407                      	ror r0
00224b 9416                      	lsr r1
00224c 9407                      	ror r0
00224d 9416                      	lsr r1
00224e 9407                      	ror r0
00224f 9416                      	lsr r1
002250 9407                      	ror r0
002251 9200 2856                 	sts pulse1_fx_3xx_speed, r0
002253 9210 2857                 	sts pulse1_fx_3xx_speed+1, r1
                                 
002255 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
002256 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
002257 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
002258 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00225a 91b0 0a8d                 	lds r27, TCB0_CCMPH
00225c 93a0 2852                 	sts pulse1_fx_3xx_start, r26
00225e 93b0 2853                 	sts pulse1_fx_3xx_start+1, r27
                                 
002260 9220 2858                 	sts pulse1_fx_3xx_total_offset, zero
002262 9220 2859                 	sts pulse1_fx_3xx_total_offset+1, zero
002264 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
002265 2fba                      	mov r27, r26
002266 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002267 95a2                      	swap r26
002268 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002269 93a0 285a                 	sts pulse1_fx_4xy_speed, r26
00226b 93b0 285b                 	sts pulse1_fx_4xy_depth, r27
00226d 9220 285c                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
00226f cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
002270 2fba                      	mov r27, r26
002271 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002272 95a2                      	swap r26
002273 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002274 93a0 285d                 	sts pulse1_fx_7xy_speed, r26
002276 93b0 285e                 	sts pulse1_fx_7xy_depth, r27
002278 9220 285f                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
00227a 9220 2860                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
00227c cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
00227d 93a0 2861                 	sts pulse1_fx_Axy, r26
00227f cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
002280 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002282 cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
002283 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002285 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
002286 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002288 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
002289 91b0 2800                 	lds r27, pulse1_param
00228b 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
00228c 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
00228d 93b0 2800                 	sts pulse1_param, r27
00228f 6096                      	sbr pulse_channel_flags, 6
002290 cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
002291 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002293 cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
002294 15a2                      	cp r26, zero
002295 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
002296 91b0 2821                 	lds r27, song_speed
002298 17ab                      	cp r26, r27
002299 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
00229a 93a0 2862                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00229c e0b1                      	ldi r27, 0x01
00229d 93b0 2827                 	sts pulse1_pattern_delay_rows, r27
00229f c22e                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
0022a0 cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0022a1 cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0022a2 cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0022a3 cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0022a4 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0022a5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022a6 937f                      	push r23
0022a7 2f6a                      	mov r22, r26
0022a8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022a9 0367                      	mulsu r22, r23
0022aa 917f                      	pop r23
0022ab 916f                      	pop r22
0022ac 9416                      	lsr r1 //shift out the fractional bits
0022ad 9407                      	ror r0
0022ae 9416                      	lsr r1
0022af 9407                      	ror r0
0022b0 9416                      	lsr r1
0022b1 9407                      	ror r0
0022b2 9416                      	lsr r1
0022b3 9407                      	ror r0
0022b4 fe13                      	sbrs r1, 3 //check if result was a negative number
0022b5 c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
0022b6 efb0                      	ldi r27, 0xF0
0022b7 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
0022b8 9200 2864                 	sts pulse1_fx_Pxx_total, r0
0022ba 9210 2865                 	sts pulse1_fx_Pxx_total+1, r1
0022bc cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
0022bd 91e0 2830                 	lds ZL, pulse1_arpeggio_macro
0022bf 91f0 2831                 	lds ZH, pulse1_arpeggio_macro+1
0022c1 9630                      	adiw Z, 0
0022c2 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
0022c3 cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
0022c4 91e0 2838                 	lds ZL, pulse1_pitch_macro
0022c6 91f0 2839                 	lds ZH, pulse1_pitch_macro+1
0022c8 9630                      	adiw Z, 0
0022c9 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
0022ca cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
0022cb 91e0 283e                 	lds ZL, pulse1_hi_pitch_macro
0022cd 91f0 283f                 	lds ZH, pulse1_hi_pitch_macro+1
0022cf 9630                      	adiw Z, 0
0022d0 f009                      	breq sound_driver_channel0_fx_Qxy_process
0022d1 cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
0022d2 2fba                      	mov r27, r26 //copy fx parameters into r27
0022d3 70bf                      	andi r27, 0x0F //mask note index offset
0022d4 91c0 2866                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
0022d6 0fbc                      	add r27, r28
0022d7 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0022d8 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
0022d9 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
0022da 93b0 2866                 	sts pulse1_fx_Qxy_target_note, r27
0022dc e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0022dd e0f0                      	ldi ZH, HIGH(note_table << 1)
0022de 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0022df 0feb                      	add ZL, r27 //add offset
0022e0 1df2                      	adc ZH, zero
0022e1 91c5                      	lpm r28, Z+ //load bytes
0022e2 91d4                      	lpm r29, Z
0022e3 93c0 2867                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
0022e5 93d0 2868                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
0022e7 95a2                      	swap r26
0022e8 70af                      	andi r26, 0x0F //mask effect speed
0022e9 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0022ea 95a3                      	inc r26 //increment the speed by 1
                                 
0022eb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0022ec 937f                      	push r23
0022ed 2f6a                      	mov r22, r26 //store the speed data into r27
0022ee eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0022ef 9f67                      	mul r22, r23
0022f0 917f                      	pop r23
0022f1 916f                      	pop r22
                                 
0022f2 9416                      	lsr r1 //shift out the fractional bits
0022f3 9407                      	ror r0
0022f4 9416                      	lsr r1
0022f5 9407                      	ror r0
0022f6 9416                      	lsr r1
0022f7 9407                      	ror r0
0022f8 9416                      	lsr r1
0022f9 9407                      	ror r0
                                 
0022fa 9200 2869                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
0022fc 9210 286a                 	sts pulse1_fx_Qxy_speed+1, r1
0022fe cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
0022ff 91e0 2830                 	lds ZL, pulse1_arpeggio_macro
002301 91f0 2831                 	lds ZH, pulse1_arpeggio_macro+1
002303 9630                      	adiw Z, 0
002304 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
002305 ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
002306 91e0 2838                 	lds ZL, pulse1_pitch_macro
002308 91f0 2839                 	lds ZH, pulse1_pitch_macro+1
00230a 9630                      	adiw Z, 0
00230b f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
00230c cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
00230d 91e0 283e                 	lds ZL, pulse1_hi_pitch_macro
00230f 91f0 283f                 	lds ZH, pulse1_hi_pitch_macro+1
002311 9630                      	adiw Z, 0
002312 f009                      	breq sound_driver_channel0_fx_Rxy_process
002313 cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
002314 2fba                      	mov r27, r26 //copy fx parameters into r27
002315 70bf                      	andi r27, 0x0F //mask note index offset
002316 91c0 286d                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
002318 1bcb                      	sub r28, r27
002319 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
00231a e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
00231b 93c0 286d                 	sts pulse1_fx_Rxy_target_note, r28
00231d e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00231e e0f0                      	ldi ZH, HIGH(note_table << 1)
00231f 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
002320 0fec                      	add ZL, r28 //add offset
002321 1df2                      	adc ZH, zero
002322 91c5                      	lpm r28, Z+ //load bytes
002323 91d4                      	lpm r29, Z
002324 93c0 286e                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
002326 93d0 286f                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
002328 95a2                      	swap r26
002329 70af                      	andi r26, 0x0F //mask effect speed
00232a 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00232b 95a3                      	inc r26 //increment the speed by 1
                                 
00232c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00232d 937f                      	push r23
00232e 2f6a                      	mov r22, r26 //store the speed data into r27
00232f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002330 9f67                      	mul r22, r23
002331 917f                      	pop r23
002332 916f                      	pop r22
                                 
002333 9416                      	lsr r1 //shift out the fractional bits
002334 9407                      	ror r0
002335 9416                      	lsr r1
002336 9407                      	ror r0
002337 9416                      	lsr r1
002338 9407                      	ror r0
002339 9416                      	lsr r1
00233a 9407                      	ror r0
                                 
00233b 9200 2870                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
00233d 9210 2871                 	sts pulse1_fx_Rxy_speed+1, r1
00233f ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
002340 15a2                      	cp r26, zero
002341 f051                      	breq sound_driver_channel0_fx_Sxx_invalid
002342 91b0 2821                 	lds r27, song_speed
002344 17ab                      	cp r26, r27
002345 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
002346 93a0 2874                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002348 e0b1                      	ldi r27, 0x01
002349 93b0 2827                 	sts pulse1_pattern_delay_rows, r27
00234b c182                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
00234c ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
00234d eee0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00234e e7f4                      	ldi ZH, HIGH(sequences << 1)
00234f 0fea                      	add ZL, r26 //offset the pointer
002350 1df2                      	adc ZH, zero
                                 
002351 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
002352 95a7                      	ror r26
002353 95a7                      	ror r26
002354 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
002356 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
002357 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
002358 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
002359 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
00235a ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
00235b 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
00235c 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00235d 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00235e 93c0 2800                 	sts pulse1_param, r28
002360 ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
002361 ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
002362 ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
002363 ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
002364 ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
002365 93b0 2807                 	sts pulse1_note, r27 //store the note index
002367 93b0 2866                 	sts pulse1_fx_Qxy_target_note, r27
002369 93b0 286d                 	sts pulse1_fx_Rxy_target_note, r27
00236b e0a3                      	ldi r26, 0x03
00236c e0b2                      	ldi r27, 0x02
00236d 93b0 282d                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00236f 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26
002371 93b0 283a                 	sts pulse1_pitch_macro_offset, r27
002373 93b0 2840                 	sts pulse1_hi_pitch_macro_offset, r27
002375 93b0 2845                 	sts pulse1_duty_macro_offset, r27
002377 9220 2836                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
002379 9220 2837                 	sts pulse1_total_pitch_offset+1, zero
00237b 9220 283d                 	sts pulse1_total_hi_pitch_offset, zero
00237d 9220 284c                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00237f 9220 284d                 	sts pulse1_fx_1xx_total+1, zero
002381 9220 2850                 	sts pulse1_fx_2xx_total, zero
002383 9220 2851                 	sts pulse1_fx_2xx_total+1, zero
002385 9220 2858                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
002387 9220 2859                 	sts pulse1_fx_3xx_total_offset+1, zero
002389 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00238b 91b0 0a8d                 	lds r27, TCB0_CCMPH
00238d 93a0 2852                 	sts pulse1_fx_3xx_start, r26
00238f 93b0 2853                 	sts pulse1_fx_3xx_start+1, r27
002391 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
002393 6097                      	sbr pulse_channel_flags, 7 //set reload flag
002394 9220 2867                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002396 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
002398 9220 286b                 	sts pulse1_fx_Qxy_total_offset, zero
00239a 9220 286c                 	sts pulse1_fx_Qxy_total_offset+1, zero
00239c 9220 286e                 	sts pulse1_fx_Rxy_target, zero
00239e 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
0023a0 9220 2872                 	sts pulse1_fx_Rxy_total_offset, zero
0023a2 9220 2873                 	sts pulse1_fx_Rxy_total_offset+1, zero
0023a4 d106                      	rcall sound_driver_channel0_increment_offset
0023a5 ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
0023a6 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
0023a7 91a0 2800                 	lds r26, pulse1_param
0023a9 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0023aa 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
0023ab 93a0 2800                 	sts pulse1_param, r26
0023ad 6096                      	sbr pulse_channel_flags, 6
0023ae d0fc                      	rcall sound_driver_channel0_increment_offset
0023af ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
0023b0 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0023b1 93b0 2827                 	sts pulse1_pattern_delay_rows, r27
0023b3 d0f7                      	rcall sound_driver_channel0_increment_offset
0023b4 c10a                      	rjmp sound_driver_channel0_end
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
0023b5 9220 282b                 	sts pulse1_volume_macro, zero //reset all macro addresses
0023b7 9220 282c                 	sts pulse1_volume_macro+1, zero
0023b9 9220 2830                 	sts pulse1_arpeggio_macro, zero
0023bb 9220 2831                 	sts pulse1_arpeggio_macro+1, zero
0023bd 9220 2838                 	sts pulse1_pitch_macro, zero
0023bf 9220 2839                 	sts pulse1_pitch_macro+1, zero
0023c1 9220 283e                 	sts pulse1_hi_pitch_macro, zero
0023c3 9220 283f                 	sts pulse1_hi_pitch_macro+1, zero
0023c5 9220 2843                 	sts pulse1_duty_macro, zero
0023c7 9220 2844                 	sts pulse1_duty_macro+1, zero
0023c9 9220 2836                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
0023cb 9220 2837                 	sts pulse1_total_pitch_offset+1, zero
0023cd 9220 283d                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0023cf 9631                      	adiw Z, 1 //point to the byte next to the flag
0023d0 91b4                      	lpm r27, Z //store the instrument offset into r27
0023d1 edec                      	ldi ZL, LOW(instruments) //point Z to instruments table
0023d2 e1fa                      	ldi ZH, HIGH(instruments)
0023d3 0feb                      	add ZL, r27 //point Z to offsetted instrument
0023d4 1df2                      	adc ZH, zero
0023d5 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0023d6 1fff                      	rol ZH
0023d7 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0023d8 91b4                      	lpm r27, Z
                                 
0023d9 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0023da 1fbb                      	rol r27
0023db 2fea                      	mov ZL, r26
0023dc 2ffb                      	mov ZH, r27
0023dd 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0023de 9632                      	adiw Z, 2 //point Z to the address of the macro
0023df e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
0023e0 95aa                      	dec r26
0023e1 f019                      	breq sound_driver_channel0_instrument_change_exit
0023e2 95b6                      	lsr r27
0023e3 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
0023e4 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
0023e5 e0a3                      	ldi r26, 0x03
0023e6 e0b2                      	ldi r27, 0x02
0023e7 93b0 282d                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0023e9 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26
0023eb 93b0 283a                 	sts pulse1_pitch_macro_offset, r27
0023ed 93b0 2840                 	sts pulse1_hi_pitch_macro_offset, r27
0023ef 93b0 2845                 	sts pulse1_duty_macro_offset, r27
0023f1 d0c3                      	rcall sound_driver_channel0_increment_offset_twice
0023f2 cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
0023f3 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0023f4 91d5                      	lpm r29, Z+
                                 
0023f5 30a5                      	cpi r26, 5
0023f6 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
0023f7 30a4                      	cpi r26, 4
0023f8 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
0023f9 30a3                      	cpi r26, 3
0023fa f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
0023fb 30a2                      	cpi r26, 2
0023fc f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
0023fd c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
0023fe 93c0 282b                 	sts pulse1_volume_macro, r28
002400 93d0 282c                 	sts pulse1_volume_macro+1, r29
002402 d041                      	rcall sound_driver_channel0_instrument_change_read_header
002403 93c0 282f                 	sts pulse1_volume_macro_release, r28
002405 93d0 282e                 	sts pulse1_volume_macro_loop, r29
002407 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
002408 93c0 2830                 	sts pulse1_arpeggio_macro, r28
00240a 93d0 2831                 	sts pulse1_arpeggio_macro+1, r29
00240c 9220 2867                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00240e 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
002410 9220 286e                 	sts pulse1_fx_Rxy_target, zero
002412 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
002414 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
002415 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
002416 93c0 2838                 	sts pulse1_pitch_macro, r28
002418 93d0 2839                 	sts pulse1_pitch_macro+1, r29
00241a 9220 2867                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00241c 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
00241e 9220 286e                 	sts pulse1_fx_Rxy_target, zero
002420 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
002422 d021                      	rcall sound_driver_channel0_instrument_change_read_header
002423 93c0 283c                 	sts pulse1_pitch_macro_release, r28
002425 93d0 283b                 	sts pulse1_pitch_macro_loop, r29
002427 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
002428 93c0 283e                 	sts pulse1_hi_pitch_macro, r28
00242a 93d0 283f                 	sts pulse1_hi_pitch_macro+1, r29
00242c 9220 2867                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00242e 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
002430 9220 286e                 	sts pulse1_fx_Rxy_target, zero
002432 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
002434 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
002435 93c0 2842                 	sts pulse1_hi_pitch_macro_release, r28
002437 93d0 2841                 	sts pulse1_hi_pitch_macro_loop, r29
002439 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
00243a 93c0 2843                 	sts pulse1_duty_macro, r28
00243c 93d0 2844                 	sts pulse1_duty_macro+1, r29
00243e d005                      	rcall sound_driver_channel0_instrument_change_read_header
00243f 93c0 2847                 	sts pulse1_duty_macro_release, r28
002441 93d0 2846                 	sts pulse1_duty_macro_loop, r29
002443 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
002444 93ef                      	push ZL
002445 93ff                      	push ZH
002446 2fec                      	mov ZL, r28
002447 2ffd                      	mov ZH, r29
002448 0fee                      	lsl ZL
002449 1fff                      	rol ZH
00244a 91c5                      	lpm r28, Z+
00244b 91d4                      	lpm r29, Z
00244c 91ff                      	pop ZH
00244d 91ef                      	pop ZL
00244e 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
00244f 93ef                      	push ZL
002450 93ff                      	push ZH
002451 2fec                      	mov ZL, r28
002452 2ffd                      	mov ZH, r29
002453 0fee                      	lsl ZL
002454 1fff                      	rol ZH
002455 91c5                      	lpm r28, Z+
002456 91d5                      	lpm r29, Z+
002457 93c0 2834                 	sts pulse1_arpeggio_macro_release, r28
002459 93d0 2833                 	sts pulse1_arpeggio_macro_loop, r29
00245b 91c4                      	lpm r28, Z
00245c 93c0 2835                 	sts pulse1_arpeggio_macro_mode, r28
00245e 91ff                      	pop ZH
00245f 91ef                      	pop ZL
002460 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
002461 91b0 282f                 	lds r27, pulse1_volume_macro_release
002463 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002464 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
002465 95b3                      	inc r27
002466 93b0 282d                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
002468 91b0 2834                 	lds r27, pulse1_arpeggio_macro_release
00246a 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00246b f019                      	breq sound_driver_channel0_release_pitch
00246c 95b3                      	inc r27
00246d 93b0 2832                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
00246f 91b0 283c                 	lds r27, pulse1_pitch_macro_release
002471 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002472 f019                      	breq sound_driver_channel0_release_hi_pitch
002473 95b3                      	inc r27
002474 93b0 283a                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
002476 91b0 2842                 	lds r27, pulse1_hi_pitch_macro_release
002478 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002479 f019                      	breq sound_driver_channel0_release_duty
00247a 95b3                      	inc r27
00247b 93b0 2840                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
00247d 91b0 2847                 	lds r27, pulse1_duty_macro_release
00247f 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002480 f019                      	breq sound_driver_channel0_release_exit
002481 95b3                      	inc r27
002482 93b0 2845                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
002484 d026                      	rcall sound_driver_channel0_increment_offset
002485 cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
002486 91e0 2819                 	lds ZL, song_frames
002488 91f0 281a                 	lds ZH, song_frames+1
00248a 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00248c 91b0 281c                 	lds r27, song_frame_offset+1
00248e 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
00248f 93a0 281b                 	sts song_frame_offset, r26
002491 93b0 281c                 	sts song_frame_offset+1, r27
                                 
002493 91c0 281d                 	lds r28, song_size
002495 91d0 281e                 	lds r29, song_size+1
002497 17ac                      	cp r26, r28
002498 07bd                      	cpc r27, r29
002499 f010                      	brlo sound_driver_channel0_next_pattern_exists
00249a 940c 3a5a                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
00249c 0fea                      	add ZL, r26
00249d 1ffb                      	adc ZH, r27
                                 
00249e 91a5                      	lpm r26, Z+ //load the address of the next pattern
00249f 91b4                      	lpm r27, Z
0024a0 0faa                      	lsl r26
0024a1 1fbb                      	rol r27
0024a2 93a0 2825                 	sts pulse1_pattern, r26
0024a4 93b0 2826                 	sts pulse1_pattern+1, r27
                                 
0024a6 9220 2829                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0024a8 9220 282a                 	sts pulse1_pattern_offset+1, zero
0024aa cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
0024ab 91e0 2829                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0024ad 91f0 282a                 	lds ZH, pulse1_pattern_offset+1
0024af 9631                      	adiw Z, 1
0024b0 93e0 2829                 	sts pulse1_pattern_offset, ZL
0024b2 93f0 282a                 	sts pulse1_pattern_offset+1, ZH
0024b4 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0024b5 91e0 2829                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0024b7 91f0 282a                 	lds ZH, pulse1_pattern_offset+1
0024b9 9632                      	adiw Z, 2 //increment the pointer twice
0024ba 93e0 2829                 	sts pulse1_pattern_offset, ZL
0024bc 93f0 282a                 	sts pulse1_pattern_offset+1, ZH
0024be 9508                      	ret
                                 
                                 sound_driver_channel0_end:
                                 sound_driver_channel0_check_Sxx_invalid:
0024bf efbf                      	ldi r27, 0xFF
0024c0 91a0 2875                 	lds r26, pulse1_fx_Sxx_post
0024c2 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
0024c3 f419                      	brne sound_driver_channel0_check_Gxx_invalid
0024c4 93b0 2875                 	sts pulse1_fx_Sxx_post, r27
0024c6 9508                      	ret
                                 sound_driver_channel0_check_Gxx_invalid:
0024c7 91a0 2863                 	lds r26, pulse1_fx_Gxx_post
0024c9 15a2                      	cp r26, zero
0024ca f419                      	brne sound_driver_channel1
0024cb 93b0 2863                 	sts pulse1_fx_Gxx_post, r27
0024cd 9508                      	ret
                                 
                                 
                                 sound_driver_channel1:
0024ce 91a0 2878                 	lds r26, pulse2_pattern_delay_rows
0024d0 91b0 2879                 	lds r27, pulse2_pattern_delay_frames
                                 sound_driver_channel1_decrement_frame_delay:
0024d2 95ba                      	dec r27
0024d3 93b0 2879                 	sts pulse2_pattern_delay_frames, r27
                                 
0024d5 9610                      	adiw r27:r26, 0
0024d6 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
0024d7 c2d7                      	rjmp sound_driver_channel1_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel1_main:
0024d8 91e0 2876                 	lds ZL, pulse2_pattern //current pattern for pulse 2
0024da 91f0 2877                 	lds ZH, pulse2_pattern+1
0024dc 91a0 287a                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
0024de 91b0 287b                 	lds r27, pulse2_pattern_offset+1
0024e0 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0024e1 1ffb                      	adc ZH, r27
0024e2 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
0024e3 35b7                      	cpi r27, 0x57
0024e4 f408                      	brsh sound_driver_channel1_check_if_volume
0024e5 c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
0024e6 36b7                      	cpi r27, 0x67
0024e7 f408                      	brsh sound_driver_channel1_check_if_delay
0024e8 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0024e9 3eb3                      	cpi r27, 0xE3
0024ea f408                      	brsh sound_driver_channel1_check_if_instrument
0024eb c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
0024ec f409                      	brne sound_driver_channel1_check_if_release
0024ed c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
0024ee 3eb4                      	cpi r27, 0xE4
0024ef f409                      	brne sound_driver_channel1_check_if_end
0024f0 c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
0024f1 3fbf                      	cpi r27, 0xFF
0024f2 f409                      	brne sound_driver_channel1_check_if_fx
0024f3 c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
0024f4 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0024f5 91a4                      	lpm r26, Z //load the fx data into r26
0024f6 d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
0024f7 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0024f8 e1e8                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
0024f9 e7f5                      	ldi ZH, HIGH(channel1_fx << 1)
0024fa 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0024fb 0feb                      	add ZL, r27 //add offset
0024fc 1df2                      	adc ZH, zero
0024fd 91c5                      	lpm r28, Z+ //load address bytes
0024fe 91d4                      	lpm r29, Z
0024ff 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002500 2ffd                      	mov ZH, r29
002501 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
002502 93a0 2899                 	sts pulse2_fx_0xy_sequence, r26
002504 9220 289a                 	sts pulse2_fx_0xy_sequence+1, zero
002506 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
002507 9220 289f                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
002509 9220 28a0                 	sts pulse2_fx_2xx+1, zero
00250b 9220 2899                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
00250d 9220 289a                 	sts pulse2_fx_0xy_sequence+1, zero
00250f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002510 937f                      	push r23
002511 2f6a                      	mov r22, r26 //store the rate into r22
002512 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002513 9f67                      	mul r22, r23
002514 917f                      	pop r23
002515 916f                      	pop r22
                                 
002516 9416                      	lsr r1 //shift out the fractional bits
002517 9407                      	ror r0
002518 9416                      	lsr r1
002519 9407                      	ror r0
00251a 9416                      	lsr r1
00251b 9407                      	ror r0
00251c 9416                      	lsr r1
00251d 9407                      	ror r0
00251e 9200 289b                 	sts pulse2_fx_1xx, r0
002520 9210 289c                 	sts pulse2_fx_1xx+1, r1
002522 cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
002523 9220 289b                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
002525 9220 289c                 	sts pulse2_fx_1xx+1, zero
002527 9220 2899                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
002529 9220 289a                 	sts pulse2_fx_0xy_sequence+1, zero
00252b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00252c 937f                      	push r23
00252d 2f6a                      	mov r22, r26 //store the rate into r22
00252e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00252f 9f67                      	mul r22, r23
002530 917f                      	pop r23
002531 916f                      	pop r22
                                 
002532 9416                      	lsr r1 //shift out the fractional bits
002533 9407                      	ror r0
002534 9416                      	lsr r1
002535 9407                      	ror r0
002536 9416                      	lsr r1
002537 9407                      	ror r0
002538 9416                      	lsr r1
002539 9407                      	ror r0
00253a 9200 289f                 	sts pulse2_fx_2xx, r0
00253c 9210 28a0                 	sts pulse2_fx_2xx+1, r1
00253e cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
00253f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002540 937f                      	push r23
002541 2f6a                      	mov r22, r26 //store the rate into r22
002542 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002543 9f67                      	mul r22, r23
002544 917f                      	pop r23
002545 916f                      	pop r22
                                 
002546 9416                      	lsr r1 //shift out the fractional bits
002547 9407                      	ror r0
002548 9416                      	lsr r1
002549 9407                      	ror r0
00254a 9416                      	lsr r1
00254b 9407                      	ror r0
00254c 9416                      	lsr r1
00254d 9407                      	ror r0
00254e 9200 28a7                 	sts pulse2_fx_3xx_speed, r0
002550 9210 28a8                 	sts pulse2_fx_3xx_speed+1, r1
                                 
002552 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
002553 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
002554 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
002555 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002557 91b0 0a9d                 	lds r27, TCB1_CCMPH
002559 93a0 28a3                 	sts pulse2_fx_3xx_start, r26
00255b 93b0 28a4                 	sts pulse2_fx_3xx_start+1, r27
                                 
00255d 9220 28a9                 	sts pulse2_fx_3xx_total_offset, zero
00255f 9220 28aa                 	sts pulse2_fx_3xx_total_offset+1, zero
002561 cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
002562 2fba                      	mov r27, r26
002563 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002564 95a2                      	swap r26
002565 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002566 93a0 28ab                 	sts pulse2_fx_4xy_speed, r26
002568 93b0 28ac                 	sts pulse2_fx_4xy_depth, r27
00256a 9220 28ad                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
00256c cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
00256d 2fba                      	mov r27, r26
00256e 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00256f 95a2                      	swap r26
002570 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002571 93a0 28ae                 	sts pulse2_fx_7xy_speed, r26
002573 93b0 28af                 	sts pulse2_fx_7xy_depth, r27
002575 9220 28b0                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
002577 9220 28b1                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
002579 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
00257a 93a0 28b2                 	sts pulse2_fx_Axy, r26
00257c cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
00257d 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
00257f cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
002580 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002582 cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
002583 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002585 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
002586 91b0 2808                 	lds r27, pulse2_param
002588 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
002589 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
00258a 93b0 2808                 	sts pulse2_param, r27
00258c 6092                      	sbr pulse_channel_flags, 2
00258d cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
00258e 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002590 cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
002591 15a2                      	cp r26, zero
002592 f051                      	breq sound_driver_channel1_fx_Gxx_invalid
002593 91b0 2821                 	lds r27, song_speed
002595 17ab                      	cp r26, r27
002596 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
002597 93a0 28b3                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002599 e0b1                      	ldi r27, 0x01
00259a 93b0 2878                 	sts pulse2_pattern_delay_rows, r27
00259c c221                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
00259d cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
00259e cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
00259f cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
0025a0 cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
0025a1 cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
0025a2 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025a3 937f                      	push r23
0025a4 2f6a                      	mov r22, r26
0025a5 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025a6 0367                      	mulsu r22, r23
0025a7 917f                      	pop r23
0025a8 916f                      	pop r22
0025a9 9416                      	lsr r1 //shift out the fractional bits
0025aa 9407                      	ror r0
0025ab 9416                      	lsr r1
0025ac 9407                      	ror r0
0025ad 9416                      	lsr r1
0025ae 9407                      	ror r0
0025af 9416                      	lsr r1
0025b0 9407                      	ror r0
0025b1 fe13                      	sbrs r1, 3 //check if result was a negative number
0025b2 c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
0025b3 efb0                      	ldi r27, 0xF0
0025b4 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
0025b5 9200 28b5                 	sts pulse2_fx_Pxx_total, r0
0025b7 9210 28b6                 	sts pulse2_fx_Pxx_total+1, r1
0025b9 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
0025ba 91e0 2881                 	lds ZL, pulse2_arpeggio_macro
0025bc 91f0 2882                 	lds ZH, pulse2_arpeggio_macro+1
0025be 9630                      	adiw Z, 0
0025bf f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
0025c0 cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
0025c1 91e0 2889                 	lds ZL, pulse2_pitch_macro
0025c3 91f0 288a                 	lds ZH, pulse2_pitch_macro+1
0025c5 9630                      	adiw Z, 0
0025c6 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
0025c7 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
0025c8 91e0 288f                 	lds ZL, pulse2_hi_pitch_macro
0025ca 91f0 2890                 	lds ZH, pulse2_hi_pitch_macro+1
0025cc 9630                      	adiw Z, 0
0025cd f009                      	breq sound_driver_channel1_fx_Qxy_process
0025ce cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
0025cf 2fba                      	mov r27, r26 //copy fx parameters into r27
0025d0 70bf                      	andi r27, 0x0F //mask note index offset
0025d1 91c0 28b7                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
0025d3 0fbc                      	add r27, r28
0025d4 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0025d5 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
0025d6 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
0025d7 93b0 28b7                 	sts pulse2_fx_Qxy_target_note, r27
0025d9 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0025da e0f0                      	ldi ZH, HIGH(note_table << 1)
0025db 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0025dc 0feb                      	add ZL, r27 //add offset
0025dd 1df2                      	adc ZH, zero
0025de 91c5                      	lpm r28, Z+ //load bytes
0025df 91d4                      	lpm r29, Z
0025e0 93c0 28b8                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
0025e2 93d0 28b9                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
0025e4 95a2                      	swap r26
0025e5 70af                      	andi r26, 0x0F //mask effect speed
0025e6 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0025e7 95a3                      	inc r26 //increment the speed by 1
                                 
0025e8 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0025e9 937f                      	push r23
0025ea 2f6a                      	mov r22, r26 //store the speed data into r27
0025eb eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0025ec 9f67                      	mul r22, r23
0025ed 917f                      	pop r23
0025ee 916f                      	pop r22
                                 
0025ef 9416                      	lsr r1 //shift out the fractional bits
0025f0 9407                      	ror r0
0025f1 9416                      	lsr r1
0025f2 9407                      	ror r0
0025f3 9416                      	lsr r1
0025f4 9407                      	ror r0
0025f5 9416                      	lsr r1
0025f6 9407                      	ror r0
                                 
0025f7 9200 28ba                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
0025f9 9210 28bb                 	sts pulse2_fx_Qxy_speed+1, r1
0025fb cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
0025fc 91e0 2881                 	lds ZL, pulse2_arpeggio_macro
0025fe 91f0 2882                 	lds ZH, pulse2_arpeggio_macro+1
002600 9630                      	adiw Z, 0
002601 f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
002602 ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
002603 91e0 2889                 	lds ZL, pulse2_pitch_macro
002605 91f0 288a                 	lds ZH, pulse2_pitch_macro+1
002607 9630                      	adiw Z, 0
002608 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
002609 cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
00260a 91e0 288f                 	lds ZL, pulse2_hi_pitch_macro
00260c 91f0 2890                 	lds ZH, pulse2_hi_pitch_macro+1
00260e 9630                      	adiw Z, 0
00260f f009                      	breq sound_driver_channel1_fx_Rxy_process
002610 cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
002611 2fba                      	mov r27, r26 //copy fx parameters into r27
002612 70bf                      	andi r27, 0x0F //mask note index offset
002613 91c0 28be                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
002615 1bcb                      	sub r28, r27
002616 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
002617 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
002618 93c0 28be                 	sts pulse2_fx_Rxy_target_note, r28
00261a e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00261b e0f0                      	ldi ZH, HIGH(note_table << 1)
00261c 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00261d 0fec                      	add ZL, r28 //add offset
00261e 1df2                      	adc ZH, zero
00261f 91c5                      	lpm r28, Z+ //load bytes
002620 91d4                      	lpm r29, Z
002621 93c0 28bf                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
002623 93d0 28c0                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
002625 95a2                      	swap r26
002626 70af                      	andi r26, 0x0F //mask effect speed
002627 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
002628 95a3                      	inc r26 //increment the speed by 1
                                 
002629 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00262a 937f                      	push r23
00262b 2f6a                      	mov r22, r26 //store the speed data into r27
00262c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00262d 9f67                      	mul r22, r23
00262e 917f                      	pop r23
00262f 916f                      	pop r22
                                 
002630 9416                      	lsr r1 //shift out the fractional bits
002631 9407                      	ror r0
002632 9416                      	lsr r1
002633 9407                      	ror r0
002634 9416                      	lsr r1
002635 9407                      	ror r0
002636 9416                      	lsr r1
002637 9407                      	ror r0
                                 
002638 9200 28c1                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
00263a 9210 28c2                 	sts pulse2_fx_Rxy_speed+1, r1
00263c ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
00263d 15a2                      	cp r26, zero
00263e f051                      	breq sound_driver_channel1_fx_Sxx_invalid
00263f 91b0 2821                 	lds r27, song_speed
002641 17ab                      	cp r26, r27
002642 f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
002643 93a0 28c5                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002645 e0b1                      	ldi r27, 0x01
002646 93b0 2878                 	sts pulse2_pattern_delay_rows, r27
002648 c175                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
002649 ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
00264a eee0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00264b e7f4                      	ldi ZH, HIGH(sequences << 1)
00264c 0fea                      	add ZL, r26 //offset the pointer
00264d 1df2                      	adc ZH, zero
                                 
00264e 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
00264f 95a7                      	ror r26
002650 95a7                      	ror r26
002651 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
002653 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
002654 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
002655 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
002656 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
002657 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
002658 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
002659 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00265a 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00265b 93c0 2808                 	sts pulse2_param, r28
00265d ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
00265e ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
00265f ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
002660 ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
002661 ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
002662 93b0 280f                 	sts pulse2_note, r27 //store the note index
002664 93b0 28b7                 	sts pulse2_fx_Qxy_target_note, r27
002666 93b0 28be                 	sts pulse2_fx_Rxy_target_note, r27
002668 e0a3                      	ldi r26, 0x03
002669 e0b2                      	ldi r27, 0x02
00266a 93b0 287e                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
00266c 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26
00266e 93b0 288b                 	sts pulse2_pitch_macro_offset, r27
002670 93b0 2891                 	sts pulse2_hi_pitch_macro_offset, r27
002672 93b0 2896                 	sts pulse2_duty_macro_offset, r27
002674 9220 2887                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
002676 9220 2888                 	sts pulse2_total_pitch_offset+1, zero
002678 9220 288e                 	sts pulse2_total_hi_pitch_offset, zero
00267a 9220 289d                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00267c 9220 289e                 	sts pulse2_fx_1xx_total+1, zero
00267e 9220 28a1                 	sts pulse2_fx_2xx_total, zero
002680 9220 28a2                 	sts pulse2_fx_2xx_total+1, zero
002682 9220 28a9                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
002684 9220 28aa                 	sts pulse2_fx_3xx_total_offset+1, zero
002686 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002688 91b0 0a9d                 	lds r27, TCB1_CCMPH
00268a 93a0 28a3                 	sts pulse2_fx_3xx_start, r26
00268c 93b0 28a4                 	sts pulse2_fx_3xx_start+1, r27
00268e 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
002690 6093                      	sbr pulse_channel_flags, 3 //set reload flag
002691 9220 28b8                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002693 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
002695 9220 28bc                 	sts pulse2_fx_Qxy_total_offset, zero
002697 9220 28bd                 	sts pulse2_fx_Qxy_total_offset+1, zero
002699 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
00269b 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
00269d 9220 28c3                 	sts pulse2_fx_Rxy_total_offset, zero
00269f 9220 28c4                 	sts pulse2_fx_Rxy_total_offset+1, zero
0026a1 d0f9                      	rcall sound_driver_channel1_increment_offset
0026a2 ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
0026a3 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
0026a4 91a0 2808                 	lds r26, pulse2_param
0026a6 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0026a7 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
0026a8 93a0 2808                 	sts pulse2_param, r26
0026aa 6092                      	sbr pulse_channel_flags, 2
0026ab d0ef                      	rcall sound_driver_channel1_increment_offset
0026ac ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
0026ad 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0026ae 93b0 2878                 	sts pulse2_pattern_delay_rows, r27
0026b0 d0ea                      	rcall sound_driver_channel1_increment_offset
0026b1 c0fd                      	rjmp sound_driver_channel1_end
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
0026b2 9220 287c                 	sts pulse2_volume_macro, zero //reset all macro addresses
0026b4 9220 287d                 	sts pulse2_volume_macro+1, zero
0026b6 9220 2881                 	sts pulse2_arpeggio_macro, zero
0026b8 9220 2882                 	sts pulse2_arpeggio_macro+1, zero
0026ba 9220 2889                 	sts pulse2_pitch_macro, zero
0026bc 9220 288a                 	sts pulse2_pitch_macro+1, zero
0026be 9220 288f                 	sts pulse2_hi_pitch_macro, zero
0026c0 9220 2890                 	sts pulse2_hi_pitch_macro+1, zero
0026c2 9220 2894                 	sts pulse2_duty_macro, zero
0026c4 9220 2895                 	sts pulse2_duty_macro+1, zero
0026c6 9220 2887                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
0026c8 9220 2888                 	sts pulse2_total_pitch_offset+1, zero
0026ca 9220 288e                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0026cc 9631                      	adiw Z, 1 //point to the byte next to the flag
0026cd 91b4                      	lpm r27, Z //store the instrument offset into r27
0026ce edec                      	ldi ZL, LOW(instruments) //point Z to instruments table
0026cf e1fa                      	ldi ZH, HIGH(instruments)
0026d0 0feb                      	add ZL, r27 //point Z to offsetted instrument
0026d1 1df2                      	adc ZH, zero
0026d2 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0026d3 1fff                      	rol ZH
0026d4 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0026d5 91b4                      	lpm r27, Z
                                 
0026d6 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0026d7 1fbb                      	rol r27
0026d8 2fea                      	mov ZL, r26
0026d9 2ffb                      	mov ZH, r27
0026da 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0026db 9632                      	adiw Z, 2 //point Z to the address of the macro
0026dc e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
0026dd 95aa                      	dec r26
0026de f019                      	breq sound_driver_channel1_instrument_change_exit
0026df 95b6                      	lsr r27
0026e0 f078                      	brcs sound_driver_channel1_instrument_change_load_macro
0026e1 cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
0026e2 e0a3                      	ldi r26, 0x03
0026e3 e0b2                      	ldi r27, 0x02
0026e4 93b0 287e                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
0026e6 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26
0026e8 93b0 288b                 	sts pulse2_pitch_macro_offset, r27
0026ea 93b0 2891                 	sts pulse2_hi_pitch_macro_offset, r27
0026ec 93b0 2896                 	sts pulse2_duty_macro_offset, r27
0026ee d0b6                      	rcall sound_driver_channel1_increment_offset_twice
0026ef cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
0026f0 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0026f1 91d5                      	lpm r29, Z+
                                 
0026f2 30a5                      	cpi r26, 5
0026f3 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
0026f4 30a4                      	cpi r26, 4
0026f5 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
0026f6 30a3                      	cpi r26, 3
0026f7 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
0026f8 30a2                      	cpi r26, 2
0026f9 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
0026fa c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
0026fb 93c0 287c                 	sts pulse2_volume_macro, r28
0026fd 93d0 287d                 	sts pulse2_volume_macro+1, r29
0026ff d041                      	rcall sound_driver_channel1_instrument_change_read_header
002700 93c0 2880                 	sts pulse2_volume_macro_release, r28
002702 93d0 287f                 	sts pulse2_volume_macro_loop, r29
002704 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
002705 93c0 2881                 	sts pulse2_arpeggio_macro, r28
002707 93d0 2882                 	sts pulse2_arpeggio_macro+1, r29
002709 9220 28b8                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00270b 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
00270d 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
00270f 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
002711 d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
002712 cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
002713 93c0 2889                 	sts pulse2_pitch_macro, r28
002715 93d0 288a                 	sts pulse2_pitch_macro+1, r29
002717 9220 28b8                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002719 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
00271b 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
00271d 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
00271f d021                      	rcall sound_driver_channel1_instrument_change_read_header
002720 93c0 288d                 	sts pulse2_pitch_macro_release, r28
002722 93d0 288c                 	sts pulse2_pitch_macro_loop, r29
002724 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
002725 93c0 288f                 	sts pulse2_hi_pitch_macro, r28
002727 93d0 2890                 	sts pulse2_hi_pitch_macro+1, r29
002729 9220 28b8                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00272b 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
00272d 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
00272f 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
002731 d00f                      	rcall sound_driver_channel1_instrument_change_read_header
002732 93c0 2893                 	sts pulse2_hi_pitch_macro_release, r28
002734 93d0 2892                 	sts pulse2_hi_pitch_macro_loop, r29
002736 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
002737 93c0 2894                 	sts pulse2_duty_macro, r28
002739 93d0 2895                 	sts pulse2_duty_macro+1, r29
00273b d005                      	rcall sound_driver_channel1_instrument_change_read_header
00273c 93c0 2898                 	sts pulse2_duty_macro_release, r28
00273e 93d0 2897                 	sts pulse2_duty_macro_loop, r29
002740 cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
002741 93ef                      	push ZL
002742 93ff                      	push ZH
002743 2fec                      	mov ZL, r28
002744 2ffd                      	mov ZH, r29
002745 0fee                      	lsl ZL
002746 1fff                      	rol ZH
002747 91c5                      	lpm r28, Z+
002748 91d4                      	lpm r29, Z
002749 91ff                      	pop ZH
00274a 91ef                      	pop ZL
00274b 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
00274c 93ef                      	push ZL
00274d 93ff                      	push ZH
00274e 2fec                      	mov ZL, r28
00274f 2ffd                      	mov ZH, r29
002750 0fee                      	lsl ZL
002751 1fff                      	rol ZH
002752 91c5                      	lpm r28, Z+
002753 91d5                      	lpm r29, Z+
002754 93c0 2885                 	sts pulse2_arpeggio_macro_release, r28
002756 93d0 2884                 	sts pulse2_arpeggio_macro_loop, r29
002758 91c4                      	lpm r28, Z
002759 93c0 2886                 	sts pulse2_arpeggio_macro_mode, r28
00275b 91ff                      	pop ZH
00275c 91ef                      	pop ZL
00275d 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
00275e 91b0 2880                 	lds r27, pulse2_volume_macro_release
002760 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002761 f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
002762 95b3                      	inc r27
002763 93b0 287e                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
002765 91b0 2885                 	lds r27, pulse2_arpeggio_macro_release
002767 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002768 f019                      	breq sound_driver_channel1_release_pitch
002769 95b3                      	inc r27
00276a 93b0 2883                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
00276c 91b0 288d                 	lds r27, pulse2_pitch_macro_release
00276e 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00276f f019                      	breq sound_driver_channel1_release_hi_pitch
002770 95b3                      	inc r27
002771 93b0 288b                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
002773 91b0 2893                 	lds r27, pulse2_hi_pitch_macro_release
002775 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002776 f019                      	breq sound_driver_channel1_release_duty
002777 95b3                      	inc r27
002778 93b0 2891                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
00277a 91b0 2898                 	lds r27, pulse2_duty_macro_release
00277c 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
00277d f019                      	breq sound_driver_channel1_release_exit
00277e 95b3                      	inc r27
00277f 93b0 2896                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
002781 d019                      	rcall sound_driver_channel1_increment_offset
002782 cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
002783 91e0 2819                 	lds ZL, song_frames
002785 91f0 281a                 	lds ZH, song_frames+1
002787 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002789 91b0 281c                 	lds r27, song_frame_offset+1
00278b 9612                      	adiw r27:r26, 2 //offset for channel 1
00278c 0fea                      	add ZL, r26
00278d 1ffb                      	adc ZH, r27
                                 
00278e 91a5                      	lpm r26, Z+ //load the address of the next pattern
00278f 91b4                      	lpm r27, Z
002790 0faa                      	lsl r26
002791 1fbb                      	rol r27
002792 93a0 2876                 	sts pulse2_pattern, r26
002794 93b0 2877                 	sts pulse2_pattern+1, r27
                                 
002796 9220 287a                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002798 9220 287b                 	sts pulse2_pattern_offset+1, zero
00279a cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
00279b 91e0 287a                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
00279d 91f0 287b                 	lds ZH, pulse2_pattern_offset+1
00279f 9631                      	adiw Z, 1
0027a0 93e0 287a                 	sts pulse2_pattern_offset, ZL
0027a2 93f0 287b                 	sts pulse2_pattern_offset+1, ZH
0027a4 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0027a5 91e0 287a                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
0027a7 91f0 287b                 	lds ZH, pulse2_pattern_offset+1
0027a9 9632                      	adiw Z, 2 //increment the pointer twice
0027aa 93e0 287a                 	sts pulse2_pattern_offset, ZL
0027ac 93f0 287b                 	sts pulse2_pattern_offset+1, ZH
0027ae 9508                      	ret
                                 
                                 sound_driver_channel1_end:
                                 sound_driver_channel1_check_Sxx_invalid:
0027af efbf                      	ldi r27, 0xFF
0027b0 91a0 28c6                 	lds r26, pulse2_fx_Sxx_post
0027b2 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
0027b3 f419                      	brne sound_driver_channel1_check_Gxx_invalid
0027b4 93b0 28c6                 	sts pulse2_fx_Sxx_post, r27
0027b6 9508                      	ret
                                 sound_driver_channel1_check_Gxx_invalid:
0027b7 91a0 28b4                 	lds r26, pulse2_fx_Gxx_post
0027b9 15a2                      	cp r26, zero
0027ba f419                      	brne sound_driver_channel2
0027bb 93b0 28b4                 	sts pulse2_fx_Gxx_post, r27
0027bd 9508                      	ret
                                 
                                 
                                 sound_driver_channel2:
0027be 91a0 28c9                 	lds r26, triangle_pattern_delay_rows
0027c0 91b0 28ca                 	lds r27, triangle_pattern_delay_frames
                                 sound_driver_channel2_decrement_frame_delay:
0027c2 95ba                      	dec r27
0027c3 93b0 28ca                 	sts triangle_pattern_delay_frames, r27
                                 
0027c5 9610                      	adiw r27:r26, 0
0027c6 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
0027c7 c2bf                      	rjmp sound_driver_channel2_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel2_main:
0027c8 91e0 28c7                 	lds ZL, triangle_pattern //current pattern for triangle
0027ca 91f0 28c8                 	lds ZH, triangle_pattern+1
0027cc 91a0 28cb                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
0027ce 91b0 28cc                 	lds r27, triangle_pattern_offset+1
0027d0 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0027d1 1ffb                      	adc ZH, r27
0027d2 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
0027d3 35b7                      	cpi r27, 0x57
0027d4 f408                      	brsh sound_driver_channel2_check_if_volume
0027d5 c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
0027d6 36b7                      	cpi r27, 0x67
0027d7 f408                      	brsh sound_driver_channel2_check_if_delay
0027d8 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
0027d9 3eb3                      	cpi r27, 0xE3
0027da f408                      	brsh sound_driver_channel2_check_if_instrument
0027db c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
0027dc f409                      	brne sound_driver_channel2_check_if_release
0027dd c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
0027de 3eb4                      	cpi r27, 0xE4
0027df f409                      	brne sound_driver_channel2_check_if_end
0027e0 c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
0027e1 3fbf                      	cpi r27, 0xFF
0027e2 f409                      	brne sound_driver_channel2_check_if_fx
0027e3 c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
0027e4 9631                      	adiw Z, 1 //point Z to the byte next to the flag
0027e5 91a4                      	lpm r26, Z //load the fx data into r26
0027e6 d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
0027e7 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
0027e8 e4ec                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
0027e9 e7f5                      	ldi ZH, HIGH(channel2_fx << 1)
0027ea 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
0027eb 0feb                      	add ZL, r27 //add offset
0027ec 1df2                      	adc ZH, zero
0027ed 91c5                      	lpm r28, Z+ //load address bytes
0027ee 91d4                      	lpm r29, Z
0027ef 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
0027f0 2ffd                      	mov ZH, r29
0027f1 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
0027f2 93a0 28ea                 	sts triangle_fx_0xy_sequence, r26
0027f4 9220 28eb                 	sts triangle_fx_0xy_sequence+1, zero
0027f6 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
0027f7 9220 28f0                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
0027f9 9220 28f1                 	sts triangle_fx_2xx+1, zero
0027fb 9220 28ea                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
0027fd 9220 28eb                 	sts triangle_fx_0xy_sequence+1, zero
0027ff 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002800 937f                      	push r23
002801 2f6a                      	mov r22, r26 //store the rate into r22
002802 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002803 9f67                      	mul r22, r23
002804 917f                      	pop r23
002805 916f                      	pop r22
                                 
002806 9416                      	lsr r1 //shift out the fractional bits
002807 9407                      	ror r0
002808 9416                      	lsr r1
002809 9407                      	ror r0
00280a 9416                      	lsr r1
00280b 9407                      	ror r0
00280c 9416                      	lsr r1
00280d 9407                      	ror r0
00280e 9200 28ec                 	sts triangle_fx_1xx, r0
002810 9210 28ed                 	sts triangle_fx_1xx+1, r1
002812 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
002813 9220 28ec                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
002815 9220 28ed                 	sts triangle_fx_1xx+1, zero
002817 9220 28ea                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
002819 9220 28eb                 	sts triangle_fx_0xy_sequence+1, zero
00281b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00281c 937f                      	push r23
00281d 2f6a                      	mov r22, r26 //store the rate into r22
00281e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00281f 9f67                      	mul r22, r23
002820 917f                      	pop r23
002821 916f                      	pop r22
                                 
002822 9416                      	lsr r1 //shift out the fractional bits
002823 9407                      	ror r0
002824 9416                      	lsr r1
002825 9407                      	ror r0
002826 9416                      	lsr r1
002827 9407                      	ror r0
002828 9416                      	lsr r1
002829 9407                      	ror r0
00282a 9200 28f0                 	sts triangle_fx_2xx, r0
00282c 9210 28f1                 	sts triangle_fx_2xx+1, r1
00282e cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
00282f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002830 937f                      	push r23
002831 2f6a                      	mov r22, r26 //store the rate into r22
002832 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002833 9f67                      	mul r22, r23
002834 917f                      	pop r23
002835 916f                      	pop r22
                                 
002836 9416                      	lsr r1 //shift out the fractional bits
002837 9407                      	ror r0
002838 9416                      	lsr r1
002839 9407                      	ror r0
00283a 9416                      	lsr r1
00283b 9407                      	ror r0
00283c 9416                      	lsr r1
00283d 9407                      	ror r0
00283e 9200 28f8                 	sts triangle_fx_3xx_speed, r0
002840 9210 28f9                 	sts triangle_fx_3xx_speed+1, r1
                                 
002842 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
002843 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
002844 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
002845 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
002847 91b0 0aad                 	lds r27, TCB2_CCMPH
002849 93a0 28f4                 	sts triangle_fx_3xx_start, r26
00284b 93b0 28f5                 	sts triangle_fx_3xx_start+1, r27
                                 
00284d 9220 28fa                 	sts triangle_fx_3xx_total_offset, zero
00284f 9220 28fb                 	sts triangle_fx_3xx_total_offset+1, zero
002851 cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
002852 2fba                      	mov r27, r26
002853 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002854 95a2                      	swap r26
002855 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002856 93a0 28fc                 	sts triangle_fx_4xy_speed, r26
002858 93b0 28fd                 	sts triangle_fx_4xy_depth, r27
00285a 9220 28fe                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
00285c cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
00285d cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
00285e cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
00285f 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002861 cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
002862 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002864 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
002865 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002867 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
002868 15a2                      	cp r26, zero
002869 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
00286a e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00286b 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00286d cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
00286e 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
002870 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002872 9220 0aad                 	sts TCB2_CCMPH, zero
002874 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
002875 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002877 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
002878 15a2                      	cp r26, zero
002879 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
00287a 91b0 2821                 	lds r27, song_speed
00287c 17ab                      	cp r26, r27
00287d f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
00287e 93a0 28ff                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002880 e0b1                      	ldi r27, 0x01
002881 93b0 28c9                 	sts triangle_pattern_delay_rows, r27
002883 c212                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
002884 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
002885 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
002886 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
002887 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
002888 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
002889 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00288a 937f                      	push r23
00288b 2f6a                      	mov r22, r26
00288c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00288d 0367                      	mulsu r22, r23
00288e 917f                      	pop r23
00288f 916f                      	pop r22
002890 9416                      	lsr r1 //shift out the fractional bits
002891 9407                      	ror r0
002892 9416                      	lsr r1
002893 9407                      	ror r0
002894 9416                      	lsr r1
002895 9407                      	ror r0
002896 9416                      	lsr r1
002897 9407                      	ror r0
002898 fe13                      	sbrs r1, 3 //check if result was a negative number
002899 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
00289a efb0                      	ldi r27, 0xF0
00289b 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
00289c 9200 2901                 	sts triangle_fx_Pxx_total, r0
00289e 9210 2902                 	sts triangle_fx_Pxx_total+1, r1
0028a0 cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
0028a1 91e0 28d2                 	lds ZL, triangle_arpeggio_macro
0028a3 91f0 28d3                 	lds ZH, triangle_arpeggio_macro+1
0028a5 9630                      	adiw Z, 0
0028a6 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
0028a7 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
0028a8 91e0 28da                 	lds ZL, triangle_pitch_macro
0028aa 91f0 28db                 	lds ZH, triangle_pitch_macro+1
0028ac 9630                      	adiw Z, 0
0028ad f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
0028ae cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
0028af 91e0 28e0                 	lds ZL, triangle_hi_pitch_macro
0028b1 91f0 28e1                 	lds ZH, triangle_hi_pitch_macro+1
0028b3 9630                      	adiw Z, 0
0028b4 f009                      	breq sound_driver_channel2_fx_Qxy_process
0028b5 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
0028b6 2fba                      	mov r27, r26 //copy fx parameters into r27
0028b7 70bf                      	andi r27, 0x0F //mask note index offset
0028b8 91c0 2903                 	lds r28, triangle_fx_Qxy_target_note //load current note index
0028ba 0fbc                      	add r27, r28
0028bb 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
0028bc f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
0028bd e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
0028be 93b0 2903                 	sts triangle_fx_Qxy_target_note, r27
0028c0 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0028c1 e0f0                      	ldi ZH, HIGH(note_table << 1)
0028c2 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
0028c3 0feb                      	add ZL, r27 //add offset
0028c4 1df2                      	adc ZH, zero
0028c5 91c5                      	lpm r28, Z+ //load bytes
0028c6 91d4                      	lpm r29, Z
0028c7 93c0 2904                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
0028c9 93d0 2905                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
0028cb 95a2                      	swap r26
0028cc 70af                      	andi r26, 0x0F //mask effect speed
0028cd 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
0028ce 95a3                      	inc r26 //increment the speed by 1
                                 
0028cf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0028d0 937f                      	push r23
0028d1 2f6a                      	mov r22, r26 //store the speed data into r27
0028d2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0028d3 9f67                      	mul r22, r23
0028d4 917f                      	pop r23
0028d5 916f                      	pop r22
                                 
0028d6 9416                      	lsr r1 //shift out the fractional bits
0028d7 9407                      	ror r0
0028d8 9416                      	lsr r1
0028d9 9407                      	ror r0
0028da 9416                      	lsr r1
0028db 9407                      	ror r0
0028dc 9416                      	lsr r1
0028dd 9407                      	ror r0
                                 
0028de 9200 2906                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
0028e0 9210 2907                 	sts triangle_fx_Qxy_speed+1, r1
0028e2 cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
0028e3 91e0 28d2                 	lds ZL, triangle_arpeggio_macro
0028e5 91f0 28d3                 	lds ZH, triangle_arpeggio_macro+1
0028e7 9630                      	adiw Z, 0
0028e8 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
0028e9 cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
0028ea 91e0 28da                 	lds ZL, triangle_pitch_macro
0028ec 91f0 28db                 	lds ZH, triangle_pitch_macro+1
0028ee 9630                      	adiw Z, 0
0028ef f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
0028f0 ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
0028f1 91e0 28e0                 	lds ZL, triangle_hi_pitch_macro
0028f3 91f0 28e1                 	lds ZH, triangle_hi_pitch_macro+1
0028f5 9630                      	adiw Z, 0
0028f6 f009                      	breq sound_driver_channel2_fx_Rxy_process
0028f7 ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
0028f8 2fba                      	mov r27, r26 //copy fx parameters into r27
0028f9 70bf                      	andi r27, 0x0F //mask note index offset
0028fa 91c0 290a                 	lds r28, triangle_fx_Rxy_target_note //load current note index
0028fc 1bcb                      	sub r28, r27
0028fd f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
0028fe e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
0028ff 93c0 290a                 	sts triangle_fx_Rxy_target_note, r28
002901 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002902 e0f0                      	ldi ZH, HIGH(note_table << 1)
002903 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
002904 0fec                      	add ZL, r28 //add offset
002905 1df2                      	adc ZH, zero
002906 91c5                      	lpm r28, Z+ //load bytes
002907 91d4                      	lpm r29, Z
002908 93c0 290b                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
00290a 93d0 290c                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
00290c 95a2                      	swap r26
00290d 70af                      	andi r26, 0x0F //mask effect speed
00290e 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00290f 95a3                      	inc r26 //increment the speed by 1
                                 
002910 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002911 937f                      	push r23
002912 2f6a                      	mov r22, r26 //store the speed data into r27
002913 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002914 9f67                      	mul r22, r23
002915 917f                      	pop r23
002916 916f                      	pop r22
                                 
002917 9416                      	lsr r1 //shift out the fractional bits
002918 9407                      	ror r0
002919 9416                      	lsr r1
00291a 9407                      	ror r0
00291b 9416                      	lsr r1
00291c 9407                      	ror r0
00291d 9416                      	lsr r1
00291e 9407                      	ror r0
                                 
00291f 9200 290d                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
002921 9210 290e                 	sts triangle_fx_Rxy_speed+1, r1
002923 cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
002924 15a2                      	cp r26, zero
002925 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
002926 91b0 2821                 	lds r27, song_speed
002928 17ab                      	cp r26, r27
002929 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
00292a 93a0 2911                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00292c e0b1                      	ldi r27, 0x01
00292d 93b0 28c9                 	sts triangle_pattern_delay_rows, r27
00292f c166                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
002930 ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
002931 ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
002932 ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
002933 ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
002934 ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
002935 ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
002936 93b0 2812                 	sts triangle_note, r27 //store the note index
002938 93b0 2903                 	sts triangle_fx_Qxy_target_note, r27
00293a 93b0 290a                 	sts triangle_fx_Rxy_target_note, r27
00293c e0a3                      	ldi r26, 0x03
00293d e0b2                      	ldi r27, 0x02
00293e 93b0 28cf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
002940 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26
002942 93b0 28dc                 	sts triangle_pitch_macro_offset, r27
002944 93b0 28e2                 	sts triangle_hi_pitch_macro_offset, r27
002946 93b0 28e7                 	sts triangle_duty_macro_offset, r27
002948 9220 28d8                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
00294a 9220 28d9                 	sts triangle_total_pitch_offset+1, zero
00294c 9220 28df                 	sts triangle_total_hi_pitch_offset, zero
00294e 9220 28ee                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002950 9220 28ef                 	sts triangle_fx_1xx_total+1, zero
002952 9220 28f2                 	sts triangle_fx_2xx_total, zero
002954 9220 28f3                 	sts triangle_fx_2xx_total+1, zero
002956 9220 28fa                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
002958 9220 28fb                 	sts triangle_fx_3xx_total_offset+1, zero
00295a 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
00295c 91b0 0aad                 	lds r27, TCB2_CCMPH
00295e 93a0 28f4                 	sts triangle_fx_3xx_start, r26
002960 93b0 28f5                 	sts triangle_fx_3xx_start+1, r27
002962 9220 2904                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002964 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
002966 9220 2908                 	sts triangle_fx_Qxy_total_offset, zero
002968 9220 2909                 	sts triangle_fx_Qxy_total_offset+1, zero
00296a 9220 290b                 	sts triangle_fx_Rxy_target, zero
00296c 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
00296e 9220 290f                 	sts triangle_fx_Rxy_total_offset, zero
002970 9220 2910                 	sts triangle_fx_Rxy_total_offset+1, zero
002972 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002973 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002975 d0fd                      	rcall sound_driver_channel2_increment_offset
002976 ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
002977 d0fb                      	rcall sound_driver_channel2_increment_offset
002978 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
002979 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
00297a e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
00297b 93b0 0aa5                 	sts TCB2_INTCTRL, r27
00297d ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
00297e 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
002980 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002982 9220 0aad                 	sts TCB2_CCMPH, zero
002984 ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
002985 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002986 93b0 28c9                 	sts triangle_pattern_delay_rows, r27
002988 d0ea                      	rcall sound_driver_channel2_increment_offset
002989 c0fd                      	rjmp sound_driver_channel2_end
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
00298a 9220 28cd                 	sts triangle_volume_macro, zero //reset all macro addresses
00298c 9220 28ce                 	sts triangle_volume_macro+1, zero
00298e 9220 28d2                 	sts triangle_arpeggio_macro, zero
002990 9220 28d3                 	sts triangle_arpeggio_macro+1, zero
002992 9220 28da                 	sts triangle_pitch_macro, zero
002994 9220 28db                 	sts triangle_pitch_macro+1, zero
002996 9220 28e0                 	sts triangle_hi_pitch_macro, zero
002998 9220 28e1                 	sts triangle_hi_pitch_macro+1, zero
00299a 9220 28e5                 	sts triangle_duty_macro, zero
00299c 9220 28e6                 	sts triangle_duty_macro+1, zero
00299e 9220 28d8                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
0029a0 9220 28d9                 	sts triangle_total_pitch_offset+1, zero
0029a2 9220 28df                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0029a4 9631                      	adiw Z, 1 //point to the byte next to the flag
0029a5 91b4                      	lpm r27, Z //store the instrument offset into r27
0029a6 edec                      	ldi ZL, LOW(instruments) //point Z to instruments table
0029a7 e1fa                      	ldi ZH, HIGH(instruments)
0029a8 0feb                      	add ZL, r27 //point Z to offsetted instrument
0029a9 1df2                      	adc ZH, zero
0029aa 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0029ab 1fff                      	rol ZH
0029ac 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0029ad 91b4                      	lpm r27, Z
                                 
0029ae 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0029af 1fbb                      	rol r27
0029b0 2fea                      	mov ZL, r26
0029b1 2ffb                      	mov ZH, r27
0029b2 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
0029b3 9632                      	adiw Z, 2 //point Z to the address of the macro
0029b4 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
0029b5 95aa                      	dec r26
0029b6 f019                      	breq sound_driver_channel2_instrument_change_exit
0029b7 95b6                      	lsr r27
0029b8 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
0029b9 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
0029ba e0a3                      	ldi r26, 0x03
0029bb e0b2                      	ldi r27, 0x02
0029bc 93b0 28cf                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
0029be 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26
0029c0 93b0 28dc                 	sts triangle_pitch_macro_offset, r27
0029c2 93b0 28e2                 	sts triangle_hi_pitch_macro_offset, r27
0029c4 93b0 28e7                 	sts triangle_duty_macro_offset, r27
0029c6 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
0029c7 ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
0029c8 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0029c9 91d5                      	lpm r29, Z+
                                 
0029ca 30a5                      	cpi r26, 5
0029cb f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
0029cc 30a4                      	cpi r26, 4
0029cd f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
0029ce 30a3                      	cpi r26, 3
0029cf f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
0029d0 30a2                      	cpi r26, 2
0029d1 f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
0029d2 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
0029d3 93c0 28cd                 	sts triangle_volume_macro, r28
0029d5 93d0 28ce                 	sts triangle_volume_macro+1, r29
0029d7 d041                      	rcall sound_driver_channel2_instrument_change_read_header
0029d8 93c0 28d1                 	sts triangle_volume_macro_release, r28
0029da 93d0 28d0                 	sts triangle_volume_macro_loop, r29
0029dc cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
0029dd 93c0 28d2                 	sts triangle_arpeggio_macro, r28
0029df 93d0 28d3                 	sts triangle_arpeggio_macro+1, r29
0029e1 9220 2904                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0029e3 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
0029e5 9220 290b                 	sts triangle_fx_Rxy_target, zero
0029e7 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
0029e9 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
0029ea cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
0029eb 93c0 28da                 	sts triangle_pitch_macro, r28
0029ed 93d0 28db                 	sts triangle_pitch_macro+1, r29
0029ef 9220 2904                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0029f1 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
0029f3 9220 290b                 	sts triangle_fx_Rxy_target, zero
0029f5 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
0029f7 d021                      	rcall sound_driver_channel2_instrument_change_read_header
0029f8 93c0 28de                 	sts triangle_pitch_macro_release, r28
0029fa 93d0 28dd                 	sts triangle_pitch_macro_loop, r29
0029fc cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
0029fd 93c0 28e0                 	sts triangle_hi_pitch_macro, r28
0029ff 93d0 28e1                 	sts triangle_hi_pitch_macro+1, r29
002a01 9220 2904                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
002a03 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
002a05 9220 290b                 	sts triangle_fx_Rxy_target, zero
002a07 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
002a09 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
002a0a 93c0 28e4                 	sts triangle_hi_pitch_macro_release, r28
002a0c 93d0 28e3                 	sts triangle_hi_pitch_macro_loop, r29
002a0e cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
002a0f 93c0 28e5                 	sts triangle_duty_macro, r28
002a11 93d0 28e6                 	sts triangle_duty_macro+1, r29
002a13 d005                      	rcall sound_driver_channel2_instrument_change_read_header
002a14 93c0 28e9                 	sts triangle_duty_macro_release, r28
002a16 93d0 28e8                 	sts triangle_duty_macro_loop, r29
002a18 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
002a19 93ef                      	push ZL
002a1a 93ff                      	push ZH
002a1b 2fec                      	mov ZL, r28
002a1c 2ffd                      	mov ZH, r29
002a1d 0fee                      	lsl ZL
002a1e 1fff                      	rol ZH
002a1f 91c5                      	lpm r28, Z+
002a20 91d4                      	lpm r29, Z
002a21 91ff                      	pop ZH
002a22 91ef                      	pop ZL
002a23 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
002a24 93ef                      	push ZL
002a25 93ff                      	push ZH
002a26 2fec                      	mov ZL, r28
002a27 2ffd                      	mov ZH, r29
002a28 0fee                      	lsl ZL
002a29 1fff                      	rol ZH
002a2a 91c5                      	lpm r28, Z+
002a2b 91d5                      	lpm r29, Z+
002a2c 93c0 28d6                 	sts triangle_arpeggio_macro_release, r28
002a2e 93d0 28d5                 	sts triangle_arpeggio_macro_loop, r29
002a30 91c4                      	lpm r28, Z
002a31 93c0 28d7                 	sts triangle_arpeggio_macro_mode, r28
002a33 91ff                      	pop ZH
002a34 91ef                      	pop ZL
002a35 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
002a36 91b0 28d1                 	lds r27, triangle_volume_macro_release
002a38 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002a39 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
002a3a 95b3                      	inc r27
002a3b 93b0 28cf                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
002a3d 91b0 28d6                 	lds r27, triangle_arpeggio_macro_release
002a3f 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002a40 f019                      	breq sound_driver_channel2_release_pitch
002a41 95b3                      	inc r27
002a42 93b0 28d4                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
002a44 91b0 28de                 	lds r27, triangle_pitch_macro_release
002a46 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002a47 f019                      	breq sound_driver_channel2_release_hi_pitch
002a48 95b3                      	inc r27
002a49 93b0 28dc                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
002a4b 91b0 28e4                 	lds r27, triangle_hi_pitch_macro_release
002a4d 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002a4e f019                      	breq sound_driver_channel2_release_duty
002a4f 95b3                      	inc r27
002a50 93b0 28e2                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
002a52 91b0 28e9                 	lds r27, triangle_duty_macro_release
002a54 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002a55 f019                      	breq sound_driver_channel2_release_exit
002a56 95b3                      	inc r27
002a57 93b0 28e7                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
002a59 d019                      	rcall sound_driver_channel2_increment_offset
002a5a cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
002a5b 91e0 2819                 	lds ZL, song_frames
002a5d 91f0 281a                 	lds ZH, song_frames+1
002a5f 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002a61 91b0 281c                 	lds r27, song_frame_offset+1
002a63 9614                      	adiw r27:r26, 4 //offset for channel 2
002a64 0fea                      	add ZL, r26
002a65 1ffb                      	adc ZH, r27
                                 
002a66 91a5                      	lpm r26, Z+ //load the address of the next pattern
002a67 91b4                      	lpm r27, Z
002a68 0faa                      	lsl r26
002a69 1fbb                      	rol r27
002a6a 93a0 28c7                 	sts triangle_pattern, r26
002a6c 93b0 28c8                 	sts triangle_pattern+1, r27
                                 
002a6e 9220 28cb                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002a70 9220 28cc                 	sts triangle_pattern_offset+1, zero
002a72 cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
002a73 91e0 28cb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
002a75 91f0 28cc                 	lds ZH, triangle_pattern_offset+1
002a77 9631                      	adiw Z, 1
002a78 93e0 28cb                 	sts triangle_pattern_offset, ZL
002a7a 93f0 28cc                 	sts triangle_pattern_offset+1, ZH
002a7c 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002a7d 91e0 28cb                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
002a7f 91f0 28cc                 	lds ZH, triangle_pattern_offset+1
002a81 9632                      	adiw Z, 2 //increment the pointer twice
002a82 93e0 28cb                 	sts triangle_pattern_offset, ZL
002a84 93f0 28cc                 	sts triangle_pattern_offset+1, ZH
002a86 9508                      	ret
                                 
                                 sound_driver_channel2_end:
                                 sound_driver_channel2_check_Sxx_invalid:
002a87 efbf                      	ldi r27, 0xFF
002a88 91a0 2912                 	lds r26, triangle_fx_Sxx_post
002a8a 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
002a8b f419                      	brne sound_driver_channel2_check_Gxx_invalid
002a8c 93b0 2912                 	sts triangle_fx_Sxx_post, r27
002a8e 9508                      	ret
                                 sound_driver_channel2_check_Gxx_invalid:
002a8f 91a0 2900                 	lds r26, triangle_fx_Gxx_post
002a91 15a2                      	cp r26, zero
002a92 f419                      	brne sound_driver_channel3
002a93 93b0 2900                 	sts triangle_fx_Gxx_post, r27
002a95 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3:
002a96 91a0 2915                 	lds r26, noise_pattern_delay_rows
002a98 91b0 2916                 	lds r27, noise_pattern_delay_frames
                                 sound_driver_channel3_decrement_frame_delay:
002a9a 95ba                      	dec r27
002a9b 93b0 2916                 	sts noise_pattern_delay_frames, r27
                                 
002a9d 9610                      	adiw r27:r26, 0
002a9e f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
002a9f c1b9                      	rjmp sound_driver_channel3_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel3_main:
002aa0 91e0 2913                 	lds ZL, noise_pattern //current pattern for noise
002aa2 91f0 2914                 	lds ZH, noise_pattern+1
002aa4 91a0 2917                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
002aa6 91b0 2918                 	lds r27, noise_pattern_offset+1
002aa8 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
002aa9 1ffb                      	adc ZH, r27
002aaa 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
002aab 35b7                      	cpi r27, 0x57
002aac f408                      	brsh sound_driver_channel3_check_if_volume
002aad c096                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
002aae 36b7                      	cpi r27, 0x67
002aaf f408                      	brsh sound_driver_channel3_check_if_delay
002ab0 c0b1                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
002ab1 3eb3                      	cpi r27, 0xE3
002ab2 f408                      	brsh sound_driver_channel3_check_if_instrument
002ab3 c0b7                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
002ab4 f409                      	brne sound_driver_channel3_check_if_release
002ab5 c0ba                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
002ab6 3eb4                      	cpi r27, 0xE4
002ab7 f409                      	brne sound_driver_channel3_check_if_end
002ab8 c14b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
002ab9 3fbf                      	cpi r27, 0xFF
002aba f409                      	brne sound_driver_channel3_check_if_fx
002abb c16d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
002abc 9631                      	adiw Z, 1 //point Z to the byte next to the flag
002abd 91a4                      	lpm r26, Z //load the fx data into r26
002abe d190                      	rcall sound_driver_channel3_increment_offset_twice
                                 
002abf 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
002ac0 e8e0                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
002ac1 e7f5                      	ldi ZH, HIGH(channel3_fx << 1)
002ac2 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
002ac3 0feb                      	add ZL, r27 //add offset
002ac4 1df2                      	adc ZH, zero
002ac5 91c5                      	lpm r28, Z+ //load address bytes
002ac6 91d4                      	lpm r29, Z
002ac7 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002ac8 2ffd                      	mov ZH, r29
002ac9 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
002aca 93a0 2936                 	sts noise_fx_0xy_sequence, r26
002acc 9220 2937                 	sts noise_fx_0xy_sequence+1, zero
002ace cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
002acf 9220 293a                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
002ad1 9220 2936                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002ad3 9220 2937                 	sts noise_fx_0xy_sequence+1, zero
002ad5 93a0 2938                 	sts noise_fx_1xx, r26
002ad7 cfc8                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
002ad8 9220 2938                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
002ada 9220 2936                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
002adc 9220 2937                 	sts noise_fx_0xy_sequence+1, zero
002ade 93a0 293a                 	sts noise_fx_2xx, r26
002ae0 cfbf                      	rjmp sound_driver_channel3_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel3_fx_3xx:
002ae1 cfbe                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
002ae2 2fba                      	mov r27, r26
002ae3 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002ae4 95a2                      	swap r26
002ae5 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002ae6 93a0 293c                 	sts noise_fx_4xy_speed, r26
002ae8 93b0 293d                 	sts noise_fx_4xy_depth, r27
002aea 9220 293e                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
002aec 9220 293f                 	sts noise_fx_4xy_offset, zero
002aee cfb1                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
002aef 2fba                      	mov r27, r26
002af0 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
002af1 95a2                      	swap r26
002af2 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
002af3 93a0 2940                 	sts noise_fx_7xy_speed, r26
002af5 93b0 2941                 	sts noise_fx_7xy_depth, r27
002af7 9220 2942                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
002af9 9220 2943                 	sts noise_fx_7xy_value, zero //reset the tremelo value
002afb cfa4                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
002afc 93a0 2944                 	sts noise_fx_Axy, r26
002afe cfa1                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
002aff 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002b01 cf9e                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
002b02 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002b04 cf9b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
002b05 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002b07 cf98                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
002b08 91b0 2813                 	lds r27, noise_param
002b0a 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
002b0b 2bba                      	or r27, r26 //move new VVVV bits into noise_param
002b0c 93b0 2813                 	sts noise_param, r27
002b0e cf91                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
002b0f 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002b11 cf8e                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
002b12 15a2                      	cp r26, zero
002b13 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
002b14 91b0 2821                 	lds r27, song_speed
002b16 17ab                      	cp r26, r27
002b17 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
002b18 93a0 2945                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002b1a e0b1                      	ldi r27, 0x01
002b1b 93b0 2915                 	sts noise_pattern_delay_rows, r27
002b1d c14a                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
002b1e cf81                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
002b1f cf80                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
002b20 cf7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
002b21 cf7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
002b22 cf7d                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
002b23 93a0 2947                 	sts noise_fx_Pxx_total, r26
002b25 cf7a                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Qxy: //note slide up
002b26 cf79                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Rxy: //note slide down
002b27 cf78                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
002b28 15a2                      	cp r26, zero
002b29 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
002b2a 91b0 2821                 	lds r27, song_speed
002b2c 17ab                      	cp r26, r27
002b2d f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
002b2e 93a0 2948                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002b30 e0b1                      	ldi r27, 0x01
002b31 93b0 2915                 	sts noise_pattern_delay_rows, r27
002b33 c134                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
002b34 cf6b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
002b35 95a6                      	lsr r26
002b36 95a7                      	ror r26 //move mode bit to bit 7
002b37 91b0 2814                 	lds r27, noise_period
002b39 77bf                      	andi r27, 0b01111111
002b3a 2bba                      	or r27, r26 //store the new noise mode
002b3b 93b0 2813                 	sts noise_param, r27
                                 
002b3d 776f                      	andi noise_sequence_HIGH, 0b01111111
002b3e 2b6a                      	or noise_sequence_HIGH, r26
002b3f cf60                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
002b40 cf5f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
002b41 cf5e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
002b42 cf5d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
002b43 cf5c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
002b44 93b0 2817                 	sts noise_note, r27
002b46 93b0 2818                 	sts noise_adjusted_note, r27
002b48 e0a3                      	ldi r26, 0x03
002b49 e0b2                      	ldi r27, 0x02
002b4a 93b0 291b                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002b4c 93a0 2920                 	sts noise_arpeggio_macro_offset, r26
002b4e 93b0 2928                 	sts noise_pitch_macro_offset, r27
002b50 93b0 292e                 	sts noise_hi_pitch_macro_offset, r27
002b52 93b0 2933                 	sts noise_duty_macro_offset, r27
002b54 9220 2924                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
002b56 9220 2925                 	sts noise_total_pitch_offset+1, zero
002b58 9220 292b                 	sts noise_total_hi_pitch_offset, zero
002b5a 9220 2939                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
002b5c 9220 293b                 	sts noise_fx_2xx_total, zero
002b5e 9220 293f                 	sts noise_fx_4xy_offset, zero
002b60 d0e4                      	rcall sound_driver_channel3_increment_offset
002b61 cf3e                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
002b62 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest note value, which is 0x56
002b63 91a0 2813                 	lds r26, noise_param
002b65 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
002b66 2bab                      	or r26, r27 //move new VVVV bits into noise_param
002b67 93a0 2813                 	sts noise_param, r26
002b69 d0db                      	rcall sound_driver_channel3_increment_offset
002b6a cf35                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
002b6b 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002b6c 93b0 2915                 	sts noise_pattern_delay_rows, r27
002b6e d0d6                      	rcall sound_driver_channel3_increment_offset
002b6f c0e9                      	rjmp sound_driver_channel3_end
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
002b70 9220 2919                 	sts noise_volume_macro, zero //reset all macro addresses
002b72 9220 291a                 	sts noise_volume_macro+1, zero
002b74 9220 291e                 	sts noise_arpeggio_macro, zero
002b76 9220 291f                 	sts noise_arpeggio_macro+1, zero
002b78 9220 2926                 	sts noise_pitch_macro, zero
002b7a 9220 2927                 	sts noise_pitch_macro+1, zero
002b7c 9220 292c                 	sts noise_hi_pitch_macro, zero
002b7e 9220 292d                 	sts noise_hi_pitch_macro+1, zero
002b80 9220 2931                 	sts noise_duty_macro, zero
002b82 9220 2932                 	sts noise_duty_macro+1, zero
002b84 9220 2924                 	sts noise_total_pitch_offset, zero //reset the pitch offset
002b86 9220 2925                 	sts noise_total_pitch_offset+1, zero
002b88 9220 292b                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
002b8a 9631                      	adiw Z, 1 //point to the byte next to the flag
002b8b 91b4                      	lpm r27, Z //store the instrument offset into r27
002b8c edec                      	ldi ZL, LOW(instruments) //point Z to instruments table
002b8d e1fa                      	ldi ZH, HIGH(instruments)
002b8e 0feb                      	add ZL, r27 //point Z to offsetted instrument
002b8f 1df2                      	adc ZH, zero
002b90 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
002b91 1fff                      	rol ZH
002b92 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
002b93 91b4                      	lpm r27, Z
                                 
002b94 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
002b95 1fbb                      	rol r27
002b96 2fea                      	mov ZL, r26
002b97 2ffb                      	mov ZH, r27
002b98 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
002b99 9632                      	adiw Z, 2 //point Z to the address of the macro
002b9a e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
002b9b 95aa                      	dec r26
002b9c f019                      	breq sound_driver_channel3_instrument_change_exit
002b9d 95b6                      	lsr r27
002b9e f078                      	brcs sound_driver_channel3_instrument_change_load_macro
002b9f cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
002ba0 e0a3                      	ldi r26, 0x03
002ba1 e0b2                      	ldi r27, 0x02
002ba2 93b0 291b                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
002ba4 93a0 2920                 	sts noise_arpeggio_macro_offset, r26
002ba6 93b0 2928                 	sts noise_pitch_macro_offset, r27
002ba8 93b0 292e                 	sts noise_hi_pitch_macro_offset, r27
002baa 93b0 2933                 	sts noise_duty_macro_offset, r27
002bac d0a2                      	rcall sound_driver_channel3_increment_offset_twice
002bad cef2                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
002bae 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
002baf 91d5                      	lpm r29, Z+
                                 
002bb0 30a5                      	cpi r26, 5
002bb1 f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
002bb2 30a4                      	cpi r26, 4
002bb3 f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
002bb4 30a3                      	cpi r26, 3
002bb5 f099                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
002bb6 30a2                      	cpi r26, 2
002bb7 f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
002bb8 c024                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
002bb9 93c0 2919                 	sts noise_volume_macro, r28
002bbb 93d0 291a                 	sts noise_volume_macro+1, r29
002bbd d029                      	rcall sound_driver_channel3_instrument_change_read_header
002bbe 93c0 291d                 	sts noise_volume_macro_release, r28
002bc0 93d0 291c                 	sts noise_volume_macro_loop, r29
002bc2 cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
002bc3 93c0 291e                 	sts noise_arpeggio_macro, r28
002bc5 93d0 291f                 	sts noise_arpeggio_macro+1, r29
002bc7 d02a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
002bc8 cfd2                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
002bc9 93c0 2926                 	sts noise_pitch_macro, r28
002bcb 93d0 2927                 	sts noise_pitch_macro+1, r29
002bcd d019                      	rcall sound_driver_channel3_instrument_change_read_header
002bce 93c0 292a                 	sts noise_pitch_macro_release, r28
002bd0 93d0 2929                 	sts noise_pitch_macro_loop, r29
002bd2 cfc8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
002bd3 93c0 292c                 	sts noise_hi_pitch_macro, r28
002bd5 93d0 292d                 	sts noise_hi_pitch_macro+1, r29
002bd7 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
002bd8 93c0 2930                 	sts noise_hi_pitch_macro_release, r28
002bda 93d0 292f                 	sts noise_hi_pitch_macro_loop, r29
002bdc cfbe                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
002bdd 93c0 2931                 	sts noise_duty_macro, r28
002bdf 93d0 2932                 	sts noise_duty_macro+1, r29
002be1 d005                      	rcall sound_driver_channel3_instrument_change_read_header
002be2 93c0 2935                 	sts noise_duty_macro_release, r28
002be4 93d0 2934                 	sts noise_duty_macro_loop, r29
002be6 cfb4                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
002be7 93ef                      	push ZL
002be8 93ff                      	push ZH
002be9 2fec                      	mov ZL, r28
002bea 2ffd                      	mov ZH, r29
002beb 0fee                      	lsl ZL
002bec 1fff                      	rol ZH
002bed 91c5                      	lpm r28, Z+
002bee 91d4                      	lpm r29, Z
002bef 91ff                      	pop ZH
002bf0 91ef                      	pop ZL
002bf1 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
002bf2 93ef                      	push ZL
002bf3 93ff                      	push ZH
002bf4 2fec                      	mov ZL, r28
002bf5 2ffd                      	mov ZH, r29
002bf6 0fee                      	lsl ZL
002bf7 1fff                      	rol ZH
002bf8 91c5                      	lpm r28, Z+
002bf9 91d5                      	lpm r29, Z+
002bfa 93c0 2922                 	sts noise_arpeggio_macro_release, r28
002bfc 93d0 2921                 	sts noise_arpeggio_macro_loop, r29
002bfe 91c4                      	lpm r28, Z
002bff 93c0 2923                 	sts noise_arpeggio_macro_mode, r28
002c01 91ff                      	pop ZH
002c02 91ef                      	pop ZL
002c03 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
002c04 91b0 291d                 	lds r27, noise_volume_macro_release
002c06 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002c07 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
002c08 95b3                      	inc r27
002c09 93b0 291b                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
002c0b 91b0 2922                 	lds r27, noise_arpeggio_macro_release
002c0d 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
002c0e f019                      	breq sound_driver_channel3_release_pitch
002c0f 95b3                      	inc r27
002c10 93b0 2920                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
002c12 91b0 292a                 	lds r27, noise_pitch_macro_release
002c14 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002c15 f019                      	breq sound_driver_channel3_release_hi_pitch
002c16 95b3                      	inc r27
002c17 93b0 2928                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
002c19 91b0 2930                 	lds r27, noise_hi_pitch_macro_release
002c1b 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
002c1c f019                      	breq sound_driver_channel3_release_duty
002c1d 95b3                      	inc r27
002c1e 93b0 292e                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
002c20 91b0 2935                 	lds r27, noise_duty_macro_release
002c22 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002c23 f019                      	breq sound_driver_channel3_release_exit
002c24 95b3                      	inc r27
002c25 93b0 2933                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
002c27 d01d                      	rcall sound_driver_channel3_increment_offset
002c28 ce77                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
002c29 91e0 2819                 	lds ZL, song_frames
002c2b 91f0 281a                 	lds ZH, song_frames+1
002c2d 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002c2f 91b0 281c                 	lds r27, song_frame_offset+1
002c31 93a0 281b                 	sts song_frame_offset, r26
002c33 93b0 281c                 	sts song_frame_offset+1, r27
002c35 9616                      	adiw r27:r26, 6 //offset for channel 3
002c36 0fea                      	add ZL, r26
002c37 1ffb                      	adc ZH, r27
                                 
002c38 91a5                      	lpm r26, Z+ //load the address of the next pattern
002c39 91b4                      	lpm r27, Z
002c3a 0faa                      	lsl r26
002c3b 1fbb                      	rol r27
002c3c 93a0 2913                 	sts noise_pattern, r26
002c3e 93b0 2914                 	sts noise_pattern+1, r27
                                 
002c40 9220 2917                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002c42 9220 2918                 	sts noise_pattern_offset+1, zero
002c44 ce5b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
002c45 91e0 2917                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002c47 91f0 2918                 	lds ZH, noise_pattern_offset+1
002c49 9631                      	adiw Z, 1
002c4a 93e0 2917                 	sts noise_pattern_offset, ZL
002c4c 93f0 2918                 	sts noise_pattern_offset+1, ZH
002c4e 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002c4f 91e0 2917                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002c51 91f0 2918                 	lds ZH, noise_pattern_offset+1
002c53 9632                      	adiw Z, 2 //increment the pointer twice
002c54 93e0 2917                 	sts noise_pattern_offset, ZL
002c56 93f0 2918                 	sts noise_pattern_offset+1, ZH
002c58 9508                      	ret
                                 
                                 sound_driver_channel3_end:
                                 sound_driver_channel3_check_Sxx_invalid:
002c59 efbf                      	ldi r27, 0xFF
002c5a 91a0 2949                 	lds r26, noise_fx_Sxx_post
002c5c 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
002c5d f419                      	brne sound_driver_channel3_check_Gxx_invalid
002c5e 93b0 2949                 	sts noise_fx_Sxx_post, r27
002c60 9508                      	ret
                                 sound_driver_channel3_check_Gxx_invalid:
002c61 91a0 2946                 	lds r26, noise_fx_Gxx_post
002c63 15a2                      	cp r26, zero
002c64 f419                      	brne sound_driver_channel4
002c65 93b0 2946                 	sts noise_fx_Gxx_post, r27
002c67 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel4:
002c68 91a0 294c                 	lds r26, dpcm_pattern_delay_rows
002c6a 91b0 294d                 	lds r27, dpcm_pattern_delay_frames
                                 sound_driver_channel4_decrement_frame_delay:
002c6c 95ba                      	dec r27
002c6d 93b0 294d                 	sts dpcm_pattern_delay_frames, r27
                                 
002c6f 9610                      	adiw r27:r26, 0
002c70 f009                      	breq sound_driver_channel4_main //if the pattern delay is 0, proceed with sound driver procedures
002c71 c0cc                      	rjmp sound_driver_channel4_end //if the pattern delay is not 0, end routine
                                 
                                 sound_driver_channel4_main:
002c72 91e0 294a                 	lds ZL, dpcm_pattern //current pattern for dpcm
002c74 91f0 294b                 	lds ZH, dpcm_pattern+1
002c76 91a0 294e                 	lds r26, dpcm_pattern_offset //current offset in the pattern for dpcm
002c78 91b0 294f                 	lds r27, dpcm_pattern_offset+1
002c7a 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
002c7b 1ffb                      	adc ZH, r27
002c7c 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel4_check_if_note: //check if data is a note (0x00 - 0x56)
002c7d 35b7                      	cpi r27, 0x57
002c7e f408                      	brsh sound_driver_channel4_check_if_volume
002c7f c056                      	rjmp sound_driver_channel4_note
                                 sound_driver_channel4_check_if_volume: //check if data is volume (0x57-0x66)
002c80 36b7                      	cpi r27, 0x67
002c81 f408                      	brsh sound_driver_channel4_check_if_delay
002c82 c080                      	rjmp sound_driver_channel4_volume
                                 sound_driver_channel4_check_if_delay: //check if data is a delay (0x67 - 0xE2)
002c83 3eb3                      	cpi r27, 0xE3
002c84 f408                      	brsh sound_driver_channel4_check_if_instrument
002c85 c07f                      	rjmp sound_driver_channel4_delay
                                 sound_driver_channel4_check_if_instrument: //check for instrument flag (0xE3)
002c86 f409                      	brne sound_driver_channel4_check_if_release
002c87 c082                      	rjmp sound_driver_channel4_instrument_change 
                                 sound_driver_channel4_check_if_release: //check for note release flag (0xE4)
002c88 3eb4                      	cpi r27, 0xE4
002c89 f409                      	brne sound_driver_channel4_check_if_end
002c8a c081                      	rjmp sound_driver_channel4_release
                                 sound_driver_channel4_check_if_end:
002c8b 3fbf                      	cpi r27, 0xFF
002c8c f409                      	brne sound_driver_channel4_check_if_fx
002c8d c080                      	rjmp sound_driver_channel4_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel4_check_if_fx: //fx flags (0xE5 - 0xFE)
002c8e 9631                      	adiw Z, 1 //point Z to the byte next to the flag
002c8f 91a4                      	lpm r26, Z //load the fx data into r26
002c90 d0a3                      	rcall sound_driver_channel4_increment_offset_twice
                                 
002c91 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
002c92 ebe4                      	ldi ZL, LOW(channel4_fx << 1) //load in note table
002c93 e7f5                      	ldi ZH, HIGH(channel4_fx << 1)
002c94 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
002c95 0feb                      	add ZL, r27 //add offset
002c96 1df2                      	adc ZH, zero
002c97 91c5                      	lpm r28, Z+ //load address bytes
002c98 91d4                      	lpm r29, Z
002c99 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
002c9a 2ffd                      	mov ZH, r29
002c9b 9409                      	ijmp
                                 
                                 
                                 
                                 sound_driver_channel4_fx_0xy: //arpeggio
002c9c cfd5                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_1xx: //pitch slide up
002c9d cfd4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_2xx: //pitch slide down
002c9e cfd3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_3xx: //automatic portamento
002c9f cfd2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_4xy: //vibrato
002ca0 cfd1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_7xy: //tremelo
002ca1 cfd0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Axy: //volume slide
002ca2 cfcf                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel4_fx_Bxx:
002ca3 93a0 2822                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002ca5 cfcc                      	rjmp sound_driver_channel4_main
                                 
                                 //HALT
                                 sound_driver_channel4_fx_Cxx:
002ca6 93b0 2823                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002ca8 cfc9                      	rjmp sound_driver_channel4_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel4_fx_Dxx:
002ca9 93b0 2824                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002cab cfc6                      	rjmp sound_driver_channel4_main
                                 
                                 sound_driver_channel4_fx_Exx: //volume
002cac cfc5                      	rjmp sound_driver_channel4_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel4_fx_Fxx:
002cad 93a0 2821                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002caf cfc2                      	rjmp sound_driver_channel4_main
                                 
                                 //DELAY
                                 sound_driver_channel4_fx_Gxx:
002cb0 15a2                      	cp r26, zero
002cb1 f051                      	breq sound_driver_channel4_fx_Gxx_invalid
002cb2 91b0 2821                 	lds r27, song_speed
002cb4 17ab                      	cp r26, r27
002cb5 f430                      	brsh sound_driver_channel4_fx_Gxx_invalid
002cb6 93a0 2954                 	sts dpcm_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002cb8 e0b1                      	ldi r27, 0x01
002cb9 93b0 294c                 	sts dpcm_pattern_delay_rows, r27
002cbb c091                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Gxx_invalid:
002cbc cfb5                      	rjmp sound_driver_channel4_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Hxy: //hardware sweep up
002cbd cfb4                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixy: //hardware sweep down
002cbe cfb3                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Hxx: //FDS modulation depth
002cbf cfb2                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Ixx: //FDS modulation speed
002cc0 cfb1                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Pxx: //fine pitch
002cc1 cfb0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Qxy: //note slide up
002cc2 cfaf                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Rxy: //note slide down
002cc3 cfae                      	rjmp sound_driver_channel4_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel4_fx_Sxx:
002cc4 15a2                      	cp r26, zero
002cc5 f051                      	breq sound_driver_channel4_fx_Sxx_invalid
002cc6 91b0 2821                 	lds r27, song_speed
002cc8 17ab                      	cp r26, r27
002cc9 f430                      	brsh sound_driver_channel4_fx_Sxx_invalid
002cca 93a0 2956                 	sts dpcm_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002ccc e0b1                      	ldi r27, 0x01
002ccd 93b0 294c                 	sts dpcm_pattern_delay_rows, r27
002ccf c07d                      	rjmp sound_driver_calculate_delays
                                 sound_driver_channel4_fx_Sxx_invalid:
002cd0 cfa1                      	rjmp sound_driver_channel4_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel4_fx_Vxx: //duty
002cd1 cfa0                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Wxx: //DPCM sample speed
002cd2 cf9f                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Xxx: //DPCM sample retrigger
002cd3 cf9e                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Yxx: //DPCM sample offset
002cd4 cf9d                      	rjmp sound_driver_channel4_main
                                 sound_driver_channel4_fx_Zxx: //DPCM sample delta counter
002cd5 cf9c                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_note:
002cd6 9631                      	adiw Z, 1 //point to the byte next to the flag
002cd7 90f4                      	lpm dpcm_period, Z //store the DPCM sample rate
002cd8 edec                      	ldi ZL, LOW(dpcm_samples) //point Z to dpcm_samples table
002cd9 e1fa                      	ldi ZH, HIGH(dpcm_samples)
002cda 0feb                      	add ZL, r27 //point Z to offsetted sample
002cdb 1df2                      	adc ZH, zero
002cdc 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the samples's address
002cdd 1fff                      	rol ZH
002cde 91a5                      	lpm r26, Z+ //r26:r27 now points to the sample
002cdf 91b4                      	lpm r27, Z
                                 
002ce0 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the sample's data
002ce1 1fbb                      	rol r27
002ce2 2fea                      	mov ZL, r26
002ce3 2ffb                      	mov ZH, r27
002ce4 91b4                      	lpm r27, Z //get sample length
002ce5 ef70                      	ldi dpcm_length_LOW, 0b11110000
002ce6 e08f                      	ldi dpcm_length_HIGH, 0b00001111
002ce7 95b2                      	swap r27
002ce8 237b                      	and dpcm_length_LOW, r27
002ce9 238b                      	and dpcm_length_HIGH, r27
                                 
002cea 93e0 2950                 	sts dpcm_sample, ZL //store address to sample
002cec 93f0 2951                 	sts dpcm_sample+1, ZH
002cee 9230 2952                 	sts dpcm_sample_offset, one //reset sample offset to 1 (0th byte contains length)
002cf0 9220 2953                 	sts dpcm_sample_offset+1, zero
                                 
002cf2 2ce2                      	mov dpcm_bit_counter, zero
                                 
002cf3 e6e2                      	ldi ZL, LOW(dpcm_period_table << 1) //load in dpcm period table
002cf4 e0f1                      	ldi ZH, HIGH(dpcm_period_table << 1)
002cf5 0cff                      	lsl dpcm_period //double the offset for the period table because we are getting byte data
002cf6 0def                      	add ZL, dpcm_period //add offset
002cf7 1df2                      	adc ZH, zero
002cf8 91a5                      	lpm r26, Z+ //load bytes
002cf9 91b4                      	lpm r27, Z
002cfa 93a0 0a26                 	sts TCA0_SINGLE_PER, r26 //load the LOW bits for timer
002cfc 93b0 0a27                 	sts TCA0_SINGlE_PER + 1, r27 //load the HIGH bits for timer
002cfe e0a3                      	ldi r26, TCA_SINGLE_CLKSEL_DIV2_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 2 and enable timer
002cff 93a0 0a00                 	sts TCA0_SINGLE_CTRLA, r26
                                 
002d01 d032                      	rcall sound_driver_channel4_increment_offset_twice
002d02 cf6f                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_volume:
002d03 d026                      	rcall sound_driver_channel4_increment_offset
002d04 cf6d                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_delay:
002d05 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
002d06 93b0 294c                 	sts dpcm_pattern_delay_rows, r27
002d08 d021                      	rcall sound_driver_channel4_increment_offset
002d09 c034                      	rjmp sound_driver_channel4_end
                                 
                                 
                                 
                                 sound_driver_channel4_instrument_change:
002d0a d029                      	rcall sound_driver_channel4_increment_offset_twice
002d0b cf66                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_release:
002d0c d01d                      	rcall sound_driver_channel4_increment_offset
002d0d cf64                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_next_pattern:
002d0e 91e0 2819                 	lds ZL, song_frames
002d10 91f0 281a                 	lds ZH, song_frames+1
002d12 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
002d14 91b0 281c                 	lds r27, song_frame_offset+1
002d16 93a0 281b                 	sts song_frame_offset, r26
002d18 93b0 281c                 	sts song_frame_offset+1, r27
002d1a 9618                      	adiw r27:r26, 8 //offset for channel 4
002d1b 0fea                      	add ZL, r26
002d1c 1ffb                      	adc ZH, r27
                                 
002d1d 91a5                      	lpm r26, Z+ //load the address of the next pattern
002d1e 91b4                      	lpm r27, Z
002d1f 0faa                      	lsl r26
002d20 1fbb                      	rol r27
002d21 93a0 294a                 	sts dpcm_pattern, r26
002d23 93b0 294b                 	sts dpcm_pattern+1, r27
                                 
002d25 9220 294e                 	sts dpcm_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002d27 9220 294f                 	sts dpcm_pattern_offset+1, zero
002d29 cf48                      	rjmp sound_driver_channel4_main
                                 
                                 
                                 
                                 sound_driver_channel4_increment_offset:
002d2a 91e0 294e                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002d2c 91f0 294f                 	lds ZH, dpcm_pattern_offset+1
002d2e 9631                      	adiw Z, 1
002d2f 93e0 294e                 	sts dpcm_pattern_offset, ZL
002d31 93f0 294f                 	sts dpcm_pattern_offset+1, ZH
002d33 9508                      	ret
                                 
                                 sound_driver_channel4_increment_offset_twice: //used for data that takes up 2 bytes worth of space
002d34 91e0 294e                 	lds ZL, dpcm_pattern_offset //current offset in the pattern for dpcm
002d36 91f0 294f                 	lds ZH, dpcm_pattern_offset+1
002d38 9632                      	adiw Z, 2 //increment the pointer twice
002d39 93e0 294e                 	sts dpcm_pattern_offset, ZL
002d3b 93f0 294f                 	sts dpcm_pattern_offset+1, ZH
002d3d 9508                      	ret
                                 
                                 sound_driver_channel4_end:
                                 sound_driver_channel4_check_Sxx_invalid:
002d3e efbf                      	ldi r27, 0xFF
002d3f 91a0 2957                 	lds r26, dpcm_fx_Sxx_post
002d41 15a2                      	cp r26, zero //check if routine was called from calculate_delays due to invalid Sxx/Gxx
002d42 f419                      	brne sound_driver_channel4_check_Gxx_invalid
002d43 93b0 2957                 	sts dpcm_fx_Sxx_post, r27
002d45 9508                      	ret
                                 sound_driver_channel4_check_Gxx_invalid:
002d46 91a0 2955                 	lds r26, dpcm_fx_Gxx_post
002d48 15a2                      	cp r26, zero
002d49 f419                      	brne sound_driver_calculate_delays
002d4a 93b0 2955                 	sts dpcm_fx_Gxx_post, r27
002d4c 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
002d4d 91f0 2821                 	lds r31, song_speed
                                 
                                 sound_driver_calculate_delays_pulse1:
002d4f 91a0 2828                 	lds r26, pulse1_pattern_delay_frames
002d51 11a2                      	cpse r26, zero
002d52 c044                      	rjmp sound_driver_calculate_delays_pulse2
002d53 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002d54 2faf                      	mov r26, r31 //move speed into r26
002d55 91b0 2827                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002d57 15b2                      	cp r27, zero
002d58 f409                      	brne PC+2
002d59 c03d                      	rjmp sound_driver_calculate_delays_pulse2
002d5a 95ba                      	dec r27
002d5b 93b0 2827                 	sts pulse1_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002d5d efbf                      	ldi r27, 0xFF
002d5e 91c0 2874                 	lds r28, pulse1_fx_Sxx_pre
002d60 91d0 2875                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002d62 17cb                      	cp r28, r27
002d63 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002d64 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
002d65 17db                      	cp r29, r27
002d66 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
002d67 c014                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
002d68 91c0 2862                 	lds r28, pulse1_fx_Gxx_pre
002d6a 91d0 2863                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
002d6c 17cb                      	cp r28, r27
002d6d f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
002d6e c011                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
002d6f 17db                      	cp r29, r27
002d70 f121                      	breq sound_driver_calculate_delays_pulse1_store
002d71 c018                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
002d72 93b0 2874                 	sts pulse1_fx_Sxx_pre, r27
002d74 1bac                      	sub r26, r28 //(song speed)-Sxx
002d75 93a0 2875                 	sts pulse1_fx_Sxx_post, r26
002d77 93c0 2828                 	sts pulse1_pattern_delay_frames, r28
002d79 11a2                      	cpse r26, zero
002d7a c01c                      	rjmp sound_driver_calculate_delays_pulse2
002d7b c012                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
002d7c 93b0 2875                 	sts pulse1_fx_Sxx_post, r27
002d7e 2fad                      	mov r26, r29
002d7f c015                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
002d80 93b0 2862                 	sts pulse1_fx_Gxx_pre, r27
002d82 1bac                      	sub r26, r28 //(song speed)-Gxx
002d83 93a0 2863                 	sts pulse1_fx_Gxx_post, r26
002d85 93c0 2828                 	sts pulse1_pattern_delay_frames, r28
002d87 11a2                      	cpse r26, zero
002d88 c00e                      	rjmp sound_driver_calculate_delays_pulse2
002d89 c004                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
002d8a 93b0 2863                 	sts pulse1_fx_Gxx_post, r27
002d8c 2fad                      	mov r26, r29
002d8d c007                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_Gxx_invalid:
002d8e 9220 2828                 	sts pulse1_pattern_delay_frames, zero
002d90 940e 21db                 	call sound_driver_channel0_main
002d92 91f0 2821                 	lds r31, song_speed
002d94 cfba                      	rjmp sound_driver_calculate_delays_pulse1
                                 
                                 sound_driver_calculate_delays_pulse1_store:
002d95 93a0 2828                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
002d97 91a0 2879                 	lds r26, pulse2_pattern_delay_frames
002d99 11a2                      	cpse r26, zero
002d9a c044                      	rjmp sound_driver_calculate_delays_triangle
002d9b c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
002d9c 2faf                      	mov r26, r31 //move the speed to r26
002d9d 91b0 2878                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
002d9f 15b2                      	cp r27, zero
002da0 f409                      	brne PC+2
002da1 c03d                      	rjmp sound_driver_calculate_delays_triangle
002da2 95ba                      	dec r27
002da3 93b0 2878                 	sts pulse2_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
002da5 efbf                      	ldi r27, 0xFF
002da6 91c0 28c5                 	lds r28, pulse2_fx_Sxx_pre
002da8 91d0 28c6                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
002daa 17cb                      	cp r28, r27
002dab f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
002dac c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
002dad 17db                      	cp r29, r27
002dae f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
002daf c014                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
002db0 91c0 28b3                 	lds r28, pulse2_fx_Gxx_pre
002db2 91d0 28b4                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
002db4 17cb                      	cp r28, r27
002db5 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
002db6 c011                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
002db7 17db                      	cp r29, r27
002db8 f121                      	breq sound_driver_calculate_delays_pulse2_store
002db9 c018                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
002dba 93b0 28c5                 	sts pulse2_fx_Sxx_pre, r27
002dbc 1bac                      	sub r26, r28 //(song speed)-Sxx
002dbd 93a0 28c6                 	sts pulse2_fx_Sxx_post, r26
002dbf 93c0 2879                 	sts pulse2_pattern_delay_frames, r28
002dc1 11a2                      	cpse r26, zero
002dc2 c01c                      	rjmp sound_driver_calculate_delays_triangle
002dc3 c012                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
002dc4 93b0 28c6                 	sts pulse2_fx_Sxx_post, r27
002dc6 2fad                      	mov r26, r29
002dc7 c015                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
002dc8 93b0 28b3                 	sts pulse2_fx_Gxx_pre, r27
002dca 1bac                      	sub r26, r28 //(song speed)-1-Gxx
002dcb 93a0 28b4                 	sts pulse2_fx_Gxx_post, r26
002dcd 93c0 2879                 	sts pulse2_pattern_delay_frames, r28
002dcf 11a2                      	cpse r26, zero
002dd0 c00e                      	rjmp sound_driver_calculate_delays_triangle
002dd1 c004                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
002dd2 93b0 28b4                 	sts pulse2_fx_Gxx_post, r27
002dd4 2fad                      	mov r26, r29
002dd5 c007                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_Gxx_invalid:
002dd6 9220 2879                 	sts pulse2_pattern_delay_frames, zero
002dd8 940e 24d8                 	call sound_driver_channel1_main
002dda 91f0 2821                 	lds r31, song_speed
002ddc cfba                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_store:
002ddd 93a0 2879                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
002ddf 91a0 28ca                 	lds r26, triangle_pattern_delay_frames
002de1 11a2                      	cpse r26, zero
002de2 c044                      	rjmp sound_driver_calculate_delays_noise
002de3 c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
002de4 2faf                      	mov r26, r31 //move the speed to r26
002de5 91b0 28c9                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
002de7 15b2                      	cp r27, zero
002de8 f409                      	brne PC+2
002de9 c03d                      	rjmp sound_driver_calculate_delays_noise
002dea 95ba                      	dec r27
002deb 93b0 28c9                 	sts triangle_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
002ded efbf                      	ldi r27, 0xFF
002dee 91c0 2911                 	lds r28, triangle_fx_Sxx_pre
002df0 91d0 2912                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
002df2 17cb                      	cp r28, r27
002df3 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
002df4 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
002df5 17db                      	cp r29, r27
002df6 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
002df7 c014                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
002df8 91c0 28ff                 	lds r28, triangle_fx_Gxx_pre
002dfa 91d0 2900                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
002dfc 17cb                      	cp r28, r27
002dfd f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
002dfe c011                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
002dff 17db                      	cp r29, r27
002e00 f121                      	breq sound_driver_calculate_delays_triangle_store
002e01 c018                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
002e02 93b0 2911                 	sts triangle_fx_Sxx_pre, r27
002e04 1bac                      	sub r26, r28 //(song speed)-Sxx
002e05 93a0 2912                 	sts triangle_fx_Sxx_post, r26
002e07 93c0 28ca                 	sts triangle_pattern_delay_frames, r28
002e09 11a2                      	cpse r26, zero
002e0a c01c                      	rjmp sound_driver_calculate_delays_noise
002e0b c012                      	rjmp sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
002e0c 93b0 2912                 	sts triangle_fx_Sxx_post, r27
002e0e 2fad                      	mov r26, r29
002e0f c015                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002e10 93b0 28ff                 	sts triangle_fx_Gxx_pre, r27
002e12 1bac                      	sub r26, r28 //(song speed)-Gxx
002e13 93a0 2900                 	sts triangle_fx_Gxx_post, r26
002e15 93c0 28ca                 	sts triangle_pattern_delay_frames, r28
002e17 11a2                      	cpse r26, zero
002e18 c00e                      	rjmp sound_driver_calculate_delays_noise
002e19 c004                      	rjmp sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
002e1a 93b0 2900                 	sts triangle_fx_Gxx_post, r27
002e1c 2fad                      	mov r26, r29
002e1d c007                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_Gxx_invalid:
002e1e 9220 28ca                 	sts triangle_pattern_delay_frames, zero
002e20 940e 27c8                 	call sound_driver_channel2_main
002e22 91f0 2821                 	lds r31, song_speed
002e24 cfba                      	rjmp sound_driver_calculate_delays_triangle
                                 
                                 sound_driver_calculate_delays_triangle_store:
002e25 93a0 28ca                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
002e27 91a0 2916                 	lds r26, noise_pattern_delay_frames
002e29 11a2                      	cpse r26, zero
002e2a c044                      	rjmp sound_driver_calculate_delays_dpcm
002e2b c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
002e2c 2faf                      	mov r26, r31 //move the speed to r26
002e2d 91b0 2915                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
002e2f 15b2                      	cp r27, zero
002e30 f409                      	brne PC+2
002e31 c03d                      	rjmp sound_driver_calculate_delays_dpcm
002e32 95ba                      	dec r27
002e33 93b0 2915                 	sts noise_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
002e35 efbf                      	ldi r27, 0xFF
002e36 91c0 2948                 	lds r28, noise_fx_Sxx_pre
002e38 91d0 2949                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
002e3a 17cb                      	cp r28, r27
002e3b f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
002e3c c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
002e3d 17db                      	cp r29, r27
002e3e f009                      	breq sound_driver_calculate_delays_noise_Gxx
002e3f c014                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
002e40 91c0 2945                 	lds r28, noise_fx_Gxx_pre
002e42 91d0 2946                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
002e44 17cb                      	cp r28, r27
002e45 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002e46 c011                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002e47 17db                      	cp r29, r27
002e48 f121                      	breq sound_driver_calculate_delays_noise_store
002e49 c018                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
002e4a 93b0 2948                 	sts noise_fx_Sxx_pre, r27
002e4c 1bac                      	sub r26, r28 //(song speed)-Sxx
002e4d 93a0 2949                 	sts noise_fx_Sxx_post, r26
002e4f 93c0 2916                 	sts noise_pattern_delay_frames, r28
002e51 11a2                      	cpse r26, zero
002e52 c01c                      	rjmp sound_driver_calculate_delays_dpcm
002e53 c012                      	rjmp sound_driver_calculate_delays_noise_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
002e54 93b0 2949                 	sts noise_fx_Sxx_post, r27
002e56 2fad                      	mov r26, r29
002e57 c015                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002e58 93b0 2945                 	sts noise_fx_Gxx_pre, r27
002e5a 1bac                      	sub r26, r28 //(song speed)-Gxx
002e5b 93a0 2946                 	sts noise_fx_Gxx_post, r26
002e5d 93c0 2916                 	sts noise_pattern_delay_frames, r28
002e5f 11a2                      	cpse r26, zero
002e60 c00e                      	rjmp sound_driver_calculate_delays_dpcm
002e61 c004                      	rjmp sound_driver_calculate_delays_noise_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
002e62 93b0 2946                 	sts noise_fx_Gxx_post, r27
002e64 2fad                      	mov r26, r29
002e65 c007                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Sxx_Gxx_invalid:
002e66 9220 2916                 	sts noise_pattern_delay_frames, zero
002e68 940e 2aa0                 	call sound_driver_channel3_main
002e6a 91f0 2821                 	lds r31, song_speed
002e6c cfba                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_noise_store:
002e6d 93a0 2916                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
002e6f 91a0 294d                 	lds r26, dpcm_pattern_delay_frames
002e71 11a2                      	cpse r26, zero
002e72 c044                      	rjmp sound_driver_instrument_fx_routine
002e73 c000                      	rjmp sound_driver_calculate_delays_dpcm_main
                                 
                                 sound_driver_calculate_delays_dpcm_main:
002e74 2faf                      	mov r26, r31 //move the speed to r26
002e75 91b0 294c                 	lds r27, dpcm_pattern_delay_rows //decrement the delay rows
002e77 15b2                      	cp r27, zero
002e78 f409                      	brne PC+2
002e79 c03d                      	rjmp sound_driver_instrument_fx_routine
002e7a 95ba                      	dec r27
002e7b 93b0 294c                 	sts dpcm_pattern_delay_rows, r27
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx:
002e7d efbf                      	ldi r27, 0xFF
002e7e 91c0 2956                 	lds r28, dpcm_fx_Sxx_pre
002e80 91d0 2957                 	lds r29, dpcm_fx_Sxx_post
                                 sound_driver_calculate_delays_dpcm_Sxx_check_pre:
002e82 17cb                      	cp r28, r27
002e83 f009                      	breq sound_driver_calculate_delays_dpcm_Sxx_check_post
002e84 c00d                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_pre
                                 sound_driver_calculate_delays_dpcm_Sxx_check_post:
002e85 17db                      	cp r29, r27
002e86 f009                      	breq sound_driver_calculate_delays_dpcm_Gxx
002e87 c014                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx:
002e88 91c0 2954                 	lds r28, dpcm_fx_Gxx_pre
002e8a 91d0 2955                 	lds r29, dpcm_fx_Gxx_post
                                 sound_driver_calculate_delays_dpcm_Gxx_check_pre:
002e8c 17cb                      	cp r28, r27
002e8d f009                      	breq sound_driver_calculate_delays_dpcm_Gxx_check_post
002e8e c011                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_pre
                                 sound_driver_calculate_delays_dpcm_Gxx_check_post:
002e8f 17db                      	cp r29, r27
002e90 f121                      	breq sound_driver_calculate_delays_dpcm_store
002e91 c018                      	rjmp sound_driver_calculate_delays_dpcm_Gxx_post
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_pre:
002e92 93b0 2956                 	sts dpcm_fx_Sxx_pre, r27
002e94 1bac                      	sub r26, r28 //(song speed)-Sxx
002e95 93a0 2957                 	sts dpcm_fx_Sxx_post, r26
002e97 93c0 294d                 	sts dpcm_pattern_delay_frames, r28
002e99 11a2                      	cpse r26, zero
002e9a c01c                      	rjmp sound_driver_instrument_fx_routine
002e9b c012                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_post:
002e9c 93b0 2957                 	sts dpcm_fx_Sxx_post, r27
002e9e 2fad                      	mov r26, r29
002e9f c015                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Gxx_pre:
002ea0 93b0 2954                 	sts dpcm_fx_Gxx_pre, r27
002ea2 1bac                      	sub r26, r28 //(song speed)-Gxx
002ea3 93a0 2955                 	sts dpcm_fx_Gxx_post, r26
002ea5 93c0 294d                 	sts dpcm_pattern_delay_frames, r28
002ea7 11a2                      	cpse r26, zero
002ea8 c00e                      	rjmp sound_driver_instrument_fx_routine
002ea9 c004                      	rjmp sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid
                                 	
                                 sound_driver_calculate_delays_dpcm_Gxx_post:
002eaa 93b0 2955                 	sts dpcm_fx_Gxx_post, r27
002eac 2fad                      	mov r26, r29
002ead c007                      	rjmp sound_driver_calculate_delays_dpcm_store
                                 
                                 sound_driver_calculate_delays_dpcm_Sxx_Gxx_invalid:
002eae 9220 294d                 	sts dpcm_pattern_delay_frames, zero
002eb0 940e 2c72                 	call sound_driver_channel4_main
002eb2 91f0 2821                 	lds r31, song_speed
002eb4 cfba                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_dpcm_store:
002eb5 93a0 294d                 	sts dpcm_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002eb7 91e0 282b                 	lds ZL, pulse1_volume_macro
002eb9 91f0 282c                 	lds ZH, pulse1_volume_macro+1
002ebb 9630                      	adiw Z, 0
002ebc f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
002ebd 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002ebe 1fff                      	rol ZH
002ebf 91a0 282d                 	lds r26, pulse1_volume_macro_offset
002ec1 0fea                      	add ZL, r26
002ec2 1df2                      	adc ZH, zero
                                 
002ec3 91b0 282f                 	lds r27, pulse1_volume_macro_release
002ec5 17ba                      	cp r27, r26
002ec6 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
002ec7 91a0 282e                 	lds r26, pulse1_volume_macro_loop
002ec9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002eca f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002ecb c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
002ecc 95a3                      	inc r26 //increment the macro offset
002ecd 93a0 282d                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
002ecf 91b4                      	lpm r27, Z //load volume data into r27
002ed0 3fbf                      	cpi r27, 0xFF //check for macro end flag
002ed1 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
002ed2 91b0 282f                 	lds r27, pulse1_volume_macro_release
002ed4 3fbf                      	cpi r27, 0xFF
002ed5 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
002ed6 91b0 282e                 	lds r27, pulse1_volume_macro_loop //load the loop index
002ed8 93b0 282d                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
002eda cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
002edb 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002edc 93a0 282d                 	sts pulse1_volume_macro_offset, r26
002ede cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
002edf eee8                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002ee0 e7f5                      	ldi ZH, HIGH(volumes << 1)
002ee1 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002ee2 0feb                      	add ZL, r27 //add offset to the table
002ee3 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
002ee4 91b0 2800                 	lds r27, pulse1_param //load main volume
002ee6 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002ee7 91a0 2860                 	lds r26, pulse1_fx_7xy_value
002ee9 30a0                      	cpi r26, 0x00
002eea f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
002eeb 0feb                      	add ZL, r27 //offset the volume table by the main volume
002eec 1df2                      	adc ZH, zero
002eed 91b4                      	lpm r27, Z
002eee 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002ef0 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
002ef1 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002ef3 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002ef4 91a0 2860                 	lds r26, pulse1_fx_7xy_value
002ef6 30a0                      	cpi r26, 0x00
002ef7 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
002ef8 93b0 2806                 	sts pulse1_output_volume, r27
002efa c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
002efb 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002efc f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
002efd f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
002efe 0feb                      	add ZL, r27 //offset the volume table by the main volume
002eff 1df2                      	adc ZH, zero
002f00 91b4                      	lpm r27, Z
002f01 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002f03 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
002f04 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f05 0feb                      	add ZL, r27 //offset the volume table by the main volume
002f06 1df2                      	adc ZH, zero
002f07 91b4                      	lpm r27, Z
002f08 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
002f0a c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
002f0b 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002f0c f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002f0d f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
002f0e 93b0 2806                 	sts pulse1_output_volume, r27
002f10 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
002f11 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002f12 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002f14 91e0 2830                 	lds ZL, pulse1_arpeggio_macro
002f16 91f0 2831                 	lds ZH, pulse1_arpeggio_macro+1
002f18 9630                      	adiw Z, 0
002f19 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002f1a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002f1b 1fff                      	rol ZH
002f1c 91a0 2832                 	lds r26, pulse1_arpeggio_macro_offset
002f1e 0fea                      	add ZL, r26
002f1f 1df2                      	adc ZH, zero
                                 
002f20 91b0 2834                 	lds r27, pulse1_arpeggio_macro_release
002f22 17ba                      	cp r27, r26
002f23 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002f24 91a0 2833                 	lds r26, pulse1_arpeggio_macro_loop
002f26 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002f27 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002f28 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
002f29 95a3                      	inc r26 //increment the macro offset
002f2a 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
002f2c 91b4                      	lpm r27, Z //load arpeggio data into r27
002f2d 38b0                      	cpi r27, 0x80 //check for macro end flag
002f2e f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
002f2f c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
002f30 50a1                      	subi r26, 1 //keep the offset at the end flag
002f31 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26
002f33 91b0 2835                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002f35 30b1                      	cpi r27, 0x01
002f36 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
002f37 91b0 2834                 	lds r27, pulse1_arpeggio_macro_release
002f39 3fbf                      	cpi r27, 0xFF
002f3a f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
002f3b 91b0 2833                 	lds r27, pulse1_arpeggio_macro_loop
002f3d 3fbf                      	cpi r27, 0xFF
002f3e f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002f3f c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002f40 91b0 2834                 	lds r27, pulse1_arpeggio_macro_release
002f42 3fbf                      	cpi r27, 0xFF
002f43 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
002f44 91b0 2833                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
002f46 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002f47 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
002f48 91c0 2848                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
002f4a 91d0 2849                 	lds r29, pulse1_fx_0xy_sequence+1
002f4c 9620                      	adiw r29:r28, 0
002f4d f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002f4e 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002f4f 93a0 2832                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
002f51 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002f52 93b0 2832                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
002f54 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
002f55 91c0 2848                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
002f57 91d0 2849                 	lds r29, pulse1_fx_0xy_sequence+1
002f59 9620                      	adiw r29:r28, 0 //check for 0xy effect
002f5a f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
002f5b 95d6                      	lsr r29
002f5c 95c7                      	ror r28
002f5d 95d7                      	ror r29
002f5e 95c7                      	ror r28
002f5f 95d7                      	ror r29
002f60 95c7                      	ror r28
002f61 95d7                      	ror r29
002f62 95c7                      	ror r28
002f63 95d7                      	ror r29
002f64 95d2                      	swap r29
                                 
002f65 93c0 2848                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
002f67 93d0 2849                 	sts pulse1_fx_0xy_sequence+1, r29
002f69 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002f6a 91a0 2807                 	lds r26, pulse1_note //load the current note index
002f6c 0fac                      	add r26, r28 //add the note offset
002f6d c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002f6e 91a0 2807                 	lds r26, pulse1_note //load the current note index
002f70 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002f71 9220 2836                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002f73 9220 2837                 	sts pulse1_total_pitch_offset+1, zero
002f75 9220 283d                 	sts pulse1_total_hi_pitch_offset, zero
002f77 91a0 2835                 	lds r26, pulse1_arpeggio_macro_mode
002f79 30a1                      	cpi r26, 0x01 //absolute mode
002f7a f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
002f7b f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
002f7c c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
002f7d 91a0 2807                 	lds r26, pulse1_note //load the current note index
002f7f 0fab                      	add r26, r27 //offset the note with the arpeggio data
002f80 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002f81 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002f82 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002f83 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002f84 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002f85 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
002f86 fda7                      	sbrc r26, 7 //check if result is negative
002f87 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002f88 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
002f89 2fab                      	mov r26, r27 //move the arpeggio data into r26
002f8a c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
002f8b 91a0 2807                 	lds r26, pulse1_note //load the current note index
002f8d 0fab                      	add r26, r27 //offset the note with the arpeggio data
002f8e fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002f8f c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002f90 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002f92 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002f93 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002f94 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002f95 93a0 2807                 	sts pulse1_note, r26
002f97 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
002f98 fda7                      	sbrc r26, 7 //check if result is negative
002f99 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002f9a 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
002f9c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
002f9d e0f0                      	ldi ZH, HIGH(note_table << 1)
002f9e 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002f9f 0fea                      	add ZL, r26 //add offset
002fa0 1df2                      	adc ZH, zero
002fa1 91a5                      	lpm r26, Z+ //load bytes
002fa2 91b4                      	lpm r27, Z
002fa3 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002fa5 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002fa7 93a0 2854                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002fa9 93b0 2855                 	sts pulse1_fx_3xx_target+1, r27
002fab c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
002fac 91e0 2838                 	lds ZL, pulse1_pitch_macro
002fae 91f0 2839                 	lds ZH, pulse1_pitch_macro+1
002fb0 9630                      	adiw Z, 0
002fb1 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002fb2 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002fb3 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002fb4 1fff                      	rol ZH
002fb5 91a0 283a                 	lds r26, pulse1_pitch_macro_offset
002fb7 0fea                      	add ZL, r26
002fb8 1df2                      	adc ZH, zero
                                 
002fb9 91b0 283c                 	lds r27, pulse1_pitch_macro_release
002fbb 17ba                      	cp r27, r26
002fbc f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
002fbd 91a0 283b                 	lds r26, pulse1_pitch_macro_loop
002fbf 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002fc0 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002fc1 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
002fc2 95a3                      	inc r26 //increment the macro offset
002fc3 93a0 283a                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
002fc5 91b4                      	lpm r27, Z //load pitch data into r27
002fc6 38b0                      	cpi r27, 0x80 //check for macro end flag
002fc7 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
002fc8 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002fc9 93a0 283a                 	sts pulse1_pitch_macro_offset, r26
002fcb 91b0 283c                 	lds r27, pulse1_pitch_macro_release
002fcd 3fbf                      	cpi r27, 0xFF
002fce f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
002fcf 91b0 283b                 	lds r27, pulse1_pitch_macro_loop //load the loop index
002fd1 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002fd2 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002fd3 93b0 283a                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
002fd5 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002fd6 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002fd7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002fd8 937f                      	push r23
002fd9 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002fda eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002fdb 0367                      	mulsu r22, r23
002fdc 917f                      	pop r23
002fdd 916f                      	pop r22
                                 
002fde 9416                      	lsr r1 //shift out the fractional bits
002fdf 9407                      	ror r0
002fe0 9416                      	lsr r1
002fe1 9407                      	ror r0
002fe2 9416                      	lsr r1
002fe3 9407                      	ror r0
002fe4 9416                      	lsr r1
002fe5 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
002fe6 fe13                      	sbrs r1, 3 //check if result was a negative number
002fe7 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
002fe8 efc0                      	ldi r28, 0xF0
002fe9 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
002fea 70b7                      	andi r27, 0b00000111
002feb f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
002fec e0b1                      	ldi r27, 0x01
002fed 0e0b                      	add r0, r27
002fee 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
002fef 91a0 2836                 	lds r26, pulse1_total_pitch_offset
002ff1 91b0 2837                 	lds r27, pulse1_total_pitch_offset+1
002ff3 0e0a                      	add r0, r26
002ff4 1e1b                      	adc r1, r27
002ff5 9200 2836                 	sts pulse1_total_pitch_offset, r0
002ff7 9210 2837                 	sts pulse1_total_pitch_offset+1, r1
002ff9 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
002ffb 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
002ffd 0da0                      	add r26, r0 //offset the timer values
002ffe 1db1                      	adc r27, r1
                                 	
002fff 91c0 284c                 	lds r28, pulse1_fx_1xx_total
003001 91d0 284d                 	lds r29, pulse1_fx_1xx_total+1
003003 1bac                      	sub r26, r28
003004 0bbd                      	sbc r27, r29
003005 91c0 2850                 	lds r28, pulse1_fx_2xx_total
003007 91d0 2851                 	lds r29, pulse1_fx_2xx_total+1
003009 0fac                      	add r26, r28
00300a 1fbd                      	adc r27, r29
00300b 91c0 2864                 	lds r28, pulse1_fx_Pxx_total
00300d 91d0 2865                 	lds r29, pulse1_fx_Pxx_total+1
00300f 0fac                      	add r26, r28
003010 1fbd                      	adc r27, r29
003011 91c0 286b                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
003013 91d0 286c                 	lds r29, pulse1_fx_Qxy_total_offset+1
003015 1bac                      	sub r26, r28
003016 0bbd                      	sbc r27, r29
003017 91c0 2872                 	lds r28, pulse1_fx_Rxy_total_offset
003019 91d0 2873                 	lds r29, pulse1_fx_Rxy_total_offset+1
00301b 0fac                      	add r26, r28
00301c 1fbd                      	adc r27, r29
                                 
00301d e5c9                      	ldi r28, 0x59
00301e e0d0                      	ldi r29, 0x00
00301f 17ac                      	cp r26, r28
003020 07bd                      	cpc r27, r29
003021 f030                      	brlo sound_driver_instrument_routine_channel0_pitch_min
                                 
003022 e5ca                      	ldi r28, 0x5A
003023 e5d9                      	ldi r29, 0x59
003024 17ac                      	cp r26, r28
003025 07bd                      	cpc r27, r29
003026 f420                      	brsh sound_driver_instrument_routine_channel0_pitch_max
003027 c006                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_min:
003028 e5c9                      	ldi r28, 0x59
003029 e0d0                      	ldi r29, 0x00
00302a c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_max:
00302b e5c9                      	ldi r28, 0x59
00302c e5d9                      	ldi r29, 0x59
00302d c000                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_store:
00302e 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
003030 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
003032 91e0 283e                 	lds ZL, pulse1_hi_pitch_macro
003034 91f0 283f                 	lds ZH, pulse1_hi_pitch_macro+1
003036 9630                      	adiw Z, 0
003037 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
003038 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
003039 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00303a 1fff                      	rol ZH
00303b 91a0 2840                 	lds r26, pulse1_hi_pitch_macro_offset
00303d 0fea                      	add ZL, r26
00303e 1df2                      	adc ZH, zero
                                 
00303f 91b0 2842                 	lds r27, pulse1_hi_pitch_macro_release
003041 17ba                      	cp r27, r26
003042 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
003043 91a0 2841                 	lds r26, pulse1_hi_pitch_macro_loop
003045 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003046 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003047 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
003048 95a3                      	inc r26 //increment the macro offset
003049 93a0 2840                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
00304b 91b4                      	lpm r27, Z //load hi pitch data into r27
00304c 38b0                      	cpi r27, 0x80 //check for macro end flag
00304d f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
00304e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00304f 93a0 2840                 	sts pulse1_hi_pitch_macro_offset, r26
003051 91b0 2842                 	lds r27, pulse1_hi_pitch_macro_release
003053 3fbf                      	cpi r27, 0xFF
003054 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
003055 91b0 2841                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
003057 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003058 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
003059 93b0 2840                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
00305b cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
00305c 91b0 283d                 	lds r27, pulse1_total_hi_pitch_offset
00305e c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
00305f 91a0 283d                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
003061 0fba                      	add r27, r26
003062 93b0 283d                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
003064 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003065 937f                      	push r23
003066 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
003067 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003068 0367                      	mulsu r22, r23
003069 917f                      	pop r23
00306a 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
00306b 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00306d 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00306f 0da0                      	add r26, r0 //offset the timer values
003070 1db1                      	adc r27, r1
003071 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
003073 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
003075 91e0 2843                 	lds ZL, pulse1_duty_macro
003077 91f0 2844                 	lds ZH, pulse1_duty_macro+1
003079 9630                      	adiw Z, 0
00307a f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
00307b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00307c 1fff                      	rol ZH
00307d 91a0 2845                 	lds r26, pulse1_duty_macro_offset
00307f 0fea                      	add ZL, r26
003080 1df2                      	adc ZH, zero
                                 
003081 91b0 2847                 	lds r27, pulse1_duty_macro_release
003083 17ba                      	cp r27, r26
003084 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
003085 91a0 2846                 	lds r26, pulse1_duty_macro_loop
003087 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003088 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003089 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
00308a 95a3                      	inc r26 //increment the macro offset
00308b 93a0 2845                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
00308d 91b4                      	lpm r27, Z //load pitch data into r27
00308e 3fbf                      	cpi r27, 0xFF //check for macro end flag
00308f f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
003090 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003091 93a0 2845                 	sts pulse1_duty_macro_offset, r26
003093 91b0 2847                 	lds r27, pulse1_duty_macro_release
003095 3fbf                      	cpi r27, 0xFF
003096 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
003097 91b0 2846                 	lds r27, pulse1_duty_macro_loop //load the loop index
003099 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00309a f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00309b 93b0 2845                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
00309d cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
00309e eee0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00309f e7f4                      	ldi ZH, HIGH(sequences << 1)
0030a0 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0030a1 1df2                      	adc ZH, zero
                                 
0030a2 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0030a3 95b7                      	ror r27
0030a4 95b7                      	ror r27
0030a5 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0030a7 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0030a8 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0030a9 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0030aa c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0030ab c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0030ac 9074                      	lpm pulse1_sequence, Z //store the sequence
                                 
0030ad 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0030ae 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0030af 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0030b1 91e0 284a                 	lds ZL, pulse1_fx_1xx
0030b3 91f0 284b                 	lds ZH, pulse1_fx_1xx+1
0030b5 9630                      	adiw Z, 0
0030b6 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0030b7 91a0 284c                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0030b9 91b0 284d                 	lds r27, pulse1_fx_1xx_total+1
0030bb 0fae                      	add r26, ZL //increase the total offset by the rate
0030bc 1fbf                      	adc r27, ZH
0030bd 93a0 284c                 	sts pulse1_fx_1xx_total, r26
0030bf 93b0 284d                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0030c1 91e0 284e                 	lds ZL, pulse1_fx_2xx
0030c3 91f0 284f                 	lds ZH, pulse1_fx_2xx+1
0030c5 9630                      	adiw Z, 0
0030c6 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0030c7 91a0 2850                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0030c9 91b0 2851                 	lds r27, pulse1_fx_2xx_total+1
0030cb 0fae                      	add r26, ZL //increase the total offset by the rate
0030cc 1fbf                      	adc r27, ZH
0030cd 93a0 2850                 	sts pulse1_fx_2xx_total, r26
0030cf 93b0 2851                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
0030d1 91e0 2856                 	lds ZL, pulse1_fx_3xx_speed
0030d3 91f0 2857                 	lds ZH, pulse1_fx_3xx_speed+1
0030d5 9630                      	adiw Z, 0
0030d6 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
0030d7 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
0030d8 91a0 2852                 	lds r26, pulse1_fx_3xx_start
0030da 91b0 2853                 	lds r27, pulse1_fx_3xx_start+1
0030dc 9610                      	adiw r26:r27, 0
0030dd f409                      	brne sound_driver_channel0_fx_3xx_routine_main
0030de c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
0030df 91c0 2854                 	lds r28, pulse1_fx_3xx_target
0030e1 91d0 2855                 	lds r29, pulse1_fx_3xx_target+1
                                 
0030e3 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0030e4 07bd                      	cpc r27, r29
0030e5 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0030e6 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0030e7 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0030e8 9220 2852                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0030ea 9220 2853                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0030ec c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0030ed 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0030ee 0bdb                      	sbc r29, r27
0030ef 91a0 2858                 	lds r26, pulse1_fx_3xx_total_offset
0030f1 91b0 2859                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0030f3 0fae                      	add r26, ZL //add the speed to the total offset
0030f4 1fbf                      	adc r27, ZH
0030f5 1bca                      	sub r28, r26 //invert the total difference with the total offset
0030f6 0bdb                      	sbc r29, r27
0030f7 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0030f8 93a0 2858                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0030fa 93b0 2859                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0030fc 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0030fe 91b0 0a8d                 	lds r27, TCB0_CCMPH
003100 1bac                      	sub r26, r28 //offset the current timer period with the total offset
003101 0bbd                      	sbc r27, r29
003102 93a0 0a8c                 	sts TCB0_CCMPL, r26
003104 93b0 0a8d                 	sts TCB0_CCMPH, r27
003106 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
003107 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
003108 0bbd                      	sbc r27, r29
003109 91c0 2858                 	lds r28, pulse1_fx_3xx_total_offset
00310b 91d0 2859                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
00310d 0fce                      	add r28, ZL //add the speed to the total offset
00310e 1fdf                      	adc r29, ZH
00310f 1bac                      	sub r26, r28 //invert the total difference with the total offset
003110 0bbd                      	sbc r27, r29
003111 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
003112 93c0 2858                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
003114 93d0 2859                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
003116 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
003118 91d0 0a8d                 	lds r29, TCB0_CCMPH
00311a 0fca                      	add r28, r26 //offset the current timer period with the total offset
00311b 1fdb                      	adc r29, r27
00311c 93c0 0a8c                 	sts TCB0_CCMPL, r28
00311e 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
003120 91a0 285a                 	lds r26, pulse1_fx_4xy_speed
003122 15a2                      	cp r26, zero
003123 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
003124 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
003125 91b0 285b                 	lds r27, pulse1_fx_4xy_depth
003127 91c0 285c                 	lds r28, pulse1_fx_4xy_phase
003129 0fca                      	add r28, r26 //increase the phase by the speed
00312a 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00312b f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00312c e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
00312d 93c0 285c                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
00312f 31c0                      	cpi r28, 16
003130 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
003131 32c0                      	cpi r28, 32
003132 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
003133 33c0                      	cpi r28, 48
003134 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
003135 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
003136 70cf                      	andi r28, 0x0F //mask for values 0-15
003137 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
003138 6fc0                      	ori r28, 0xF0
003139 95c0                      	com r28 //invert values 0-15
00313a c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
00313b 70cf                      	andi r28, 0x0F //mask for values 0-15
00313c c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
00313d 6fc0                      	ori r28, 0xF0
00313e 95c0                      	com r28 //invert values 0-15
00313f c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
003140 95b2                      	swap r27 //multiply depth by 16
003141 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003142 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003143 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003144 0fec                      	add ZL, r28 //offset the table by the depth+phase
003145 1df2                      	adc ZH, zero
003146 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
003147 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003148 937f                      	push r23
003149 2f6c                      	mov r22, r28 //store the vibrato value into r22
00314a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00314b 9f67                      	mul r22, r23
00314c 917f                      	pop r23
00314d 916f                      	pop r22
                                 
00314e 9416                      	lsr r1 //shift out the fractional bits
00314f 9407                      	ror r0
003150 9416                      	lsr r1
003151 9407                      	ror r0
003152 9416                      	lsr r1
003153 9407                      	ror r0
003154 9416                      	lsr r1
003155 9407                      	ror r0
                                 	
003156 91a0 0a8c                 	lds r26, TCB0_CCMPL
003158 91b0 0a8d                 	lds r27, TCB0_CCMPH
00315a 0da0                      	add r26, r0
00315b 1db1                      	adc r27, r1
00315c 93a0 0a8c                 	sts TCB0_CCMPL, r26
00315e 93b0 0a8d                 	sts TCB0_CCMPH, r27
003160 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
003161 95b2                      	swap r27 //multiply depth by 16
003162 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
003163 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003164 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003165 0fec                      	add ZL, r28 //offset the table by the depth+phase
003166 1df2                      	adc ZH, zero
003167 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003168 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003169 937f                      	push r23
00316a 2f6c                      	mov r22, r28 //store the vibrato value into r22
00316b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00316c 9f67                      	mul r22, r23
00316d 917f                      	pop r23
00316e 916f                      	pop r22
                                 
00316f 9416                      	lsr r1 //shift out the fractional bits
003170 9407                      	ror r0
003171 9416                      	lsr r1
003172 9407                      	ror r0
003173 9416                      	lsr r1
003174 9407                      	ror r0
003175 9416                      	lsr r1
003176 9407                      	ror r0
                                 
003177 91a0 0a8c                 	lds r26, TCB0_CCMPL
003179 91b0 0a8d                 	lds r27, TCB0_CCMPH
00317b 19a0                      	sub r26, r0
00317c 09b1                      	sbc r27, r1
00317d 93a0 0a8c                 	sts TCB0_CCMPL, r26
00317f 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
003181 91a0 285d                 	lds r26, pulse1_fx_7xy_speed
003183 15a2                      	cp r26, zero
003184 f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
003185 91b0 285e                 	lds r27, pulse1_fx_7xy_depth
003187 91c0 285f                 	lds r28, pulse1_fx_7xy_phase
003189 0fca                      	add r28, r26 //increase the phase by the speed
00318a 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00318b f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00318c e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
00318d 93c0 285f                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
00318f 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
003190 ffc4                      	sbrs r28, 4
003191 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
003192 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
003193 70cf                      	andi r28, 0x0F //mask for values 0-15
003194 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
003195 6fc0                      	ori r28, 0xF0
003196 95c0                      	com r28 //invert values 0-15
003197 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
003198 95b2                      	swap r27 //multiply depth by 16
003199 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00319a e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00319b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00319c 0fec                      	add ZL, r28 //offset the table by the depth+phase
00319d 1df2                      	adc ZH, zero
00319e 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00319f 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0031a0 93c0 2860                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
0031a2 91b0 2861                 	lds r27, pulse1_fx_Axy
0031a4 15b2                      	cp r27, zero
0031a5 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0031a6 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0031a8 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0031aa 2fda                      	mov r29, r26 //copy fractional volume into r29
0031ab 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0031ac 95e2                      	swap r30
0031ad 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0031ae 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0031af 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0031b0 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0031b1 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0031b2 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0031b3 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0031b4 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0031b5 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0031b6 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0031b7 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0031b8 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0031b9 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0031ba e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0031bb 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0031bd 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0031be 95a2                      	swap r26
0031bf 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0031c0 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0031c1 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0031c3 91e0 2867                 	lds ZL, pulse1_fx_Qxy_target
0031c5 91f0 2868                 	lds ZH, pulse1_fx_Qxy_target+1
0031c7 9630                      	adiw Z, 0
0031c8 f129                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0031c9 91a0 286b                 	lds r26, pulse1_fx_Qxy_total_offset
0031cb 91b0 286c                 	lds r27, pulse1_fx_Qxy_total_offset+1
0031cd 91c0 0a8c                 	lds r28, TCB0_CCMPL
0031cf 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0031d1 1bec                      	sub ZL, r28 //calculate the difference to the target
0031d2 0bfd                      	sbc ZH, r29
0031d3 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
0031d4 f078                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
0031d5 9220 286b                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
0031d7 9220 286c                 	sts pulse1_fx_Qxy_total_offset+1, zero
0031d9 9220 2867                 	sts pulse1_fx_Qxy_target, zero
0031db 9220 2868                 	sts pulse1_fx_Qxy_target+1, zero
0031dd 91b0 2866                 	lds r27, pulse1_fx_Qxy_target_note
0031df 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
0031e1 93b0 286d                 	sts pulse1_fx_Rxy_target_note, r27
0031e3 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0031e4 91c0 2869                 	lds r28, pulse1_fx_Qxy_speed
0031e6 91d0 286a                 	lds r29, pulse1_fx_Qxy_speed+1
0031e8 0fac                      	add r26, r28 //increase the total offset by the speed
0031e9 1fbd                      	adc r27, r29
0031ea 93a0 286b                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0031ec 93b0 286c                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0031ee 91e0 286e                 	lds ZL, pulse1_fx_Rxy_target
0031f0 91f0 286f                 	lds ZH, pulse1_fx_Rxy_target+1
0031f2 9630                      	adiw Z, 0
0031f3 f129                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0031f4 91a0 2872                 	lds r26, pulse1_fx_Rxy_total_offset
0031f6 91b0 2873                 	lds r27, pulse1_fx_Rxy_total_offset+1
0031f8 91c0 0a8c                 	lds r28, TCB0_CCMPL
0031fa 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0031fc 1bce                      	sub r28, ZL //calculate the difference to the target
0031fd 0bdf                      	sbc r29, ZH
0031fe f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0031ff f078                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
003200 9220 2872                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
003202 9220 2873                 	sts pulse1_fx_Rxy_total_offset+1, zero
003204 9220 286e                 	sts pulse1_fx_Rxy_target, zero
003206 9220 286f                 	sts pulse1_fx_Rxy_target+1, zero
003208 91b0 286d                 	lds r27, pulse1_fx_Rxy_target_note
00320a 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
00320c 93b0 2866                 	sts pulse1_fx_Qxy_target_note, r27
00320e c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
00320f 91c0 2870                 	lds r28, pulse1_fx_Rxy_speed
003211 91d0 2871                 	lds r29, pulse1_fx_Rxy_speed+1
003213 0fac                      	add r26, r28 //increase the total offset by the speed
003214 1fbd                      	adc r27, r29
003215 93a0 2872                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
003217 93b0 2873                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
003219 91e0 287c                 	lds ZL, pulse2_volume_macro
00321b 91f0 287d                 	lds ZH, pulse2_volume_macro+1
00321d 9630                      	adiw Z, 0
00321e f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
00321f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
003220 1fff                      	rol ZH
003221 91a0 287e                 	lds r26, pulse2_volume_macro_offset
003223 0fea                      	add ZL, r26
003224 1df2                      	adc ZH, zero
                                 
003225 91b0 2880                 	lds r27, pulse2_volume_macro_release
003227 17ba                      	cp r27, r26
003228 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
003229 91a0 287f                 	lds r26, pulse2_volume_macro_loop
00322b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00322c f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00322d c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
00322e 95a3                      	inc r26 //increment the macro offset
00322f 93a0 287e                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
003231 91b4                      	lpm r27, Z //load volume data into r27
003232 3fbf                      	cpi r27, 0xFF //check for macro end flag
003233 f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
003234 91b0 2880                 	lds r27, pulse2_volume_macro_release
003236 3fbf                      	cpi r27, 0xFF
003237 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
003238 91b0 287f                 	lds r27, pulse2_volume_macro_loop //load the loop index
00323a 93b0 287e                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
00323c cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
00323d 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00323e 93a0 287e                 	sts pulse2_volume_macro_offset, r26
003240 cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
003241 eee8                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
003242 e7f5                      	ldi ZH, HIGH(volumes << 1)
003243 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
003244 0feb                      	add ZL, r27 //add offset to the table
003245 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
003246 91b0 2808                 	lds r27, pulse2_param //load main volume
003248 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
003249 91a0 28b1                 	lds r26, pulse2_fx_7xy_value
00324b 30a0                      	cpi r26, 0x00
00324c f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
00324d 0feb                      	add ZL, r27 //offset the volume table by the main volume
00324e 1df2                      	adc ZH, zero
00324f 91b4                      	lpm r27, Z
003250 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
003252 c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
003253 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
003255 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
003256 91a0 28b1                 	lds r26, pulse2_fx_7xy_value
003258 30a0                      	cpi r26, 0x00
003259 f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
00325a 93b0 280e                 	sts pulse2_output_volume, r27
00325c c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
00325d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00325e f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
00325f f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
003260 0feb                      	add ZL, r27 //offset the volume table by the main volume
003261 1df2                      	adc ZH, zero
003262 91b4                      	lpm r27, Z
003263 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
003265 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
003266 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
003267 0feb                      	add ZL, r27 //offset the volume table by the main volume
003268 1df2                      	adc ZH, zero
003269 91b4                      	lpm r27, Z
00326a 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00326c c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
00326d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00326e f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00326f f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
003270 93b0 280e                 	sts pulse2_output_volume, r27
003272 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
003273 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
003274 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
003276 91e0 2881                 	lds ZL, pulse2_arpeggio_macro
003278 91f0 2882                 	lds ZH, pulse2_arpeggio_macro+1
00327a 9630                      	adiw Z, 0
00327b f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00327c 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00327d 1fff                      	rol ZH
00327e 91a0 2883                 	lds r26, pulse2_arpeggio_macro_offset
003280 0fea                      	add ZL, r26
003281 1df2                      	adc ZH, zero
                                 
003282 91b0 2885                 	lds r27, pulse2_arpeggio_macro_release
003284 17ba                      	cp r27, r26
003285 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
003286 91a0 2884                 	lds r26, pulse2_arpeggio_macro_loop
003288 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003289 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00328a c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
00328b 95a3                      	inc r26 //increment the macro offset
00328c 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
00328e 91b4                      	lpm r27, Z //load arpeggio data into r27
00328f 38b0                      	cpi r27, 0x80 //check for macro end flag
003290 f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
003291 c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
003292 50a1                      	subi r26, 1 //keep the offset at the end flag
003293 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26
003295 91b0 2886                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
003297 30b1                      	cpi r27, 0x01
003298 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
003299 91b0 2885                 	lds r27, pulse2_arpeggio_macro_release
00329b 3fbf                      	cpi r27, 0xFF
00329c f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
00329d 91b0 2884                 	lds r27, pulse2_arpeggio_macro_loop
00329f 3fbf                      	cpi r27, 0xFF
0032a0 f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0032a1 c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
0032a2 91b0 2885                 	lds r27, pulse2_arpeggio_macro_release
0032a4 3fbf                      	cpi r27, 0xFF
0032a5 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
0032a6 91b0 2884                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
0032a8 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0032a9 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
0032aa 91c0 2899                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
0032ac 91d0 289a                 	lds r29, pulse2_fx_0xy_sequence+1
0032ae 9620                      	adiw r29:r28, 0
0032af f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0032b0 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0032b1 93a0 2883                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
0032b3 cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
0032b4 93b0 2883                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
0032b6 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
0032b7 91c0 2899                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
0032b9 91d0 289a                 	lds r29, pulse2_fx_0xy_sequence+1
0032bb 9620                      	adiw r29:r28, 0 //check for 0xy effect
0032bc f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
0032bd 95d6                      	lsr r29
0032be 95c7                      	ror r28
0032bf 95d7                      	ror r29
0032c0 95c7                      	ror r28
0032c1 95d7                      	ror r29
0032c2 95c7                      	ror r28
0032c3 95d7                      	ror r29
0032c4 95c7                      	ror r28
0032c5 95d7                      	ror r29
0032c6 95d2                      	swap r29
                                 
0032c7 93c0 2899                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
0032c9 93d0 289a                 	sts pulse2_fx_0xy_sequence+1, r29
0032cb 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0032cc 91a0 280f                 	lds r26, pulse2_note //load the current note index
0032ce 0fac                      	add r26, r28 //add the note offset
0032cf c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0032d0 91a0 280f                 	lds r26, pulse2_note //load the current note index
0032d2 c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
0032d3 9220 2887                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0032d5 9220 2888                 	sts pulse2_total_pitch_offset+1, zero
0032d7 9220 288e                 	sts pulse2_total_hi_pitch_offset, zero
0032d9 91a0 2886                 	lds r26, pulse2_arpeggio_macro_mode
0032db 30a1                      	cpi r26, 0x01 //absolute mode
0032dc f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
0032dd f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
0032de c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
0032df 91a0 280f                 	lds r26, pulse2_note //load the current note index
0032e1 0fab                      	add r26, r27 //offset the note with the arpeggio data
0032e2 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0032e3 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0032e4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0032e5 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0032e6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0032e7 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0032e8 fda7                      	sbrc r26, 7 //check if result is negative
0032e9 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0032ea c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0032eb 2fab                      	mov r26, r27 //move the arpeggio data into r26
0032ec c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0032ed 91a0 280f                 	lds r26, pulse2_note //load the current note index
0032ef 0fab                      	add r26, r27 //offset the note with the arpeggio data
0032f0 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0032f1 c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0032f2 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0032f4 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0032f5 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0032f6 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0032f7 93a0 280f                 	sts pulse2_note, r26
0032f9 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0032fa fda7                      	sbrc r26, 7 //check if result is negative
0032fb e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0032fc 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
0032fe e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0032ff e0f0                      	ldi ZH, HIGH(note_table << 1)
003300 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
003301 0fea                      	add ZL, r26 //add offset
003302 1df2                      	adc ZH, zero
003303 91a5                      	lpm r26, Z+ //load bytes
003304 91b4                      	lpm r27, Z
003305 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
003307 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
003309 93a0 28a5                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00330b 93b0 28a6                 	sts pulse2_fx_3xx_target+1, r27
00330d c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
00330e 91e0 2889                 	lds ZL, pulse2_pitch_macro
003310 91f0 288a                 	lds ZH, pulse2_pitch_macro+1
003312 9630                      	adiw Z, 0
003313 f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
003314 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
003315 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003316 1fff                      	rol ZH
003317 91a0 288b                 	lds r26, pulse2_pitch_macro_offset
003319 0fea                      	add ZL, r26
00331a 1df2                      	adc ZH, zero
                                 
00331b 91b0 288d                 	lds r27, pulse2_pitch_macro_release
00331d 17ba                      	cp r27, r26
00331e f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
00331f 91a0 288c                 	lds r26, pulse2_pitch_macro_loop
003321 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003322 f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003323 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
003324 95a3                      	inc r26 //increment the macro offset
003325 93a0 288b                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
003327 91b4                      	lpm r27, Z //load pitch data into r27
003328 38b0                      	cpi r27, 0x80 //check for macro end flag
003329 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
00332a 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00332b 93a0 288b                 	sts pulse2_pitch_macro_offset, r26
00332d 91b0 288d                 	lds r27, pulse2_pitch_macro_release
00332f 3fbf                      	cpi r27, 0xFF
003330 f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
003331 91b0 288c                 	lds r27, pulse2_pitch_macro_loop //load the loop index
003333 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003334 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
003335 93b0 288b                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
003337 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
003338 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
003339 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00333a 937f                      	push r23
00333b 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00333c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00333d 0367                      	mulsu r22, r23
00333e 917f                      	pop r23
00333f 916f                      	pop r22
                                 
003340 9416                      	lsr r1 //shift out the fractional bits
003341 9407                      	ror r0
003342 9416                      	lsr r1
003343 9407                      	ror r0
003344 9416                      	lsr r1
003345 9407                      	ror r0
003346 9416                      	lsr r1
003347 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
003348 fe13                      	sbrs r1, 3 //check if result was a negative number
003349 c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
00334a efc0                      	ldi r28, 0xF0
00334b 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
00334c 70b7                      	andi r27, 0b00000111
00334d f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
00334e e0b1                      	ldi r27, 0x01
00334f 0e0b                      	add r0, r27
003350 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
003351 91a0 2887                 	lds r26, pulse2_total_pitch_offset
003353 91b0 2888                 	lds r27, pulse2_total_pitch_offset+1
003355 0e0a                      	add r0, r26
003356 1e1b                      	adc r1, r27
003357 9200 2887                 	sts pulse2_total_pitch_offset, r0
003359 9210 2888                 	sts pulse2_total_pitch_offset+1, r1
00335b 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
00335d 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
00335f 0da0                      	add r26, r0 //offset the timer values
003360 1db1                      	adc r27, r1
                                 	
003361 91c0 289d                 	lds r28, pulse2_fx_1xx_total
003363 91d0 289e                 	lds r29, pulse2_fx_1xx_total+1
003365 1bac                      	sub r26, r28
003366 0bbd                      	sbc r27, r29
003367 91c0 28a1                 	lds r28, pulse2_fx_2xx_total
003369 91d0 28a2                 	lds r29, pulse2_fx_2xx_total+1
00336b 0fac                      	add r26, r28
00336c 1fbd                      	adc r27, r29
00336d 91c0 28b5                 	lds r28, pulse2_fx_Pxx_total
00336f 91d0 28b6                 	lds r29, pulse2_fx_Pxx_total+1
003371 0fac                      	add r26, r28
003372 1fbd                      	adc r27, r29
003373 91c0 28bc                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
003375 91d0 28bd                 	lds r29, pulse2_fx_Qxy_total_offset+1
003377 1bac                      	sub r26, r28
003378 0bbd                      	sbc r27, r29
003379 91c0 28c3                 	lds r28, pulse2_fx_Rxy_total_offset
00337b 91d0 28c4                 	lds r29, pulse2_fx_Rxy_total_offset+1
00337d 0fac                      	add r26, r28
00337e 1fbd                      	adc r27, r29
                                 
00337f e5c9                      	ldi r28, 0x59
003380 e0d0                      	ldi r29, 0x00
003381 17ac                      	cp r26, r28
003382 07bd                      	cpc r27, r29
003383 f030                      	brlo sound_driver_instrument_routine_channel1_pitch_min
                                 
003384 e5ca                      	ldi r28, 0x5A
003385 e5d9                      	ldi r29, 0x59
003386 17ac                      	cp r26, r28
003387 07bd                      	cpc r27, r29
003388 f420                      	brsh sound_driver_instrument_routine_channel1_pitch_max
003389 c006                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_min:
00338a e5c9                      	ldi r28, 0x59
00338b e0d0                      	ldi r29, 0x00
00338c c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_max:
00338d e5c9                      	ldi r28, 0x59
00338e e5d9                      	ldi r29, 0x59
00338f c000                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_store:
003390 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
003392 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
003394 91e0 288f                 	lds ZL, pulse2_hi_pitch_macro
003396 91f0 2890                 	lds ZH, pulse2_hi_pitch_macro+1
003398 9630                      	adiw Z, 0
003399 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
00339a c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
00339b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00339c 1fff                      	rol ZH
00339d 91a0 2891                 	lds r26, pulse2_hi_pitch_macro_offset
00339f 0fea                      	add ZL, r26
0033a0 1df2                      	adc ZH, zero
                                 
0033a1 91b0 2893                 	lds r27, pulse2_hi_pitch_macro_release
0033a3 17ba                      	cp r27, r26
0033a4 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0033a5 91a0 2892                 	lds r26, pulse2_hi_pitch_macro_loop
0033a7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0033a8 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0033a9 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
0033aa 95a3                      	inc r26 //increment the macro offset
0033ab 93a0 2891                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
0033ad 91b4                      	lpm r27, Z //load hi pitch data into r27
0033ae 38b0                      	cpi r27, 0x80 //check for macro end flag
0033af f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
0033b0 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0033b1 93a0 2891                 	sts pulse2_hi_pitch_macro_offset, r26
0033b3 91b0 2893                 	lds r27, pulse2_hi_pitch_macro_release
0033b5 3fbf                      	cpi r27, 0xFF
0033b6 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
0033b7 91b0 2892                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
0033b9 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0033ba f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0033bb 93b0 2891                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
0033bd cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
0033be 91b0 288e                 	lds r27, pulse2_total_hi_pitch_offset
0033c0 c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
0033c1 91a0 288e                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
0033c3 0fba                      	add r27, r26
0033c4 93b0 288e                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
0033c6 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0033c7 937f                      	push r23
0033c8 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0033c9 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0033ca 0367                      	mulsu r22, r23
0033cb 917f                      	pop r23
0033cc 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
0033cd 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
0033cf 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
0033d1 0da0                      	add r26, r0 //offset the timer values
0033d2 1db1                      	adc r27, r1
0033d3 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
0033d5 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
0033d7 91e0 2894                 	lds ZL, pulse2_duty_macro
0033d9 91f0 2895                 	lds ZH, pulse2_duty_macro+1
0033db 9630                      	adiw Z, 0
0033dc f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
0033dd 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0033de 1fff                      	rol ZH
0033df 91a0 2896                 	lds r26, pulse2_duty_macro_offset
0033e1 0fea                      	add ZL, r26
0033e2 1df2                      	adc ZH, zero
                                 
0033e3 91b0 2898                 	lds r27, pulse2_duty_macro_release
0033e5 17ba                      	cp r27, r26
0033e6 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
0033e7 91a0 2897                 	lds r26, pulse2_duty_macro_loop
0033e9 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0033ea f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0033eb c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
0033ec 95a3                      	inc r26 //increment the macro offset
0033ed 93a0 2896                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
0033ef 91b4                      	lpm r27, Z //load pitch data into r27
0033f0 3fbf                      	cpi r27, 0xFF //check for macro end flag
0033f1 f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
0033f2 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0033f3 93a0 2896                 	sts pulse2_duty_macro_offset, r26
0033f5 91b0 2898                 	lds r27, pulse2_duty_macro_release
0033f7 3fbf                      	cpi r27, 0xFF
0033f8 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
0033f9 91b0 2897                 	lds r27, pulse2_duty_macro_loop //load the loop index
0033fb 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0033fc f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0033fd 93b0 2896                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
0033ff cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
003400 eee0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
003401 e7f4                      	ldi ZH, HIGH(sequences << 1)
003402 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
003403 1df2                      	adc ZH, zero
                                 
003404 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
003405 95b7                      	ror r27
003406 95b7                      	ror r27
003407 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
003409 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
00340a 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
00340b 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
00340c c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
00340d c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
00340e 90a4                      	lpm pulse2_sequence, Z //store the sequence
                                 
00340f 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
003410 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
003411 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
003413 91e0 289b                 	lds ZL, pulse2_fx_1xx
003415 91f0 289c                 	lds ZH, pulse2_fx_1xx+1
003417 9630                      	adiw Z, 0
003418 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
003419 91a0 289d                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
00341b 91b0 289e                 	lds r27, pulse2_fx_1xx_total+1
00341d 0fae                      	add r26, ZL //increase the total offset by the rate
00341e 1fbf                      	adc r27, ZH
00341f 93a0 289d                 	sts pulse2_fx_1xx_total, r26
003421 93b0 289e                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
003423 91e0 289f                 	lds ZL, pulse2_fx_2xx
003425 91f0 28a0                 	lds ZH, pulse2_fx_2xx+1
003427 9630                      	adiw Z, 0
003428 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
003429 91a0 28a1                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
00342b 91b0 28a2                 	lds r27, pulse2_fx_2xx_total+1
00342d 0fae                      	add r26, ZL //increase the total offset by the rate
00342e 1fbf                      	adc r27, ZH
00342f 93a0 28a1                 	sts pulse2_fx_2xx_total, r26
003431 93b0 28a2                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
003433 91e0 28a7                 	lds ZL, pulse2_fx_3xx_speed
003435 91f0 28a8                 	lds ZH, pulse2_fx_3xx_speed+1
003437 9630                      	adiw Z, 0
003438 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
003439 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
00343a 91a0 28a3                 	lds r26, pulse2_fx_3xx_start
00343c 91b0 28a4                 	lds r27, pulse2_fx_3xx_start+1
00343e 9610                      	adiw r26:r27, 0
00343f f409                      	brne sound_driver_channel1_fx_3xx_routine_main
003440 c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
003441 91c0 28a5                 	lds r28, pulse2_fx_3xx_target
003443 91d0 28a6                 	lds r29, pulse2_fx_3xx_target+1
                                 
003445 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
003446 07bd                      	cpc r27, r29
003447 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
003448 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
003449 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
00344a 9220 28a3                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00344c 9220 28a4                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
00344e c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
00344f 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
003450 0bdb                      	sbc r29, r27
003451 91a0 28a9                 	lds r26, pulse2_fx_3xx_total_offset
003453 91b0 28aa                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
003455 0fae                      	add r26, ZL //add the speed to the total offset
003456 1fbf                      	adc r27, ZH
003457 1bca                      	sub r28, r26 //invert the total difference with the total offset
003458 0bdb                      	sbc r29, r27
003459 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00345a 93a0 28a9                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
00345c 93b0 28aa                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
00345e 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
003460 91b0 0a9d                 	lds r27, TCB1_CCMPH
003462 1bac                      	sub r26, r28 //offset the current timer period with the total offset
003463 0bbd                      	sbc r27, r29
003464 93a0 0a9c                 	sts TCB1_CCMPL, r26
003466 93b0 0a9d                 	sts TCB1_CCMPH, r27
003468 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
003469 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00346a 0bbd                      	sbc r27, r29
00346b 91c0 28a9                 	lds r28, pulse2_fx_3xx_total_offset
00346d 91d0 28aa                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
00346f 0fce                      	add r28, ZL //add the speed to the total offset
003470 1fdf                      	adc r29, ZH
003471 1bac                      	sub r26, r28 //invert the total difference with the total offset
003472 0bbd                      	sbc r27, r29
003473 f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
003474 93c0 28a9                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
003476 93d0 28aa                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
003478 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
00347a 91d0 0a9d                 	lds r29, TCB1_CCMPH
00347c 0fca                      	add r28, r26 //offset the current timer period with the total offset
00347d 1fdb                      	adc r29, r27
00347e 93c0 0a9c                 	sts TCB1_CCMPL, r28
003480 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
003482 91a0 28ab                 	lds r26, pulse2_fx_4xy_speed
003484 15a2                      	cp r26, zero
003485 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
003486 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
003487 91b0 28ac                 	lds r27, pulse2_fx_4xy_depth
003489 91c0 28ad                 	lds r28, pulse2_fx_4xy_phase
00348b 0fca                      	add r28, r26 //increase the phase by the speed
00348c 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00348d f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00348e e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
00348f 93c0 28ad                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
003491 31c0                      	cpi r28, 16
003492 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
003493 32c0                      	cpi r28, 32
003494 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
003495 33c0                      	cpi r28, 48
003496 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
003497 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
003498 70cf                      	andi r28, 0x0F //mask for values 0-15
003499 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
00349a 6fc0                      	ori r28, 0xF0
00349b 95c0                      	com r28 //invert values 0-15
00349c c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
00349d 70cf                      	andi r28, 0x0F //mask for values 0-15
00349e c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
00349f 6fc0                      	ori r28, 0xF0
0034a0 95c0                      	com r28 //invert values 0-15
0034a1 c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
0034a2 95b2                      	swap r27 //multiply depth by 16
0034a3 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0034a4 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0034a5 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0034a6 0fec                      	add ZL, r28 //offset the table by the depth+phase
0034a7 1df2                      	adc ZH, zero
0034a8 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0034a9 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0034aa 937f                      	push r23
0034ab 2f6c                      	mov r22, r28 //store the vibrato value into r22
0034ac eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0034ad 9f67                      	mul r22, r23
0034ae 917f                      	pop r23
0034af 916f                      	pop r22
                                 
0034b0 9416                      	lsr r1 //shift out the fractional bits
0034b1 9407                      	ror r0
0034b2 9416                      	lsr r1
0034b3 9407                      	ror r0
0034b4 9416                      	lsr r1
0034b5 9407                      	ror r0
0034b6 9416                      	lsr r1
0034b7 9407                      	ror r0
                                 	
0034b8 91a0 0a9c                 	lds r26, TCB1_CCMPL
0034ba 91b0 0a9d                 	lds r27, TCB1_CCMPH
0034bc 0da0                      	add r26, r0
0034bd 1db1                      	adc r27, r1
0034be 93a0 0a9c                 	sts TCB1_CCMPL, r26
0034c0 93b0 0a9d                 	sts TCB1_CCMPH, r27
0034c2 c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
0034c3 95b2                      	swap r27 //multiply depth by 16
0034c4 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0034c5 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0034c6 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0034c7 0fec                      	add ZL, r28 //offset the table by the depth+phase
0034c8 1df2                      	adc ZH, zero
0034c9 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0034ca 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0034cb 937f                      	push r23
0034cc 2f6c                      	mov r22, r28 //store the vibrato value into r22
0034cd eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0034ce 9f67                      	mul r22, r23
0034cf 917f                      	pop r23
0034d0 916f                      	pop r22
                                 
0034d1 9416                      	lsr r1 //shift out the fractional bits
0034d2 9407                      	ror r0
0034d3 9416                      	lsr r1
0034d4 9407                      	ror r0
0034d5 9416                      	lsr r1
0034d6 9407                      	ror r0
0034d7 9416                      	lsr r1
0034d8 9407                      	ror r0
                                 
0034d9 91a0 0a9c                 	lds r26, TCB1_CCMPL
0034db 91b0 0a9d                 	lds r27, TCB1_CCMPH
0034dd 19a0                      	sub r26, r0
0034de 09b1                      	sbc r27, r1
0034df 93a0 0a9c                 	sts TCB1_CCMPL, r26
0034e1 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
0034e3 91a0 28ae                 	lds r26, pulse2_fx_7xy_speed
0034e5 15a2                      	cp r26, zero
0034e6 f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0034e7 91b0 28af                 	lds r27, pulse2_fx_7xy_depth
0034e9 91c0 28b0                 	lds r28, pulse2_fx_7xy_phase
0034eb 0fca                      	add r28, r26 //increase the phase by the speed
0034ec 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0034ed f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0034ee e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
0034ef 93c0 28b0                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
0034f1 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0034f2 ffc4                      	sbrs r28, 4
0034f3 c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
0034f4 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
0034f5 70cf                      	andi r28, 0x0F //mask for values 0-15
0034f6 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
0034f7 6fc0                      	ori r28, 0xF0
0034f8 95c0                      	com r28 //invert values 0-15
0034f9 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
0034fa 95b2                      	swap r27 //multiply depth by 16
0034fb 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0034fc e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0034fd e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0034fe 0fec                      	add ZL, r28 //offset the table by the depth+phase
0034ff 1df2                      	adc ZH, zero
003500 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003501 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
003502 93c0 28b1                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
003504 91b0 28b2                 	lds r27, pulse2_fx_Axy
003506 15b2                      	cp r27, zero
003507 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
003508 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
00350a 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
00350c 2fda                      	mov r29, r26 //copy fractional volume into r29
00350d 2fec                      	mov r30, r28 //copy the pulse2_param into r30
00350e 95e2                      	swap r30
00350f 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
003510 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
003511 17ed                      	cp r30, r29 //compare the fractional and integer volumes
003512 f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
003513 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
003514 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
003515 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
003516 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
003517 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
003518 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
003519 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
00351a 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
00351b f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00351c e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
00351d 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
00351f 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
003520 95a2                      	swap r26
003521 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
003522 2bca                      	or r28, r26 //store the new volume back into pulse2_param
003523 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
003525 91e0 28b8                 	lds ZL, pulse2_fx_Qxy_target
003527 91f0 28b9                 	lds ZH, pulse2_fx_Qxy_target+1
003529 9630                      	adiw Z, 0
00352a f129                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
00352b 91a0 28bc                 	lds r26, pulse2_fx_Qxy_total_offset
00352d 91b0 28bd                 	lds r27, pulse2_fx_Qxy_total_offset+1
00352f 91c0 0a9c                 	lds r28, TCB1_CCMPL
003531 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
003533 1bec                      	sub ZL, r28 //calculate the difference to the target
003534 0bfd                      	sbc ZH, r29
003535 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
003536 f078                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
003537 9220 28bc                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
003539 9220 28bd                 	sts pulse2_fx_Qxy_total_offset+1, zero
00353b 9220 28b8                 	sts pulse2_fx_Qxy_target, zero
00353d 9220 28b9                 	sts pulse2_fx_Qxy_target+1, zero
00353f 91b0 28b7                 	lds r27, pulse2_fx_Qxy_target_note
003541 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
003543 93b0 28be                 	sts pulse2_fx_Rxy_target_note, r27
003545 c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
003546 91c0 28ba                 	lds r28, pulse2_fx_Qxy_speed
003548 91d0 28bb                 	lds r29, pulse2_fx_Qxy_speed+1
00354a 0fac                      	add r26, r28 //increase the total offset by the speed
00354b 1fbd                      	adc r27, r29
00354c 93a0 28bc                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
00354e 93b0 28bd                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
003550 91e0 28bf                 	lds ZL, pulse2_fx_Rxy_target
003552 91f0 28c0                 	lds ZH, pulse2_fx_Rxy_target+1
003554 9630                      	adiw Z, 0
003555 f129                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
003556 91a0 28c3                 	lds r26, pulse2_fx_Rxy_total_offset
003558 91b0 28c4                 	lds r27, pulse2_fx_Rxy_total_offset+1
00355a 91c0 0a9c                 	lds r28, TCB1_CCMPL
00355c 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
00355e 1bce                      	sub r28, ZL //calculate the difference to the target
00355f 0bdf                      	sbc r29, ZH
003560 f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
003561 f078                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
003562 9220 28c3                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
003564 9220 28c4                 	sts pulse2_fx_Rxy_total_offset+1, zero
003566 9220 28bf                 	sts pulse2_fx_Rxy_target, zero
003568 9220 28c0                 	sts pulse2_fx_Rxy_target+1, zero
00356a 91b0 28be                 	lds r27, pulse2_fx_Rxy_target_note
00356c 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
00356e 93b0 28b7                 	sts pulse2_fx_Qxy_target_note, r27
003570 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
003571 91c0 28c1                 	lds r28, pulse2_fx_Rxy_speed
003573 91d0 28c2                 	lds r29, pulse2_fx_Rxy_speed+1
003575 0fac                      	add r26, r28 //increase the total offset by the speed
003576 1fbd                      	adc r27, r29
003577 93a0 28c3                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
003579 93b0 28c4                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
00357b 91e0 28cd                 	lds ZL, triangle_volume_macro
00357d 91f0 28ce                 	lds ZH, triangle_volume_macro+1
00357f 9630                      	adiw Z, 0
003580 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
003581 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
003582 1fff                      	rol ZH
003583 91a0 28cf                 	lds r26, triangle_volume_macro_offset
003585 0fea                      	add ZL, r26
003586 1df2                      	adc ZH, zero
                                 
003587 91b0 28d1                 	lds r27, triangle_volume_macro_release
003589 17ba                      	cp r27, r26
00358a f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
00358b 91a0 28d0                 	lds r26, triangle_volume_macro_loop
00358d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00358e f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00358f c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
003590 95a3                      	inc r26 //increment the macro offset
003591 93a0 28cf                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
003593 91b4                      	lpm r27, Z //load volume data into r27
003594 3fbf                      	cpi r27, 0xFF //check for macro end flag
003595 f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
003596 91b0 28d1                 	lds r27, triangle_volume_macro_release
003598 3fbf                      	cpi r27, 0xFF
003599 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
00359a 91b0 28d0                 	lds r27, triangle_volume_macro_loop //load the loop index
00359c 93b0 28cf                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
00359e cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
00359f 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0035a0 93a0 28cf                 	sts triangle_volume_macro_offset, r26
0035a2 cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
0035a3 15b2                      	cp r27, zero
0035a4 f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
0035a5 91b0 0aa5                 	lds r27, TCB2_INTCTRL
0035a7 30b1                      	cpi r27, TCB_CAPT_bm
0035a8 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
0035a9 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0035aa 93b0 0aa5                 	sts TCB2_INTCTRL, r27
0035ac c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
0035ad 9220 0aa5                 	sts TCB2_INTCTRL, zero
0035af 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
0035b1 9220 0aad                 	sts TCB2_CCMPH, zero
0035b3 c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0035b4 91e0 28d2                 	lds ZL, triangle_arpeggio_macro
0035b6 91f0 28d3                 	lds ZH, triangle_arpeggio_macro+1
0035b8 9630                      	adiw Z, 0
0035b9 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0035ba 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0035bb 1fff                      	rol ZH
0035bc 91a0 28d4                 	lds r26, triangle_arpeggio_macro_offset
0035be 0fea                      	add ZL, r26
0035bf 1df2                      	adc ZH, zero
                                 
0035c0 91b0 28d6                 	lds r27, triangle_arpeggio_macro_release
0035c2 17ba                      	cp r27, r26
0035c3 f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0035c4 91a0 28d5                 	lds r26, triangle_arpeggio_macro_loop
0035c6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0035c7 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0035c8 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
0035c9 95a3                      	inc r26 //increment the macro offset
0035ca 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
0035cc 91b4                      	lpm r27, Z //load arpeggio data into r27
0035cd 38b0                      	cpi r27, 0x80 //check for macro end flag
0035ce f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
0035cf c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
0035d0 50a1                      	subi r26, 1 //keep the offset at the end flag
0035d1 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26
0035d3 91b0 28d7                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0035d5 30b1                      	cpi r27, 0x01
0035d6 f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
0035d7 91b0 28d6                 	lds r27, triangle_arpeggio_macro_release
0035d9 3fbf                      	cpi r27, 0xFF
0035da f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
0035db 91b0 28d5                 	lds r27, triangle_arpeggio_macro_loop
0035dd 3fbf                      	cpi r27, 0xFF
0035de f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0035df c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
0035e0 91b0 28d6                 	lds r27, triangle_arpeggio_macro_release
0035e2 3fbf                      	cpi r27, 0xFF
0035e3 f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
0035e4 91b0 28d5                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
0035e6 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0035e7 f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
0035e8 91c0 28ea                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
0035ea 91d0 28eb                 	lds r29, triangle_fx_0xy_sequence+1
0035ec 9620                      	adiw r29:r28, 0
0035ed f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0035ee 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0035ef 93a0 28d4                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
0035f1 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
0035f2 93b0 28d4                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
0035f4 cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
0035f5 91c0 28ea                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
0035f7 91d0 28eb                 	lds r29, triangle_fx_0xy_sequence+1
0035f9 9620                      	adiw r29:r28, 0 //check for 0xy effect
0035fa f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
0035fb 95d6                      	lsr r29
0035fc 95c7                      	ror r28
0035fd 95d7                      	ror r29
0035fe 95c7                      	ror r28
0035ff 95d7                      	ror r29
003600 95c7                      	ror r28
003601 95d7                      	ror r29
003602 95c7                      	ror r28
003603 95d7                      	ror r29
003604 95d2                      	swap r29
                                 
003605 93c0 28ea                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
003607 93d0 28eb                 	sts triangle_fx_0xy_sequence+1, r29
003609 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00360a 91a0 2812                 	lds r26, triangle_note //load the current note index
00360c 0fac                      	add r26, r28 //add the note offset
00360d c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00360e 91a0 2812                 	lds r26, triangle_note //load the current note index
003610 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
003611 9220 28d8                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
003613 9220 28d9                 	sts triangle_total_pitch_offset+1, zero
003615 9220 28df                 	sts triangle_total_hi_pitch_offset, zero
003617 91a0 28d7                 	lds r26, triangle_arpeggio_macro_mode
003619 30a1                      	cpi r26, 0x01 //absolute mode
00361a f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
00361b f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
00361c c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
00361d 91a0 2812                 	lds r26, triangle_note //load the current note index
00361f 0fab                      	add r26, r27 //offset the note with the arpeggio data
003620 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
003621 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
003622 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
003623 f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
003624 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
003625 c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
003626 fda7                      	sbrc r26, 7 //check if result is negative
003627 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
003628 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
003629 2fab                      	mov r26, r27 //move the arpeggio data into r26
00362a c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
00362b 91a0 2812                 	lds r26, triangle_note //load the current note index
00362d 0fab                      	add r26, r27 //offset the note with the arpeggio data
00362e fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00362f c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
003630 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
003632 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
003633 f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
003634 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
003635 93a0 2812                 	sts triangle_note, r26
003637 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
003638 fda7                      	sbrc r26, 7 //check if result is negative
003639 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00363a 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
00363c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00363d e0f0                      	ldi ZH, HIGH(note_table << 1)
00363e 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00363f 0fea                      	add ZL, r26 //add offset
003640 1df2                      	adc ZH, zero
003641 91a5                      	lpm r26, Z+ //load bytes
003642 91b4                      	lpm r27, Z
003643 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
003645 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
003647 93a0 28f6                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
003649 93b0 28f7                 	sts triangle_fx_3xx_target+1, r27
00364b c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
00364c 91e0 28da                 	lds ZL, triangle_pitch_macro
00364e 91f0 28db                 	lds ZH, triangle_pitch_macro+1
003650 9630                      	adiw Z, 0
003651 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
003652 c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
003653 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003654 1fff                      	rol ZH
003655 91a0 28dc                 	lds r26, triangle_pitch_macro_offset
003657 0fea                      	add ZL, r26
003658 1df2                      	adc ZH, zero
                                 
003659 91b0 28de                 	lds r27, triangle_pitch_macro_release
00365b 17ba                      	cp r27, r26
00365c f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
00365d 91a0 28dd                 	lds r26, triangle_pitch_macro_loop
00365f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003660 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003661 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
003662 95a3                      	inc r26 //increment the macro offset
003663 93a0 28dc                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
003665 91b4                      	lpm r27, Z //load pitch data into r27
003666 38b0                      	cpi r27, 0x80 //check for macro end flag
003667 f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
003668 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003669 93a0 28dc                 	sts triangle_pitch_macro_offset, r26
00366b 91b0 28de                 	lds r27, triangle_pitch_macro_release
00366d 3fbf                      	cpi r27, 0xFF
00366e f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
00366f 91b0 28dd                 	lds r27, triangle_pitch_macro_loop //load the loop index
003671 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003672 f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
003673 93b0 28dc                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
003675 cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
003676 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
003677 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003678 937f                      	push r23
003679 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00367a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00367b 0367                      	mulsu r22, r23
00367c 917f                      	pop r23
00367d 916f                      	pop r22
                                 
00367e 9416                      	lsr r1 //shift out the fractional bits
00367f 9407                      	ror r0
003680 9416                      	lsr r1
003681 9407                      	ror r0
003682 9416                      	lsr r1
003683 9407                      	ror r0
003684 9416                      	lsr r1
003685 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
003686 fe13                      	sbrs r1, 3 //check if result was a negative number
003687 c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
003688 efc0                      	ldi r28, 0xF0
003689 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
00368a 70b7                      	andi r27, 0b00000111
00368b f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
00368c e0b1                      	ldi r27, 0x01
00368d 0e0b                      	add r0, r27
00368e 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
00368f 91a0 28d8                 	lds r26, triangle_total_pitch_offset
003691 91b0 28d9                 	lds r27, triangle_total_pitch_offset+1
003693 0e0a                      	add r0, r26
003694 1e1b                      	adc r1, r27
003695 9200 28d8                 	sts triangle_total_pitch_offset, r0
003697 9210 28d9                 	sts triangle_total_pitch_offset+1, r1
003699 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
00369b 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
00369d 0da0                      	add r26, r0 //offset the timer values
00369e 1db1                      	adc r27, r1
                                 	
00369f 91c0 28ee                 	lds r28, triangle_fx_1xx_total
0036a1 91d0 28ef                 	lds r29, triangle_fx_1xx_total+1
0036a3 1bac                      	sub r26, r28
0036a4 0bbd                      	sbc r27, r29
0036a5 91c0 28f2                 	lds r28, triangle_fx_2xx_total
0036a7 91d0 28f3                 	lds r29, triangle_fx_2xx_total+1
0036a9 0fac                      	add r26, r28
0036aa 1fbd                      	adc r27, r29
0036ab 91c0 2901                 	lds r28, triangle_fx_Pxx_total
0036ad 91d0 2902                 	lds r29, triangle_fx_Pxx_total+1
0036af 0fac                      	add r26, r28
0036b0 1fbd                      	adc r27, r29
0036b1 91c0 2908                 	lds r28, triangle_fx_Qxy_total_offset
0036b3 91d0 2909                 	lds r29, triangle_fx_Qxy_total_offset+1
0036b5 1bac                      	sub r26, r28
0036b6 0bbd                      	sbc r27, r29
0036b7 91c0 290f                 	lds r28, triangle_fx_Rxy_total_offset
0036b9 91d0 2910                 	lds r29, triangle_fx_Rxy_total_offset+1
0036bb 0fac                      	add r26, r28
0036bc 1fbd                      	adc r27, r29
                                 
0036bd e5c9                      	ldi r28, 0x59
0036be e0d0                      	ldi r29, 0x00
0036bf 17ac                      	cp r26, r28
0036c0 07bd                      	cpc r27, r29
0036c1 f030                      	brlo sound_driver_instrument_routine_channel2_pitch_min
                                 
0036c2 e5ca                      	ldi r28, 0x5A
0036c3 e5d9                      	ldi r29, 0x59
0036c4 17ac                      	cp r26, r28
0036c5 07bd                      	cpc r27, r29
0036c6 f420                      	brsh sound_driver_instrument_routine_channel2_pitch_max
0036c7 c006                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_min:
0036c8 e5c9                      	ldi r28, 0x59
0036c9 e0d0                      	ldi r29, 0x00
0036ca c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_max:
0036cb e5c9                      	ldi r28, 0x59
0036cc e5d9                      	ldi r29, 0x59
0036cd c000                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_store:
0036ce 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
0036d0 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
0036d2 91e0 28e0                 	lds ZL, triangle_hi_pitch_macro
0036d4 91f0 28e1                 	lds ZH, triangle_hi_pitch_macro+1
0036d6 9630                      	adiw Z, 0
0036d7 f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
0036d8 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
0036d9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0036da 1fff                      	rol ZH
0036db 91a0 28e2                 	lds r26, triangle_hi_pitch_macro_offset
0036dd 0fea                      	add ZL, r26
0036de 1df2                      	adc ZH, zero
                                 
0036df 91b0 28e4                 	lds r27, triangle_hi_pitch_macro_release
0036e1 17ba                      	cp r27, r26
0036e2 f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
0036e3 91a0 28e3                 	lds r26, triangle_hi_pitch_macro_loop
0036e5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0036e6 f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0036e7 c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
0036e8 95a3                      	inc r26 //increment the macro offset
0036e9 93a0 28e2                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
0036eb 91b4                      	lpm r27, Z //load hi pitch data into r27
0036ec 38b0                      	cpi r27, 0x80 //check for macro end flag
0036ed f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
0036ee 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0036ef 93a0 28e2                 	sts triangle_hi_pitch_macro_offset, r26
0036f1 91b0 28e4                 	lds r27, triangle_hi_pitch_macro_release
0036f3 3fbf                      	cpi r27, 0xFF
0036f4 f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
0036f5 91b0 28e3                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
0036f7 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0036f8 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0036f9 93b0 28e2                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
0036fb cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
0036fc 91b0 28df                 	lds r27, triangle_total_hi_pitch_offset
0036fe c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
0036ff 91a0 28df                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
003701 0fba                      	add r27, r26
003702 93b0 28df                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
003704 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
003705 937f                      	push r23
003706 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
003707 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
003708 0367                      	mulsu r22, r23
003709 917f                      	pop r23
00370a 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
00370b 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
00370d 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
00370f 0da0                      	add r26, r0 //offset the timer values
003710 1db1                      	adc r27, r1
003711 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
003713 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
003715 91e0 28ec                 	lds ZL, triangle_fx_1xx
003717 91f0 28ed                 	lds ZH, triangle_fx_1xx+1
003719 9630                      	adiw Z, 0
00371a f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
00371b 91a0 28ee                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
00371d 91b0 28ef                 	lds r27, triangle_fx_1xx_total+1
00371f 0fae                      	add r26, ZL //increase the total offset by the rate
003720 1fbf                      	adc r27, ZH
003721 93a0 28ee                 	sts triangle_fx_1xx_total, r26
003723 93b0 28ef                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
003725 91e0 28f0                 	lds ZL, triangle_fx_2xx
003727 91f0 28f1                 	lds ZH, triangle_fx_2xx+1
003729 9630                      	adiw Z, 0
00372a f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
00372b 91a0 28f2                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
00372d 91b0 28f3                 	lds r27, triangle_fx_2xx_total+1
00372f 0fae                      	add r26, ZL //increase the total offset by the rate
003730 1fbf                      	adc r27, ZH
003731 93a0 28f2                 	sts triangle_fx_2xx_total, r26
003733 93b0 28f3                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
003735 91e0 28f8                 	lds ZL, triangle_fx_3xx_speed
003737 91f0 28f9                 	lds ZH, triangle_fx_3xx_speed+1
003739 9630                      	adiw Z, 0
00373a f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
00373b c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
00373c 91a0 28f4                 	lds r26, triangle_fx_3xx_start
00373e 91b0 28f5                 	lds r27, triangle_fx_3xx_start+1
003740 9610                      	adiw r26:r27, 0
003741 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
003742 c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
003743 91c0 28f6                 	lds r28, triangle_fx_3xx_target
003745 91d0 28f7                 	lds r29, triangle_fx_3xx_target+1
                                 
003747 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
003748 07bd                      	cpc r27, r29
003749 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
00374a f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00374b c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
00374c 9220 28f4                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00374e 9220 28f5                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
003750 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
003751 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
003752 0bdb                      	sbc r29, r27
003753 91a0 28fa                 	lds r26, triangle_fx_3xx_total_offset
003755 91b0 28fb                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
003757 0fae                      	add r26, ZL //add the speed to the total offset
003758 1fbf                      	adc r27, ZH
003759 1bca                      	sub r28, r26 //invert the total difference with the total offset
00375a 0bdb                      	sbc r29, r27
00375b f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00375c 93a0 28fa                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
00375e 93b0 28fb                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
003760 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
003762 91b0 0aad                 	lds r27, TCB2_CCMPH
003764 1bac                      	sub r26, r28 //offset the current timer period with the total offset
003765 0bbd                      	sbc r27, r29
003766 93a0 0aac                 	sts TCB2_CCMPL, r26
003768 93b0 0aad                 	sts TCB2_CCMPH, r27
00376a c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
00376b 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00376c 0bbd                      	sbc r27, r29
00376d 91c0 28fa                 	lds r28, triangle_fx_3xx_total_offset
00376f 91d0 28fb                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
003771 0fce                      	add r28, ZL //add the speed to the total offset
003772 1fdf                      	adc r29, ZH
003773 1bac                      	sub r26, r28 //invert the total difference with the total offset
003774 0bbd                      	sbc r27, r29
003775 f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
003776 93c0 28fa                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
003778 93d0 28fb                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
00377a 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
00377c 91d0 0aad                 	lds r29, TCB2_CCMPH
00377e 0fca                      	add r28, r26 //offset the current timer period with the total offset
00377f 1fdb                      	adc r29, r27
003780 93c0 0aac                 	sts TCB2_CCMPL, r28
003782 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
003784 91a0 28fc                 	lds r26, triangle_fx_4xy_speed
003786 15a2                      	cp r26, zero
003787 f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
003788 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
003789 91b0 28fd                 	lds r27, triangle_fx_4xy_depth
00378b 91c0 28fe                 	lds r28, triangle_fx_4xy_phase
00378d 0fca                      	add r28, r26 //increase the phase by the speed
00378e 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00378f f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
003790 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
003791 93c0 28fe                 	sts triangle_fx_4xy_phase, r28 //store the new phase
003793 31c0                      	cpi r28, 16
003794 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
003795 32c0                      	cpi r28, 32
003796 f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
003797 33c0                      	cpi r28, 48
003798 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
003799 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
00379a 70cf                      	andi r28, 0x0F //mask for values 0-15
00379b c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
00379c 6fc0                      	ori r28, 0xF0
00379d 95c0                      	com r28 //invert values 0-15
00379e c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
00379f 70cf                      	andi r28, 0x0F //mask for values 0-15
0037a0 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
0037a1 6fc0                      	ori r28, 0xF0
0037a2 95c0                      	com r28 //invert values 0-15
0037a3 c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
0037a4 95b2                      	swap r27 //multiply depth by 16
0037a5 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0037a6 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0037a7 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0037a8 0fec                      	add ZL, r28 //offset the table by the depth+phase
0037a9 1df2                      	adc ZH, zero
0037aa 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
0037ab 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0037ac 937f                      	push r23
0037ad 2f6c                      	mov r22, r28 //store the vibrato value into r22
0037ae eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0037af 9f67                      	mul r22, r23
0037b0 917f                      	pop r23
0037b1 916f                      	pop r22
                                 
0037b2 9416                      	lsr r1 //shift out the fractional bits
0037b3 9407                      	ror r0
0037b4 9416                      	lsr r1
0037b5 9407                      	ror r0
0037b6 9416                      	lsr r1
0037b7 9407                      	ror r0
0037b8 9416                      	lsr r1
0037b9 9407                      	ror r0
                                 	
0037ba 91a0 0aac                 	lds r26, TCB2_CCMPL
0037bc 91b0 0aad                 	lds r27, TCB2_CCMPH
0037be 0da0                      	add r26, r0
0037bf 1db1                      	adc r27, r1
0037c0 93a0 0aac                 	sts TCB2_CCMPL, r26
0037c2 93b0 0aad                 	sts TCB2_CCMPH, r27
0037c4 c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
0037c5 95b2                      	swap r27 //multiply depth by 16
0037c6 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0037c7 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0037c8 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0037c9 0fec                      	add ZL, r28 //offset the table by the depth+phase
0037ca 1df2                      	adc ZH, zero
0037cb 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0037cc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0037cd 937f                      	push r23
0037ce 2f6c                      	mov r22, r28 //store the vibrato value into r22
0037cf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0037d0 9f67                      	mul r22, r23
0037d1 917f                      	pop r23
0037d2 916f                      	pop r22
                                 
0037d3 9416                      	lsr r1 //shift out the fractional bits
0037d4 9407                      	ror r0
0037d5 9416                      	lsr r1
0037d6 9407                      	ror r0
0037d7 9416                      	lsr r1
0037d8 9407                      	ror r0
0037d9 9416                      	lsr r1
0037da 9407                      	ror r0
                                 
0037db 91a0 0aac                 	lds r26, TCB2_CCMPL
0037dd 91b0 0aad                 	lds r27, TCB2_CCMPH
0037df 19a0                      	sub r26, r0
0037e0 09b1                      	sbc r27, r1
0037e1 93a0 0aac                 	sts TCB2_CCMPL, r26
0037e3 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
0037e5 91e0 2904                 	lds ZL, triangle_fx_Qxy_target
0037e7 91f0 2905                 	lds ZH, triangle_fx_Qxy_target+1
0037e9 9630                      	adiw Z, 0
0037ea f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0037eb 91a0 2908                 	lds r26, triangle_fx_Qxy_total_offset
0037ed 91b0 2909                 	lds r27, triangle_fx_Qxy_total_offset+1
0037ef 91c0 0aac                 	lds r28, TCB2_CCMPL
0037f1 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
0037f3 1bec                      	sub ZL, r28 //calculate the difference to the target
0037f4 0bfd                      	sbc ZH, r29
0037f5 f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
0037f6 f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
0037f7 9220 2908                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
0037f9 9220 2909                 	sts triangle_fx_Qxy_total_offset+1, zero
0037fb 9220 2904                 	sts triangle_fx_Qxy_target, zero
0037fd 9220 2905                 	sts triangle_fx_Qxy_target+1, zero
0037ff 91b0 2903                 	lds r27, triangle_fx_Qxy_target_note
003801 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
003803 c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
003804 91c0 2906                 	lds r28, triangle_fx_Qxy_speed
003806 91d0 2907                 	lds r29, triangle_fx_Qxy_speed+1
003808 0fac                      	add r26, r28 //increase the total offset by the speed
003809 1fbd                      	adc r27, r29
00380a 93a0 2908                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
00380c 93b0 2909                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
00380e 91e0 290b                 	lds ZL, triangle_fx_Rxy_target
003810 91f0 290c                 	lds ZH, triangle_fx_Rxy_target+1
003812 9630                      	adiw Z, 0
003813 f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
003814 91a0 290f                 	lds r26, triangle_fx_Rxy_total_offset
003816 91b0 2910                 	lds r27, triangle_fx_Rxy_total_offset+1
003818 91c0 0aac                 	lds r28, TCB2_CCMPL
00381a 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
00381c 1bce                      	sub r28, ZL //calculate the difference to the target
00381d 0bdf                      	sbc r29, ZH
00381e f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
00381f f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
003820 9220 290f                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
003822 9220 2910                 	sts triangle_fx_Rxy_total_offset+1, zero
003824 9220 290b                 	sts triangle_fx_Rxy_target, zero
003826 9220 290c                 	sts triangle_fx_Rxy_target+1, zero
003828 91b0 290a                 	lds r27, triangle_fx_Rxy_target_note
00382a 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
00382c c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
00382d 91c0 290d                 	lds r28, triangle_fx_Rxy_speed
00382f 91d0 290e                 	lds r29, triangle_fx_Rxy_speed+1
003831 0fac                      	add r26, r28 //increase the total offset by the speed
003832 1fbd                      	adc r27, r29
003833 93a0 290f                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
003835 93b0 2910                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
003837 91e0 2919                 	lds ZL, noise_volume_macro
003839 91f0 291a                 	lds ZH, noise_volume_macro+1
00383b 9630                      	adiw Z, 0
00383c f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
00383d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00383e 1fff                      	rol ZH
00383f 91a0 291b                 	lds r26, noise_volume_macro_offset
003841 0fea                      	add ZL, r26
003842 1df2                      	adc ZH, zero
                                 
003843 91b0 291d                 	lds r27, noise_volume_macro_release
003845 17ba                      	cp r27, r26
003846 f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
003847 91a0 291c                 	lds r26, noise_volume_macro_loop
003849 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00384a f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00384b c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
00384c 95a3                      	inc r26 //increment the macro offset
00384d 93a0 291b                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
00384f 91b4                      	lpm r27, Z //load volume data into r27
003850 3fbf                      	cpi r27, 0xFF //check for macro end flag
003851 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
003852 91b0 291d                 	lds r27, noise_volume_macro_release
003854 3fbf                      	cpi r27, 0xFF
003855 f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
003856 91b0 291c                 	lds r27, noise_volume_macro_loop //load the loop index
003858 93b0 291b                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
00385a cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
00385b 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00385c 93a0 291b                 	sts noise_volume_macro_offset, r26
00385e cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
00385f eee8                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
003860 e7f5                      	ldi ZH, HIGH(volumes << 1)
003861 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
003862 0feb                      	add ZL, r27 //add offset to the table
003863 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
003864 91b0 2813                 	lds r27, noise_param //load main volume
003866 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
003867 91a0 2943                 	lds r26, noise_fx_7xy_value
003869 30a0                      	cpi r26, 0x00
00386a f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
00386b 0feb                      	add ZL, r27 //offset the volume table by the main volume
00386c 1df2                      	adc ZH, zero
00386d 91b4                      	lpm r27, Z
00386e 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
003870 c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
003871 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
003873 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
003874 91a0 2943                 	lds r26, noise_fx_7xy_value
003876 30a0                      	cpi r26, 0x00
003877 f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
003878 93b0 2816                 	sts noise_output_volume, r27
00387a c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
00387b 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00387c f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
00387d f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
00387e 0feb                      	add ZL, r27 //offset the volume table by the main volume
00387f 1df2                      	adc ZH, zero
003880 91b4                      	lpm r27, Z
003881 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
003883 c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
003884 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
003885 0feb                      	add ZL, r27 //offset the volume table by the main volume
003886 1df2                      	adc ZH, zero
003887 91b4                      	lpm r27, Z
003888 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
00388a c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
00388b 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00388c f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
00388d f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
00388e 93b0 2816                 	sts noise_output_volume, r27
003890 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
003891 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
003892 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
003894 91e0 291e                 	lds ZL, noise_arpeggio_macro
003896 91f0 291f                 	lds ZH, noise_arpeggio_macro+1
003898 9630                      	adiw Z, 0
003899 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00389a 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00389b 1fff                      	rol ZH
00389c 91a0 2920                 	lds r26, noise_arpeggio_macro_offset
00389e 0fea                      	add ZL, r26
00389f 1df2                      	adc ZH, zero
                                 
0038a0 91b0 2922                 	lds r27, noise_arpeggio_macro_release
0038a2 17ba                      	cp r27, r26
0038a3 f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0038a4 91a0 2921                 	lds r26, noise_arpeggio_macro_loop
0038a6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0038a7 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0038a8 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
0038a9 95a3                      	inc r26 //increment the macro offset
0038aa 93a0 2920                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
0038ac 91b4                      	lpm r27, Z //load arpeggio data into r27
0038ad 38b0                      	cpi r27, 0x80 //check for macro end flag
0038ae f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
0038af c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
0038b0 50a1                      	subi r26, 1 //keep the offset at the end flag
0038b1 93a0 2920                 	sts noise_arpeggio_macro_offset, r26
0038b3 91b0 2923                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0038b5 30b1                      	cpi r27, 0x01
0038b6 f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
0038b7 91b0 2922                 	lds r27, noise_arpeggio_macro_release
0038b9 3fbf                      	cpi r27, 0xFF
0038ba f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
0038bb 91b0 2921                 	lds r27, noise_arpeggio_macro_loop
0038bd 3fbf                      	cpi r27, 0xFF
0038be f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0038bf c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
0038c0 91b0 2922                 	lds r27, noise_arpeggio_macro_release
0038c2 3fbf                      	cpi r27, 0xFF
0038c3 f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
0038c4 91b0 2921                 	lds r27, noise_arpeggio_macro_loop //load the loop index
0038c6 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0038c7 f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
0038c8 91c0 2936                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
0038ca 91d0 2937                 	lds r29, noise_fx_0xy_sequence+1
0038cc 9620                      	adiw r29:r28, 0
0038cd f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0038ce 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0038cf 93a0 2920                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
0038d1 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
0038d2 93b0 2920                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
0038d4 cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
0038d5 91c0 2936                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
0038d7 91d0 2937                 	lds r29, noise_fx_0xy_sequence+1
0038d9 9620                      	adiw r29:r28, 0 //check for 0xy effect
0038da f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
0038db 95d6                      	lsr r29
0038dc 95c7                      	ror r28
0038dd 95d7                      	ror r29
0038de 95c7                      	ror r28
0038df 95d7                      	ror r29
0038e0 95c7                      	ror r28
0038e1 95d7                      	ror r29
0038e2 95c7                      	ror r28
0038e3 95d7                      	ror r29
0038e4 95d2                      	swap r29
                                 
0038e5 93c0 2936                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
0038e7 93d0 2937                 	sts noise_fx_0xy_sequence+1, r29
0038e9 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0038ea 91a0 2817                 	lds r26, noise_note //load the current note index
0038ec 0fac                      	add r26, r28 //add the note offset
0038ed c01c                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0038ee 91a0 2817                 	lds r26, noise_note //load the current note index
0038f0 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
0038f1 9220 2924                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0038f3 9220 2925                 	sts noise_total_pitch_offset+1, zero
0038f5 9220 292b                 	sts noise_total_hi_pitch_offset, zero
0038f7 91a0 2923                 	lds r26, noise_arpeggio_macro_mode
0038f9 30a1                      	cpi r26, 0x01 //absolute mode
0038fa f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
0038fb f031                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
0038fc c007                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
0038fd 91a0 2817                 	lds r26, noise_note //load the current note index
0038ff 0fab                      	add r26, r27 //offset the note with the arpeggio data
003900 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
003901 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
003902 2fab                      	mov r26, r27 //move the arpeggio data into r26
003903 c006                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
003904 91a0 2817                 	lds r26, noise_note //load the current note index
003906 0fab                      	add r26, r27 //offset the note with the arpeggio data
003907 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
003908 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
00390a 93a0 2818                 	sts noise_adjusted_note, r26
00390c c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
00390d 91e0 2926                 	lds ZL, noise_pitch_macro
00390f 91f0 2927                 	lds ZH, noise_pitch_macro+1
003911 9630                      	adiw Z, 0
003912 f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
003913 c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
003914 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003915 1fff                      	rol ZH
003916 91a0 2928                 	lds r26, noise_pitch_macro_offset
003918 0fea                      	add ZL, r26
003919 1df2                      	adc ZH, zero
                                 
00391a 91b0 292a                 	lds r27, noise_pitch_macro_release
00391c 17ba                      	cp r27, r26
00391d f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
00391e 91a0 2929                 	lds r26, noise_pitch_macro_loop
003920 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
003921 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
003922 c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
003923 95a3                      	inc r26 //increment the macro offset
003924 93a0 2928                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
003926 91b4                      	lpm r27, Z //load pitch data into r27
003927 38b0                      	cpi r27, 0x80 //check for macro end flag
003928 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
003929 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00392a 93a0 2928                 	sts noise_pitch_macro_offset, r26
00392c 91b0 292a                 	lds r27, noise_pitch_macro_release
00392e 3fbf                      	cpi r27, 0xFF
00392f f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
003930 91b0 2929                 	lds r27, noise_pitch_macro_loop //load the loop index
003932 3fbf                      	cpi r27, 0xFF //check if there is a loop index
003933 f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
003934 93b0 2928                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
003936 cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
003937 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
003938 91a0 2924                 	lds r26, noise_total_pitch_offset
00393a 0fba                      	add r27, r26
00393b 93b0 2924                 	sts noise_total_pitch_offset, r27
00393d 91a0 2818                 	lds r26, noise_adjusted_note
00393f 1bab                      	sub r26, r27
                                 	
003940 91b0 2939                 	lds r27, noise_fx_1xx_total
003942 0fab                      	add r26, r27
003943 91b0 293b                 	lds r27, noise_fx_2xx_total
003945 1bab                      	sub r26, r27
003946 91b0 293f                 	lds r27, noise_fx_4xy_offset
003948 1bab                      	sub r26, r27
003949 91b0 2947                 	lds r27, noise_fx_Pxx_total
00394b 1bab                      	sub r26, r27
                                 
00394c 70af                      	andi r26, 0x0F
                                 
00394d e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
00394e e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
00394f 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
003950 0fea                      	add ZL, r26 //add offset
003951 1df2                      	adc ZH, zero
003952 91a5                      	lpm r26, Z+ //load bytes
003953 91b4                      	lpm r27, Z
003954 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
003956 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
003958 91e0 292c                 	lds ZL, noise_hi_pitch_macro
00395a 91f0 292d                 	lds ZH, noise_hi_pitch_macro+1
00395c 9630                      	adiw Z, 0
00395d f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
00395e c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
00395f 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
003960 1fff                      	rol ZH
003961 91a0 292e                 	lds r26, noise_hi_pitch_macro_offset
003963 0fea                      	add ZL, r26
003964 1df2                      	adc ZH, zero
                                 
003965 91b0 2930                 	lds r27, noise_hi_pitch_macro_release
003967 17ba                      	cp r27, r26
003968 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
003969 91a0 292f                 	lds r26, noise_hi_pitch_macro_loop
00396b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00396c f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00396d c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
00396e 95a3                      	inc r26 //increment the macro offset
00396f 93a0 292e                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
003971 91b4                      	lpm r27, Z //load hi pitch data into r27
003972 38b0                      	cpi r27, 0x80 //check for macro end flag
003973 f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
003974 50a1                      	subi r26, 1 //keep the macro offset at the end flag
003975 93a0 292e                 	sts noise_hi_pitch_macro_offset, r26
003977 91b0 2930                 	lds r27, noise_hi_pitch_macro_release
003979 3fbf                      	cpi r27, 0xFF
00397a f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
00397b 91b0 292f                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
00397d 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00397e f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00397f 93b0 292e                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
003981 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
003982 91b0 292b                 	lds r27, noise_total_hi_pitch_offset
003984 c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
003985 91a0 292b                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
003987 0fba                      	add r27, r26
003988 93b0 292b                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
00398a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00398b 937f                      	push r23
00398c 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00398d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00398e 0367                      	mulsu r22, r23
00398f 917f                      	pop r23
003990 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
003991 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
003993 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
003995 0da0                      	add r26, r0 //offset the timer values
003996 1db1                      	adc r27, r1
003997 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
003999 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
00399b 91e0 2931                 	lds ZL, noise_duty_macro
00399d 91f0 2932                 	lds ZH, noise_duty_macro+1
00399f 9630                      	adiw Z, 0
0039a0 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
0039a1 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0039a2 1fff                      	rol ZH
0039a3 91a0 2933                 	lds r26, noise_duty_macro_offset
0039a5 0fea                      	add ZL, r26
0039a6 1df2                      	adc ZH, zero
                                 
0039a7 91b0 2935                 	lds r27, noise_duty_macro_release
0039a9 17ba                      	cp r27, r26
0039aa f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
0039ab 91a0 2934                 	lds r26, noise_duty_macro_loop
0039ad 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0039ae f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0039af c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
0039b0 95a3                      	inc r26 //increment the macro offset
0039b1 93a0 2933                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
0039b3 91b4                      	lpm r27, Z //load pitch data into r27
0039b4 3fbf                      	cpi r27, 0xFF //check for macro end flag
0039b5 f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
0039b6 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0039b7 93a0 2933                 	sts noise_duty_macro_offset, r26
0039b9 91b0 2935                 	lds r27, noise_duty_macro_release
0039bb 3fbf                      	cpi r27, 0xFF
0039bc f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
0039bd 91b0 2934                 	lds r27, noise_duty_macro_loop //load the loop index
0039bf 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0039c0 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0039c1 93b0 2933                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
0039c3 cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
0039c4 95b6                      	lsr r27
0039c5 95b7                      	ror r27 //move mode bit to bit 7
0039c6 91c0 2814                 	lds r28, noise_period
0039c8 77cf                      	andi r28, 0b01111111
0039c9 2bcb                      	or r28, r27 //store the new noise mode
0039ca 93c0 2814                 	sts noise_period, r28
                                 
0039cc 776f                      	andi noise_sequence_HIGH, 0b01111111
0039cd 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
0039ce 91e0 2938                 	lds ZL, noise_fx_1xx
0039d0 30e0                      	cpi ZL, 0
0039d1 f029                      	breq sound_driver_channel3_fx_2xx_routine
                                 
0039d2 91a0 2939                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
0039d4 0fae                      	add r26, ZL //increase the total offset by the rate
0039d5 93a0 2939                 	sts noise_fx_1xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
0039d7 91e0 293a                 	lds ZL, noise_fx_2xx
0039d9 30e0                      	cpi ZL, 0
0039da f029                      	breq sound_driver_channel3_fx_3xx_routine
                                 
0039db 91a0 293b                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
0039dd 0fae                      	add r26, ZL //increase the total offset by the rate
0039de 93a0 293b                 	sts noise_fx_2xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
0039e0 91a0 293c                 	lds r26, noise_fx_4xy_speed
0039e2 15a2                      	cp r26, zero
0039e3 f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
0039e4 c033                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
0039e5 91b0 293d                 	lds r27, noise_fx_4xy_depth
0039e7 91c0 293e                 	lds r28, noise_fx_4xy_phase
0039e9 0fca                      	add r28, r26 //increase the phase by the speed
0039ea 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0039eb f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0039ec e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
0039ed 93c0 293e                 	sts noise_fx_4xy_phase, r28 //store the new phase
0039ef 31c0                      	cpi r28, 16
0039f0 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
0039f1 32c0                      	cpi r28, 32
0039f2 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
0039f3 33c0                      	cpi r28, 48
0039f4 f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
0039f5 c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
0039f6 70cf                      	andi r28, 0x0F //mask for values 0-15
0039f7 c014                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
0039f8 6fc0                      	ori r28, 0xF0
0039f9 95c0                      	com r28 //invert values 0-15
0039fa c011                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
0039fb 70cf                      	andi r28, 0x0F //mask for values 0-15
0039fc c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
0039fd 6fc0                      	ori r28, 0xF0
0039fe 95c0                      	com r28 //invert values 0-15
0039ff c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
003a00 95b2                      	swap r27 //multiply depth by 16
003a01 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003a02 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003a03 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003a04 0fec                      	add ZL, r28 //offset the table by the depth+phase
003a05 1df2                      	adc ZH, zero
003a06 91c4                      	lpm r28, Z //load the tremelo value into r28
003a07 95c2                      	swap r28
003a08 70cf                      	andi r28, 0x0F
                                 
003a09 93c0 293f                 	sts noise_fx_4xy_offset, r28
003a0b c00c                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
003a0c 95b2                      	swap r27 //multiply depth by 16
003a0d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
003a0e e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003a0f e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003a10 0fec                      	add ZL, r28 //offset the table by the depth+phase
003a11 1df2                      	adc ZH, zero
003a12 91c4                      	lpm r28, Z //load the vibrato value into r28
003a13 95c2                      	swap r28
003a14 70cf                      	andi r28, 0x0F
                                 
003a15 95c1                      	neg r28
003a16 93c0 293f                 	sts noise_fx_4xy_offset, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
003a18 91a0 2940                 	lds r26, noise_fx_7xy_speed
003a1a 15a2                      	cp r26, zero
003a1b f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
003a1c 91b0 2941                 	lds r27, noise_fx_7xy_depth
003a1e 91c0 2942                 	lds r28, noise_fx_7xy_phase
003a20 0fca                      	add r28, r26 //increase the phase by the speed
003a21 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
003a22 f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
003a23 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
003a24 93c0 2942                 	sts noise_fx_7xy_phase, r28 //store the new phase
003a26 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
003a27 ffc4                      	sbrs r28, 4
003a28 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
003a29 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
003a2a 70cf                      	andi r28, 0x0F //mask for values 0-15
003a2b c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
003a2c 6fc0                      	ori r28, 0xF0
003a2d 95c0                      	com r28 //invert values 0-15
003a2e c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
003a2f 95b2                      	swap r27 //multiply depth by 16
003a30 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
003a31 e8e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
003a32 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
003a33 0fec                      	add ZL, r28 //offset the table by the depth+phase
003a34 1df2                      	adc ZH, zero
003a35 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
003a36 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
003a37 93c0 2943                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
003a39 91b0 2944                 	lds r27, noise_fx_Axy
003a3b 15b2                      	cp r27, zero
003a3c f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
003a3d 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
003a3f 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
003a41 2fda                      	mov r29, r26 //copy fractional volume into r29
003a42 2fec                      	mov r30, r28 //copy the noise_param into r30
003a43 95e2                      	swap r30
003a44 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
003a45 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
003a46 17ed                      	cp r30, r29 //compare the fractional and integer volumes
003a47 f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
003a48 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
003a49 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
003a4a c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
003a4b 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
003a4c f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
003a4d efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
003a4e c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
003a4f 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
003a50 f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
003a51 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
003a52 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
003a54 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
003a55 95a2                      	swap r26
003a56 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
003a57 2bca                      	or r28, r26 //store the new volume back into noise_param
003a58 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Qxy_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
                                 
                                 
                                 
                                 sound_driver_exit:
003a5a 91ff                      	pop r31
003a5b 91ef                      	pop r30
003a5c 91df                      	pop r29
003a5d 91cf                      	pop r28
003a5e 940c 1f5c                 	jmp sequence_1_3
                                 
                                 
                                 
                                 //TABLES
003a60 7f05
003a61 010a
003a62 0214
003a63 0328
003a64 0450
003a65 051e
003a66 0607
003a67 070d
003a68 0806
003a69 090c
003a6a 0a18
003a6b 0b30
003a6c 0c60
003a6d 0d24
003a6e 0e08
003a6f 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
003a70 0301
003a71 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
003a72 2205
003a73 220a
003a74 2226
003a75 2242
003a76 2265                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
003a77 2270
003a78 227d
003a79 2280
003a7a 2283
003a7b 2286                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
003a7c 2289
003a7d 2291
003a7e 2294
003a7f 22a1
003a80 22a2                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
003a81 22a3
003a82 22a4
003a83 22a5
003a84 22bd
003a85 22ff                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
003a86 2340
003a87 234d
003a88 2361
003a89 2362
003a8a 2363                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
003a8b 2364                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
003a8c 2502
003a8d 2507
003a8e 2523
003a8f 253f
003a90 2562                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
003a91 256d
003a92 257a
003a93 257d
003a94 2580
003a95 2583                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
003a96 2586
003a97 258e
003a98 2591
003a99 259e
003a9a 259f                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
003a9b 25a0
003a9c 25a1
003a9d 25a2
003a9e 25ba
003a9f 25fc                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
003aa0 263d
003aa1 264a
003aa2 265e
003aa3 265f
003aa4 2660                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
003aa5 2661                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
003aa6 27f2
003aa7 27f7
003aa8 2813
003aa9 282f
003aaa 2852                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
003aab 285d
003aac 285e
003aad 285f
003aae 2862
003aaf 2865                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
003ab0 2868
003ab1 2875
003ab2 2878
003ab3 2885
003ab4 2886                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
003ab5 2887
003ab6 2888
003ab7 2889
003ab8 28a1
003ab9 28e3                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
003aba 2924
003abb 2931
003abc 2932
003abd 2933
003abe 2934                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
003abf 2935                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
003ac0 2aca
003ac1 2acf
003ac2 2ad8
003ac3 2ae1
003ac4 2ae2                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
003ac5 2aef
003ac6 2afc
003ac7 2aff
003ac8 2b02
003ac9 2b05                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
003aca 2b08
003acb 2b0f
003acc 2b12
003acd 2b1f
003ace 2b20                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
003acf 2b21
003ad0 2b22
003ad1 2b23
003ad2 2b26
003ad3 2b27                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
003ad4 2b28
003ad5 2b35
003ad6 2b40
003ad7 2b41
003ad8 2b42                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
003ad9 2b43                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 channel4_fx:
003ada 2c9c
003adb 2c9d
003adc 2c9e
003add 2c9f
003ade 2ca0                      	.dw sound_driver_channel4_fx_0xy, sound_driver_channel4_fx_1xx, sound_driver_channel4_fx_2xx, sound_driver_channel4_fx_3xx, sound_driver_channel4_fx_4xy
003adf 2ca1
003ae0 2ca2
003ae1 2ca3
003ae2 2ca6
003ae3 2ca9                      	.dw sound_driver_channel4_fx_7xy, sound_driver_channel4_fx_Axy, sound_driver_channel4_fx_Bxx, sound_driver_channel4_fx_Cxx, sound_driver_channel4_fx_Dxx
003ae4 2cac
003ae5 2cad
003ae6 2cb0
003ae7 2cbd
003ae8 2cbe                      	.dw sound_driver_channel4_fx_Exx, sound_driver_channel4_fx_Fxx, sound_driver_channel4_fx_Gxx, sound_driver_channel4_fx_Hxy, sound_driver_channel4_fx_Ixy
003ae9 2cbf
003aea 2cc0
003aeb 2cc1
003aec 2cc2
003aed 2cc3                      	.dw sound_driver_channel4_fx_Hxx, sound_driver_channel4_fx_Ixx, sound_driver_channel4_fx_Pxx, sound_driver_channel4_fx_Qxy, sound_driver_channel4_fx_Rxy
003aee 2cc4
003aef 2cd1
003af0 2cd2
003af1 2cd3
003af2 2cd4                      	.dw sound_driver_channel4_fx_Sxx, sound_driver_channel4_fx_Vxx, sound_driver_channel4_fx_Wxx, sound_driver_channel4_fx_Xxx, sound_driver_channel4_fx_Yxx
003af3 2cd5                      	.dw sound_driver_channel4_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
003af4 0000
003af5 0000
003af6 0000
003af7 0000
003af8 0000
003af9 0000
003afa 0000
003afb 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
003afc 0100
003afd 0101
003afe 0101
003aff 0101
003b00 0101
003b01 0101
003b02 0101
003b03 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
003b04 0100
003b05 0101
003b06 0101
003b07 0101
003b08 0101
003b09 0101
003b0a 0101
003b0b 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
003b0c 0100
003b0d 0101
003b0e 0101
003b0f 0101
003b10 0101
003b11 0202
003b12 0202
003b13 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
003b14 0100
003b15 0101
003b16 0101
003b17 0101
003b18 0202
003b19 0202
003b1a 0303
003b1b 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
003b1c 0100
003b1d 0101
003b1e 0101
003b1f 0202
003b20 0302
003b21 0303
003b22 0404
003b23 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
003b24 0100
003b25 0101
003b26 0201
003b27 0202
003b28 0303
003b29 0404
003b2a 0504
003b2b 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
003b2c 0100
003b2d 0101
003b2e 0201
003b2f 0302
003b30 0403
003b31 0504
003b32 0605
003b33 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
003b34 0100
003b35 0101
003b36 0202
003b37 0303
003b38 0404
003b39 0505
003b3a 0606
003b3b 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
003b3c 0100
003b3d 0101
003b3e 0302
003b3f 0403
003b40 0504
003b41 0606
003b42 0707
003b43 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
003b44 0100
003b45 0201
003b46 0302
003b47 0404
003b48 0605
003b49 0706
003b4a 0808
003b4b 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
003b4c 0100
003b4d 0201
003b4e 0302
003b4f 0504
003b50 0605
003b51 0807
003b52 0908
003b53 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
003b54 0100
003b55 0201
003b56 0403
003b57 0504
003b58 0706
003b59 0808
003b5a 0a09
003b5b 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
003b5c 0100
003b5d 0201
003b5e 0403
003b5f 0605
003b60 0706
003b61 0908
003b62 0b0a
003b63 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
003b64 0100
003b65 0201
003b66 0403
003b67 0605
003b68 0807
003b69 0a09
003b6a 0c0b
003b6b 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
003b6c 0100
003b6d 0302
003b6e 0504
003b6f 0706
003b70 0908
003b71 0b0a
003b72 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 258 r0 : 148 r1 : 160 r2 : 689 r3 :  25 r4 :   4 
r5 :   8 r6 :   0 r7 :   6 r8 :   4 r9 :   9 r10:   6 r11:   4 r12:   9 
r13:   5 r14:   5 r15:   4 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 138 r23: 129 r24:   5 r25:  24 r26:1017 r27:1235 r28: 664 
r29: 353 r30: 345 r31: 329 
Registers used: 32 out of 35 (91.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 135 add   : 189 adiw  : 100 and   :   2 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   6 brcs  :  13 break :   0 breq  : 175 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  77 brlt  :   0 brmi  :   0 
brne  : 133 brpl  :   0 brsh  :  38 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   5 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   7 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 129 cpc   :  16 
cpi   : 175 cpse  :  26 dec   :  25 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   5 in    :   6 inc   :  46 
jmp   :   9 ld    :   0 ldd   :   0 ldi   : 314 lds   : 696 lpm   : 284 
lsl   :  83 lsr   : 137 mov   : 138 movw  :   0 mul   :  21 muls  :   0 
mulsu :  10 neg   :   1 nop   :   0 or    :  24 ori   :  12 out   :  10 
pop   :  98 push  :  90 rcall :  56 ret   :  44 reti  :   8 rjmp  : 578 
rol   :  59 ror   : 156 sbc   :  31 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  26 sbrs  :  18 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1400 sub   :  57 subi  :  38 swap  :  47 tst   :   0 wdr   :   0 

Instructions used: 55 out of 114 (48.2%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0076e8  15802  14518  30320   49152  61.7%
[.dseg] 0x002800 0x002958      0    344    344    6144   5.6%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 53 warnings
