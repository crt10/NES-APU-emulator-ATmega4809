
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Tue Jan 12 00:05:20 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4002 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           song_frames: .byte 2
00280a                           song_frame_offset: .byte 2
00280c                           song_speed: .byte 1
                                 
                                 
00280d                           pulse1_pattern: .byte 2
00280f                           pulse1_pattern_delay: .byte 2
002811                           pulse1_pattern_offset: .byte 2
                                 
002813                           pulse1_volume_macro: .byte 2
002815                           pulse1_volume_macro_offset: .byte 1
002816                           pulse1_volume_macro_loop: .byte 1
002817                           pulse1_volume_macro_release: .byte 1
                                 
002818                           pulse1_arpeggio_macro: .byte 2
00281a                           pulse1_arpeggio_macro_offset: .byte 1
00281b                           pulse1_arpeggio_macro_loop: .byte 1
00281c                           pulse1_arpeggio_macro_release: .byte 1
00281d                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00281e                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00281f                           pulse1_pitch_macro: .byte 2
002821                           pulse1_pitch_macro_offset: .byte 1
002822                           pulse1_pitch_macro_loop: .byte 1
002823                           pulse1_pitch_macro_release: .byte 1
                                 
002824                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002825                           pulse1_hi_pitch_macro: .byte 2
002827                           pulse1_hi_pitch_macro_offset: .byte 1
002828                           pulse1_hi_pitch_macro_loop: .byte 1
002829                           pulse1_hi_pitch_macro_release: .byte 1
                                 
00282a                           pulse1_duty_macro: .byte 2
00282c                           pulse1_duty_macro_offset: .byte 1
00282d                           pulse1_duty_macro_loop: .byte 1
00282e                           pulse1_duty_macro_release: .byte 1
                                 
00282f                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002831                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002833                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002835                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002837                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002839                           pulse1_fx_3xx_start: .byte 2 //the starting note period
00283b                           pulse1_fx_3xx_target: .byte 2 //target note period
00283d                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00283f                           pulse1_fx_3xx_total_offset: .byte 2
002841                           pulse1_fx_4xy_speed: .byte 1
002842                           pulse1_fx_4xy_depth: .byte 1
002843                           pulse1_fx_4xy_phase: .byte 1
002844                           pulse1_fx_7xy_speed: .byte 1
002845                           pulse1_fx_7xy_depth: .byte 1
002846                           pulse1_fx_7xy_phase: .byte 1
002847                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002848                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002849                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
00284a                           pulse1_fx_Qxy_target: .byte 2 //target note period
00284c                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
00284e                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002850                           pulse1_fx_Rxy_target: .byte 2 //target note period
002852                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002854                           pulse1_fx_Rxy_total_offset: .byte 2
                                 
002856                           pulse2_pattern_delay: .byte 1
002857                           triangle_pattern_delay: .byte 1
002858                           noise_pattern_delay: .byte 1
002859                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.0000 = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r13
                                 .def pulse1_length_counter = r14
                                 .def pulse1_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 
                                 reset:
000000 940c 10ff                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 1248                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 122e                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 1238                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 122e                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1868                 	jmp pulse1_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(65): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(66): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(67): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(68): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(70): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(71): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(72): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(73): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(102): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(118): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(123): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(133): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(144): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(145): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(149): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(155): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(156): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(158): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(159): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(164): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(275): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(276): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(277): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(279): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(284): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(285): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(286): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(287): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(288): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(289): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(290): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(291): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(292): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(294): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(298): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(299): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(300): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(301): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(303): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(304): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(306): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(314): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(315): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(316): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(317): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(319): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(320): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(324): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(325): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(328): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(329): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(331): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(338): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(339): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(120): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
0010ff edb8                      	ldi r27, CPU_CCP_IOREG_gc //protected write
001100 93b0 0034                 	sts CPU_CCP, r27
001102 e0b0                      	ldi r27, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
001103 93b0 0061                 	sts CLKCTRL_MCLKCTRLB, r27
                                 
                                 /*	//TEST FOR C4, 1 SECOND, 50% DD
                                 	ldi r26, 0x97
                                 	ldi r27, 0x12
                                 	ldi r26, 0x15
                                 	ldi r27, 0x09
                                 	sts pulse1_timerL, r26
                                 	sts pulse1_timerH, r27
                                 	ldi r27, 0b10111111
                                 	sts pulse1_param, r27
                                 	ldi r27, 0x01
                                 	sts pulse1_length, r27
                                 	//TEST FOR SWEEP UP
                                 	ldi r27, 0b11111111
                                 	sts pulse1_sweep_param, r27*/
                                 
                                 	//ZERO
001105 2422                      	clr zero
                                 
                                 	//MEMORY
001106 e3b0                      	ldi r27, 0b00110000
001107 93b0 2800                 	sts pulse1_param, r27
001109 e8b0                      	ldi r27, 0b10000000
00110a 93b0 2801                 	sts pulse1_sweep_param, r27
00110c efbf                      	ldi r27, 0xFF
00110d 93b0 2802                 	sts pulse1_timerL, r27
00110f 93b0 2803                 	sts pulse1_timerH, r27
001111 93b0 2804                 	sts pulse1_length, r27
                                 
001113 e0b0                      	ldi r27, 0x00
001114 93b0 280a                 	sts song_frame_offset, r27
001116 93b0 280b                 	sts song_frame_offset+1, r27
001118 eee2                      	ldi ZL, LOW(song0_frames << 1)
001119 e0f1                      	ldi ZH, HIGH(song0_frames << 1)
00111a 93e0 2808                 	sts song_frames, ZL
00111c 93f0 2809                 	sts song_frames+1, ZH
00111e 9220 280c                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0 TEST
001120 e0b0                      	ldi r27, 0x00
001121 0feb                      	add ZL, r27
001122 1df2                      	adc ZH, zero
001123 91a5                      	lpm r26, Z+
001124 91b4                      	lpm r27, Z
001125 0faa                      	lsl r26
001126 1fbb                      	rol r27
001127 93a0 280d                 	sts pulse1_pattern, r26
001129 93b0 280e                 	sts pulse1_pattern+1, r27
00112b e0b0                      	ldi r27, 0x00
00112c 9220 280f                 	sts pulse1_pattern_delay, zero
00112e 9220 2810                 	sts pulse1_pattern_delay+1, zero
001130 9220 2811                 	sts pulse1_pattern_offset, zero
001132 9220 2812                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//channel 0 instrument macros
001134 efbf                      	ldi r27, 0xFF
001135 9220 2815                 	sts pulse1_volume_macro_offset, zero
001137 93b0 2816                 	sts pulse1_volume_macro_loop, r27
001139 93b0 2817                 	sts pulse1_volume_macro_release, r27
00113b 9220 281a                 	sts pulse1_arpeggio_macro_offset, zero
00113d 93b0 281b                 	sts pulse1_arpeggio_macro_loop, r27
00113f 93b0 281c                 	sts pulse1_arpeggio_macro_release, r27
001141 93b0 281d                 	sts pulse1_arpeggio_macro_mode, r27
001143 9220 2821                 	sts pulse1_pitch_macro_offset, zero
001145 93b0 2822                 	sts pulse1_pitch_macro_loop, r27
001147 93b0 2823                 	sts pulse1_pitch_macro_release, r27
001149 9220 2827                 	sts pulse1_hi_pitch_macro_offset, zero
00114b 93b0 2828                 	sts pulse1_hi_pitch_macro_loop, r27
00114d 93b0 2829                 	sts pulse1_hi_pitch_macro_release, r27
00114f 9220 282c                 	sts pulse1_duty_macro_offset, zero
001151 93b0 282d                 	sts pulse1_duty_macro_loop, r27
001153 93b0 282e                 	sts pulse1_duty_macro_release, r27
                                 
001155 9220 2813                 	sts pulse1_volume_macro, zero
001157 9220 2814                 	sts pulse1_volume_macro+1, zero
001159 9220 2818                 	sts pulse1_arpeggio_macro, zero
00115b 9220 2819                 	sts pulse1_arpeggio_macro+1, zero
00115d 9220 281e                 	sts pulse1_total_pitch_offset, zero
00115f 9220 281f                 	sts pulse1_pitch_macro, zero
001161 9220 2820                 	sts pulse1_pitch_macro+1, zero
001163 9220 2824                 	sts pulse1_total_hi_pitch_offset, zero
001165 9220 2825                 	sts pulse1_hi_pitch_macro, zero
001167 9220 2826                 	sts pulse1_hi_pitch_macro+1, zero
001169 9220 282a                 	sts pulse1_duty_macro, zero
00116b 9220 282b                 	sts pulse1_duty_macro+1, zero
                                 
00116d 9220 2856                 	sts pulse2_pattern_delay, zero
00116f 9220 2857                 	sts triangle_pattern_delay, zero
001171 9220 2858                 	sts noise_pattern_delay, zero
001173 9220 2859                 	sts dcpm_pattern_delay, zero
                                 
                                 	//PINS
001175 efbf                      	ldi r27, 0xFF //set all pins in VPORTD to output
001176 b9b0                      	out VPORTA_DIR, r27
                                 
                                 	//ENVELOPE
001177 e00f                      	ldi pulse1_volume_divider, 0x0F
001178 9110 2800                 	lds pulse1_volume_decay, pulse1_param
00117a 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
00117b 9190 2800                 	lds channel_flags, pulse1_param
00117d 7390                      	andi channel_flags, 0b00110000
00117e 6490                      	sbr channel_flags, 0b01000000 //set start flag
00117f 9220 2806                 	sts pulse1_output_volume, zero
001181 93b0 2805                 	sts pulse1_fractional_volume, r27 //initialize fractional volume to max value
                                 	
                                 	//LENGTH
001183 91d0 2804                 	lds r29, pulse1_length
001185 d72f                      	rcall length_converter
001186 2eed                      	mov pulse1_length_counter, r29
                                 
                                 	//SEQUENCE
001187 91d0 2800                 	lds r29, pulse1_param //load param for sequence table
001189 0fdd                      	lsl r29 //shift duty cycle bits to LSB
00118a 1fdd                      	rol r29
00118b 1fdd                      	rol r29
00118c 70d3                      	andi r29, 0b00000011 //mask duty cycle bits
00118d d73d                      	rcall duty_cycle_sequences
00118e 2edd                      	mov pulse1_sequence, r29
                                 
                                 	//SWEEP
00118f 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param
001191 94f2                      	swap pulse1_sweep //swap data from high byte and low byte
001192 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//FX
001193 9220 282f                 	sts pulse1_fx_0xy_sequence, zero
001195 9220 2830                 	sts pulse1_fx_0xy_sequence+1, zero
001197 9220 2831                 	sts pulse1_fx_1xx, zero
001199 9220 2832                 	sts pulse1_fx_1xx+1, zero
00119b 9220 2833                 	sts pulse1_fx_1xx_total, zero
00119d 9220 2834                 	sts pulse1_fx_1xx_total+1, zero
00119f 9220 2835                 	sts pulse1_fx_2xx, zero
0011a1 9220 2836                 	sts pulse1_fx_2xx+1, zero
0011a3 9220 2837                 	sts pulse1_fx_2xx_total, zero
0011a5 9220 2838                 	sts pulse1_fx_2xx_total+1, zero
0011a7 9220 2839                 	sts pulse1_fx_3xx_start, zero
0011a9 9220 283a                 	sts pulse1_fx_3xx_start+1, zero
0011ab 9220 283b                 	sts pulse1_fx_3xx_target, zero
0011ad 9220 283c                 	sts pulse1_fx_3xx_target+1, zero
0011af 9220 283d                 	sts pulse1_fx_3xx_speed, zero
0011b1 9220 283e                 	sts pulse1_fx_3xx_speed+1, zero
0011b3 9220 283f                 	sts pulse1_fx_3xx_total_offset, zero
0011b5 9220 2840                 	sts pulse1_fx_3xx_total_offset+1, zero
0011b7 9220 2841                 	sts pulse1_fx_4xy_speed, zero
0011b9 9220 2842                 	sts pulse1_fx_4xy_depth, zero
0011bb 9220 2843                 	sts pulse1_fx_4xy_phase, zero
0011bd 9220 2844                 	sts pulse1_fx_7xy_speed, zero
0011bf 9220 2845                 	sts pulse1_fx_7xy_depth, zero
0011c1 9220 2846                 	sts pulse1_fx_7xy_phase, zero
0011c3 9220 2847                 	sts pulse1_fx_7xy_value, zero
0011c5 9220 2848                 	sts pulse1_fx_Pxx, zero
0011c7 9220 2849                 	sts pulse1_fx_Axy, zero
0011c9 9220 284a                 	sts pulse1_fx_Qxy_target, zero
0011cb 9220 284b                 	sts pulse1_fx_Qxy_target+1, zero
0011cd 9220 284c                 	sts pulse1_fx_Qxy_speed, zero
0011cf 9220 284d                 	sts pulse1_fx_Qxy_speed+1, zero
0011d1 9220 284e                 	sts pulse1_fx_Qxy_total_offset, zero
0011d3 9220 284f                 	sts pulse1_fx_Qxy_total_offset+1, zero
0011d5 9220 2850                 	sts pulse1_fx_Rxy_target, zero
0011d7 9220 2851                 	sts pulse1_fx_Rxy_target+1, zero
0011d9 9220 2852                 	sts pulse1_fx_Rxy_speed, zero
0011db 9220 2853                 	sts pulse1_fx_Rxy_speed+1, zero
0011dd 9220 2854                 	sts pulse1_fx_Rxy_total_offset, zero
0011df 9220 2855                 	sts pulse1_fx_Rxy_total_offset+1, zero
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0011e1 e7b0                      	ldi r27, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0011e2 93b0 0a01                 	sts TCA0_SINGLE_CTRLB, r27
0011e4 e7b1                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0011e5 93b0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r27
0011e7 e1b5                      	ldi r27, 0x15 //set the period for CMP0
0011e8 93b0 0a28                 	sts TCA0_SINGLE_CMP0, r27
0011ea e0b5                      	ldi r27, 0x05
0011eb 93b0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r27
0011ed e2bb                      	ldi r27, 0x2B //set the period for CMP1
0011ee 93b0 0a2a                 	sts TCA0_SINGLE_CMP1, r27
0011f0 e0ba                      	ldi r27, 0x0A
0011f1 93b0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r27
0011f3 e4b1                      	ldi r27, 0x41 //set the period for CMP2
0011f4 93b0 0a2c                 	sts TCA0_SINGLE_CMP2, r27
0011f6 e0bf                      	ldi r27, 0x0F
0011f7 93b0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r27
0011f9 e5b7                      	ldi r27, 0x57 //set the period for OVF
0011fa 93b0 0a26                 	sts TCA0_SINGLE_PER, r27
0011fc e1b4                      	ldi r27, 0x14
0011fd 93b0 0a27                 	sts TCA0_SINGLE_PER + 1, r27
0011ff e0bb                      	ldi r27, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
001200 93b0 0a00                 	sts TCA0_SINGLE_CTRLA, r27
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
001202 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001203 93b0 0a81                 	sts TCB0_CTRLB, r27
001205 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001206 93b0 0a85                 	sts TCB0_INTCTRL, r27
001208 91b0 2802                 	lds r27, pulse1_timerL //load the LOW bits for timer
00120a 93b0 0a8c                 	sts TCB0_CCMPL, r27
00120c 91b0 2803                 	lds r27, pulse1_timerH //load the HIGH bits for timer
00120e 93b0 0a8d                 	sts TCB0_CCMPH, r27
001210 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001211 93b0 0a80                 	sts TCB0_CTRLA, r27
001213 9478                      	sei //global interrupt enable
                                 
                                 pulse1:
001214 fed0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
001215 c012                      	rjmp pulse1_off
                                 
001216 14e2                      	cp pulse1_length_counter, zero //if length is zero, return
001217 f081                      	breq pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
                                 pulse1_check_timer_08:
001218 91c0 0a8c                 	lds r28, TCB0_CCMPL
00121a 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 pulse1_check_timer_08_HIGH:
00121c 30d1                      	cpi r29, 0x01 //check timer HIGH period
00121d f008                      	brlo pulse1_check_timer_08_LOW //if the timer HIGH period is $00, check the LOW period
00121e c002                      	rjmp pulse1_check_timer_7FF_HIGH //if the timer HIGH period is > $01, check > $07FF condition
                                 pulse1_check_timer_08_LOW:
00121f 35c9                      	cpi r28, 0x59 //check timer LOW period
001220 f038                      	brlo pulse1_off //if the HIGH period == $00 && LOW period <= $59, pulse off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
                                 pulse1_check_timer_7FF_HIGH:
001221 35d9                      	cpi r29, 0x59 //check timer HIGH period
001222 f038                      	brlo pulse1_on //if the HIGH period is < $59, then all conditions have passed and pulse is not muted
001223 f009                      	breq pulse1_check_timer_7FF_LOW //if the HIGH period is == $59, we go check if the LOW period is < $65
001224 c003                      	rjmp pulse1_off //pulse off if HIGH period is > $59
                                 pulse1_check_timer_7FF_LOW:
001225 36c5                      	cpi r28, 0x65 //check timer LOW period
001226 f408                      	brsh pulse1_off //if the HIGH period == $59 && LOW period >= $65, pulse off
001227 c002                      	rjmp pulse1_on //if the HIGH period == $59 && LOW period < $65, pulse on
                                 
                                 pulse1_off:
001228 b821                      	out VPORTA_OUT, zero
001229 cfea                      	rjmp pulse1
                                 
                                 pulse1_on:
00122a 91d0 2806                 	lds r29, pulse1_output_volume
                                 /*	cpse r29, zero
                                 	rjmp pulse1_off //if VVVV bits are 0, then there is no volume (channel off)*/
                                 
00122c b9d1                      	out VPORTA_OUT, r29
00122d cfe6                      	rjmp pulse1
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
00122e b7bf                      	in r27, CPU_SREG
00122f 93bf                      	push r27
001230 94f8                      	cli
                                 
                                 	//ENVELOPE
001231 d66b                      	rcall pulse1_envelope_routine
                                 
001232 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
001233 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001235 91bf                      	pop r27
001236 bfbf                      	out CPU_SREG, r27
001237 9518                      	reti
                                 
                                 sequence_1_3:
001238 b7bf                      	in r27, CPU_SREG
001239 93bf                      	push r27
00123a 94f8                      	cli
                                 
                                 	//ENVELOPE
00123b d661                      	rcall pulse1_envelope_routine
                                 
                                 	//SWEEP
00123c fcf3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
00123d d635                      	rcall pulse1_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
00123e fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
00123f c002                      	rjmp sequence_1_3_exit
001240 10e2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001241 94ea                      	dec pulse1_length_counter
                                 
                                 sequence_1_3_exit:
001242 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
001243 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001245 91bf                      	pop r27
001246 bfbf                      	out CPU_SREG, r27
001247 9518                      	reti
                                 
                                 sound_driver:
001248 b7bf                      	in r27, CPU_SREG
001249 93bf                      	push r27
00124a 94f8                      	cli
00124b 93cf                      	push r28
00124c 93df                      	push r29
                                 
                                 	//SOUND DRIVER
00124d 91a0 280f                 	lds r26, pulse1_pattern_delay
00124f 91b0 2810                 	lds r27, pulse1_pattern_delay+1
001251 9610                      	adiw r27:r26, 0
001252 f009                      	breq sound_driver_channel0 //if the pattern delay is 0, proceed with sound driver procedures
001253 c2c3                      	rjmp sound_driver_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 
                                 
                                 sound_driver_channel0:
001254 91e0 280d                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001256 91f0 280e                 	lds ZH, pulse1_pattern+1
001258 91a0 2811                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
00125a 91b0 2812                 	lds r27, pulse1_pattern_offset+1
00125c 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00125d 1ffb                      	adc ZH, r27
00125e 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
00125f 35b7                      	cpi r27, 0x57
001260 f408                      	brsh sound_driver_channel0_check_if_volume
001261 c15a                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001262 36b7                      	cpi r27, 0x67
001263 f408                      	brsh sound_driver_channel0_check_if_delay
001264 c192                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001265 3eb3                      	cpi r27, 0xE3
001266 f408                      	brsh sound_driver_channel0_check_if_instrument
001267 c199                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
001268 f409                      	brne sound_driver_channel0_check_if_release
001269 c19c                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
00126a 3eb4                      	cpi r27, 0xE4
00126b f409                      	brne sound_driver_channel0_check_if_end
00126c c243                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
00126d 3fbf                      	cpi r27, 0xFF
00126e f409                      	brne sound_driver_channel0_check_if_fx
00126f c265                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001270 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001271 91a4                      	lpm r26, Z //load the fx data into r26
001272 d288                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001273 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001274 eae6                      	ldi ZL, LOW(fx << 1) //load in note table
001275 e3f1                      	ldi ZH, HIGH(fx << 1)
001276 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001277 0feb                      	add ZL, r27 //add offset
001278 1df2                      	adc ZH, zero
001279 91c5                      	lpm r28, Z+ //load address bytes
00127a 91d4                      	lpm r29, Z
00127b 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00127c 2ffd                      	mov ZH, r29
00127d 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
00127e 93a0 282f                 	sts pulse1_fx_0xy_sequence, r26
001280 9220 2830                 	sts pulse1_fx_0xy_sequence+1, zero
001282 cfd1                      	rjmp sound_driver_channel0
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
001283 9220 2835                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001285 9220 2836                 	sts pulse1_fx_2xx+1, zero
001287 9220 282f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001289 9220 2830                 	sts pulse1_fx_0xy_sequence+1, zero
00128b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00128c 937f                      	push r23
00128d 2f6a                      	mov r22, r26 //store the rate into r22
00128e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00128f 9f67                      	mul r22, r23
001290 917f                      	pop r23
001291 916f                      	pop r22
                                 
001292 9416                      	lsr r1 //shift out the fractional bits
001293 9407                      	ror r0
001294 9416                      	lsr r1
001295 9407                      	ror r0
001296 9416                      	lsr r1
001297 9407                      	ror r0
001298 9416                      	lsr r1
001299 9407                      	ror r0
00129a 9200 2831                 	sts pulse1_fx_1xx, r0
00129c 9210 2832                 	sts pulse1_fx_1xx+1, r1
00129e cfb5                      	rjmp sound_driver_channel0
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
00129f 9220 2831                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
0012a1 9220 2832                 	sts pulse1_fx_1xx+1, zero
0012a3 9220 282f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
0012a5 9220 2830                 	sts pulse1_fx_0xy_sequence+1, zero
0012a7 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0012a8 937f                      	push r23
0012a9 2f6a                      	mov r22, r26 //store the rate into r22
0012aa eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0012ab 9f67                      	mul r22, r23
0012ac 917f                      	pop r23
0012ad 916f                      	pop r22
                                 
0012ae 9416                      	lsr r1 //shift out the fractional bits
0012af 9407                      	ror r0
0012b0 9416                      	lsr r1
0012b1 9407                      	ror r0
0012b2 9416                      	lsr r1
0012b3 9407                      	ror r0
0012b4 9416                      	lsr r1
0012b5 9407                      	ror r0
0012b6 9200 2835                 	sts pulse1_fx_2xx, r0
0012b8 9210 2836                 	sts pulse1_fx_2xx+1, r1
0012ba cf99                      	rjmp sound_driver_channel0
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
0012bb 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0012bc 937f                      	push r23
0012bd 2f6a                      	mov r22, r26 //store the rate into r22
0012be eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0012bf 9f67                      	mul r22, r23
0012c0 917f                      	pop r23
0012c1 916f                      	pop r22
                                 
0012c2 9416                      	lsr r1 //shift out the fractional bits
0012c3 9407                      	ror r0
0012c4 9416                      	lsr r1
0012c5 9407                      	ror r0
0012c6 9416                      	lsr r1
0012c7 9407                      	ror r0
0012c8 9416                      	lsr r1
0012c9 9407                      	ror r0
0012ca 9200 283d                 	sts pulse1_fx_3xx_speed, r0
0012cc 9210 283e                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0012ce 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0012cf c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0012d0 cf83                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0012d1 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0012d3 91b0 0a8d                 	lds r27, TCB0_CCMPH
0012d5 93a0 2839                 	sts pulse1_fx_3xx_start, r26
0012d7 93b0 283a                 	sts pulse1_fx_3xx_start+1, r27
                                 
0012d9 9220 283f                 	sts pulse1_fx_3xx_total_offset, zero
0012db 9220 2840                 	sts pulse1_fx_3xx_total_offset+1, zero
0012dd cf76                      	rjmp sound_driver_channel0
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0012de 2fba                      	mov r27, r26
0012df 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0012e0 95a2                      	swap r26
0012e1 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0012e2 93a0 2841                 	sts pulse1_fx_4xy_speed, r26
0012e4 93b0 2842                 	sts pulse1_fx_4xy_depth, r27
0012e6 9220 2843                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0012e8 cf6b                      	rjmp sound_driver_channel0
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0012e9 2fba                      	mov r27, r26
0012ea 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0012eb 95a2                      	swap r26
0012ec 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0012ed 93a0 2844                 	sts pulse1_fx_7xy_speed, r26
0012ef 93b0 2845                 	sts pulse1_fx_7xy_depth, r27
0012f1 9220 2846                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0012f3 9220 2847                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0012f5 cf5e                      	rjmp sound_driver_channel0
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0012f6 93a0 2849                 	sts pulse1_fx_Axy, r26
0012f8 cf5b                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Bxx: //pattern jump
0012f9 cf5a                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Cxx: //halt
0012fa cf59                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Dxx: //frame skip
0012fb cf58                      	rjmp sound_driver_channel0
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0012fc 91b0 2800                 	lds r27, pulse1_param
0012fe 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0012ff 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
001300 93b0 2800                 	sts pulse1_param, r27
001302 6096                      	sbr channel_flags, 6
001303 cf50                      	rjmp sound_driver_channel0
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
001304 93a0 280c                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001306 cf4d                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Gxx: //note delay
001307 cf4c                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
001308 95a2                      	swap r26
001309 68a8                      	ori r26, 0b10001000 //enable negate and enable sweep flag
00130a 2efa                      	mov pulse1_sweep, r26
00130b 92f0 2801                 	sts pulse1_sweep_param, pulse1_sweep
00130d 6097                      	sbr channel_flags, 7 //set reload flag
00130e cf45                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
00130f 95a2                      	swap r26
001310 77af                      	andi r26, 0b01111111 //disable negate flag
001311 60a8                      	ori r26, 0b00001000 //enable sweep flag
001312 2efa                      	mov pulse1_sweep, r26
001313 92f0 2801                 	sts pulse1_sweep_param, pulse1_sweep
001315 6097                      	sbr channel_flags, 7 //set reload flag
001316 cf3d                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
001317 cf3c                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
001318 cf3b                      	rjmp sound_driver_channel0
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
001319 93a0 2848                 	sts pulse1_fx_Pxx, r26
00131b cf38                      	rjmp sound_driver_channel0
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
00131c 91e0 2818                 	lds ZL, pulse1_arpeggio_macro
00131e 91f0 2819                 	lds ZH, pulse1_arpeggio_macro+1
001320 9630                      	adiw Z, 0
001321 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
001322 cf31                      	rjmp sound_driver_channel0 //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
001323 91e0 281f                 	lds ZL, pulse1_pitch_macro
001325 91f0 2820                 	lds ZH, pulse1_pitch_macro+1
001327 9630                      	adiw Z, 0
001328 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
001329 cf2a                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
00132a 91e0 2825                 	lds ZL, pulse1_hi_pitch_macro
00132c 91f0 2826                 	lds ZH, pulse1_hi_pitch_macro+1
00132e 9630                      	adiw Z, 0
00132f f009                      	breq sound_driver_channel0_fx_Qxy_process
001330 cf23                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001331 2fba                      	mov r27, r26 //copy fx parameters into r27
001332 70bf                      	andi r27, 0x0F //mask note index offset
001333 91c0 2807                 	lds r28, pulse1_note //load current note index
001335 0fbc                      	add r27, r28
001336 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001337 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001338 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001339 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00133a e0f0                      	ldi ZH, HIGH(note_table << 1)
00133b 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
00133c 0feb                      	add ZL, r27 //add offset
00133d 1df2                      	adc ZH, zero
00133e 91c5                      	lpm r28, Z+ //load bytes
00133f 91d4                      	lpm r29, Z
001340 93c0 284a                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001342 93d0 284b                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001344 95a2                      	swap r26
001345 70af                      	andi r26, 0x0F //mask effect speed
001346 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001347 95a3                      	inc r26 //increment the speed by 1
                                 
001348 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001349 937f                      	push r23
00134a 2f6a                      	mov r22, r26 //store the speed data into r27
00134b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00134c 9f67                      	mul r22, r23
00134d 917f                      	pop r23
00134e 916f                      	pop r22
                                 
00134f 9416                      	lsr r1 //shift out the fractional bits
001350 9407                      	ror r0
001351 9416                      	lsr r1
001352 9407                      	ror r0
001353 9416                      	lsr r1
001354 9407                      	ror r0
001355 9416                      	lsr r1
001356 9407                      	ror r0
                                 
001357 9200 284c                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001359 9210 284d                 	sts pulse1_fx_Qxy_speed+1, r1
00135b 9220 284e                 	sts pulse1_fx_Qxy_total_offset, zero
00135d 9220 284f                 	sts pulse1_fx_Qxy_total_offset+1, zero
00135f cef4                      	rjmp sound_driver_channel0
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001360 91e0 2818                 	lds ZL, pulse1_arpeggio_macro
001362 91f0 2819                 	lds ZH, pulse1_arpeggio_macro+1
001364 9630                      	adiw Z, 0
001365 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001366 ceed                      	rjmp sound_driver_channel0 //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001367 91e0 281f                 	lds ZL, pulse1_pitch_macro
001369 91f0 2820                 	lds ZH, pulse1_pitch_macro+1
00136b 9630                      	adiw Z, 0
00136c f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
00136d cee6                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
00136e 91e0 2825                 	lds ZL, pulse1_hi_pitch_macro
001370 91f0 2826                 	lds ZH, pulse1_hi_pitch_macro+1
001372 9630                      	adiw Z, 0
001373 f009                      	breq sound_driver_channel0_fx_Rxy_process
001374 cedf                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001375 2fba                      	mov r27, r26 //copy fx parameters into r27
001376 70bf                      	andi r27, 0x0F //mask note index offset
001377 91c0 2807                 	lds r28, pulse1_note //load current note index
001379 1bcb                      	sub r28, r27
00137a f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
00137b e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
00137c e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00137d e0f0                      	ldi ZH, HIGH(note_table << 1)
00137e 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00137f 0fec                      	add ZL, r28 //add offset
001380 1df2                      	adc ZH, zero
001381 91c5                      	lpm r28, Z+ //load bytes
001382 91d4                      	lpm r29, Z
001383 93c0 2850                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001385 93d0 2851                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
001387 95a2                      	swap r26
001388 70af                      	andi r26, 0x0F //mask effect speed
001389 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00138a 95a3                      	inc r26 //increment the speed by 1
                                 
00138b 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00138c 937f                      	push r23
00138d 2f6a                      	mov r22, r26 //store the speed data into r27
00138e eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00138f 9f67                      	mul r22, r23
001390 917f                      	pop r23
001391 916f                      	pop r22
                                 
001392 9416                      	lsr r1 //shift out the fractional bits
001393 9407                      	ror r0
001394 9416                      	lsr r1
001395 9407                      	ror r0
001396 9416                      	lsr r1
001397 9407                      	ror r0
001398 9416                      	lsr r1
001399 9407                      	ror r0
                                 
00139a 9200 2852                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
00139c 9210 2853                 	sts pulse1_fx_Rxy_speed+1, r1
00139e 9220 2854                 	sts pulse1_fx_Rxy_total_offset, zero
0013a0 9220 2855                 	sts pulse1_fx_Rxy_total_offset+1, zero
0013a2 ceb1                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Sxx: //mute delay
0013a3 ceb0                      	rjmp sound_driver_channel0
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
0013a4 eae2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0013a5 e3f1                      	ldi ZH, HIGH(sequences << 1)
0013a6 0fea                      	add ZL, r26 //offset the pointer
0013a7 1df2                      	adc ZH, zero
                                 
0013a8 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0013a9 95a7                      	ror r26
0013aa 95a7                      	ror r26
0013ab 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
0013ad 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
0013ae 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
0013af 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
0013b0 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
0013b1 cea2                      	rjmp sound_driver_channel0 //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
0013b2 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0013b3 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0013b4 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0013b5 93c0 2800                 	sts pulse1_param, r28
0013b7 ce9c                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
0013b8 ce9b                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
0013b9 ce9a                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
0013ba ce99                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
0013bb ce98                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_channel0_note:
0013bc 93b0 2807                 	sts pulse1_note, r27 //store the note index
0013be e0a3                      	ldi r26, 0x03
0013bf e0b2                      	ldi r27, 0x02
0013c0 93b0 2815                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
0013c2 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26
0013c4 93b0 2821                 	sts pulse1_pitch_macro_offset, r27
0013c6 93b0 2827                 	sts pulse1_hi_pitch_macro_offset, r27
0013c8 93b0 282c                 	sts pulse1_duty_macro_offset, r27
0013ca 9220 281e                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0013cc 9220 2824                 	sts pulse1_total_hi_pitch_offset, zero
0013ce 9220 2833                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0013d0 9220 2834                 	sts pulse1_fx_1xx_total+1, zero
0013d2 9220 2837                 	sts pulse1_fx_2xx_total, zero
0013d4 9220 2838                 	sts pulse1_fx_2xx_total+1, zero
0013d6 9220 283f                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
0013d8 9220 2840                 	sts pulse1_fx_3xx_total_offset+1, zero
0013da 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0013dc 91b0 0a8d                 	lds r27, TCB0_CCMPH
0013de 93a0 2839                 	sts pulse1_fx_3xx_start, r26
0013e0 93b0 283a                 	sts pulse1_fx_3xx_start+1, r27
0013e2 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
0013e4 6097                      	sbr channel_flags, 7 //set reload flag
0013e5 9220 284a                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0013e7 9220 284b                 	sts pulse1_fx_Qxy_target+1, zero
0013e9 9220 284e                 	sts pulse1_fx_Qxy_total_offset, zero
0013eb 9220 284f                 	sts pulse1_fx_Qxy_total_offset+1, zero
0013ed 9220 2850                 	sts pulse1_fx_Rxy_target, zero
0013ef 9220 2851                 	sts pulse1_fx_Rxy_target+1, zero
0013f1 9220 2854                 	sts pulse1_fx_Rxy_total_offset, zero
0013f3 9220 2855                 	sts pulse1_fx_Rxy_total_offset+1, zero
0013f5 d0fb                      	rcall sound_driver_channel0_increment_offset
0013f6 ce5d                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
0013f7 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0013f8 91a0 2800                 	lds r26, pulse1_param
0013fa 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0013fb 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
0013fc 93a0 2800                 	sts pulse1_param, r26
0013fe 6096                      	sbr channel_flags, 6
0013ff d0f1                      	rcall sound_driver_channel0_increment_offset
001400 ce53                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
001401 56b7                      	subi r27, 0x67 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001402 93b0 280f                 	sts pulse1_pattern_delay, r27
001404 d0ec                      	rcall sound_driver_channel0_increment_offset
001405 c0ff                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
001406 9220 2813                 	sts pulse1_volume_macro, zero //reset all macro addresses
001408 9220 2814                 	sts pulse1_volume_macro+1, zero
00140a 9220 2818                 	sts pulse1_arpeggio_macro, zero
00140c 9220 2819                 	sts pulse1_arpeggio_macro+1, zero
00140e 9220 281f                 	sts pulse1_pitch_macro, zero
001410 9220 2820                 	sts pulse1_pitch_macro+1, zero
001412 9220 2825                 	sts pulse1_hi_pitch_macro, zero
001414 9220 2826                 	sts pulse1_hi_pitch_macro+1, zero
001416 9220 282a                 	sts pulse1_duty_macro, zero
001418 9220 282b                 	sts pulse1_duty_macro+1, zero
00141a 9220 281e                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
00141c 9220 2824                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
00141e 9631                      	adiw Z, 1 //point to the byte next to the flag
00141f 91b4                      	lpm r27, Z //store the instrument offset into r27
001420 edef                      	ldi ZL, LOW(instruments) //point Z to instruments table
001421 e0fe                      	ldi ZH, HIGH(instruments)
001422 0feb                      	add ZL, r27 //point Z to offsetted instrument
001423 1df2                      	adc ZH, zero
001424 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001425 1fff                      	rol ZH
001426 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001427 91b4                      	lpm r27, Z
                                 
001428 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001429 1fbb                      	rol r27
00142a 2fea                      	mov ZL, r26
00142b 2ffb                      	mov ZH, r27
00142c 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
00142d 9632                      	adiw Z, 2 //point Z to the address of the macro
00142e e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
00142f 95aa                      	dec r26
001430 f019                      	breq sound_driver_channel0_instrument_change_exit
001431 95b6                      	lsr r27
001432 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001433 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001434 e0a3                      	ldi r26, 0x03
001435 e0b2                      	ldi r27, 0x02
001436 93b0 2815                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001438 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26
00143a 93b0 2821                 	sts pulse1_pitch_macro_offset, r27
00143c 93b0 2827                 	sts pulse1_hi_pitch_macro_offset, r27
00143e 93b0 282c                 	sts pulse1_duty_macro_offset, r27
001440 d0ba                      	rcall sound_driver_channel0_increment_offset_twice
001441 ce12                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001442 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001443 91d5                      	lpm r29, Z+
                                 
001444 30a5                      	cpi r26, 5
001445 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001446 30a4                      	cpi r26, 4
001447 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001448 30a3                      	cpi r26, 3
001449 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
00144a 30a2                      	cpi r26, 2
00144b f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
00144c c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
00144d 93c0 2813                 	sts pulse1_volume_macro, r28
00144f 93d0 2814                 	sts pulse1_volume_macro+1, r29
001451 d041                      	rcall sound_driver_channel0_instrument_change_read_header
001452 93c0 2817                 	sts pulse1_volume_macro_release, r28
001454 93d0 2816                 	sts pulse1_volume_macro_loop, r29
001456 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001457 93c0 2818                 	sts pulse1_arpeggio_macro, r28
001459 93d0 2819                 	sts pulse1_arpeggio_macro+1, r29
00145b 9220 284a                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00145d 9220 284b                 	sts pulse1_fx_Qxy_target+1, zero
00145f 9220 2850                 	sts pulse1_fx_Rxy_target, zero
001461 9220 2851                 	sts pulse1_fx_Rxy_target+1, zero
001463 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001464 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001465 93c0 281f                 	sts pulse1_pitch_macro, r28
001467 93d0 2820                 	sts pulse1_pitch_macro+1, r29
001469 9220 284a                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00146b 9220 284b                 	sts pulse1_fx_Qxy_target+1, zero
00146d 9220 2850                 	sts pulse1_fx_Rxy_target, zero
00146f 9220 2851                 	sts pulse1_fx_Rxy_target+1, zero
001471 d021                      	rcall sound_driver_channel0_instrument_change_read_header
001472 93c0 2823                 	sts pulse1_pitch_macro_release, r28
001474 93d0 2822                 	sts pulse1_pitch_macro_loop, r29
001476 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001477 93c0 2825                 	sts pulse1_hi_pitch_macro, r28
001479 93d0 2826                 	sts pulse1_hi_pitch_macro+1, r29
00147b 9220 284a                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00147d 9220 284b                 	sts pulse1_fx_Qxy_target+1, zero
00147f 9220 2850                 	sts pulse1_fx_Rxy_target, zero
001481 9220 2851                 	sts pulse1_fx_Rxy_target+1, zero
001483 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001484 93c0 2829                 	sts pulse1_hi_pitch_macro_release, r28
001486 93d0 2828                 	sts pulse1_hi_pitch_macro_loop, r29
001488 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001489 93c0 282a                 	sts pulse1_duty_macro, r28
00148b 93d0 282b                 	sts pulse1_duty_macro+1, r29
00148d d005                      	rcall sound_driver_channel0_instrument_change_read_header
00148e 93c0 282e                 	sts pulse1_duty_macro_release, r28
001490 93d0 282d                 	sts pulse1_duty_macro_loop, r29
001492 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001493 93ef                      	push ZL
001494 93ff                      	push ZH
001495 2fec                      	mov ZL, r28
001496 2ffd                      	mov ZH, r29
001497 0fee                      	lsl ZL
001498 1fff                      	rol ZH
001499 91c5                      	lpm r28, Z+
00149a 91d4                      	lpm r29, Z
00149b 91ff                      	pop ZH
00149c 91ef                      	pop ZL
00149d 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
00149e 93ef                      	push ZL
00149f 93ff                      	push ZH
0014a0 2fec                      	mov ZL, r28
0014a1 2ffd                      	mov ZH, r29
0014a2 0fee                      	lsl ZL
0014a3 1fff                      	rol ZH
0014a4 91c5                      	lpm r28, Z+
0014a5 91d5                      	lpm r29, Z+
0014a6 93c0 281c                 	sts pulse1_arpeggio_macro_release, r28
0014a8 93d0 281b                 	sts pulse1_arpeggio_macro_loop, r29
0014aa 91c4                      	lpm r28, Z
0014ab 93c0 281d                 	sts pulse1_arpeggio_macro_mode, r28
0014ad 91ff                      	pop ZH
0014ae 91ef                      	pop ZL
0014af 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
0014b0 91b0 2817                 	lds r27, pulse1_volume_macro_release
0014b2 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
0014b3 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
0014b4 95b3                      	inc r27
0014b5 93b0 2815                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
0014b7 91b0 281c                 	lds r27, pulse1_arpeggio_macro_release
0014b9 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
0014ba f019                      	breq sound_driver_channel0_release_pitch
0014bb 95b3                      	inc r27
0014bc 93b0 281a                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
0014be 91b0 2823                 	lds r27, pulse1_pitch_macro_release
0014c0 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
0014c1 f019                      	breq sound_driver_channel0_release_hi_pitch
0014c2 95b3                      	inc r27
0014c3 93b0 2821                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
0014c5 91b0 2829                 	lds r27, pulse1_hi_pitch_macro_release
0014c7 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
0014c8 f019                      	breq sound_driver_channel0_release_duty
0014c9 95b3                      	inc r27
0014ca 93b0 2827                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
0014cc 91b0 282e                 	lds r27, pulse1_duty_macro_release
0014ce 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0014cf f019                      	breq sound_driver_channel0_release_exit
0014d0 95b3                      	inc r27
0014d1 93b0 282c                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
0014d3 d01d                      	rcall sound_driver_channel0_increment_offset
0014d4 cd7f                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
0014d5 91e0 2808                 	lds ZL, song_frames
0014d7 91f0 2809                 	lds ZH, song_frames+1
0014d9 91a0 280a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0014db 91b0 280b                 	lds r27, song_frame_offset+1
0014dd 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0014de 93a0 280a                 	sts song_frame_offset, r26
0014e0 93b0 280b                 	sts song_frame_offset+1, r27
                                 	//adiw r27:r26, 2 //offset for channel 1 (test)
0014e2 0fea                      	add ZL, r26
0014e3 1ffb                      	adc ZH, r27
                                 
0014e4 91a5                      	lpm r26, Z+ //load the address of the next pattern
0014e5 91b4                      	lpm r27, Z
0014e6 0faa                      	lsl r26
0014e7 1fbb                      	rol r27
0014e8 93a0 280d                 	sts pulse1_pattern, r26
0014ea 93b0 280e                 	sts pulse1_pattern+1, r27
                                 
0014ec 9220 2811                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0014ee 9220 2812                 	sts pulse1_pattern_offset+1, zero
0014f0 cd63                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
0014f1 91e0 2811                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0014f3 91f0 2812                 	lds ZH, pulse1_pattern_offset+1
0014f5 9631                      	adiw Z, 1
0014f6 93e0 2811                 	sts pulse1_pattern_offset, ZL
0014f8 93f0 2812                 	sts pulse1_pattern_offset+1, ZH
0014fa 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0014fb 91e0 2811                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0014fd 91f0 2812                 	lds ZH, pulse1_pattern_offset+1
0014ff 9632                      	adiw Z, 2 //increment the pointer twice
001500 93e0 2811                 	sts pulse1_pattern_offset, ZL
001502 93f0 2812                 	sts pulse1_pattern_offset+1, ZH
001504 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
001505 936f                      	push r22
001506 937f                      	push r23
001507 9160 280c                 	lds r22, song_speed
001509 2fa6                      	mov r26, r22
00150a 50a1                      	subi r26, 1
                                 
00150b 9170 280f                 	lds r23, pulse1_pattern_delay
00150d 9f67                      	mul r22, r23
00150e 0e0a                      	add r0, r26
00150f 1c12                      	adc r1, zero
001510 9200 280f                 	sts pulse1_pattern_delay, r0
001512 9210 2810                 	sts pulse1_pattern_delay+1, r1
                                 
001514 917f                      	pop r23
001515 916f                      	pop r22
001516 c006                      	rjmp sound_driver_instrument_routine
                                 
                                 sound_driver_decrement_frame_delay:
001517 50a1                      	subi r26, 1
001518 09b2                      	sbc r27, zero
001519 93a0 280f                 	sts pulse1_pattern_delay, r26
00151b 93b0 2810                 	sts pulse1_pattern_delay+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine:
                                 sound_driver_instrument_routine_channel0_volume:
00151d 91e0 2813                 	lds ZL, pulse1_volume_macro
00151f 91f0 2814                 	lds ZH, pulse1_volume_macro+1
001521 9630                      	adiw Z, 0
001522 f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
001523 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001524 1fff                      	rol ZH
001525 91a0 2815                 	lds r26, pulse1_volume_macro_offset
001527 0fea                      	add ZL, r26
001528 1df2                      	adc ZH, zero
                                 
001529 91b0 2817                 	lds r27, pulse1_volume_macro_release
00152b 17ba                      	cp r27, r26
00152c f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
00152d 91a0 2816                 	lds r26, pulse1_volume_macro_loop
00152f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001530 f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001531 c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
001532 95a3                      	inc r26 //increment the macro offset
001533 93a0 2815                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
001535 91b4                      	lpm r27, Z //load volume data into r27
001536 3fbf                      	cpi r27, 0xFF //check for macro end flag
001537 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
001538 91b0 2817                 	lds r27, pulse1_volume_macro_release
00153a 3fbf                      	cpi r27, 0xFF
00153b f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
00153c 91b0 2816                 	lds r27, pulse1_volume_macro_loop //load the loop index
00153e 93b0 2815                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
001540 cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
001541 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
001542 93a0 2815                 	sts pulse1_volume_macro_offset, r26
001544 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
001545 edea                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
001546 e3f1                      	ldi ZH, HIGH(volumes << 1)
001547 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
001548 0feb                      	add ZL, r27 //add offset to the table
001549 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
00154a 91b0 2800                 	lds r27, pulse1_param //load main volume
00154c 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00154d 91a0 2847                 	lds r26, pulse1_fx_7xy_value
00154f 30a0                      	cpi r26, 0x00
001550 f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
001551 0feb                      	add ZL, r27 //offset the volume table by the main volume
001552 1df2                      	adc ZH, zero
001553 91b4                      	lpm r27, Z
001554 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001556 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
001557 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
001559 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
00155a 91a0 2847                 	lds r26, pulse1_fx_7xy_value
00155c 30a0                      	cpi r26, 0x00
00155d f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
00155e 93b0 2806                 	sts pulse1_output_volume, r27
001560 c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
001561 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001562 f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
001563 f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
001564 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
001565 0feb                      	add ZL, r27 //offset the volume table by the main volume
001566 1df2                      	adc ZH, zero
001567 91b4                      	lpm r27, Z
001568 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00156a c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
00156b e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
00156c 0feb                      	add ZL, r27 //offset the volume table by the main volume
00156d 1df2                      	adc ZH, zero
00156e 91b4                      	lpm r27, Z
00156f 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001571 c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
001572 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
001573 f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001574 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001575 93b0 2806                 	sts pulse1_output_volume, r27
001577 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
001578 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001579 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00157b 91e0 2818                 	lds ZL, pulse1_arpeggio_macro
00157d 91f0 2819                 	lds ZH, pulse1_arpeggio_macro+1
00157f 9630                      	adiw Z, 0
001580 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
001581 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001582 1fff                      	rol ZH
001583 91a0 281a                 	lds r26, pulse1_arpeggio_macro_offset
001585 0fea                      	add ZL, r26
001586 1df2                      	adc ZH, zero
                                 
001587 91b0 281c                 	lds r27, pulse1_arpeggio_macro_release
001589 17ba                      	cp r27, r26
00158a f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00158b 91a0 281b                 	lds r26, pulse1_arpeggio_macro_loop
00158d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00158e f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00158f c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
001590 95a3                      	inc r26 //increment the macro offset
001591 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
001593 91b4                      	lpm r27, Z //load arpeggio data into r27
001594 38b0                      	cpi r27, 0x80 //check for macro end flag
001595 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
001596 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
001597 50a1                      	subi r26, 1 //keep the offset at the end flag
001598 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26
00159a 91b0 281d                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00159c 30b1                      	cpi r27, 0x01
00159d f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
00159e 91b0 281c                 	lds r27, pulse1_arpeggio_macro_release
0015a0 3fbf                      	cpi r27, 0xFF
0015a1 f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0015a2 91b0 281b                 	lds r27, pulse1_arpeggio_macro_loop
0015a4 3fbf                      	cpi r27, 0xFF
0015a5 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0015a6 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
0015a7 91b0 281c                 	lds r27, pulse1_arpeggio_macro_release
0015a9 3fbf                      	cpi r27, 0xFF
0015aa f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
0015ab 91b0 281b                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
0015ad 3fbf                      	cpi r27, 0xFF //check if loop flag exists
0015ae f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
0015af 91c0 282f                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
0015b1 91d0 2830                 	lds r29, pulse1_fx_0xy_sequence+1
0015b3 9620                      	adiw r29:r28, 0
0015b4 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0015b5 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0015b6 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0015b8 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0015b9 93b0 281a                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0015bb cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0015bc 91c0 282f                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0015be 91d0 2830                 	lds r29, pulse1_fx_0xy_sequence+1
0015c0 9620                      	adiw r29:r28, 0 //check for 0xy effect
0015c1 f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
0015c2 95d6                      	lsr r29
0015c3 95c7                      	ror r28
0015c4 95d7                      	ror r29
0015c5 95c7                      	ror r28
0015c6 95d7                      	ror r29
0015c7 95c7                      	ror r28
0015c8 95d7                      	ror r29
0015c9 95c7                      	ror r28
0015ca 95d7                      	ror r29
0015cb 95d2                      	swap r29
                                 
0015cc 93c0 282f                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0015ce 93d0 2830                 	sts pulse1_fx_0xy_sequence+1, r29
0015d0 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0015d1 91a0 2807                 	lds r26, pulse1_note //load the current note index
0015d3 0fac                      	add r26, r28 //add the note offset
0015d4 c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0015d5 91a0 2807                 	lds r26, pulse1_note //load the current note index
0015d7 c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0015d8 9220 281e                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0015da 9220 2824                 	sts pulse1_total_hi_pitch_offset, zero
0015dc 91a0 281d                 	lds r26, pulse1_arpeggio_macro_mode
0015de 30a1                      	cpi r26, 0x01 //absolute mode
0015df f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0015e0 f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0015e1 c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0015e2 91a0 2807                 	lds r26, pulse1_note //load the current note index
0015e4 0fab                      	add r26, r27 //offset the note with the arpeggio data
0015e5 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0015e6 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0015e7 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0015e8 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0015e9 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0015ea c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0015eb fda7                      	sbrc r26, 7 //check if result is negative
0015ec e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0015ed c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0015ee 2fab                      	mov r26, r27 //move the arpeggio data into r26
0015ef c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0015f0 91a0 2807                 	lds r26, pulse1_note //load the current note index
0015f2 0fab                      	add r26, r27 //offset the note with the arpeggio data
0015f3 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0015f4 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0015f5 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0015f7 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0015f8 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0015f9 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0015fa 93a0 2807                 	sts pulse1_note, r26
0015fc c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
0015fd fda7                      	sbrc r26, 7 //check if result is negative
0015fe e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0015ff 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
001601 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001602 e0f0                      	ldi ZH, HIGH(note_table << 1)
001603 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
001604 0fea                      	add ZL, r26 //add offset
001605 1df2                      	adc ZH, zero
001606 91a5                      	lpm r26, Z+ //load bytes
001607 91b4                      	lpm r27, Z
001608 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
00160a 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
00160c 93a0 283b                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
00160e 93b0 283c                 	sts pulse1_fx_3xx_target+1, r27
001610 c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
001611 91e0 281f                 	lds ZL, pulse1_pitch_macro
001613 91f0 2820                 	lds ZH, pulse1_pitch_macro+1
001615 9630                      	adiw Z, 0
001616 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
001617 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
001618 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001619 1fff                      	rol ZH
00161a 91a0 2821                 	lds r26, pulse1_pitch_macro_offset
00161c 0fea                      	add ZL, r26
00161d 1df2                      	adc ZH, zero
                                 
00161e 91b0 2823                 	lds r27, pulse1_pitch_macro_release
001620 17ba                      	cp r27, r26
001621 f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
001622 91a0 2822                 	lds r26, pulse1_pitch_macro_loop
001624 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001625 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001626 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
001627 95a3                      	inc r26 //increment the macro offset
001628 93a0 2821                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
00162a 91b4                      	lpm r27, Z //load pitch data into r27
00162b 38b0                      	cpi r27, 0x80 //check for macro end flag
00162c f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
00162d 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00162e 93a0 2821                 	sts pulse1_pitch_macro_offset, r26
001630 91b0 2823                 	lds r27, pulse1_pitch_macro_release
001632 3fbf                      	cpi r27, 0xFF
001633 f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
001634 91b0 2822                 	lds r27, pulse1_pitch_macro_loop //load the loop index
001636 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001637 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
001638 93b0 2821                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
00163a cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
00163b 91b0 281e                 	lds r27, pulse1_total_pitch_offset
00163d c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
00163e 91a0 281e                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
001640 0fba                      	add r27, r26
001641 93b0 281e                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
001643 91a0 2848                 	lds r26, pulse1_fx_Pxx
001645 0fba                      	add r27, r26
                                 
001646 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001647 937f                      	push r23
001648 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
001649 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00164a 0367                      	mulsu r22, r23
00164b 917f                      	pop r23
00164c 916f                      	pop r22
                                 
00164d 9416                      	lsr r1 //shift out the fractional bits
00164e 9407                      	ror r0
00164f 9416                      	lsr r1
001650 9407                      	ror r0
001651 9416                      	lsr r1
001652 9407                      	ror r0
001653 9416                      	lsr r1
001654 9407                      	ror r0
001655 fe13                      	sbrs r1, 3 //check if result was a negative number
001656 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
001657 efb0                      	ldi r27, 0xF0
001658 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
001659 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00165b 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00165d 0da0                      	add r26, r0 //offset the timer values
00165e 1db1                      	adc r27, r1
                                 	
00165f 91c0 2833                 	lds r28, pulse1_fx_1xx_total
001661 91d0 2834                 	lds r29, pulse1_fx_1xx_total+1
001663 1bac                      	sub r26, r28
001664 0bbd                      	sbc r27, r29
001665 91c0 2837                 	lds r28, pulse1_fx_2xx_total
001667 91d0 2838                 	lds r29, pulse1_fx_2xx_total+1
001669 0fac                      	add r26, r28
00166a 1fbd                      	adc r27, r29
00166b 91c0 284e                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
00166d 91d0 284f                 	lds r29, pulse1_fx_Qxy_total_offset+1
00166f 1bac                      	sub r26, r28
001670 0bbd                      	sbc r27, r29
001671 91c0 2854                 	lds r28, pulse1_fx_Rxy_total_offset
001673 91d0 2855                 	lds r29, pulse1_fx_Rxy_total_offset+1
001675 0fac                      	add r26, r28
001676 1fbd                      	adc r27, r29
                                 
001677 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
001679 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
00167b 91e0 2825                 	lds ZL, pulse1_hi_pitch_macro
00167d 91f0 2826                 	lds ZH, pulse1_hi_pitch_macro+1
00167f 9630                      	adiw Z, 0
001680 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
001681 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
001682 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001683 1fff                      	rol ZH
001684 91a0 2827                 	lds r26, pulse1_hi_pitch_macro_offset
001686 0fea                      	add ZL, r26
001687 1df2                      	adc ZH, zero
                                 
001688 91b0 2829                 	lds r27, pulse1_hi_pitch_macro_release
00168a 17ba                      	cp r27, r26
00168b f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
00168c 91a0 2828                 	lds r26, pulse1_hi_pitch_macro_loop
00168e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00168f f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001690 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
001691 95a3                      	inc r26 //increment the macro offset
001692 93a0 2827                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
001694 91b4                      	lpm r27, Z //load hi pitch data into r27
001695 38b0                      	cpi r27, 0x80 //check for macro end flag
001696 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
001697 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001698 93a0 2827                 	sts pulse1_hi_pitch_macro_offset, r26
00169a 91b0 2829                 	lds r27, pulse1_hi_pitch_macro_release
00169c 3fbf                      	cpi r27, 0xFF
00169d f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
00169e 91b0 2828                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
0016a0 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0016a1 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
0016a2 93b0 2827                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
0016a4 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
0016a5 91b0 2824                 	lds r27, pulse1_total_hi_pitch_offset
0016a7 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
0016a8 91a0 2824                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
0016aa 0fba                      	add r27, r26
0016ab 93b0 2824                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
0016ad 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0016ae 937f                      	push r23
0016af 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
0016b0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0016b1 0367                      	mulsu r22, r23
0016b2 917f                      	pop r23
0016b3 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0016b4 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0016b6 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0016b8 0da0                      	add r26, r0 //offset the timer values
0016b9 1db1                      	adc r27, r1
0016ba 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0016bc 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0016be 91e0 282a                 	lds ZL, pulse1_duty_macro
0016c0 91f0 282b                 	lds ZH, pulse1_duty_macro+1
0016c2 9630                      	adiw Z, 0
0016c3 f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0016c4 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0016c5 1fff                      	rol ZH
0016c6 91a0 282c                 	lds r26, pulse1_duty_macro_offset
0016c8 0fea                      	add ZL, r26
0016c9 1df2                      	adc ZH, zero
                                 
0016ca 91b0 282e                 	lds r27, pulse1_duty_macro_release
0016cc 17ba                      	cp r27, r26
0016cd f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0016ce 91a0 282d                 	lds r26, pulse1_duty_macro_loop
0016d0 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0016d1 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0016d2 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0016d3 95a3                      	inc r26 //increment the macro offset
0016d4 93a0 282c                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0016d6 91b4                      	lpm r27, Z //load pitch data into r27
0016d7 3fbf                      	cpi r27, 0xFF //check for macro end flag
0016d8 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0016d9 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0016da 93a0 282c                 	sts pulse1_duty_macro_offset, r26
0016dc 91b0 282e                 	lds r27, pulse1_duty_macro_release
0016de 3fbf                      	cpi r27, 0xFF
0016df f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0016e0 91b0 282d                 	lds r27, pulse1_duty_macro_loop //load the loop index
0016e2 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0016e3 f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0016e4 93b0 282c                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0016e6 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0016e7 eae2                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0016e8 e3f1                      	ldi ZH, HIGH(sequences << 1)
0016e9 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0016ea 1df2                      	adc ZH, zero
                                 
0016eb 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0016ec 95b7                      	ror r27
0016ed 95b7                      	ror r27
0016ee 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0016f0 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0016f1 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0016f2 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0016f3 c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0016f4 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0016f5 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0016f6 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0016f7 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0016f8 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0016fa 91e0 2831                 	lds ZL, pulse1_fx_1xx
0016fc 91f0 2832                 	lds ZH, pulse1_fx_1xx+1
0016fe 9630                      	adiw Z, 0
0016ff f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
001700 91a0 2833                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
001702 91b0 2834                 	lds r27, pulse1_fx_1xx_total+1
001704 0fae                      	add r26, ZL //increase the total offset by the rate
001705 1fbf                      	adc r27, ZH
001706 93a0 2833                 	sts pulse1_fx_1xx_total, r26
001708 93b0 2834                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
00170a 91e0 2835                 	lds ZL, pulse1_fx_2xx
00170c 91f0 2836                 	lds ZH, pulse1_fx_2xx+1
00170e 9630                      	adiw Z, 0
00170f f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
001710 91a0 2837                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
001712 91b0 2838                 	lds r27, pulse1_fx_2xx_total+1
001714 0fae                      	add r26, ZL //increase the total offset by the rate
001715 1fbf                      	adc r27, ZH
001716 93a0 2837                 	sts pulse1_fx_2xx_total, r26
001718 93b0 2838                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
00171a 91e0 283d                 	lds ZL, pulse1_fx_3xx_speed
00171c 91f0 283e                 	lds ZH, pulse1_fx_3xx_speed+1
00171e 9630                      	adiw Z, 0
00171f f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
001720 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
001721 91a0 2839                 	lds r26, pulse1_fx_3xx_start
001723 91b0 283a                 	lds r27, pulse1_fx_3xx_start+1
001725 9610                      	adiw r26:r27, 0
001726 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
001727 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
001728 91c0 283b                 	lds r28, pulse1_fx_3xx_target
00172a 91d0 283c                 	lds r29, pulse1_fx_3xx_target+1
                                 
00172c 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
00172d 07bd                      	cpc r27, r29
00172e f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
00172f f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
001730 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
001731 9220 2839                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
001733 9220 283a                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
001735 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
001736 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
001737 0bdb                      	sbc r29, r27
001738 91a0 283f                 	lds r26, pulse1_fx_3xx_total_offset
00173a 91b0 2840                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
00173c 0fae                      	add r26, ZL //add the speed to the total offset
00173d 1fbf                      	adc r27, ZH
00173e 1bca                      	sub r28, r26 //invert the total difference with the total offset
00173f 0bdb                      	sbc r29, r27
001740 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
001741 93a0 283f                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
001743 93b0 2840                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
001745 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
001747 91b0 0a8d                 	lds r27, TCB0_CCMPH
001749 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00174a 0bbd                      	sbc r27, r29
00174b 93a0 0a8c                 	sts TCB0_CCMPL, r26
00174d 93b0 0a8d                 	sts TCB0_CCMPH, r27
00174f c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
001750 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
001751 0bbd                      	sbc r27, r29
001752 91c0 283f                 	lds r28, pulse1_fx_3xx_total_offset
001754 91d0 2840                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
001756 0fce                      	add r28, ZL //add the speed to the total offset
001757 1fdf                      	adc r29, ZH
001758 1bac                      	sub r26, r28 //invert the total difference with the total offset
001759 0bbd                      	sbc r27, r29
00175a f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00175b 93c0 283f                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
00175d 93d0 2840                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
00175f 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
001761 91d0 0a8d                 	lds r29, TCB0_CCMPH
001763 0fca                      	add r28, r26 //offset the current timer period with the total offset
001764 1fdb                      	adc r29, r27
001765 93c0 0a8c                 	sts TCB0_CCMPL, r28
001767 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
001769 91a0 2841                 	lds r26, pulse1_fx_4xy_speed
00176b 15a2                      	cp r26, zero
00176c f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
00176d c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00176e 91b0 2842                 	lds r27, pulse1_fx_4xy_depth
001770 91c0 2843                 	lds r28, pulse1_fx_4xy_phase
001772 0fca                      	add r28, r26 //increase the phase by the speed
001773 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001774 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
001775 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
001776 93c0 2843                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
001778 31c0                      	cpi r28, 16
001779 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
00177a 32c0                      	cpi r28, 32
00177b f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
00177c 33c0                      	cpi r28, 48
00177d f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
00177e c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
00177f 70cf                      	andi r28, 0x0F //mask for values 0-15
001780 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
001781 6fc0                      	ori r28, 0xF0
001782 95c0                      	com r28 //invert values 0-15
001783 c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
001784 70cf                      	andi r28, 0x0F //mask for values 0-15
001785 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
001786 6fc0                      	ori r28, 0xF0
001787 95c0                      	com r28 //invert values 0-15
001788 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
001789 95b2                      	swap r27 //multiply depth by 16
00178a 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00178b eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00178c e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
00178d 0fec                      	add ZL, r28 //offset the table by the depth+phase
00178e 1df2                      	adc ZH, zero
00178f 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
001790 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001791 937f                      	push r23
001792 2f6c                      	mov r22, r28 //store the vibrato value into r22
001793 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001794 9f67                      	mul r22, r23
001795 917f                      	pop r23
001796 916f                      	pop r22
                                 
001797 9416                      	lsr r1 //shift out the fractional bits
001798 9407                      	ror r0
001799 9416                      	lsr r1
00179a 9407                      	ror r0
00179b 9416                      	lsr r1
00179c 9407                      	ror r0
00179d 9416                      	lsr r1
00179e 9407                      	ror r0
                                 	
00179f 91a0 0a8c                 	lds r26, TCB0_CCMPL
0017a1 91b0 0a8d                 	lds r27, TCB0_CCMPH
0017a3 0da0                      	add r26, r0
0017a4 1db1                      	adc r27, r1
0017a5 93a0 0a8c                 	sts TCB0_CCMPL, r26
0017a7 93b0 0a8d                 	sts TCB0_CCMPH, r27
0017a9 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
0017aa 95b2                      	swap r27 //multiply depth by 16
0017ab 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
0017ac eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0017ad e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
0017ae 0fec                      	add ZL, r28 //offset the table by the depth+phase
0017af 1df2                      	adc ZH, zero
0017b0 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0017b1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017b2 937f                      	push r23
0017b3 2f6c                      	mov r22, r28 //store the vibrato value into r22
0017b4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017b5 9f67                      	mul r22, r23
0017b6 917f                      	pop r23
0017b7 916f                      	pop r22
                                 
0017b8 9416                      	lsr r1 //shift out the fractional bits
0017b9 9407                      	ror r0
0017ba 9416                      	lsr r1
0017bb 9407                      	ror r0
0017bc 9416                      	lsr r1
0017bd 9407                      	ror r0
0017be 9416                      	lsr r1
0017bf 9407                      	ror r0
                                 
0017c0 91a0 0a8c                 	lds r26, TCB0_CCMPL
0017c2 91b0 0a8d                 	lds r27, TCB0_CCMPH
0017c4 19a0                      	sub r26, r0
0017c5 09b1                      	sbc r27, r1
0017c6 93a0 0a8c                 	sts TCB0_CCMPL, r26
0017c8 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0017ca 91a0 2844                 	lds r26, pulse1_fx_7xy_speed
0017cc 15a2                      	cp r26, zero
0017cd f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0017ce 91b0 2845                 	lds r27, pulse1_fx_7xy_depth
0017d0 91c0 2846                 	lds r28, pulse1_fx_7xy_phase
0017d2 0fca                      	add r28, r26 //increase the phase by the speed
0017d3 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0017d4 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0017d5 e0c0                      	ldi r28, 0x00
0017d6 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0017d7 93c0 2846                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
0017d9 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0017da ffc4                      	sbrs r28, 4
0017db c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
0017dc c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
0017dd 70cf                      	andi r28, 0x0F //mask for values 0-15
0017de c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
0017df 6fc0                      	ori r28, 0xF0
0017e0 95c0                      	com r28 //invert values 0-15
0017e1 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
0017e2 95b2                      	swap r27 //multiply depth by 16
0017e3 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0017e4 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0017e5 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
0017e6 0fec                      	add ZL, r28 //offset the table by the depth+phase
0017e7 1df2                      	adc ZH, zero
0017e8 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0017e9 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0017ea 93c0 2847                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
0017ec 91b0 2849                 	lds r27, pulse1_fx_Axy
0017ee 15b2                      	cp r27, zero
0017ef f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0017f0 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0017f2 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0017f4 2fda                      	mov r29, r26 //copy fractional volume into r29
0017f5 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0017f6 95e2                      	swap r30
0017f7 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0017f8 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0017f9 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0017fa f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0017fb 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0017fc fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0017fd c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0017fe 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0017ff f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
001800 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
001801 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
001802 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
001803 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
001804 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
001805 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
001807 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
001808 95a2                      	swap r26
001809 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
00180a 2bca                      	or r28, r26 //store the new volume back into pulse1_param
00180b 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
00180d 91e0 284a                 	lds ZL, pulse1_fx_Qxy_target
00180f 91f0 284b                 	lds ZH, pulse1_fx_Qxy_target+1
001811 9630                      	adiw Z, 0
001812 f131                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
001813 91a0 284e                 	lds r26, pulse1_fx_Qxy_total_offset
001815 91b0 284f                 	lds r27, pulse1_fx_Qxy_total_offset+1
001817 91c0 0a8c                 	lds r28, TCB0_CCMPL
001819 91d0 0a8d                 	lds r29, TCB0_CCMPH
00181b 1bca                      	sub r28, r26 //subtract the timer period by the total offset
00181c 0bdb                      	sbc r29, r27
                                 
00181d 17ce                      	cp r28, ZL //compare the new timer period with the target
00181e 07df                      	cpc r29, ZH
00181f f010                      	brlo sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
001820 f009                      	breq sound_driver_channel0_fx_Qxy_routine_end
001821 f468                      	brsh sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
001822 1bec                      	sub ZL, r28 //calculate the difference to the target
001823 0bfd                      	sbc ZH, r29
001824 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
001825 1fbf                      	adc r27, ZH
001826 93a0 284e                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
001828 93b0 284f                 	sts pulse1_fx_Qxy_total_offset+1, r27
00182a 9220 284a                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
00182c 9220 284b                 	sts pulse1_fx_Qxy_target+1, zero
00182e c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
00182f 91c0 284c                 	lds r28, pulse1_fx_Qxy_speed
001831 91d0 284d                 	lds r29, pulse1_fx_Qxy_speed+1
001833 0fac                      	add r26, r28 //increase the total offset by the speed
001834 1fbd                      	adc r27, r29
001835 93a0 284e                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
001837 93b0 284f                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
001839 91e0 2850                 	lds ZL, pulse1_fx_Rxy_target
00183b 91f0 2851                 	lds ZH, pulse1_fx_Rxy_target+1
00183d 9630                      	adiw Z, 0
00183e f131                      	breq sound_driver_channel0_fx_xy_routine //if the effect is not enabled, skip the routine
                                 
00183f 91a0 2854                 	lds r26, pulse1_fx_Rxy_total_offset
001841 91b0 2855                 	lds r27, pulse1_fx_Rxy_total_offset+1
001843 91c0 0a8c                 	lds r28, TCB0_CCMPL
001845 91d0 0a8d                 	lds r29, TCB0_CCMPH
001847 0fca                      	add r28, r26 //add the total offset to the timer period
001848 0fdb                      	add r29, r27
                                 
001849 17ce                      	cp r28, ZL //compare the new timer period with the target
00184a 07df                      	cpc r29, ZH
00184b f010                      	brlo sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
00184c f009                      	breq sound_driver_channel0_fx_Rxy_routine_end
00184d f468                      	brsh sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
00184e 1bec                      	sub ZL, r28 //calculate the difference to the target
00184f 0bfd                      	sbc ZH, r29
001850 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
001851 1fbf                      	adc r27, ZH
001852 93a0 2854                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
001854 93b0 2855                 	sts pulse1_fx_Rxy_total_offset+1, r27
001856 9220 2850                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
001858 9220 2851                 	sts pulse1_fx_Rxy_target+1, zero
00185a c00a                      	rjmp sound_driver_channel0_fx_xy_routine
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
00185b 91c0 2852                 	lds r28, pulse1_fx_Rxy_speed
00185d 91d0 2853                 	lds r29, pulse1_fx_Rxy_speed+1
00185f 0fac                      	add r26, r28 //increase the total offset by the speed
001860 1fbd                      	adc r27, r29
001861 93a0 2854                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
001863 93b0 2855                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 sound_driver_channel0_fx_xy_routine:
                                 
                                 sound_driver_exit:
001865 91df                      	pop r29
001866 91cf                      	pop r28
001867 c9d3                      	rjmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001868 b7bf                      	in r27, CPU_SREG
001869 93bf                      	push r27
00186a 94f8                      	cli
                                 
00186b 0cdd                      	lsl pulse1_sequence //shifts sequence to the left
00186c 1cd2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00186d e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00186e 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001870 91bf                      	pop r27
001871 bfbf                      	out CPU_SREG, r27
001872 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001873 2dbf                      	mov r27, pulse1_sweep
001874 70b7                      	andi r27, 0x07 //mask for period divider bits
001875 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001876 93df                      	push r29
001877 2ddf                      	mov r29, pulse1_sweep
001878 95d2                      	swap r29
001879 70d7                      	andi r29, 0x07 //mask for shift bits
00187a f411                      	brne pulse1_sweep_routine_action_main //shift != 0
00187b 91df                      	pop r29
00187c c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
00187d 91a0 0a8c                 	lds r26, TCB0_CCMPL
00187f 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001881 95b6                      	lsr r27
001882 95a7                      	ror r26
001883 95da                      	dec r29
001884 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001885 fef7                      	sbrs pulse1_sweep, 7 //check the negate flag
001886 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001887 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001888 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001889 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
00188b 0fad                      	add r26, r29
00188c 91d0 0a8d                 	lds r29, TCB0_CCMPH
00188e 1fbd                      	adc r27, r29
                                 
00188f 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001891 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 
                                 	//sts pulse1_timerL, r26
                                 	//sts pulse1_timerH, r27
                                 
                                 /*	//Sweep Test
                                 	mov r29, pulse1_sweep //invert the negate bit
                                 	ldi r27, 0b10000000
                                 	eor r29, r27
                                 	ori r29, 0b01111111
                                 
                                 	lds r27, pulse1_sweep_param //reload the pulse sweep divider params
                                 	swap r27
                                 	ori r27, 0b10000000
                                 	and r27, r29
                                 	mov pulse1_sweep, r27
                                 	sbr channel_flags, 0b10000000*/
                                 	
001893 91df                      	pop r29
001894 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001895 94fa                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001896 ff97                      	sbrs channel_flags, 7 //if the reload flag is set, reload the sweep divider
001897 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001898 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
00189a 94f2                      	swap pulse1_sweep //bring data from high byte to low byte
00189b 779f                      	cbr channel_flags, 0b10000000 //clear reload flag
00189c 9508                      	ret
                                 
                                 pulse1_envelope_routine:
00189d fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
00189e c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
00189f 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
0018a0 f011                      	breq PC+3 //if the divider == 0, check loop flag
0018a1 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
0018a2 9508                      	ret
                                 
0018a3 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
0018a5 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0018a6 ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
0018a7 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
0018a8 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
0018a9 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
0018aa 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
0018ab f409                      	brne PC+2 //if decay != 0, go decrement
0018ac 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
0018ad 951a                      	dec pulse1_volume_decay
0018ae 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
0018af 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
0018b0 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
0018b2 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
0018b3 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0018b4 9508                      	ret
                                 
                                 //CONVERTERS (TABLES)
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0018b5 e7e6                      	ldi ZL, LOW(length << 1)
0018b6 e3f1                      	ldi ZH, HIGH(length << 1)
0018b7 0fed                      	add ZL, r29
0018b8 1df2                      	adc ZH, zero
0018b9 91d4                      	lpm r29, Z
0018ba 9508                      	ret
                                 
0018bb 7f05
0018bc 010a
0018bd 0214
0018be 0328
0018bf 0450
0018c0 051e
0018c1 0607
0018c2 070d
0018c3 0806
0018c4 090c
0018c5 0a18
0018c6 0b30
0018c7 0c60
0018c8 0d24
0018c9 0e08
0018ca 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0018cb eae2                      	ldi ZL, LOW(sequences << 1)
0018cc e3f1                      	ldi ZH, HIGH(sequences << 1)
0018cd 0fed                      	add ZL, r29
0018ce 1df2                      	adc ZH, zero
0018cf 91d4                      	lpm r29, Z
0018d0 9508                      	ret
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
0018d1 0301
0018d2 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 fx:
0018d3 127e
0018d4 1283
0018d5 129f
0018d6 12bb
0018d7 12de                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
0018d8 12e9
0018d9 12f6
0018da 12f9
0018db 12fa
0018dc 12fb                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
0018dd 12fc
0018de 1304
0018df 1307
0018e0 1308
0018e1 130f                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
0018e2 1317
0018e3 1318
0018e4 1319
0018e5 131c
0018e6 1360                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
0018e7 13a3
0018e8 13a4
0018e9 13b8
0018ea 13b9
0018eb 13ba                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
0018ec 13bb                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0018ed 0000
0018ee 0000
0018ef 0000
0018f0 0000
0018f1 0000
0018f2 0000
0018f3 0000
0018f4 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0018f5 0100
0018f6 0101
0018f7 0101
0018f8 0101
0018f9 0101
0018fa 0101
0018fb 0101
0018fc 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0018fd 0100
0018fe 0101
0018ff 0101
001900 0101
001901 0101
001902 0101
001903 0101
001904 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
001905 0100
001906 0101
001907 0101
001908 0101
001909 0101
00190a 0202
00190b 0202
00190c 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
00190d 0100
00190e 0101
00190f 0101
001910 0101
001911 0202
001912 0202
001913 0303
001914 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
001915 0100
001916 0101
001917 0101
001918 0202
001919 0302
00191a 0303
00191b 0404
00191c 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
00191d 0100
00191e 0101
00191f 0201
001920 0202
001921 0303
001922 0404
001923 0504
001924 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
001925 0100
001926 0101
001927 0201
001928 0302
001929 0403
00192a 0504
00192b 0605
00192c 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
00192d 0100
00192e 0101
00192f 0202
001930 0303
001931 0404
001932 0505
001933 0606
001934 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
001935 0100
001936 0101
001937 0302
001938 0403
001939 0504
00193a 0606
00193b 0707
00193c 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
00193d 0100
00193e 0201
00193f 0302
001940 0404
001941 0605
001942 0706
001943 0808
001944 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
001945 0100
001946 0201
001947 0302
001948 0504
001949 0605
00194a 0807
00194b 0908
00194c 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
00194d 0100
00194e 0201
00194f 0403
001950 0504
001951 0706
001952 0808
001953 0a09
001954 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
001955 0100
001956 0201
001957 0403
001958 0605
001959 0706
00195a 0908
00195b 0b0a
00195c 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
00195d 0100
00195e 0201
00195f 0403
001960 0605
001961 0807
001962 0a09
001963 0c0b
001964 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
001965 0100
001966 0302
001967 0504
001968 0706
001969 0908
00196a 0b0a
00196b 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  :  61 r0 :  43 r1 :  45 r2 : 168 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   6 r14:   4 r15:  13 r16:   7 r17:   6 r18:   0 r19:   0 r20:   0 
r21:   0 r22:  41 r23:  40 r24:   0 r25:  15 r26: 241 r27: 352 r28: 130 
r29:  98 r30:  92 r31:  87 
Registers used: 18 out of 35 (51.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  41 add   :  56 adiw  :  26 and   :   0 
andi  :  32 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   4 break :   0 breq  :  41 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  23 brlt  :   0 brmi  :   0 
brne  :  32 brpl  :   0 brsh  :   6 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   2 
clc   :   0 clh   :   0 cli   :   4 cln   :   0 clr   :   1 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   5 cp    :  18 cpc   :   3 
cpi   :  48 cpse  :   4 dec   :   6 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :   4 inc   :  12 
jmp   :   6 ld    :   0 ldd   :   0 ldi   :  85 lds   : 179 lpm   :  68 
lsl   :  19 lsr   :  39 mov   :  34 movw  :   0 mul   :   8 muls  :   0 
mulsu :   2 neg   :   0 nop   :   0 or    :   6 ori   :   5 out   :   6 
pop   :  31 push  :  31 rcall :  16 ret   :  13 reti  :   3 rjmp  : 126 
rol   :  13 ror   :  45 sbc   :  12 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   7 sbrc  :   8 sbrs  :   6 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   : 329 sub   :  14 subi  :  13 swap  :  16 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0032da   3996   8994  12990   49152  26.4%
[.dseg] 0x002800 0x00285a      0     90     90    6144   1.5%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 100 warnings
