
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Tue Jan 12 22:48:40 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4002 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           song_frames: .byte 2
00280a                           song_frame_offset: .byte 2
00280c                           song_speed: .byte 1
                                 
                                 
00280d                           pulse1_pattern: .byte 2
00280f                           pulse1_pattern_delay: .byte 2
002811                           pulse1_pattern_offset: .byte 2
                                 
002813                           pulse1_volume_macro: .byte 2
002815                           pulse1_volume_macro_offset: .byte 1
002816                           pulse1_volume_macro_loop: .byte 1
002817                           pulse1_volume_macro_release: .byte 1
                                 
002818                           pulse1_arpeggio_macro: .byte 2
00281a                           pulse1_arpeggio_macro_offset: .byte 1
00281b                           pulse1_arpeggio_macro_loop: .byte 1
00281c                           pulse1_arpeggio_macro_release: .byte 1
00281d                           pulse1_arpeggio_macro_mode: .byte 1
                                 
00281e                           pulse1_total_pitch_offset: .byte 1 //used to reference the overall change in pitch for the pitch macro
00281f                           pulse1_pitch_macro: .byte 2
002821                           pulse1_pitch_macro_offset: .byte 1
002822                           pulse1_pitch_macro_loop: .byte 1
002823                           pulse1_pitch_macro_release: .byte 1
                                 
002824                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
002825                           pulse1_hi_pitch_macro: .byte 2
002827                           pulse1_hi_pitch_macro_offset: .byte 1
002828                           pulse1_hi_pitch_macro_loop: .byte 1
002829                           pulse1_hi_pitch_macro_release: .byte 1
                                 
00282a                           pulse1_duty_macro: .byte 2
00282c                           pulse1_duty_macro_offset: .byte 1
00282d                           pulse1_duty_macro_loop: .byte 1
00282e                           pulse1_duty_macro_release: .byte 1
                                 
00282f                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002831                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
002833                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
002835                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
002837                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002839                           pulse1_fx_3xx_start: .byte 2 //the starting note period
00283b                           pulse1_fx_3xx_target: .byte 2 //target note period
00283d                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
00283f                           pulse1_fx_3xx_total_offset: .byte 2
002841                           pulse1_fx_4xy_speed: .byte 1
002842                           pulse1_fx_4xy_depth: .byte 1
002843                           pulse1_fx_4xy_phase: .byte 1
002844                           pulse1_fx_7xy_speed: .byte 1
002845                           pulse1_fx_7xy_depth: .byte 1
002846                           pulse1_fx_7xy_phase: .byte 1
002847                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
002848                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002849                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
00284a                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
00284b                           pulse1_fx_Pxx: .byte 1 //refers to the fine pitch offset set by the Pxx effect
00284c                           pulse1_fx_Qxy_target: .byte 2 //target note period
00284e                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002850                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002852                           pulse1_fx_Rxy_target: .byte 2 //target note period
002854                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002856                           pulse1_fx_Rxy_total_offset: .byte 2
                                 
002858                           pulse2_pattern_delay: .byte 1
002859                           triangle_pattern_delay: .byte 1
00285a                           noise_pattern_delay: .byte 1
00285b                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def channel_flags = r25 //[pulse1.pulse2] RSlc.0000 = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r13
                                 .def pulse1_length_counter = r14
                                 .def pulse1_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 
                                 reset:
000000 940c 11cd                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 131a                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 1300                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 130a                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 1300                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1954                 	jmp pulse1_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(65): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(66): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(67): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(68): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(70): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(71): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(72): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(73): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(74): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(75): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(76): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(77): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(78): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(79): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(83): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(85): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(86): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(91): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(94): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(100): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(101): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(106): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(108): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(117): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(122): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(125): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(127): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(130): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(133): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(135): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(138): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(140): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(144): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(145): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(147): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(149): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(151): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(155): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(156): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(158): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(159): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(163): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(164): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(275): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(276): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(277): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(279): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(284): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(285): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(286): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(287): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(288): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(289): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(290): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(291): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(292): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(294): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(298): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(299): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(300): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(301): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(303): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(304): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(306): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(310): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(314): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(315): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(316): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(317): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(319): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(320): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(321): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(324): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(325): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(328): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(329): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(331): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(338): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(339): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(122): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
0011cd edb8                      	ldi r27, CPU_CCP_IOREG_gc //protected write
0011ce 93b0 0034                 	sts CPU_CCP, r27
0011d0 e0b0                      	ldi r27, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
0011d1 93b0 0061                 	sts CLKCTRL_MCLKCTRLB, r27
                                 
                                 /*	//TEST FOR C4, 1 SECOND, 50% DD
                                 	ldi r26, 0x97
                                 	ldi r27, 0x12
                                 	ldi r26, 0x15
                                 	ldi r27, 0x09
                                 	sts pulse1_timerL, r26
                                 	sts pulse1_timerH, r27
                                 	ldi r27, 0b10111111
                                 	sts pulse1_param, r27
                                 	ldi r27, 0x01
                                 	sts pulse1_length, r27
                                 	//TEST FOR SWEEP UP
                                 	ldi r27, 0b11111111
                                 	sts pulse1_sweep_param, r27*/
                                 
                                 	//ZERO
0011d3 2422                      	clr zero
                                 
                                 	//MEMORY
0011d4 e3b0                      	ldi r27, 0b00110000
0011d5 93b0 2800                 	sts pulse1_param, r27
0011d7 e8b0                      	ldi r27, 0b10000000
0011d8 93b0 2801                 	sts pulse1_sweep_param, r27
0011da efbf                      	ldi r27, 0xFF
0011db 93b0 2802                 	sts pulse1_timerL, r27
0011dd 93b0 2803                 	sts pulse1_timerH, r27
0011df 93b0 2804                 	sts pulse1_length, r27
                                 
0011e1 e0b0                      	ldi r27, 0x00
0011e2 93b0 280a                 	sts song_frame_offset, r27
0011e4 93b0 280b                 	sts song_frame_offset+1, r27
0011e6 eee2                      	ldi ZL, LOW(song0_frames << 1)
0011e7 e0f1                      	ldi ZH, HIGH(song0_frames << 1)
0011e8 93e0 2808                 	sts song_frames, ZL
0011ea 93f0 2809                 	sts song_frames+1, ZH
0011ec 9220 280c                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0 TEST
0011ee e0b0                      	ldi r27, 0x00
0011ef 0feb                      	add ZL, r27
0011f0 1df2                      	adc ZH, zero
0011f1 91a5                      	lpm r26, Z+
0011f2 91b4                      	lpm r27, Z
0011f3 0faa                      	lsl r26
0011f4 1fbb                      	rol r27
0011f5 93a0 280d                 	sts pulse1_pattern, r26
0011f7 93b0 280e                 	sts pulse1_pattern+1, r27
0011f9 e0b0                      	ldi r27, 0x00
0011fa 9220 280f                 	sts pulse1_pattern_delay, zero
0011fc 9220 2810                 	sts pulse1_pattern_delay+1, zero
0011fe 9220 2811                 	sts pulse1_pattern_offset, zero
001200 9220 2812                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//channel 0 instrument macros
001202 efbf                      	ldi r27, 0xFF
001203 9220 2815                 	sts pulse1_volume_macro_offset, zero
001205 93b0 2816                 	sts pulse1_volume_macro_loop, r27
001207 93b0 2817                 	sts pulse1_volume_macro_release, r27
001209 9220 281a                 	sts pulse1_arpeggio_macro_offset, zero
00120b 93b0 281b                 	sts pulse1_arpeggio_macro_loop, r27
00120d 93b0 281c                 	sts pulse1_arpeggio_macro_release, r27
00120f 93b0 281d                 	sts pulse1_arpeggio_macro_mode, r27
001211 9220 2821                 	sts pulse1_pitch_macro_offset, zero
001213 93b0 2822                 	sts pulse1_pitch_macro_loop, r27
001215 93b0 2823                 	sts pulse1_pitch_macro_release, r27
001217 9220 2827                 	sts pulse1_hi_pitch_macro_offset, zero
001219 93b0 2828                 	sts pulse1_hi_pitch_macro_loop, r27
00121b 93b0 2829                 	sts pulse1_hi_pitch_macro_release, r27
00121d 9220 282c                 	sts pulse1_duty_macro_offset, zero
00121f 93b0 282d                 	sts pulse1_duty_macro_loop, r27
001221 93b0 282e                 	sts pulse1_duty_macro_release, r27
                                 
001223 9220 2813                 	sts pulse1_volume_macro, zero
001225 9220 2814                 	sts pulse1_volume_macro+1, zero
001227 9220 2818                 	sts pulse1_arpeggio_macro, zero
001229 9220 2819                 	sts pulse1_arpeggio_macro+1, zero
00122b 9220 281e                 	sts pulse1_total_pitch_offset, zero
00122d 9220 281f                 	sts pulse1_pitch_macro, zero
00122f 9220 2820                 	sts pulse1_pitch_macro+1, zero
001231 9220 2824                 	sts pulse1_total_hi_pitch_offset, zero
001233 9220 2825                 	sts pulse1_hi_pitch_macro, zero
001235 9220 2826                 	sts pulse1_hi_pitch_macro+1, zero
001237 9220 282a                 	sts pulse1_duty_macro, zero
001239 9220 282b                 	sts pulse1_duty_macro+1, zero
                                 
00123b 9220 2858                 	sts pulse2_pattern_delay, zero
00123d 9220 2859                 	sts triangle_pattern_delay, zero
00123f 9220 285a                 	sts noise_pattern_delay, zero
001241 9220 285b                 	sts dcpm_pattern_delay, zero
                                 
                                 	//PINS
001243 efbf                      	ldi r27, 0xFF //set all pins in VPORTD to output
001244 b9b0                      	out VPORTA_DIR, r27
                                 
                                 	//ENVELOPE
001245 e00f                      	ldi pulse1_volume_divider, 0x0F
001246 9110 2800                 	lds pulse1_volume_decay, pulse1_param
001248 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
001249 9190 2800                 	lds channel_flags, pulse1_param
00124b 7390                      	andi channel_flags, 0b00110000
00124c 6490                      	sbr channel_flags, 0b01000000 //set start flag
00124d 9220 2806                 	sts pulse1_output_volume, zero
00124f 93b0 2805                 	sts pulse1_fractional_volume, r27 //initialize fractional volume to max value
                                 	
                                 	//LENGTH
001251 91d0 2804                 	lds r29, pulse1_length
001253 d74d                      	rcall length_converter
001254 2eed                      	mov pulse1_length_counter, r29
                                 
                                 	//SEQUENCE
001255 91d0 2800                 	lds r29, pulse1_param //load param for sequence table
001257 0fdd                      	lsl r29 //shift duty cycle bits to LSB
001258 1fdd                      	rol r29
001259 1fdd                      	rol r29
00125a 70d3                      	andi r29, 0b00000011 //mask duty cycle bits
00125b d75b                      	rcall duty_cycle_sequences
00125c 2edd                      	mov pulse1_sequence, r29
                                 
                                 	//SWEEP
00125d 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param
00125f 94f2                      	swap pulse1_sweep //swap data from high byte and low byte
001260 6890                      	sbr channel_flags, 0b10000000 //set reload flag
                                 
                                 	//FX
001261 9220 282f                 	sts pulse1_fx_0xy_sequence, zero
001263 9220 2830                 	sts pulse1_fx_0xy_sequence+1, zero
001265 9220 2831                 	sts pulse1_fx_1xx, zero
001267 9220 2832                 	sts pulse1_fx_1xx+1, zero
001269 9220 2833                 	sts pulse1_fx_1xx_total, zero
00126b 9220 2834                 	sts pulse1_fx_1xx_total+1, zero
00126d 9220 2835                 	sts pulse1_fx_2xx, zero
00126f 9220 2836                 	sts pulse1_fx_2xx+1, zero
001271 9220 2837                 	sts pulse1_fx_2xx_total, zero
001273 9220 2838                 	sts pulse1_fx_2xx_total+1, zero
001275 9220 2839                 	sts pulse1_fx_3xx_start, zero
001277 9220 283a                 	sts pulse1_fx_3xx_start+1, zero
001279 9220 283b                 	sts pulse1_fx_3xx_target, zero
00127b 9220 283c                 	sts pulse1_fx_3xx_target+1, zero
00127d 9220 283d                 	sts pulse1_fx_3xx_speed, zero
00127f 9220 283e                 	sts pulse1_fx_3xx_speed+1, zero
001281 9220 283f                 	sts pulse1_fx_3xx_total_offset, zero
001283 9220 2840                 	sts pulse1_fx_3xx_total_offset+1, zero
001285 9220 2841                 	sts pulse1_fx_4xy_speed, zero
001287 9220 2842                 	sts pulse1_fx_4xy_depth, zero
001289 9220 2843                 	sts pulse1_fx_4xy_phase, zero
00128b 9220 2844                 	sts pulse1_fx_7xy_speed, zero
00128d 9220 2845                 	sts pulse1_fx_7xy_depth, zero
00128f 9220 2846                 	sts pulse1_fx_7xy_phase, zero
001291 9220 2847                 	sts pulse1_fx_7xy_value, zero
001293 9220 2848                 	sts pulse1_fx_Axy, zero
001295 9220 2849                 	sts pulse1_fx_Gxx_pre, zero
001297 9220 284a                 	sts pulse1_fx_Gxx_post, zero
001299 9220 284b                 	sts pulse1_fx_Pxx, zero
00129b 9220 284c                 	sts pulse1_fx_Qxy_target, zero
00129d 9220 284d                 	sts pulse1_fx_Qxy_target+1, zero
00129f 9220 284e                 	sts pulse1_fx_Qxy_speed, zero
0012a1 9220 284f                 	sts pulse1_fx_Qxy_speed+1, zero
0012a3 9220 2850                 	sts pulse1_fx_Qxy_total_offset, zero
0012a5 9220 2851                 	sts pulse1_fx_Qxy_total_offset+1, zero
0012a7 9220 2852                 	sts pulse1_fx_Rxy_target, zero
0012a9 9220 2853                 	sts pulse1_fx_Rxy_target+1, zero
0012ab 9220 2854                 	sts pulse1_fx_Rxy_speed, zero
0012ad 9220 2855                 	sts pulse1_fx_Rxy_speed+1, zero
0012af 9220 2856                 	sts pulse1_fx_Rxy_total_offset, zero
0012b1 9220 2857                 	sts pulse1_fx_Rxy_total_offset+1, zero
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
0012b3 e7b0                      	ldi r27, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
0012b4 93b0 0a01                 	sts TCA0_SINGLE_CTRLB, r27
0012b6 e7b1                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
0012b7 93b0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r27
0012b9 e1b5                      	ldi r27, 0x15 //set the period for CMP0
0012ba 93b0 0a28                 	sts TCA0_SINGLE_CMP0, r27
0012bc e0b5                      	ldi r27, 0x05
0012bd 93b0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r27
0012bf e2bb                      	ldi r27, 0x2B //set the period for CMP1
0012c0 93b0 0a2a                 	sts TCA0_SINGLE_CMP1, r27
0012c2 e0ba                      	ldi r27, 0x0A
0012c3 93b0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r27
0012c5 e4b1                      	ldi r27, 0x41 //set the period for CMP2
0012c6 93b0 0a2c                 	sts TCA0_SINGLE_CMP2, r27
0012c8 e0bf                      	ldi r27, 0x0F
0012c9 93b0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r27
0012cb e5b7                      	ldi r27, 0x57 //set the period for OVF
0012cc 93b0 0a26                 	sts TCA0_SINGLE_PER, r27
0012ce e1b4                      	ldi r27, 0x14
0012cf 93b0 0a27                 	sts TCA0_SINGLE_PER + 1, r27
0012d1 e0bb                      	ldi r27, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
0012d2 93b0 0a00                 	sts TCA0_SINGLE_CTRLA, r27
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
0012d4 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
0012d5 93b0 0a81                 	sts TCB0_CTRLB, r27
0012d7 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
0012d8 93b0 0a85                 	sts TCB0_INTCTRL, r27
0012da 91b0 2802                 	lds r27, pulse1_timerL //load the LOW bits for timer
0012dc 93b0 0a8c                 	sts TCB0_CCMPL, r27
0012de 91b0 2803                 	lds r27, pulse1_timerH //load the HIGH bits for timer
0012e0 93b0 0a8d                 	sts TCB0_CCMPH, r27
0012e2 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
0012e3 93b0 0a80                 	sts TCB0_CTRLA, r27
0012e5 9478                      	sei //global interrupt enable
                                 
                                 pulse1:
0012e6 fed0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
0012e7 c012                      	rjmp pulse1_off
                                 
0012e8 14e2                      	cp pulse1_length_counter, zero //if length is zero, return
0012e9 f081                      	breq pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
                                 pulse1_check_timer_08:
0012ea 91c0 0a8c                 	lds r28, TCB0_CCMPL
0012ec 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 pulse1_check_timer_08_HIGH:
0012ee 30d1                      	cpi r29, 0x01 //check timer HIGH period
0012ef f008                      	brlo pulse1_check_timer_08_LOW //if the timer HIGH period is $00, check the LOW period
0012f0 c002                      	rjmp pulse1_check_timer_7FF_HIGH //if the timer HIGH period is > $01, check > $07FF condition
                                 pulse1_check_timer_08_LOW:
0012f1 35c9                      	cpi r28, 0x59 //check timer LOW period
0012f2 f038                      	brlo pulse1_off //if the HIGH period == $00 && LOW period <= $59, pulse off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $5965
                                 pulse1_check_timer_7FF_HIGH:
0012f3 35d9                      	cpi r29, 0x59 //check timer HIGH period
0012f4 f038                      	brlo pulse1_on //if the HIGH period is < $59, then all conditions have passed and pulse is not muted
0012f5 f009                      	breq pulse1_check_timer_7FF_LOW //if the HIGH period is == $59, we go check if the LOW period is < $65
0012f6 c003                      	rjmp pulse1_off //pulse off if HIGH period is > $59
                                 pulse1_check_timer_7FF_LOW:
0012f7 36c5                      	cpi r28, 0x65 //check timer LOW period
0012f8 f408                      	brsh pulse1_off //if the HIGH period == $59 && LOW period >= $65, pulse off
0012f9 c002                      	rjmp pulse1_on //if the HIGH period == $59 && LOW period < $65, pulse on
                                 
                                 pulse1_off:
0012fa b821                      	out VPORTA_OUT, zero
0012fb cfea                      	rjmp pulse1
                                 
                                 pulse1_on:
0012fc 91d0 2806                 	lds r29, pulse1_output_volume
                                 /*	cpse r29, zero
                                 	rjmp pulse1_off //if VVVV bits are 0, then there is no volume (channel off)*/
                                 
0012fe b9d1                      	out VPORTA_OUT, r29
0012ff cfe6                      	rjmp pulse1
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
001300 b7bf                      	in r27, CPU_SREG
001301 93bf                      	push r27
001302 94f8                      	cli
                                 
                                 	//ENVELOPE
001303 d685                      	rcall pulse1_envelope_routine
                                 
001304 e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
001305 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001307 91bf                      	pop r27
001308 bfbf                      	out CPU_SREG, r27
001309 9518                      	reti
                                 
                                 sequence_1_3:
00130a b7bf                      	in r27, CPU_SREG
00130b 93bf                      	push r27
00130c 94f8                      	cli
                                 
                                 	//ENVELOPE
00130d d67b                      	rcall pulse1_envelope_routine
                                 
                                 	//SWEEP
00130e fcf3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
00130f d64f                      	rcall pulse1_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
001310 fd95                      	sbrc channel_flags, 5 //check if the length counter halt bit is cleared
001311 c002                      	rjmp sequence_1_3_exit
001312 10e2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
001313 94ea                      	dec pulse1_length_counter
                                 
                                 sequence_1_3_exit:
001314 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
001315 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001317 91bf                      	pop r27
001318 bfbf                      	out CPU_SREG, r27
001319 9518                      	reti
                                 
                                 sound_driver:
00131a b7bf                      	in r27, CPU_SREG
00131b 93bf                      	push r27
00131c 94f8                      	cli
00131d 93cf                      	push r28
00131e 93df                      	push r29
                                 
                                 	//SOUND DRIVER
00131f 91a0 280f                 	lds r26, pulse1_pattern_delay
001321 91b0 2810                 	lds r27, pulse1_pattern_delay+1
001323 9610                      	adiw r27:r26, 0
001324 f009                      	breq sound_driver_channel0 //if the pattern delay is 0, proceed with sound driver procedures
001325 c2dd                      	rjmp sound_driver_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 
                                 
                                 sound_driver_channel0:
001326 91e0 280d                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001328 91f0 280e                 	lds ZH, pulse1_pattern+1
00132a 91a0 2811                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
00132c 91b0 2812                 	lds r27, pulse1_pattern_offset+1
00132e 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
00132f 1ffb                      	adc ZH, r27
001330 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
001331 35b7                      	cpi r27, 0x57
001332 f408                      	brsh sound_driver_channel0_check_if_volume
001333 c15c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001334 36b7                      	cpi r27, 0x67
001335 f408                      	brsh sound_driver_channel0_check_if_delay
001336 c194                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001337 3eb3                      	cpi r27, 0xE3
001338 f408                      	brsh sound_driver_channel0_check_if_instrument
001339 c19b                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
00133a f409                      	brne sound_driver_channel0_check_if_release
00133b c19e                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
00133c 3eb4                      	cpi r27, 0xE4
00133d f409                      	brne sound_driver_channel0_check_if_end
00133e c245                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
00133f 3fbf                      	cpi r27, 0xFF
001340 f409                      	brne sound_driver_channel0_check_if_fx
001341 c267                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001342 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001343 91a4                      	lpm r26, Z //load the fx data into r26
001344 d28a                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001345 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001346 e7ee                      	ldi ZL, LOW(fx << 1) //load in note table
001347 e3f3                      	ldi ZH, HIGH(fx << 1)
001348 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001349 0feb                      	add ZL, r27 //add offset
00134a 1df2                      	adc ZH, zero
00134b 91c5                      	lpm r28, Z+ //load address bytes
00134c 91d4                      	lpm r29, Z
00134d 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00134e 2ffd                      	mov ZH, r29
00134f 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001350 93a0 282f                 	sts pulse1_fx_0xy_sequence, r26
001352 9220 2830                 	sts pulse1_fx_0xy_sequence+1, zero
001354 cfd1                      	rjmp sound_driver_channel0
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
001355 9220 2835                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001357 9220 2836                 	sts pulse1_fx_2xx+1, zero
001359 9220 282f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00135b 9220 2830                 	sts pulse1_fx_0xy_sequence+1, zero
00135d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00135e 937f                      	push r23
00135f 2f6a                      	mov r22, r26 //store the rate into r22
001360 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001361 9f67                      	mul r22, r23
001362 917f                      	pop r23
001363 916f                      	pop r22
                                 
001364 9416                      	lsr r1 //shift out the fractional bits
001365 9407                      	ror r0
001366 9416                      	lsr r1
001367 9407                      	ror r0
001368 9416                      	lsr r1
001369 9407                      	ror r0
00136a 9416                      	lsr r1
00136b 9407                      	ror r0
00136c 9200 2831                 	sts pulse1_fx_1xx, r0
00136e 9210 2832                 	sts pulse1_fx_1xx+1, r1
001370 cfb5                      	rjmp sound_driver_channel0
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001371 9220 2831                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001373 9220 2832                 	sts pulse1_fx_1xx+1, zero
001375 9220 282f                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001377 9220 2830                 	sts pulse1_fx_0xy_sequence+1, zero
001379 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00137a 937f                      	push r23
00137b 2f6a                      	mov r22, r26 //store the rate into r22
00137c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00137d 9f67                      	mul r22, r23
00137e 917f                      	pop r23
00137f 916f                      	pop r22
                                 
001380 9416                      	lsr r1 //shift out the fractional bits
001381 9407                      	ror r0
001382 9416                      	lsr r1
001383 9407                      	ror r0
001384 9416                      	lsr r1
001385 9407                      	ror r0
001386 9416                      	lsr r1
001387 9407                      	ror r0
001388 9200 2835                 	sts pulse1_fx_2xx, r0
00138a 9210 2836                 	sts pulse1_fx_2xx+1, r1
00138c cf99                      	rjmp sound_driver_channel0
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00138d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00138e 937f                      	push r23
00138f 2f6a                      	mov r22, r26 //store the rate into r22
001390 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001391 9f67                      	mul r22, r23
001392 917f                      	pop r23
001393 916f                      	pop r22
                                 
001394 9416                      	lsr r1 //shift out the fractional bits
001395 9407                      	ror r0
001396 9416                      	lsr r1
001397 9407                      	ror r0
001398 9416                      	lsr r1
001399 9407                      	ror r0
00139a 9416                      	lsr r1
00139b 9407                      	ror r0
00139c 9200 283d                 	sts pulse1_fx_3xx_speed, r0
00139e 9210 283e                 	sts pulse1_fx_3xx_speed+1, r1
                                 
0013a0 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
0013a1 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
0013a2 cf83                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
0013a3 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0013a5 91b0 0a8d                 	lds r27, TCB0_CCMPH
0013a7 93a0 2839                 	sts pulse1_fx_3xx_start, r26
0013a9 93b0 283a                 	sts pulse1_fx_3xx_start+1, r27
                                 
0013ab 9220 283f                 	sts pulse1_fx_3xx_total_offset, zero
0013ad 9220 2840                 	sts pulse1_fx_3xx_total_offset+1, zero
0013af cf76                      	rjmp sound_driver_channel0
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
0013b0 2fba                      	mov r27, r26
0013b1 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0013b2 95a2                      	swap r26
0013b3 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0013b4 93a0 2841                 	sts pulse1_fx_4xy_speed, r26
0013b6 93b0 2842                 	sts pulse1_fx_4xy_depth, r27
0013b8 9220 2843                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
0013ba cf6b                      	rjmp sound_driver_channel0
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
0013bb 2fba                      	mov r27, r26
0013bc 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
0013bd 95a2                      	swap r26
0013be 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0013bf 93a0 2844                 	sts pulse1_fx_7xy_speed, r26
0013c1 93b0 2845                 	sts pulse1_fx_7xy_depth, r27
0013c3 9220 2846                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0013c5 9220 2847                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0013c7 cf5e                      	rjmp sound_driver_channel0
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0013c8 93a0 2848                 	sts pulse1_fx_Axy, r26
0013ca cf5b                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Bxx: //pattern jump
0013cb cf5a                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Cxx: //halt
0013cc cf59                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Dxx: //frame skip
0013cd cf58                      	rjmp sound_driver_channel0
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0013ce 91b0 2800                 	lds r27, pulse1_param
0013d0 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0013d1 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0013d2 93b0 2800                 	sts pulse1_param, r27
0013d4 6096                      	sbr channel_flags, 6
0013d5 cf50                      	rjmp sound_driver_channel0
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
0013d6 93a0 280c                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0013d8 cf4d                      	rjmp sound_driver_channel0
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0013d9 93a0 2849                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0013db cf4a                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0013dc 95a2                      	swap r26
0013dd 68a8                      	ori r26, 0b10001000 //enable negate and enable sweep flag
0013de 2efa                      	mov pulse1_sweep, r26
0013df 92f0 2801                 	sts pulse1_sweep_param, pulse1_sweep
0013e1 6097                      	sbr channel_flags, 7 //set reload flag
0013e2 cf43                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0013e3 95a2                      	swap r26
0013e4 77af                      	andi r26, 0b01111111 //disable negate flag
0013e5 60a8                      	ori r26, 0b00001000 //enable sweep flag
0013e6 2efa                      	mov pulse1_sweep, r26
0013e7 92f0 2801                 	sts pulse1_sweep_param, pulse1_sweep
0013e9 6097                      	sbr channel_flags, 7 //set reload flag
0013ea cf3b                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0013eb cf3a                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0013ec cf39                      	rjmp sound_driver_channel0
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0013ed 93a0 284b                 	sts pulse1_fx_Pxx, r26
0013ef cf36                      	rjmp sound_driver_channel0
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
0013f0 91e0 2818                 	lds ZL, pulse1_arpeggio_macro
0013f2 91f0 2819                 	lds ZH, pulse1_arpeggio_macro+1
0013f4 9630                      	adiw Z, 0
0013f5 f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
0013f6 cf2f                      	rjmp sound_driver_channel0 //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
0013f7 91e0 281f                 	lds ZL, pulse1_pitch_macro
0013f9 91f0 2820                 	lds ZH, pulse1_pitch_macro+1
0013fb 9630                      	adiw Z, 0
0013fc f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
0013fd cf28                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
0013fe 91e0 2825                 	lds ZL, pulse1_hi_pitch_macro
001400 91f0 2826                 	lds ZH, pulse1_hi_pitch_macro+1
001402 9630                      	adiw Z, 0
001403 f009                      	breq sound_driver_channel0_fx_Qxy_process
001404 cf21                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
001405 2fba                      	mov r27, r26 //copy fx parameters into r27
001406 70bf                      	andi r27, 0x0F //mask note index offset
001407 91c0 2807                 	lds r28, pulse1_note //load current note index
001409 0fbc                      	add r27, r28
00140a 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
00140b f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
00140c e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
00140d e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00140e e0f0                      	ldi ZH, HIGH(note_table << 1)
00140f 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001410 0feb                      	add ZL, r27 //add offset
001411 1df2                      	adc ZH, zero
001412 91c5                      	lpm r28, Z+ //load bytes
001413 91d4                      	lpm r29, Z
001414 93c0 284c                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001416 93d0 284d                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
001418 95a2                      	swap r26
001419 70af                      	andi r26, 0x0F //mask effect speed
00141a 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00141b 95a3                      	inc r26 //increment the speed by 1
                                 
00141c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00141d 937f                      	push r23
00141e 2f6a                      	mov r22, r26 //store the speed data into r27
00141f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001420 9f67                      	mul r22, r23
001421 917f                      	pop r23
001422 916f                      	pop r22
                                 
001423 9416                      	lsr r1 //shift out the fractional bits
001424 9407                      	ror r0
001425 9416                      	lsr r1
001426 9407                      	ror r0
001427 9416                      	lsr r1
001428 9407                      	ror r0
001429 9416                      	lsr r1
00142a 9407                      	ror r0
                                 
00142b 9200 284e                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
00142d 9210 284f                 	sts pulse1_fx_Qxy_speed+1, r1
00142f 9220 2850                 	sts pulse1_fx_Qxy_total_offset, zero
001431 9220 2851                 	sts pulse1_fx_Qxy_total_offset+1, zero
001433 cef2                      	rjmp sound_driver_channel0
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
001434 91e0 2818                 	lds ZL, pulse1_arpeggio_macro
001436 91f0 2819                 	lds ZH, pulse1_arpeggio_macro+1
001438 9630                      	adiw Z, 0
001439 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
00143a ceeb                      	rjmp sound_driver_channel0 //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
00143b 91e0 281f                 	lds ZL, pulse1_pitch_macro
00143d 91f0 2820                 	lds ZH, pulse1_pitch_macro+1
00143f 9630                      	adiw Z, 0
001440 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001441 cee4                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001442 91e0 2825                 	lds ZL, pulse1_hi_pitch_macro
001444 91f0 2826                 	lds ZH, pulse1_hi_pitch_macro+1
001446 9630                      	adiw Z, 0
001447 f009                      	breq sound_driver_channel0_fx_Rxy_process
001448 cedd                      	rjmp sound_driver_channel0 //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001449 2fba                      	mov r27, r26 //copy fx parameters into r27
00144a 70bf                      	andi r27, 0x0F //mask note index offset
00144b 91c0 2807                 	lds r28, pulse1_note //load current note index
00144d 1bcb                      	sub r28, r27
00144e f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
00144f e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001450 e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001451 e0f0                      	ldi ZH, HIGH(note_table << 1)
001452 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001453 0fec                      	add ZL, r28 //add offset
001454 1df2                      	adc ZH, zero
001455 91c5                      	lpm r28, Z+ //load bytes
001456 91d4                      	lpm r29, Z
001457 93c0 2852                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001459 93d0 2853                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
00145b 95a2                      	swap r26
00145c 70af                      	andi r26, 0x0F //mask effect speed
00145d 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
00145e 95a3                      	inc r26 //increment the speed by 1
                                 
00145f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001460 937f                      	push r23
001461 2f6a                      	mov r22, r26 //store the speed data into r27
001462 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001463 9f67                      	mul r22, r23
001464 917f                      	pop r23
001465 916f                      	pop r22
                                 
001466 9416                      	lsr r1 //shift out the fractional bits
001467 9407                      	ror r0
001468 9416                      	lsr r1
001469 9407                      	ror r0
00146a 9416                      	lsr r1
00146b 9407                      	ror r0
00146c 9416                      	lsr r1
00146d 9407                      	ror r0
                                 
00146e 9200 2854                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001470 9210 2855                 	sts pulse1_fx_Rxy_speed+1, r1
001472 9220 2856                 	sts pulse1_fx_Rxy_total_offset, zero
001474 9220 2857                 	sts pulse1_fx_Rxy_total_offset+1, zero
001476 ceaf                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Sxx: //mute delay
001477 ceae                      	rjmp sound_driver_channel0
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001478 e7ea                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001479 e3f3                      	ldi ZH, HIGH(sequences << 1)
00147a 0fea                      	add ZL, r26 //offset the pointer
00147b 1df2                      	adc ZH, zero
                                 
00147c 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00147d 95a7                      	ror r26
00147e 95a7                      	ror r26
00147f 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001481 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001482 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001483 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001484 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001485 cea0                      	rjmp sound_driver_channel0 //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001486 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001487 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001488 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001489 93c0 2800                 	sts pulse1_param, r28
00148b ce9a                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
00148c ce99                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
00148d ce98                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
00148e ce97                      	rjmp sound_driver_channel0
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
00148f ce96                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_channel0_note:
001490 93b0 2807                 	sts pulse1_note, r27 //store the note index
001492 e0a3                      	ldi r26, 0x03
001493 e0b2                      	ldi r27, 0x02
001494 93b0 2815                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001496 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26
001498 93b0 2821                 	sts pulse1_pitch_macro_offset, r27
00149a 93b0 2827                 	sts pulse1_hi_pitch_macro_offset, r27
00149c 93b0 282c                 	sts pulse1_duty_macro_offset, r27
00149e 9220 281e                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0014a0 9220 2824                 	sts pulse1_total_hi_pitch_offset, zero
0014a2 9220 2833                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0014a4 9220 2834                 	sts pulse1_fx_1xx_total+1, zero
0014a6 9220 2837                 	sts pulse1_fx_2xx_total, zero
0014a8 9220 2838                 	sts pulse1_fx_2xx_total+1, zero
0014aa 9220 283f                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
0014ac 9220 2840                 	sts pulse1_fx_3xx_total_offset+1, zero
0014ae 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0014b0 91b0 0a8d                 	lds r27, TCB0_CCMPH
0014b2 93a0 2839                 	sts pulse1_fx_3xx_start, r26
0014b4 93b0 283a                 	sts pulse1_fx_3xx_start+1, r27
0014b6 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
0014b8 6097                      	sbr channel_flags, 7 //set reload flag
0014b9 9220 284c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0014bb 9220 284d                 	sts pulse1_fx_Qxy_target+1, zero
0014bd 9220 2850                 	sts pulse1_fx_Qxy_total_offset, zero
0014bf 9220 2851                 	sts pulse1_fx_Qxy_total_offset+1, zero
0014c1 9220 2852                 	sts pulse1_fx_Rxy_target, zero
0014c3 9220 2853                 	sts pulse1_fx_Rxy_target+1, zero
0014c5 9220 2856                 	sts pulse1_fx_Rxy_total_offset, zero
0014c7 9220 2857                 	sts pulse1_fx_Rxy_total_offset+1, zero
0014c9 d0fb                      	rcall sound_driver_channel0_increment_offset
0014ca ce5b                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
0014cb 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0014cc 91a0 2800                 	lds r26, pulse1_param
0014ce 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0014cf 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
0014d0 93a0 2800                 	sts pulse1_param, r26
0014d2 6096                      	sbr channel_flags, 6
0014d3 d0f1                      	rcall sound_driver_channel0_increment_offset
0014d4 ce51                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
0014d5 56b7                      	subi r27, 0x67 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0014d6 93b0 280f                 	sts pulse1_pattern_delay, r27
0014d8 d0ec                      	rcall sound_driver_channel0_increment_offset
0014d9 c0ff                      	rjmp sound_driver_calculate_delays
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
0014da 9220 2813                 	sts pulse1_volume_macro, zero //reset all macro addresses
0014dc 9220 2814                 	sts pulse1_volume_macro+1, zero
0014de 9220 2818                 	sts pulse1_arpeggio_macro, zero
0014e0 9220 2819                 	sts pulse1_arpeggio_macro+1, zero
0014e2 9220 281f                 	sts pulse1_pitch_macro, zero
0014e4 9220 2820                 	sts pulse1_pitch_macro+1, zero
0014e6 9220 2825                 	sts pulse1_hi_pitch_macro, zero
0014e8 9220 2826                 	sts pulse1_hi_pitch_macro+1, zero
0014ea 9220 282a                 	sts pulse1_duty_macro, zero
0014ec 9220 282b                 	sts pulse1_duty_macro+1, zero
0014ee 9220 281e                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
0014f0 9220 2824                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0014f2 9631                      	adiw Z, 1 //point to the byte next to the flag
0014f3 91b4                      	lpm r27, Z //store the instrument offset into r27
0014f4 eaed                      	ldi ZL, LOW(instruments) //point Z to instruments table
0014f5 e0ff                      	ldi ZH, HIGH(instruments)
0014f6 0feb                      	add ZL, r27 //point Z to offsetted instrument
0014f7 1df2                      	adc ZH, zero
0014f8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
0014f9 1fff                      	rol ZH
0014fa 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
0014fb 91b4                      	lpm r27, Z
                                 
0014fc 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
0014fd 1fbb                      	rol r27
0014fe 2fea                      	mov ZL, r26
0014ff 2ffb                      	mov ZH, r27
001500 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001501 9632                      	adiw Z, 2 //point Z to the address of the macro
001502 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
001503 95aa                      	dec r26
001504 f019                      	breq sound_driver_channel0_instrument_change_exit
001505 95b6                      	lsr r27
001506 f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001507 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001508 e0a3                      	ldi r26, 0x03
001509 e0b2                      	ldi r27, 0x02
00150a 93b0 2815                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00150c 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26
00150e 93b0 2821                 	sts pulse1_pitch_macro_offset, r27
001510 93b0 2827                 	sts pulse1_hi_pitch_macro_offset, r27
001512 93b0 282c                 	sts pulse1_duty_macro_offset, r27
001514 d0ba                      	rcall sound_driver_channel0_increment_offset_twice
001515 ce10                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
001516 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001517 91d5                      	lpm r29, Z+
                                 
001518 30a5                      	cpi r26, 5
001519 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
00151a 30a4                      	cpi r26, 4
00151b f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
00151c 30a3                      	cpi r26, 3
00151d f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
00151e 30a2                      	cpi r26, 2
00151f f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001520 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
001521 93c0 2813                 	sts pulse1_volume_macro, r28
001523 93d0 2814                 	sts pulse1_volume_macro+1, r29
001525 d041                      	rcall sound_driver_channel0_instrument_change_read_header
001526 93c0 2817                 	sts pulse1_volume_macro_release, r28
001528 93d0 2816                 	sts pulse1_volume_macro_loop, r29
00152a cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
00152b 93c0 2818                 	sts pulse1_arpeggio_macro, r28
00152d 93d0 2819                 	sts pulse1_arpeggio_macro+1, r29
00152f 9220 284c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001531 9220 284d                 	sts pulse1_fx_Qxy_target+1, zero
001533 9220 2852                 	sts pulse1_fx_Rxy_target, zero
001535 9220 2853                 	sts pulse1_fx_Rxy_target+1, zero
001537 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001538 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001539 93c0 281f                 	sts pulse1_pitch_macro, r28
00153b 93d0 2820                 	sts pulse1_pitch_macro+1, r29
00153d 9220 284c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00153f 9220 284d                 	sts pulse1_fx_Qxy_target+1, zero
001541 9220 2852                 	sts pulse1_fx_Rxy_target, zero
001543 9220 2853                 	sts pulse1_fx_Rxy_target+1, zero
001545 d021                      	rcall sound_driver_channel0_instrument_change_read_header
001546 93c0 2823                 	sts pulse1_pitch_macro_release, r28
001548 93d0 2822                 	sts pulse1_pitch_macro_loop, r29
00154a cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
00154b 93c0 2825                 	sts pulse1_hi_pitch_macro, r28
00154d 93d0 2826                 	sts pulse1_hi_pitch_macro+1, r29
00154f 9220 284c                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001551 9220 284d                 	sts pulse1_fx_Qxy_target+1, zero
001553 9220 2852                 	sts pulse1_fx_Rxy_target, zero
001555 9220 2853                 	sts pulse1_fx_Rxy_target+1, zero
001557 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001558 93c0 2829                 	sts pulse1_hi_pitch_macro_release, r28
00155a 93d0 2828                 	sts pulse1_hi_pitch_macro_loop, r29
00155c cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
00155d 93c0 282a                 	sts pulse1_duty_macro, r28
00155f 93d0 282b                 	sts pulse1_duty_macro+1, r29
001561 d005                      	rcall sound_driver_channel0_instrument_change_read_header
001562 93c0 282e                 	sts pulse1_duty_macro_release, r28
001564 93d0 282d                 	sts pulse1_duty_macro_loop, r29
001566 cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001567 93ef                      	push ZL
001568 93ff                      	push ZH
001569 2fec                      	mov ZL, r28
00156a 2ffd                      	mov ZH, r29
00156b 0fee                      	lsl ZL
00156c 1fff                      	rol ZH
00156d 91c5                      	lpm r28, Z+
00156e 91d4                      	lpm r29, Z
00156f 91ff                      	pop ZH
001570 91ef                      	pop ZL
001571 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
001572 93ef                      	push ZL
001573 93ff                      	push ZH
001574 2fec                      	mov ZL, r28
001575 2ffd                      	mov ZH, r29
001576 0fee                      	lsl ZL
001577 1fff                      	rol ZH
001578 91c5                      	lpm r28, Z+
001579 91d5                      	lpm r29, Z+
00157a 93c0 281c                 	sts pulse1_arpeggio_macro_release, r28
00157c 93d0 281b                 	sts pulse1_arpeggio_macro_loop, r29
00157e 91c4                      	lpm r28, Z
00157f 93c0 281d                 	sts pulse1_arpeggio_macro_mode, r28
001581 91ff                      	pop ZH
001582 91ef                      	pop ZL
001583 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
001584 91b0 2817                 	lds r27, pulse1_volume_macro_release
001586 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001587 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001588 95b3                      	inc r27
001589 93b0 2815                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
00158b 91b0 281c                 	lds r27, pulse1_arpeggio_macro_release
00158d 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00158e f019                      	breq sound_driver_channel0_release_pitch
00158f 95b3                      	inc r27
001590 93b0 281a                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
001592 91b0 2823                 	lds r27, pulse1_pitch_macro_release
001594 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001595 f019                      	breq sound_driver_channel0_release_hi_pitch
001596 95b3                      	inc r27
001597 93b0 2821                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
001599 91b0 2829                 	lds r27, pulse1_hi_pitch_macro_release
00159b 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00159c f019                      	breq sound_driver_channel0_release_duty
00159d 95b3                      	inc r27
00159e 93b0 2827                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
0015a0 91b0 282e                 	lds r27, pulse1_duty_macro_release
0015a2 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0015a3 f019                      	breq sound_driver_channel0_release_exit
0015a4 95b3                      	inc r27
0015a5 93b0 282c                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
0015a7 d01d                      	rcall sound_driver_channel0_increment_offset
0015a8 cd7d                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
0015a9 91e0 2808                 	lds ZL, song_frames
0015ab 91f0 2809                 	lds ZH, song_frames+1
0015ad 91a0 280a                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0015af 91b0 280b                 	lds r27, song_frame_offset+1
0015b1 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0015b2 93a0 280a                 	sts song_frame_offset, r26
0015b4 93b0 280b                 	sts song_frame_offset+1, r27
                                 	//adiw r27:r26, 2 //offset for channel 1 (test)
0015b6 0fea                      	add ZL, r26
0015b7 1ffb                      	adc ZH, r27
                                 
0015b8 91a5                      	lpm r26, Z+ //load the address of the next pattern
0015b9 91b4                      	lpm r27, Z
0015ba 0faa                      	lsl r26
0015bb 1fbb                      	rol r27
0015bc 93a0 280d                 	sts pulse1_pattern, r26
0015be 93b0 280e                 	sts pulse1_pattern+1, r27
                                 
0015c0 9220 2811                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0015c2 9220 2812                 	sts pulse1_pattern_offset+1, zero
0015c4 cd61                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
0015c5 91e0 2811                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0015c7 91f0 2812                 	lds ZH, pulse1_pattern_offset+1
0015c9 9631                      	adiw Z, 1
0015ca 93e0 2811                 	sts pulse1_pattern_offset, ZL
0015cc 93f0 2812                 	sts pulse1_pattern_offset+1, ZH
0015ce 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0015cf 91e0 2811                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0015d1 91f0 2812                 	lds ZH, pulse1_pattern_offset+1
0015d3 9632                      	adiw Z, 2 //increment the pointer twice
0015d4 93e0 2811                 	sts pulse1_pattern_offset, ZL
0015d6 93f0 2812                 	sts pulse1_pattern_offset+1, ZH
0015d8 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_calculate_delays:
0015d9 936f                      	push r22
0015da 937f                      	push r23
0015db 9160 280c                 	lds r22, song_speed
0015dd 2fa6                      	mov r26, r22
0015de 2fd6                      	mov r29, r22
0015df 50a1                      	subi r26, 1
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
0015e0 91b0 2849                 	lds r27, pulse1_fx_Gxx_pre
0015e2 91c0 284a                 	lds r28, pulse1_fx_Gxx_post
0015e4 17b6                      	cp r27, r22 //compare the Gxx fx to the song speed
0015e5 f018                      	brlo sound_driver_calculate_delays_pulse1_Gxx_post
0015e6 e0b0                      	ldi r27, 0 //if the Gxx effect exceeds one row (the song speed), then reset the effect to 0
0015e7 9220 2849                 	sts pulse1_fx_Gxx_pre, zero
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
0015e9 15c2                      	cp r28, zero
0015ea f009                      	breq sound_driver_calculate_delays_pulse1_main
0015eb 2fac                      	mov r26, r28 //if there was a Gxx, use its post instead of the (song speed)-1
                                 	
                                 sound_driver_calculate_delays_pulse1_main:
0015ec 9170 280f                 	lds r23, pulse1_pattern_delay
0015ee 9f67                      	mul r22, r23
0015ef 0e0a                      	add r0, r26
0015f0 1c12                      	adc r1, zero
0015f1 0e0b                      	add r0, r27
0015f2 1c12                      	adc r1, zero
0015f3 9200 280f                 	sts pulse1_pattern_delay, r0
0015f5 9210 2810                 	sts pulse1_pattern_delay+1, r1
0015f7 9220 284a                 	sts pulse1_fx_Gxx_post, zero
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
0015f9 15b2                      	cp r27, zero //check if the Gxx effect was enabled
0015fa f029                      	breq sound_driver_calculate_delays_pulse2_Gxx
0015fb 1bdb                      	sub r29, r27 //(song speed)-1-Gxx
0015fc 93a0 284a                 	sts pulse1_fx_Gxx_post, r26
0015fe 9220 2849                 	sts pulse1_fx_Gxx_pre, zero
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
001600 917f                      	pop r23
001601 916f                      	pop r22
001602 c006                      	rjmp sound_driver_instrument_routine
                                 
                                 
                                 
                                 sound_driver_decrement_frame_delay:
001603 50a1                      	subi r26, 1
001604 09b2                      	sbc r27, zero
001605 93a0 280f                 	sts pulse1_pattern_delay, r26
001607 93b0 2810                 	sts pulse1_pattern_delay+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine:
                                 sound_driver_instrument_routine_channel0_volume:
001609 91e0 2813                 	lds ZL, pulse1_volume_macro
00160b 91f0 2814                 	lds ZH, pulse1_volume_macro+1
00160d 9630                      	adiw Z, 0
00160e f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
00160f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
001610 1fff                      	rol ZH
001611 91a0 2815                 	lds r26, pulse1_volume_macro_offset
001613 0fea                      	add ZL, r26
001614 1df2                      	adc ZH, zero
                                 
001615 91b0 2817                 	lds r27, pulse1_volume_macro_release
001617 17ba                      	cp r27, r26
001618 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
001619 91a0 2816                 	lds r26, pulse1_volume_macro_loop
00161b 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00161c f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00161d c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
00161e 95a3                      	inc r26 //increment the macro offset
00161f 93a0 2815                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
001621 91b4                      	lpm r27, Z //load volume data into r27
001622 3fbf                      	cpi r27, 0xFF //check for macro end flag
001623 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
001624 91b0 2817                 	lds r27, pulse1_volume_macro_release
001626 3fbf                      	cpi r27, 0xFF
001627 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
001628 91b0 2816                 	lds r27, pulse1_volume_macro_loop //load the loop index
00162a 93b0 2815                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00162c cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
00162d 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00162e 93a0 2815                 	sts pulse1_volume_macro_offset, r26
001630 cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
001631 ebe2                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
001632 e3f3                      	ldi ZH, HIGH(volumes << 1)
001633 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
001634 0feb                      	add ZL, r27 //add offset to the table
001635 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
001636 91b0 2800                 	lds r27, pulse1_param //load main volume
001638 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001639 91a0 2847                 	lds r26, pulse1_fx_7xy_value
00163b 30a0                      	cpi r26, 0x00
00163c f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
00163d 0feb                      	add ZL, r27 //offset the volume table by the main volume
00163e 1df2                      	adc ZH, zero
00163f 91b4                      	lpm r27, Z
001640 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001642 c024                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
001643 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
001645 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
001646 91a0 2847                 	lds r26, pulse1_fx_7xy_value
001648 30a0                      	cpi r26, 0x00
001649 f4a1                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
00164a 93b0 2806                 	sts pulse1_output_volume, r27
00164c c01a                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
00164d 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00164e f040                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
00164f f039                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
001650 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
                                 
001651 0feb                      	add ZL, r27 //offset the volume table by the main volume
001652 1df2                      	adc ZH, zero
001653 91b4                      	lpm r27, Z
001654 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
001656 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
001657 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001658 0feb                      	add ZL, r27 //offset the volume table by the main volume
001659 1df2                      	adc ZH, zero
00165a 91b4                      	lpm r27, Z
00165b 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
00165d c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
00165e 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00165f f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001660 f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
001661 93b0 2806                 	sts pulse1_output_volume, r27
001663 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
001664 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
001665 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
001667 91e0 2818                 	lds ZL, pulse1_arpeggio_macro
001669 91f0 2819                 	lds ZH, pulse1_arpeggio_macro+1
00166b 9630                      	adiw Z, 0
00166c f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
00166d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00166e 1fff                      	rol ZH
00166f 91a0 281a                 	lds r26, pulse1_arpeggio_macro_offset
001671 0fea                      	add ZL, r26
001672 1df2                      	adc ZH, zero
                                 
001673 91b0 281c                 	lds r27, pulse1_arpeggio_macro_release
001675 17ba                      	cp r27, r26
001676 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
001677 91a0 281b                 	lds r26, pulse1_arpeggio_macro_loop
001679 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00167a f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
00167b c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
00167c 95a3                      	inc r26 //increment the macro offset
00167d 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
00167f 91b4                      	lpm r27, Z //load arpeggio data into r27
001680 38b0                      	cpi r27, 0x80 //check for macro end flag
001681 f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
001682 c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
001683 50a1                      	subi r26, 1 //keep the offset at the end flag
001684 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26
001686 91b0 281d                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
001688 30b1                      	cpi r27, 0x01
001689 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
00168a 91b0 281c                 	lds r27, pulse1_arpeggio_macro_release
00168c 3fbf                      	cpi r27, 0xFF
00168d f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
00168e 91b0 281b                 	lds r27, pulse1_arpeggio_macro_loop
001690 3fbf                      	cpi r27, 0xFF
001691 f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
001692 c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
001693 91b0 281c                 	lds r27, pulse1_arpeggio_macro_release
001695 3fbf                      	cpi r27, 0xFF
001696 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
001697 91b0 281b                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
001699 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00169a f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
00169b 91c0 282f                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
00169d 91d0 2830                 	lds r29, pulse1_fx_0xy_sequence+1
00169f 9620                      	adiw r29:r28, 0
0016a0 f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0016a1 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0016a2 93a0 281a                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
0016a4 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
0016a5 93b0 281a                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
0016a7 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
0016a8 91c0 282f                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
0016aa 91d0 2830                 	lds r29, pulse1_fx_0xy_sequence+1
0016ac 9620                      	adiw r29:r28, 0 //check for 0xy effect
0016ad f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_xy:
0016ae 95d6                      	lsr r29
0016af 95c7                      	ror r28
0016b0 95d7                      	ror r29
0016b1 95c7                      	ror r28
0016b2 95d7                      	ror r29
0016b3 95c7                      	ror r28
0016b4 95d7                      	ror r29
0016b5 95c7                      	ror r28
0016b6 95d7                      	ror r29
0016b7 95d2                      	swap r29
                                 
0016b8 93c0 282f                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
0016ba 93d0 2830                 	sts pulse1_fx_0xy_sequence+1, r29
0016bc 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0016bd 91a0 2807                 	lds r26, pulse1_note //load the current note index
0016bf 0fac                      	add r26, r28 //add the note offset
0016c0 c02c                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0016c1 91a0 2807                 	lds r26, pulse1_note //load the current note index
0016c3 c029                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
0016c4 9220 281e                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0016c6 9220 2824                 	sts pulse1_total_hi_pitch_offset, zero
0016c8 91a0 281d                 	lds r26, pulse1_arpeggio_macro_mode
0016ca 30a1                      	cpi r26, 0x01 //absolute mode
0016cb f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
0016cc f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
0016cd c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
0016ce 91a0 2807                 	lds r26, pulse1_note //load the current note index
0016d0 0fab                      	add r26, r27 //offset the note with the arpeggio data
0016d1 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0016d2 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
0016d3 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0016d4 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0016d5 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0016d6 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
0016d7 fda7                      	sbrc r26, 7 //check if result is negative
0016d8 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0016d9 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
0016da 2fab                      	mov r26, r27 //move the arpeggio data into r26
0016db c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
0016dc 91a0 2807                 	lds r26, pulse1_note //load the current note index
0016de 0fab                      	add r26, r27 //offset the note with the arpeggio data
0016df fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0016e0 c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
0016e1 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
0016e3 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0016e4 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
0016e5 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0016e6 93a0 2807                 	sts pulse1_note, r26
0016e8 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
0016e9 fda7                      	sbrc r26, 7 //check if result is negative
0016ea e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0016eb 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
0016ed e3e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0016ee e0f0                      	ldi ZH, HIGH(note_table << 1)
0016ef 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0016f0 0fea                      	add ZL, r26 //add offset
0016f1 1df2                      	adc ZH, zero
0016f2 91a5                      	lpm r26, Z+ //load bytes
0016f3 91b4                      	lpm r27, Z
0016f4 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
0016f6 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
0016f8 93a0 283b                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0016fa 93b0 283c                 	sts pulse1_fx_3xx_target+1, r27
0016fc c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 //NOTE: There is a limitation with the pitch routines in that the total pitch can not be offset by 127 in both,
                                 //the positive and negative direction, from the original note pitch. This shouldn't be too much of a problem as
                                 //most songs that use instruments with the pitch macro, do not stray that far from the original note pitch.
                                 //In the case of hi pitch, the total pitch can not be offset by 127*16 from the original pitch. This is also
                                 //not a big deal as you can easily reach the entire note range with an offset of up to 127*16.
                                 sound_driver_instrument_routine_channel0_pitch:
0016fd 91e0 281f                 	lds ZL, pulse1_pitch_macro
0016ff 91f0 2820                 	lds ZH, pulse1_pitch_macro+1
001701 9630                      	adiw Z, 0
001702 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
001703 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
001704 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
001705 1fff                      	rol ZH
001706 91a0 2821                 	lds r26, pulse1_pitch_macro_offset
001708 0fea                      	add ZL, r26
001709 1df2                      	adc ZH, zero
                                 
00170a 91b0 2823                 	lds r27, pulse1_pitch_macro_release
00170c 17ba                      	cp r27, r26
00170d f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
00170e 91a0 2822                 	lds r26, pulse1_pitch_macro_loop
001710 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
001711 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
001712 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
001713 95a3                      	inc r26 //increment the macro offset
001714 93a0 2821                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
001716 91b4                      	lpm r27, Z //load pitch data into r27
001717 38b0                      	cpi r27, 0x80 //check for macro end flag
001718 f489                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
001719 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00171a 93a0 2821                 	sts pulse1_pitch_macro_offset, r26
00171c 91b0 2823                 	lds r27, pulse1_pitch_macro_release
00171e 3fbf                      	cpi r27, 0xFF
00171f f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
001720 91b0 2822                 	lds r27, pulse1_pitch_macro_loop //load the loop index
001722 3fbf                      	cpi r27, 0xFF //check if there is a loop index
001723 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
001724 93b0 2821                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
001726 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
001727 91b0 281e                 	lds r27, pulse1_total_pitch_offset
001729 c005                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
00172a 91a0 281e                 	lds r26, pulse1_total_pitch_offset //load the total pitch offset to change
00172c 0fba                      	add r27, r26
00172d 93b0 281e                 	sts pulse1_total_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_multiply:
                                 	//NOTE: The Pxx effect is processed with the pitch instrument macro because the calculations are the same
00172f 91a0 284b                 	lds r26, pulse1_fx_Pxx
001731 0fba                      	add r27, r26
                                 
001732 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001733 937f                      	push r23
001734 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
001735 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001736 0367                      	mulsu r22, r23
001737 917f                      	pop r23
001738 916f                      	pop r22
                                 
001739 9416                      	lsr r1 //shift out the fractional bits
00173a 9407                      	ror r0
00173b 9416                      	lsr r1
00173c 9407                      	ror r0
00173d 9416                      	lsr r1
00173e 9407                      	ror r0
00173f 9416                      	lsr r1
001740 9407                      	ror r0
001741 fe13                      	sbrs r1, 3 //check if result was a negative number
001742 c002                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
001743 efb0                      	ldi r27, 0xF0
001744 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
001745 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
001747 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
001749 0da0                      	add r26, r0 //offset the timer values
00174a 1db1                      	adc r27, r1
                                 	
00174b 91c0 2833                 	lds r28, pulse1_fx_1xx_total
00174d 91d0 2834                 	lds r29, pulse1_fx_1xx_total+1
00174f 1bac                      	sub r26, r28
001750 0bbd                      	sbc r27, r29
001751 91c0 2837                 	lds r28, pulse1_fx_2xx_total
001753 91d0 2838                 	lds r29, pulse1_fx_2xx_total+1
001755 0fac                      	add r26, r28
001756 1fbd                      	adc r27, r29
001757 91c0 2850                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
001759 91d0 2851                 	lds r29, pulse1_fx_Qxy_total_offset+1
00175b 1bac                      	sub r26, r28
00175c 0bbd                      	sbc r27, r29
00175d 91c0 2856                 	lds r28, pulse1_fx_Rxy_total_offset
00175f 91d0 2857                 	lds r29, pulse1_fx_Rxy_total_offset+1
001761 0fac                      	add r26, r28
001762 1fbd                      	adc r27, r29
                                 
001763 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
001765 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
001767 91e0 2825                 	lds ZL, pulse1_hi_pitch_macro
001769 91f0 2826                 	lds ZH, pulse1_hi_pitch_macro+1
00176b 9630                      	adiw Z, 0
00176c f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
00176d c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
00176e 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00176f 1fff                      	rol ZH
001770 91a0 2827                 	lds r26, pulse1_hi_pitch_macro_offset
001772 0fea                      	add ZL, r26
001773 1df2                      	adc ZH, zero
                                 
001774 91b0 2829                 	lds r27, pulse1_hi_pitch_macro_release
001776 17ba                      	cp r27, r26
001777 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
001778 91a0 2828                 	lds r26, pulse1_hi_pitch_macro_loop
00177a 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00177b f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00177c c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
00177d 95a3                      	inc r26 //increment the macro offset
00177e 93a0 2827                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
001780 91b4                      	lpm r27, Z //load hi pitch data into r27
001781 38b0                      	cpi r27, 0x80 //check for macro end flag
001782 f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
001783 50a1                      	subi r26, 1 //keep the macro offset at the end flag
001784 93a0 2827                 	sts pulse1_hi_pitch_macro_offset, r26
001786 91b0 2829                 	lds r27, pulse1_hi_pitch_macro_release
001788 3fbf                      	cpi r27, 0xFF
001789 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
00178a 91b0 2828                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
00178c 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00178d f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
00178e 93b0 2827                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
001790 cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
001791 91b0 2824                 	lds r27, pulse1_total_hi_pitch_offset
001793 c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
001794 91a0 2824                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
001796 0fba                      	add r27, r26
001797 93b0 2824                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
001799 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00179a 937f                      	push r23
00179b 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
00179c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00179d 0367                      	mulsu r22, r23
00179e 917f                      	pop r23
00179f 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
0017a0 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0017a2 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0017a4 0da0                      	add r26, r0 //offset the timer values
0017a5 1db1                      	adc r27, r1
0017a6 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0017a8 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
0017aa 91e0 282a                 	lds ZL, pulse1_duty_macro
0017ac 91f0 282b                 	lds ZH, pulse1_duty_macro+1
0017ae 9630                      	adiw Z, 0
0017af f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
0017b0 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0017b1 1fff                      	rol ZH
0017b2 91a0 282c                 	lds r26, pulse1_duty_macro_offset
0017b4 0fea                      	add ZL, r26
0017b5 1df2                      	adc ZH, zero
                                 
0017b6 91b0 282e                 	lds r27, pulse1_duty_macro_release
0017b8 17ba                      	cp r27, r26
0017b9 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
0017ba 91a0 282d                 	lds r26, pulse1_duty_macro_loop
0017bc 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0017bd f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0017be c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
0017bf 95a3                      	inc r26 //increment the macro offset
0017c0 93a0 282c                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
0017c2 91b4                      	lpm r27, Z //load pitch data into r27
0017c3 3fbf                      	cpi r27, 0xFF //check for macro end flag
0017c4 f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
0017c5 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0017c6 93a0 282c                 	sts pulse1_duty_macro_offset, r26
0017c8 91b0 282e                 	lds r27, pulse1_duty_macro_release
0017ca 3fbf                      	cpi r27, 0xFF
0017cb f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
0017cc 91b0 282d                 	lds r27, pulse1_duty_macro_loop //load the loop index
0017ce 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0017cf f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0017d0 93b0 282c                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
0017d2 cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
0017d3 e7ea                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0017d4 e3f3                      	ldi ZH, HIGH(sequences << 1)
0017d5 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0017d6 1df2                      	adc ZH, zero
                                 
0017d7 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
0017d8 95b7                      	ror r27
0017d9 95b7                      	ror r27
0017da 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
0017dc 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
0017dd 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0017de 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0017df c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
0017e0 c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
0017e1 90d4                      	lpm pulse1_sequence, Z //store the sequence
                                 
0017e2 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0017e3 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0017e4 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
0017e6 91e0 2831                 	lds ZL, pulse1_fx_1xx
0017e8 91f0 2832                 	lds ZH, pulse1_fx_1xx+1
0017ea 9630                      	adiw Z, 0
0017eb f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
0017ec 91a0 2833                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
0017ee 91b0 2834                 	lds r27, pulse1_fx_1xx_total+1
0017f0 0fae                      	add r26, ZL //increase the total offset by the rate
0017f1 1fbf                      	adc r27, ZH
0017f2 93a0 2833                 	sts pulse1_fx_1xx_total, r26
0017f4 93b0 2834                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
0017f6 91e0 2835                 	lds ZL, pulse1_fx_2xx
0017f8 91f0 2836                 	lds ZH, pulse1_fx_2xx+1
0017fa 9630                      	adiw Z, 0
0017fb f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
0017fc 91a0 2837                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
0017fe 91b0 2838                 	lds r27, pulse1_fx_2xx_total+1
001800 0fae                      	add r26, ZL //increase the total offset by the rate
001801 1fbf                      	adc r27, ZH
001802 93a0 2837                 	sts pulse1_fx_2xx_total, r26
001804 93b0 2838                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
001806 91e0 283d                 	lds ZL, pulse1_fx_3xx_speed
001808 91f0 283e                 	lds ZH, pulse1_fx_3xx_speed+1
00180a 9630                      	adiw Z, 0
00180b f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
00180c c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
00180d 91a0 2839                 	lds r26, pulse1_fx_3xx_start
00180f 91b0 283a                 	lds r27, pulse1_fx_3xx_start+1
001811 9610                      	adiw r26:r27, 0
001812 f409                      	brne sound_driver_channel0_fx_3xx_routine_main
001813 c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
001814 91c0 283b                 	lds r28, pulse1_fx_3xx_target
001816 91d0 283c                 	lds r29, pulse1_fx_3xx_target+1
                                 
001818 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
001819 07bd                      	cpc r27, r29
00181a f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
00181b f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
00181c c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
00181d 9220 2839                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
00181f 9220 283a                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
001821 c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
001822 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
001823 0bdb                      	sbc r29, r27
001824 91a0 283f                 	lds r26, pulse1_fx_3xx_total_offset
001826 91b0 2840                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
001828 0fae                      	add r26, ZL //add the speed to the total offset
001829 1fbf                      	adc r27, ZH
00182a 1bca                      	sub r28, r26 //invert the total difference with the total offset
00182b 0bdb                      	sbc r29, r27
00182c f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
00182d 93a0 283f                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
00182f 93b0 2840                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
001831 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
001833 91b0 0a8d                 	lds r27, TCB0_CCMPH
001835 1bac                      	sub r26, r28 //offset the current timer period with the total offset
001836 0bbd                      	sbc r27, r29
001837 93a0 0a8c                 	sts TCB0_CCMPL, r26
001839 93b0 0a8d                 	sts TCB0_CCMPH, r27
00183b c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
00183c 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
00183d 0bbd                      	sbc r27, r29
00183e 91c0 283f                 	lds r28, pulse1_fx_3xx_total_offset
001840 91d0 2840                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
001842 0fce                      	add r28, ZL //add the speed to the total offset
001843 1fdf                      	adc r29, ZH
001844 1bac                      	sub r26, r28 //invert the total difference with the total offset
001845 0bbd                      	sbc r27, r29
001846 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
001847 93c0 283f                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
001849 93d0 2840                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
00184b 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
00184d 91d0 0a8d                 	lds r29, TCB0_CCMPH
00184f 0fca                      	add r28, r26 //offset the current timer period with the total offset
001850 1fdb                      	adc r29, r27
001851 93c0 0a8c                 	sts TCB0_CCMPL, r28
001853 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
001855 91a0 2841                 	lds r26, pulse1_fx_4xy_speed
001857 15a2                      	cp r26, zero
001858 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
001859 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
00185a 91b0 2842                 	lds r27, pulse1_fx_4xy_depth
00185c 91c0 2843                 	lds r28, pulse1_fx_4xy_phase
00185e 0fca                      	add r28, r26 //increase the phase by the speed
00185f 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
001860 f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
001861 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
001862 93c0 2843                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
001864 31c0                      	cpi r28, 16
001865 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
001866 32c0                      	cpi r28, 32
001867 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
001868 33c0                      	cpi r28, 48
001869 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
00186a c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
00186b 70cf                      	andi r28, 0x0F //mask for values 0-15
00186c c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
00186d 6fc0                      	ori r28, 0xF0
00186e 95c0                      	com r28 //invert values 0-15
00186f c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
001870 70cf                      	andi r28, 0x0F //mask for values 0-15
001871 c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
001872 6fc0                      	ori r28, 0xF0
001873 95c0                      	com r28 //invert values 0-15
001874 c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
001875 95b2                      	swap r27 //multiply depth by 16
001876 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
001877 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001878 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
001879 0fec                      	add ZL, r28 //offset the table by the depth+phase
00187a 1df2                      	adc ZH, zero
00187b 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
00187c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00187d 937f                      	push r23
00187e 2f6c                      	mov r22, r28 //store the vibrato value into r22
00187f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001880 9f67                      	mul r22, r23
001881 917f                      	pop r23
001882 916f                      	pop r22
                                 
001883 9416                      	lsr r1 //shift out the fractional bits
001884 9407                      	ror r0
001885 9416                      	lsr r1
001886 9407                      	ror r0
001887 9416                      	lsr r1
001888 9407                      	ror r0
001889 9416                      	lsr r1
00188a 9407                      	ror r0
                                 	
00188b 91a0 0a8c                 	lds r26, TCB0_CCMPL
00188d 91b0 0a8d                 	lds r27, TCB0_CCMPH
00188f 0da0                      	add r26, r0
001890 1db1                      	adc r27, r1
001891 93a0 0a8c                 	sts TCB0_CCMPL, r26
001893 93b0 0a8d                 	sts TCB0_CCMPH, r27
001895 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
001896 95b2                      	swap r27 //multiply depth by 16
001897 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
001898 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
001899 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
00189a 0fec                      	add ZL, r28 //offset the table by the depth+phase
00189b 1df2                      	adc ZH, zero
00189c 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00189d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00189e 937f                      	push r23
00189f 2f6c                      	mov r22, r28 //store the vibrato value into r22
0018a0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0018a1 9f67                      	mul r22, r23
0018a2 917f                      	pop r23
0018a3 916f                      	pop r22
                                 
0018a4 9416                      	lsr r1 //shift out the fractional bits
0018a5 9407                      	ror r0
0018a6 9416                      	lsr r1
0018a7 9407                      	ror r0
0018a8 9416                      	lsr r1
0018a9 9407                      	ror r0
0018aa 9416                      	lsr r1
0018ab 9407                      	ror r0
                                 
0018ac 91a0 0a8c                 	lds r26, TCB0_CCMPL
0018ae 91b0 0a8d                 	lds r27, TCB0_CCMPH
0018b0 19a0                      	sub r26, r0
0018b1 09b1                      	sbc r27, r1
0018b2 93a0 0a8c                 	sts TCB0_CCMPL, r26
0018b4 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
0018b6 91a0 2844                 	lds r26, pulse1_fx_7xy_speed
0018b8 15a2                      	cp r26, zero
0018b9 f0f1                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0018ba 91b0 2845                 	lds r27, pulse1_fx_7xy_depth
0018bc 91c0 2846                 	lds r28, pulse1_fx_7xy_phase
0018be 0fca                      	add r28, r26 //increase the phase by the speed
0018bf 36c4                      	cpi r28, 0x64 //check if the phase overflowed NOTE: phase values range from 0-63
0018c0 f010                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0018c1 e0c0                      	ldi r28, 0x00
0018c2 56c3                      	subi r28, 0x63 //if there was overflow, re-adjust the phase
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
0018c3 93c0 2846                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
0018c5 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0018c6 ffc4                      	sbrs r28, 4
0018c7 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
0018c8 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
0018c9 70cf                      	andi r28, 0x0F //mask for values 0-15
0018ca c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
0018cb 6fc0                      	ori r28, 0xF0
0018cc 95c0                      	com r28 //invert values 0-15
0018cd c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
0018ce 95b2                      	swap r27 //multiply depth by 16
0018cf 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0018d0 eee2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0018d1 e0f0                      	ldi ZH, HIGH(vibrato_table << 1)
0018d2 0fec                      	add ZL, r28 //offset the table by the depth+phase
0018d3 1df2                      	adc ZH, zero
0018d4 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0018d5 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0018d6 93c0 2847                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
0018d8 91b0 2848                 	lds r27, pulse1_fx_Axy
0018da 15b2                      	cp r27, zero
0018db f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0018dc 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
0018de 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
0018e0 2fda                      	mov r29, r26 //copy fractional volume into r29
0018e1 2fec                      	mov r30, r28 //copy the pulse1_param into r30
0018e2 95e2                      	swap r30
0018e3 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0018e4 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0018e5 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0018e6 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
0018e7 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
0018e8 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0018e9 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
0018ea 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0018eb f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0018ec efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0018ed c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
0018ee 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0018ef f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0018f0 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
0018f1 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
0018f3 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0018f4 95a2                      	swap r26
0018f5 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0018f6 2bca                      	or r28, r26 //store the new volume back into pulse1_param
0018f7 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
0018f9 91e0 284c                 	lds ZL, pulse1_fx_Qxy_target
0018fb 91f0 284d                 	lds ZH, pulse1_fx_Qxy_target+1
0018fd 9630                      	adiw Z, 0
0018fe f131                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0018ff 91a0 2850                 	lds r26, pulse1_fx_Qxy_total_offset
001901 91b0 2851                 	lds r27, pulse1_fx_Qxy_total_offset+1
001903 91c0 0a8c                 	lds r28, TCB0_CCMPL
001905 91d0 0a8d                 	lds r29, TCB0_CCMPH
001907 1bca                      	sub r28, r26 //subtract the timer period by the total offset
001908 0bdb                      	sbc r29, r27
                                 
001909 17ce                      	cp r28, ZL //compare the new timer period with the target
00190a 07df                      	cpc r29, ZH
00190b f010                      	brlo sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
00190c f009                      	breq sound_driver_channel0_fx_Qxy_routine_end
00190d f468                      	brsh sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
00190e 1bec                      	sub ZL, r28 //calculate the difference to the target
00190f 0bfd                      	sbc ZH, r29
001910 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
001911 1fbf                      	adc r27, ZH
001912 93a0 2850                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
001914 93b0 2851                 	sts pulse1_fx_Qxy_total_offset+1, r27
001916 9220 284c                 	sts pulse1_fx_Qxy_target, zero //loading the target with 0 stops any further calculations
001918 9220 284d                 	sts pulse1_fx_Qxy_target+1, zero
00191a c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
00191b 91c0 284e                 	lds r28, pulse1_fx_Qxy_speed
00191d 91d0 284f                 	lds r29, pulse1_fx_Qxy_speed+1
00191f 0fac                      	add r26, r28 //increase the total offset by the speed
001920 1fbd                      	adc r27, r29
001921 93a0 2850                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
001923 93b0 2851                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
001925 91e0 2852                 	lds ZL, pulse1_fx_Rxy_target
001927 91f0 2853                 	lds ZH, pulse1_fx_Rxy_target+1
001929 9630                      	adiw Z, 0
00192a f131                      	breq sound_driver_channel0_fx_xy_routine //if the effect is not enabled, skip the routine
                                 
00192b 91a0 2856                 	lds r26, pulse1_fx_Rxy_total_offset
00192d 91b0 2857                 	lds r27, pulse1_fx_Rxy_total_offset+1
00192f 91c0 0a8c                 	lds r28, TCB0_CCMPL
001931 91d0 0a8d                 	lds r29, TCB0_CCMPH
001933 0fca                      	add r28, r26 //add the total offset to the timer period
001934 0fdb                      	add r29, r27
                                 
001935 17ce                      	cp r28, ZL //compare the new timer period with the target
001936 07df                      	cpc r29, ZH
001937 f010                      	brlo sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
001938 f009                      	breq sound_driver_channel0_fx_Rxy_routine_end
001939 f468                      	brsh sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
00193a 1bec                      	sub ZL, r28 //calculate the difference to the target
00193b 0bfd                      	sbc ZH, r29
00193c 0fae                      	add r26, ZL //increase the total offset to the exact amount needed to reach the target
00193d 1fbf                      	adc r27, ZH
00193e 93a0 2856                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
001940 93b0 2857                 	sts pulse1_fx_Rxy_total_offset+1, r27
001942 9220 2852                 	sts pulse1_fx_Rxy_target, zero //loading the target with 0 stops any further calculations
001944 9220 2853                 	sts pulse1_fx_Rxy_target+1, zero
001946 c00a                      	rjmp sound_driver_channel0_fx_xy_routine
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
001947 91c0 2854                 	lds r28, pulse1_fx_Rxy_speed
001949 91d0 2855                 	lds r29, pulse1_fx_Rxy_speed+1
00194b 0fac                      	add r26, r28 //increase the total offset by the speed
00194c 1fbd                      	adc r27, r29
00194d 93a0 2856                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
00194f 93b0 2857                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 sound_driver_channel0_fx_xy_routine:
                                 
                                 sound_driver_exit:
001951 91df                      	pop r29
001952 91cf                      	pop r28
001953 c9b9                      	rjmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001954 b7bf                      	in r27, CPU_SREG
001955 93bf                      	push r27
001956 94f8                      	cli
                                 
001957 0cdd                      	lsl pulse1_sequence //shifts sequence to the left
001958 1cd2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
001959 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00195a 93b0 0a86                 	sts TCB0_INTFLAGS, r27
00195c 91bf                      	pop r27
00195d bfbf                      	out CPU_SREG, r27
00195e 9518                      	reti
                                 
                                 pulse1_sweep_routine:
00195f 2dbf                      	mov r27, pulse1_sweep
001960 70b7                      	andi r27, 0x07 //mask for period divider bits
001961 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001962 93df                      	push r29
001963 2ddf                      	mov r29, pulse1_sweep
001964 95d2                      	swap r29
001965 70d7                      	andi r29, 0x07 //mask for shift bits
001966 f411                      	brne pulse1_sweep_routine_action_main //shift != 0
001967 91df                      	pop r29
001968 c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
001969 91a0 0a8c                 	lds r26, TCB0_CCMPL
00196b 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
00196d 95b6                      	lsr r27
00196e 95a7                      	ror r26
00196f 95da                      	dec r29
001970 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001971 fef7                      	sbrs pulse1_sweep, 7 //check the negate flag
001972 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001973 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001974 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
001975 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
001977 0fad                      	add r26, r29
001978 91d0 0a8d                 	lds r29, TCB0_CCMPH
00197a 1fbd                      	adc r27, r29
                                 
00197b 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
00197d 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 
                                 	//sts pulse1_timerL, r26
                                 	//sts pulse1_timerH, r27
                                 
                                 /*	//Sweep Test
                                 	mov r29, pulse1_sweep //invert the negate bit
                                 	ldi r27, 0b10000000
                                 	eor r29, r27
                                 	ori r29, 0b01111111
                                 
                                 	lds r27, pulse1_sweep_param //reload the pulse sweep divider params
                                 	swap r27
                                 	ori r27, 0b10000000
                                 	and r27, r29
                                 	mov pulse1_sweep, r27
                                 	sbr channel_flags, 0b10000000*/
                                 	
00197f 91df                      	pop r29
001980 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001981 94fa                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001982 ff97                      	sbrs channel_flags, 7 //if the reload flag is set, reload the sweep divider
001983 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001984 90f0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001986 94f2                      	swap pulse1_sweep //bring data from high byte to low byte
001987 779f                      	cbr channel_flags, 0b10000000 //clear reload flag
001988 9508                      	ret
                                 
                                 pulse1_envelope_routine:
001989 fd96                      	sbrc channel_flags, 6 //check if start flag is cleared
00198a c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
00198b 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
00198c f011                      	breq PC+3 //if the divider == 0, check loop flag
00198d 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
00198e 9508                      	ret
                                 
00198f 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001991 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001992 ff95                      	sbrs channel_flags, 5 //check if the loop flag is set
001993 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001994 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001995 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
001996 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
001997 f409                      	brne PC+2 //if decay != 0, go decrement
001998 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
001999 951a                      	dec pulse1_volume_decay
00199a 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
00199b 7b9f                      	cbr channel_flags, 0b01000000 //if the start flag is set, clear it
00199c 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
00199e 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
00199f e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
0019a0 9508                      	ret
                                 
                                 //CONVERTERS (TABLES)
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0019a1 e4ee                      	ldi ZL, LOW(length << 1)
0019a2 e3f3                      	ldi ZH, HIGH(length << 1)
0019a3 0fed                      	add ZL, r29
0019a4 1df2                      	adc ZH, zero
0019a5 91d4                      	lpm r29, Z
0019a6 9508                      	ret
                                 
0019a7 7f05
0019a8 010a
0019a9 0214
0019aa 0328
0019ab 0450
0019ac 051e
0019ad 0607
0019ae 070d
0019af 0806
0019b0 090c
0019b1 0a18
0019b2 0b30
0019b3 0c60
0019b4 0d24
0019b5 0e08
0019b6 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0019b7 e7ea                      	ldi ZL, LOW(sequences << 1)
0019b8 e3f3                      	ldi ZH, HIGH(sequences << 1)
0019b9 0fed                      	add ZL, r29
0019ba 1df2                      	adc ZH, zero
0019bb 91d4                      	lpm r29, Z
0019bc 9508                      	ret
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
0019bd 0301
0019be fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 fx:
0019bf 1350
0019c0 1355
0019c1 1371
0019c2 138d
0019c3 13b0                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
0019c4 13bb
0019c5 13c8
0019c6 13cb
0019c7 13cc
0019c8 13cd                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
0019c9 13ce
0019ca 13d6
0019cb 13d9
0019cc 13dc
0019cd 13e3                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
0019ce 13eb
0019cf 13ec
0019d0 13ed
0019d1 13f0
0019d2 1434                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
0019d3 1477
0019d4 1478
0019d5 148c
0019d6 148d
0019d7 148e                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
0019d8 148f                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
0019d9 0000
0019da 0000
0019db 0000
0019dc 0000
0019dd 0000
0019de 0000
0019df 0000
0019e0 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
0019e1 0100
0019e2 0101
0019e3 0101
0019e4 0101
0019e5 0101
0019e6 0101
0019e7 0101
0019e8 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
0019e9 0100
0019ea 0101
0019eb 0101
0019ec 0101
0019ed 0101
0019ee 0101
0019ef 0101
0019f0 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
0019f1 0100
0019f2 0101
0019f3 0101
0019f4 0101
0019f5 0101
0019f6 0202
0019f7 0202
0019f8 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
0019f9 0100
0019fa 0101
0019fb 0101
0019fc 0101
0019fd 0202
0019fe 0202
0019ff 0303
001a00 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
001a01 0100
001a02 0101
001a03 0101
001a04 0202
001a05 0302
001a06 0303
001a07 0404
001a08 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
001a09 0100
001a0a 0101
001a0b 0201
001a0c 0202
001a0d 0303
001a0e 0404
001a0f 0504
001a10 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
001a11 0100
001a12 0101
001a13 0201
001a14 0302
001a15 0403
001a16 0504
001a17 0605
001a18 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
001a19 0100
001a1a 0101
001a1b 0202
001a1c 0303
001a1d 0404
001a1e 0505
001a1f 0606
001a20 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
001a21 0100
001a22 0101
001a23 0302
001a24 0403
001a25 0504
001a26 0606
001a27 0707
001a28 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
001a29 0100
001a2a 0201
001a2b 0302
001a2c 0404
001a2d 0605
001a2e 0706
001a2f 0808
001a30 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
001a31 0100
001a32 0201
001a33 0302
001a34 0504
001a35 0605
001a36 0807
001a37 0908
001a38 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
001a39 0100
001a3a 0201
001a3b 0403
001a3c 0504
001a3d 0706
001a3e 0808
001a3f 0a09
001a40 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
001a41 0100
001a42 0201
001a43 0403
001a44 0605
001a45 0706
001a46 0908
001a47 0b0a
001a48 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
001a49 0100
001a4a 0201
001a4b 0403
001a4c 0605
001a4d 0807
001a4e 0a09
001a4f 0c0b
001a50 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
001a51 0100
001a52 0302
001a53 0504
001a54 0706
001a55 0908
001a56 0b0a
001a57 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  :  61 r0 :  44 r1 :  46 r2 : 176 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   6 r14:   4 r15:  13 r16:   7 r17:   6 r18:   0 r19:   0 r20:   0 
r21:   0 r22:  43 r23:  40 r24:   0 r25:  15 r26: 244 r27: 358 r28: 133 
r29: 100 r30:  92 r31:  87 
Registers used: 18 out of 35 (51.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :  42 add   :  57 adiw  :  26 and   :   0 
andi  :  32 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   4 break :   0 breq  :  43 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  24 brlt  :   0 brmi  :   0 
brne  :  32 brpl  :   0 brsh  :   6 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   2 
clc   :   0 clh   :   0 cli   :   4 cln   :   0 clr   :   1 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   5 cp    :  21 cpc   :   3 
cpi   :  48 cpse  :   4 dec   :   6 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   1 in    :   4 inc   :  12 
jmp   :   6 ld    :   0 ldd   :   0 ldi   :  86 lds   : 181 lpm   :  68 
lsl   :  19 lsr   :  39 mov   :  36 movw  :   0 mul   :   8 muls  :   0 
mulsu :   2 neg   :   0 nop   :   0 or    :   6 ori   :   5 out   :   6 
pop   :  31 push  :  31 rcall :  16 ret   :  13 reti  :   3 rjmp  : 126 
rol   :  13 ror   :  45 sbc   :  12 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   7 sbrc  :   8 sbrs  :   6 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   : 336 sub   :  15 subi  :  13 swap  :  16 tst   :   0 wdr   :   0 

Instructions used: 51 out of 114 (44.7%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0034b2   4056   9406  13462   49152  27.4%
[.dseg] 0x002800 0x00285c      0     92     92    6144   1.5%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 104 warnings
