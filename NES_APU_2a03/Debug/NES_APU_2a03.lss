
AVRASM ver. 2.2.8  C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm Tue Jan 26 23:56:39 2021

C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(9): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): Including file 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm'
                                 
                                 
                                 ; NES_APU_2a03.asm
                                 ;
                                 ; Created: 11/29/2020 1:44:10 AM
                                 ; Author : Tennyson Cheng
                                 ;
                                 
                                 .list
                                 
                                 .dseg
002800                           pulse1_param: .byte 1 //$4000 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002801                           pulse1_sweep_param: .byte 1 //$4001 EPPP.NSSS = Enable, Period, Negate, Shift
                                 //NOTE: In order to account for multiplier, we use 16 instead of 11 bits for the timer
002802                           pulse1_timerL: .byte 1 //$4002 LLLL.LLLL = Low 8 bits for timer
002803                           pulse1_timerH: .byte 1 //$4002 HHHH.HHHH = High 8 bits for timer
002804                           pulse1_length: .byte 1 //$4003 000l.llll = Length counter load
002805                           pulse1_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002806                           pulse1_output_volume: .byte 1 //this is the final output volume of pulse 1
002807                           pulse1_note: .byte 1 //the current note index in the note table
                                 
002808                           pulse2_param: .byte 1 //$4004 DDlc.vvvv = Duty cycle, Length counter halt/Loop flag, Constant volume flag, Volume
002809                           pulse2_sweep_param: .byte 1 //$4005 EPPP.NSSS = Enable, Period, Negate, Shift
00280a                           pulse2_timerL: .byte 1 //$4006 LLLL.LLLL = Low 8 bits for timer
00280b                           pulse2_timerH: .byte 1 //$4006 HHHH.HHHH = High 8 bits for timer
00280c                           pulse2_length: .byte 1 //$4007 000l.llll = Length counter load
00280d                           pulse2_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
00280e                           pulse2_output_volume: .byte 1 //this is the final output volume of pulse 2
00280f                           pulse2_note: .byte 1 //the current note index in the note table
                                 
002810                           triangle_timerL: .byte 1 //$400A LLLL.LLLL = Low 8 bits for timer
002811                           triangle_timerH: .byte 1 //$400A HHHH.HHHH = High 8 bits for time
002812                           triangle_note: .byte 1 //the current note index in the note table
                                 
002813                           noise_param: .byte 1 //$400C 00lc.vvvv = Length counter halt/Loop flag, Constant volume flag, Volume
002814                           noise_period: .byte 1 //$400E M000.PPPP = Mode, Period
002815                           noise_fractional_volume: .byte 1 //used with the Axy effect to calculate volume. represents the VVVV bits in $4000, but with fractional data in bits 0 to 3.
002816                           noise_output_volume: .byte 1 //this is the final output volume of pulse 2
002817                           noise_note: .byte 1 //the current note index in the period table
002818                           noise_adjusted_note: .byte 1 //the resultant note index after the arpeggio macro
                                 
002819                           song_frames: .byte 2
00281b                           song_frame_offset: .byte 2
00281d                           song_size: .byte 2
00281f                           song_speed: .byte 1
                                 //song_channel_delay_reload: .byte 1 //bit 0-4 represents channels 0-4. a set bit means that there is a delay that needs to be calculated for that channel.
002820                           song_fx_Bxx: .byte 1
002821                           song_fx_Cxx: .byte 1
002822                           song_fx_Dxx: .byte 1
                                 
                                 //PULSE 1
002823                           pulse1_pattern: .byte 2
002825                           pulse1_pattern_delay_rows: .byte 1
002826                           pulse1_pattern_delay_frames: .byte 1
002827                           pulse1_pattern_offset: .byte 2
                                 
002829                           pulse1_volume_macro: .byte 2
00282b                           pulse1_volume_macro_offset: .byte 1
00282c                           pulse1_volume_macro_loop: .byte 1
00282d                           pulse1_volume_macro_release: .byte 1
                                 
00282e                           pulse1_arpeggio_macro: .byte 2
002830                           pulse1_arpeggio_macro_offset: .byte 1
002831                           pulse1_arpeggio_macro_loop: .byte 1
002832                           pulse1_arpeggio_macro_release: .byte 1
002833                           pulse1_arpeggio_macro_mode: .byte 1
                                 
002834                           pulse1_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002836                           pulse1_pitch_macro: .byte 2
002838                           pulse1_pitch_macro_offset: .byte 1
002839                           pulse1_pitch_macro_loop: .byte 1
00283a                           pulse1_pitch_macro_release: .byte 1
                                 
00283b                           pulse1_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00283c                           pulse1_hi_pitch_macro: .byte 2
00283e                           pulse1_hi_pitch_macro_offset: .byte 1
00283f                           pulse1_hi_pitch_macro_loop: .byte 1
002840                           pulse1_hi_pitch_macro_release: .byte 1
                                 
002841                           pulse1_duty_macro: .byte 2
002843                           pulse1_duty_macro_offset: .byte 1
002844                           pulse1_duty_macro_loop: .byte 1
002845                           pulse1_duty_macro_release: .byte 1
                                 
002846                           pulse1_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002848                           pulse1_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00284a                           pulse1_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00284c                           pulse1_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00284e                           pulse1_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
002850                           pulse1_fx_3xx_start: .byte 2 //the starting note period
002852                           pulse1_fx_3xx_target: .byte 2 //target note period
002854                           pulse1_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
002856                           pulse1_fx_3xx_total_offset: .byte 2
002858                           pulse1_fx_4xy_speed: .byte 1
002859                           pulse1_fx_4xy_depth: .byte 1
00285a                           pulse1_fx_4xy_phase: .byte 1
00285b                           pulse1_fx_7xy_speed: .byte 1
00285c                           pulse1_fx_7xy_depth: .byte 1
00285d                           pulse1_fx_7xy_phase: .byte 1
00285e                           pulse1_fx_7xy_value: .byte 1 //value to offset the volume
00285f                           pulse1_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002860                           pulse1_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002861                           pulse1_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002862                           pulse1_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002864                           pulse1_fx_Qxy_target_note: .byte 1 //target note index
002865                           pulse1_fx_Qxy_target: .byte 2 //target note period
002867                           pulse1_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002869                           pulse1_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
00286b                           pulse1_fx_Rxy_target_note: .byte 1 //target note index
00286c                           pulse1_fx_Rxy_target: .byte 2 //target note period
00286e                           pulse1_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
002870                           pulse1_fx_Rxy_total_offset: .byte 2
002872                           pulse1_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002873                           pulse1_fx_Sxx_post: .byte 1
                                 
                                 //PULSE 2
002874                           pulse2_pattern: .byte 2
002876                           pulse2_pattern_delay_rows: .byte 1
002877                           pulse2_pattern_delay_frames: .byte 1
002878                           pulse2_pattern_offset: .byte 2
                                 
00287a                           pulse2_volume_macro: .byte 2
00287c                           pulse2_volume_macro_offset: .byte 1
00287d                           pulse2_volume_macro_loop: .byte 1
00287e                           pulse2_volume_macro_release: .byte 1
                                 
00287f                           pulse2_arpeggio_macro: .byte 2
002881                           pulse2_arpeggio_macro_offset: .byte 1
002882                           pulse2_arpeggio_macro_loop: .byte 1
002883                           pulse2_arpeggio_macro_release: .byte 1
002884                           pulse2_arpeggio_macro_mode: .byte 1
                                 
002885                           pulse2_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002887                           pulse2_pitch_macro: .byte 2
002889                           pulse2_pitch_macro_offset: .byte 1
00288a                           pulse2_pitch_macro_loop: .byte 1
00288b                           pulse2_pitch_macro_release: .byte 1
                                 
00288c                           pulse2_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00288d                           pulse2_hi_pitch_macro: .byte 2
00288f                           pulse2_hi_pitch_macro_offset: .byte 1
002890                           pulse2_hi_pitch_macro_loop: .byte 1
002891                           pulse2_hi_pitch_macro_release: .byte 1
                                 
002892                           pulse2_duty_macro: .byte 2
002894                           pulse2_duty_macro_offset: .byte 1
002895                           pulse2_duty_macro_loop: .byte 1
002896                           pulse2_duty_macro_release: .byte 1
                                 
002897                           pulse2_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002899                           pulse2_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
00289b                           pulse2_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
00289d                           pulse2_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
00289f                           pulse2_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028a1                           pulse2_fx_3xx_start: .byte 2 //the starting note period
0028a3                           pulse2_fx_3xx_target: .byte 2 //target note period
0028a5                           pulse2_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028a7                           pulse2_fx_3xx_total_offset: .byte 2
0028a9                           pulse2_fx_4xy_speed: .byte 1
0028aa                           pulse2_fx_4xy_depth: .byte 1
0028ab                           pulse2_fx_4xy_phase: .byte 1
0028ac                           pulse2_fx_7xy_speed: .byte 1
0028ad                           pulse2_fx_7xy_depth: .byte 1
0028ae                           pulse2_fx_7xy_phase: .byte 1
0028af                           pulse2_fx_7xy_value: .byte 1 //value to offset the volume
0028b0                           pulse2_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
0028b1                           pulse2_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028b2                           pulse2_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028b3                           pulse2_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
0028b5                           pulse2_fx_Qxy_target_note: .byte 1 //target note index
0028b6                           pulse2_fx_Qxy_target: .byte 2 //target note period
0028b8                           pulse2_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
0028ba                           pulse2_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
0028bc                           pulse2_fx_Rxy_target_note: .byte 1 //target note index
0028bd                           pulse2_fx_Rxy_target: .byte 2 //target note period
0028bf                           pulse2_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
0028c1                           pulse2_fx_Rxy_total_offset: .byte 2
0028c3                           pulse2_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
0028c4                           pulse2_fx_Sxx_post: .byte 1
                                 
                                 //TRIANGLE
0028c5                           triangle_pattern: .byte 2
0028c7                           triangle_pattern_delay_rows: .byte 1
0028c8                           triangle_pattern_delay_frames: .byte 1
0028c9                           triangle_pattern_offset: .byte 2
                                 
0028cb                           triangle_volume_macro: .byte 2
0028cd                           triangle_volume_macro_offset: .byte 1
0028ce                           triangle_volume_macro_loop: .byte 1
0028cf                           triangle_volume_macro_release: .byte 1
                                 
0028d0                           triangle_arpeggio_macro: .byte 2
0028d2                           triangle_arpeggio_macro_offset: .byte 1
0028d3                           triangle_arpeggio_macro_loop: .byte 1
0028d4                           triangle_arpeggio_macro_release: .byte 1
0028d5                           triangle_arpeggio_macro_mode: .byte 1
                                 
0028d6                           triangle_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
0028d8                           triangle_pitch_macro: .byte 2
0028da                           triangle_pitch_macro_offset: .byte 1
0028db                           triangle_pitch_macro_loop: .byte 1
0028dc                           triangle_pitch_macro_release: .byte 1
                                 
0028dd                           triangle_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
0028de                           triangle_hi_pitch_macro: .byte 2
0028e0                           triangle_hi_pitch_macro_offset: .byte 1
0028e1                           triangle_hi_pitch_macro_loop: .byte 1
0028e2                           triangle_hi_pitch_macro_release: .byte 1
                                 
0028e3                           triangle_duty_macro: .byte 2
0028e5                           triangle_duty_macro_offset: .byte 1
0028e6                           triangle_duty_macro_loop: .byte 1
0028e7                           triangle_duty_macro_release: .byte 1
                                 
0028e8                           triangle_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
0028ea                           triangle_fx_1xx: .byte 2 //refers to the rate in which to subtract the pitch from by the 1xx
0028ec                           triangle_fx_1xx_total: .byte 2 //the total pitch offset for 1xx
0028ee                           triangle_fx_2xx: .byte 2 //refers to the rate in which to add to the pitch by the 2xx
0028f0                           triangle_fx_2xx_total: .byte 2 //the total pitch offset for 2xx
0028f2                           triangle_fx_3xx_start: .byte 2 //the starting note period
0028f4                           triangle_fx_3xx_target: .byte 2 //target note period
0028f6                           triangle_fx_3xx_speed: .byte 2 //the amount to offset by to get to the target
0028f8                           triangle_fx_3xx_total_offset: .byte 2
0028fa                           triangle_fx_4xy_speed: .byte 1
0028fb                           triangle_fx_4xy_depth: .byte 1
0028fc                           triangle_fx_4xy_phase: .byte 1
0028fd                           triangle_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
0028fe                           triangle_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
0028ff                           triangle_fx_Pxx_total: .byte 2 //refers to the fine pitch offset set by the Pxx effect
002901                           triangle_fx_Qxy_target_note: .byte 1 //target note index
002902                           triangle_fx_Qxy_target: .byte 2 //target note period
002904                           triangle_fx_Qxy_speed: .byte 2 //the amount to offset by to get to the target
002906                           triangle_fx_Qxy_total_offset: .byte 2 //NOTE: due to the way the sound driver is setup, we need to keep track of the total pitch offset
002908                           triangle_fx_Rxy_target_note: .byte 1 //target note index
002909                           triangle_fx_Rxy_target: .byte 2 //target note period
00290b                           triangle_fx_Rxy_speed: .byte 2 //the amount to offset by to get to the target
00290d                           triangle_fx_Rxy_total_offset: .byte 2
00290f                           triangle_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002910                           triangle_fx_Sxx_post: .byte 1
                                 
                                 //NOISE
002911                           noise_pattern: .byte 2
002913                           noise_pattern_delay_rows: .byte 1
002914                           noise_pattern_delay_frames: .byte 1
002915                           noise_pattern_offset: .byte 2
                                 
002917                           noise_volume_macro: .byte 2
002919                           noise_volume_macro_offset: .byte 1
00291a                           noise_volume_macro_loop: .byte 1
00291b                           noise_volume_macro_release: .byte 1
                                 
00291c                           noise_arpeggio_macro: .byte 2
00291e                           noise_arpeggio_macro_offset: .byte 1
00291f                           noise_arpeggio_macro_loop: .byte 1
002920                           noise_arpeggio_macro_release: .byte 1
002921                           noise_arpeggio_macro_mode: .byte 1
                                 
002922                           noise_total_pitch_offset: .byte 2 //used to reference the overall change in pitch for the pitch macro
002924                           noise_pitch_macro: .byte 2
002926                           noise_pitch_macro_offset: .byte 1
002927                           noise_pitch_macro_loop: .byte 1
002928                           noise_pitch_macro_release: .byte 1
                                 
002929                           noise_total_hi_pitch_offset: .byte 1 //used to reference the overall change in pitch for the hi pitch macro
00292a                           noise_hi_pitch_macro: .byte 2
00292c                           noise_hi_pitch_macro_offset: .byte 1
00292d                           noise_hi_pitch_macro_loop: .byte 1
00292e                           noise_hi_pitch_macro_release: .byte 1
                                 
00292f                           noise_duty_macro: .byte 2
002931                           noise_duty_macro_offset: .byte 1
002932                           noise_duty_macro_loop: .byte 1
002933                           noise_duty_macro_release: .byte 1
                                 
002934                           noise_fx_0xy_sequence: .byte 2 //arpeggio sequence in the order of 00:xy. xy are from the parameters in 0xy
002936                           noise_fx_1xx: .byte 1 //refers to the rate in which to subtract the pitch from by the 1xx
002937                           noise_fx_1xx_total: .byte 1 //the total pitch offset for 1xx
002938                           noise_fx_2xx: .byte 1 //refers to the rate in which to add to the pitch by the 2xx
002939                           noise_fx_2xx_total: .byte 1 //the total pitch offset for 2xx
00293a                           noise_fx_4xy_speed: .byte 1
00293b                           noise_fx_4xy_depth: .byte 1
00293c                           noise_fx_4xy_phase: .byte 1
00293d                           noise_fx_4xy_offset: .byte 1
00293e                           noise_fx_7xy_speed: .byte 1
00293f                           noise_fx_7xy_depth: .byte 1
002940                           noise_fx_7xy_phase: .byte 1
002941                           noise_fx_7xy_value: .byte 1 //value to offset the volume
002942                           noise_fx_Axy: .byte 1 //refers to the decay/addition in volume set by the Axy effect NOTE: this value is a signed fractional byte, with the decimal between bits 3 and 4.
002943                           noise_fx_Gxx_pre: .byte 1 //holds the # of NES frames to wait before executing the current row
002944                           noise_fx_Gxx_post: .byte 1 //holds the # of NES frames to add to the delay before going to the next famitracker row NOTE: Gxx is limited to delay up till the end of the row it was called on
002945                           noise_fx_Pxx_total: .byte 1 //refers to the fine pitch offset set by the Pxx effect
002946                           noise_fx_Sxx_pre: .byte 1 //NOTE: Gxx and Sxx can not both be in effect at the same time. Sxx has priority.
002947                           noise_fx_Sxx_post: .byte 1
                                 
                                 //DPCM
002948                           dcpm_pattern_delay: .byte 1
                                 
                                 .cseg
                                 
                                 //NOTE: zero is defined in order to use the cp instruction without the need to load 0x00 into a register beforehand
                                 .def zero = r2
                                 .def pulse_channel_flags = r25 //[pulse1.pulse2] RSlc.RSlc = Reload, Start, Length halt/Loop, Constant volume
                                 .def pulse1_sequence = r10
                                 .def pulse1_length_counter = r11
                                 .def pulse1_sweep = r12 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse1_volume_divider = r16 //0000.PPPP = Period divider
                                 .def pulse1_volume_decay = r17 //0000.dddd = Decay
                                 .def pulse2_sequence = r13
                                 .def pulse2_length_counter = r14
                                 .def pulse2_sweep = r15 //NSSS.EPPP = Negate sweep flag, Shift, Enable sweep flag, Period divider
                                 .def pulse2_volume_divider = r18 //0000.PPPP = Period divider
                                 .def pulse2_volume_decay = r19 //0000.dddd = Decay
                                 .def triangle_sequence = r20
                                 .def noise_sequence_LOW = r21
                                 .def noise_sequence_HIGH = r22
                                 
                                 reset:
000000 940c 1155                 	jmp init
                                 
                                 .org TCA0_OVF_vect
00000e 940c 15e0                 	jmp sound_driver
                                 
                                 .org TCA0_CMP0_vect
000012 940c 14e7                 	jmp sequence_0_2
                                 
                                 .org TCA0_CMP1_vect
000014 940c 14f2                 	jmp sequence_1_3
                                 
                                 .org TCA0_CMP2_vect
000016 940c 14e7                 	jmp sequence_0_2
                                 
                                 .org TCB0_INT_vect
000018 940c 1509                 	jmp pulse1_sequence_routine
                                 
                                 .org TCB1_INT_vect
00001a 940c 1556                 	jmp pulse2_sequence_routine
                                 
                                 .org TCB2_INT_vect
000032 940c 15a3                 	jmp triangle_sequence_routine
                                 
                                 .org TCB3_INT_vect
000048 940c 15ae                 	jmp noise_sequence_routine
                                 
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(33): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(48): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(80): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(82): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(87): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(88): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(89): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(90): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(93): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(95): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(96): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(97): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(99): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(104): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(107): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(109): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(110): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(111): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(112): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(113): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(115): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(116): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(119): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(120): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(128): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(129): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(131): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(132): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(133): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(134): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(136): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(137): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(139): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(141): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(143): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(146): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(150): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(152): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(153): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(154): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(157): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(159): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(160): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(162): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(166): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(205): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(207): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(208): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(209): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(212): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(213): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(214): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(217): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(219): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(225): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(226): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(230): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(231): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm(238): warning: .cseg .db misalignment - padding zero byte
C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\main.asm(346): 'C:\Users\creat\Documents\NES_APU_2a03 - Timers\NES_APU_2a03\song_data.asm' included form here
                                 .list
                                 
                                 init:
                                 	//MAIN CLOCK
001155 edc8                      	ldi r28, CPU_CCP_IOREG_gc //protected write
001156 93c0 0034                 	sts CPU_CCP, r28
001158 e0c0                      	ldi r28, 0 << CLKCTRL_PEN_bp //disable prescaler for 20 MHz on main clock
001159 93c0 0061                 	sts CLKCTRL_MCLKCTRLB, r28
                                 
                                 	//ZERO
00115b 2422                      	clr zero
                                 
                                 	//MEMORY
00115c e3c0                      	ldi r28, 0b00110000
00115d 93c0 2800                 	sts pulse1_param, r28
00115f e8c0                      	ldi r28, 0b10000000
001160 93c0 2801                 	sts pulse1_sweep_param, r28
001162 efcf                      	ldi r28, 0xFF
001163 93c0 2802                 	sts pulse1_timerL, r28
001165 93c0 2803                 	sts pulse1_timerH, r28
001167 93c0 2804                 	sts pulse1_length, r28
                                 
001169 e3c0                      	ldi r28, 0b00110000
00116a 93c0 2808                 	sts pulse2_param, r28
00116c e8c0                      	ldi r28, 0b10000000
00116d 93c0 2809                 	sts pulse2_sweep_param, r28
00116f efcf                      	ldi r28, 0xFF
001170 93c0 280a                 	sts pulse2_timerL, r28
001172 93c0 280b                 	sts pulse2_timerH, r28
001174 93c0 280c                 	sts pulse2_length, r28
                                 
001176 efcf                      	ldi r28, 0xFF
001177 93c0 2810                 	sts triangle_timerL, r28
001179 93c0 2811                 	sts triangle_timerH, r28
                                 
00117b e3c0                      	ldi r28, 0b00110000
00117c 93c0 2813                 	sts noise_param, r28
00117e e0cf                      	ldi r28, 0b00001111
00117f 93c0 2814                 	sts noise_period, r28
                                 
001181 e0c2                      	ldi r28, 0x02
001182 93c0 281b                 	sts song_frame_offset, r28
001184 9220 281c                 	sts song_frame_offset+1, zero
001186 efcf                      	ldi r28, 0xFF
001187 93c0 2820                 	sts song_fx_Bxx, r28
001189 9220 2821                 	sts song_fx_Cxx, zero
00118b 9220 2822                 	sts song_fx_Dxx, zero
00118d e4ee                      	ldi ZL, LOW(song0_frames << 1)
00118e e0f3                      	ldi ZH, HIGH(song0_frames << 1)
00118f 93e0 2819                 	sts song_frames, ZL
001191 93f0 281a                 	sts song_frames+1, ZH
001193 91c5                      	lpm r28, Z+ //load the song size
001194 91d5                      	lpm r29, Z+
001195 93c0 281d                 	sts song_size, r28
001197 93d0 281e                 	sts song_size+1, r29
001199 9220 281f                 	sts song_speed, zero
                                 
                                 	//CHANNEL 0
00119b 91c5                      	lpm r28, Z+
00119c 91d5                      	lpm r29, Z+
00119d 0fcc                      	lsl r28
00119e 1fdd                      	rol r29
00119f 93c0 2823                 	sts pulse1_pattern, r28
0011a1 93d0 2824                 	sts pulse1_pattern+1, r29
0011a3 9220 2825                 	sts pulse1_pattern_delay_rows, zero
0011a5 9220 2826                 	sts pulse1_pattern_delay_frames, zero
0011a7 9220 2827                 	sts pulse1_pattern_offset, zero
0011a9 9220 2828                 	sts pulse1_pattern_offset+1, zero
                                 
                                 	//CHANNEL 1
0011ab 91c5                      	lpm r28, Z+
0011ac 91d5                      	lpm r29, Z+
0011ad 0fcc                      	lsl r28
0011ae 1fdd                      	rol r29
0011af 93c0 2874                 	sts pulse2_pattern, r28
0011b1 93d0 2875                 	sts pulse2_pattern+1, r29
0011b3 9220 2876                 	sts pulse2_pattern_delay_rows, zero
0011b5 9220 2877                 	sts pulse2_pattern_delay_frames, zero
0011b7 9220 2878                 	sts pulse2_pattern_offset, zero
0011b9 9220 2879                 	sts pulse2_pattern_offset+1, zero
                                 
                                 	//CHANNEL 2
0011bb 91c5                      	lpm r28, Z+
0011bc 91d5                      	lpm r29, Z+
0011bd 0fcc                      	lsl r28
0011be 1fdd                      	rol r29
0011bf 93c0 28c5                 	sts triangle_pattern, r28
0011c1 93d0 28c6                 	sts triangle_pattern+1, r29
0011c3 9220 28c7                 	sts triangle_pattern_delay_rows, zero
0011c5 9220 28c8                 	sts triangle_pattern_delay_frames, zero
0011c7 9220 28c9                 	sts triangle_pattern_offset, zero
0011c9 9220 28ca                 	sts triangle_pattern_offset+1, zero
                                 
                                 	//CHANNEL 3
0011cb 91c5                      	lpm r28, Z+
0011cc 91d5                      	lpm r29, Z+
0011cd 0fcc                      	lsl r28
0011ce 1fdd                      	rol r29
0011cf 93c0 2911                 	sts noise_pattern, r28
0011d1 93d0 2912                 	sts noise_pattern+1, r29
0011d3 9220 2913                 	sts noise_pattern_delay_rows, zero
0011d5 9220 2914                 	sts noise_pattern_delay_frames, zero
0011d7 9220 2915                 	sts noise_pattern_offset, zero
0011d9 9220 2916                 	sts noise_pattern_offset+1, zero
                                 
                                 	//CHANNEL 0 instrument macros
0011db efcf                      	ldi r28, 0xFF
0011dc 9220 282b                 	sts pulse1_volume_macro_offset, zero
0011de 93c0 282c                 	sts pulse1_volume_macro_loop, r28
0011e0 93c0 282d                 	sts pulse1_volume_macro_release, r28
0011e2 9220 2830                 	sts pulse1_arpeggio_macro_offset, zero
0011e4 93c0 2831                 	sts pulse1_arpeggio_macro_loop, r28
0011e6 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
0011e8 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
0011ea 9220 2838                 	sts pulse1_pitch_macro_offset, zero
0011ec 93c0 2839                 	sts pulse1_pitch_macro_loop, r28
0011ee 93c0 283a                 	sts pulse1_pitch_macro_release, r28
0011f0 9220 283e                 	sts pulse1_hi_pitch_macro_offset, zero
0011f2 93c0 283f                 	sts pulse1_hi_pitch_macro_loop, r28
0011f4 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
0011f6 9220 2843                 	sts pulse1_duty_macro_offset, zero
0011f8 93c0 2844                 	sts pulse1_duty_macro_loop, r28
0011fa 93c0 2845                 	sts pulse1_duty_macro_release, r28
                                 
0011fc 9220 2829                 	sts pulse1_volume_macro, zero
0011fe 9220 282a                 	sts pulse1_volume_macro+1, zero
001200 9220 282e                 	sts pulse1_arpeggio_macro, zero
001202 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
001204 9220 2834                 	sts pulse1_total_pitch_offset, zero
001206 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
001208 9220 2836                 	sts pulse1_pitch_macro, zero
00120a 9220 2837                 	sts pulse1_pitch_macro+1, zero
00120c 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
00120e 9220 283c                 	sts pulse1_hi_pitch_macro, zero
001210 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
001212 9220 2841                 	sts pulse1_duty_macro, zero
001214 9220 2842                 	sts pulse1_duty_macro+1, zero
                                 
                                 	//CHANNEL 0 ENVELOPE
001216 e00f                      	ldi pulse1_volume_divider, 0x0F
001217 9110 2800                 	lds pulse1_volume_decay, pulse1_param
001219 701f                      	andi pulse1_volume_decay, 0x0F //mask for VVVV bits
00121a 9190 2800                 	lds pulse_channel_flags, pulse1_param
00121c 7390                      	andi pulse_channel_flags, 0b00110000
00121d 6490                      	sbr pulse_channel_flags, 0b01000000 //set start flag
00121e 9220 2806                 	sts pulse1_output_volume, zero
001220 93c0 2805                 	sts pulse1_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 0 LENGTH
001222 2ebc                      	mov pulse1_length_counter, r28
                                 
                                 	//CHANNEL 0 SEQUENCE
001223 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
001224 2eac                      	mov pulse1_sequence, r28
                                 
                                 	//CHANNEL 0 SWEEP
001225 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param
001227 94c2                      	swap pulse1_sweep //swap data from high byte and low byte
001228 6890                      	sbr pulse_channel_flags, 0b10000000 //set reload flag
                                 
                                 	//CHANNEL 0 FX
001229 efcf                      	ldi r28, 0xFF
00122a 9220 2846                 	sts pulse1_fx_0xy_sequence, zero
00122c 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
00122e 9220 2848                 	sts pulse1_fx_1xx, zero
001230 9220 2849                 	sts pulse1_fx_1xx+1, zero
001232 9220 284a                 	sts pulse1_fx_1xx_total, zero
001234 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
001236 9220 284c                 	sts pulse1_fx_2xx, zero
001238 9220 284d                 	sts pulse1_fx_2xx+1, zero
00123a 9220 284e                 	sts pulse1_fx_2xx_total, zero
00123c 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
00123e 9220 2850                 	sts pulse1_fx_3xx_start, zero
001240 9220 2851                 	sts pulse1_fx_3xx_start+1, zero
001242 9220 2852                 	sts pulse1_fx_3xx_target, zero
001244 9220 2853                 	sts pulse1_fx_3xx_target+1, zero
001246 9220 2854                 	sts pulse1_fx_3xx_speed, zero
001248 9220 2855                 	sts pulse1_fx_3xx_speed+1, zero
00124a 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
00124c 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
00124e 9220 2858                 	sts pulse1_fx_4xy_speed, zero
001250 9220 2859                 	sts pulse1_fx_4xy_depth, zero
001252 9220 285a                 	sts pulse1_fx_4xy_phase, zero
001254 9220 285b                 	sts pulse1_fx_7xy_speed, zero
001256 9220 285c                 	sts pulse1_fx_7xy_depth, zero
001258 9220 285d                 	sts pulse1_fx_7xy_phase, zero
00125a 9220 285e                 	sts pulse1_fx_7xy_value, zero
00125c 9220 285f                 	sts pulse1_fx_Axy, zero
00125e 93c0 2860                 	sts pulse1_fx_Gxx_pre, r28
001260 93c0 2861                 	sts pulse1_fx_Gxx_post, r28
001262 9220 2862                 	sts pulse1_fx_Pxx_total, zero
001264 9220 2863                 	sts pulse1_fx_Pxx_total+1, zero
001266 9220 2864                 	sts pulse1_fx_Qxy_target_note, zero
001268 9220 2865                 	sts pulse1_fx_Qxy_target, zero
00126a 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
00126c 9220 2867                 	sts pulse1_fx_Qxy_speed, zero
00126e 9220 2868                 	sts pulse1_fx_Qxy_speed+1, zero
001270 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
001272 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
001274 9220 286b                 	sts pulse1_fx_Rxy_target_note, zero
001276 9220 286c                 	sts pulse1_fx_Rxy_target, zero
001278 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
00127a 9220 286e                 	sts pulse1_fx_Rxy_speed, zero
00127c 9220 286f                 	sts pulse1_fx_Rxy_speed+1, zero
00127e 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
001280 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
001282 93c0 2872                 	sts pulse1_fx_Sxx_pre, r28
001284 93c0 2873                 	sts pulse1_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 1 instrument macros
001286 efcf                      	ldi r28, 0xFF
001287 9220 287c                 	sts pulse2_volume_macro_offset, zero
001289 93c0 287d                 	sts pulse2_volume_macro_loop, r28
00128b 93c0 287e                 	sts pulse2_volume_macro_release, r28
00128d 9220 2881                 	sts pulse2_arpeggio_macro_offset, zero
00128f 93c0 2882                 	sts pulse2_arpeggio_macro_loop, r28
001291 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
001293 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
001295 9220 2889                 	sts pulse2_pitch_macro_offset, zero
001297 93c0 288a                 	sts pulse2_pitch_macro_loop, r28
001299 93c0 288b                 	sts pulse2_pitch_macro_release, r28
00129b 9220 288f                 	sts pulse2_hi_pitch_macro_offset, zero
00129d 93c0 2890                 	sts pulse2_hi_pitch_macro_loop, r28
00129f 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
0012a1 9220 2894                 	sts pulse2_duty_macro_offset, zero
0012a3 93c0 2895                 	sts pulse2_duty_macro_loop, r28
0012a5 93c0 2896                 	sts pulse2_duty_macro_release, r28
                                 
0012a7 9220 287a                 	sts pulse2_volume_macro, zero
0012a9 9220 287b                 	sts pulse2_volume_macro+1, zero
0012ab 9220 287f                 	sts pulse2_arpeggio_macro, zero
0012ad 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
0012af 9220 2885                 	sts pulse2_total_pitch_offset, zero
0012b1 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
0012b3 9220 2887                 	sts pulse2_pitch_macro, zero
0012b5 9220 2888                 	sts pulse2_pitch_macro+1, zero
0012b7 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
0012b9 9220 288d                 	sts pulse2_hi_pitch_macro, zero
0012bb 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
0012bd 9220 2892                 	sts pulse2_duty_macro, zero
0012bf 9220 2893                 	sts pulse2_duty_macro+1, zero
                                 
                                 	//CHANNEL 1 ENVELOPE
0012c1 e02f                      	ldi pulse2_volume_divider, 0x0F
0012c2 9130 2808                 	lds pulse2_volume_decay, pulse2_param
0012c4 703f                      	andi pulse2_volume_decay, 0x0F //mask for VVVV bits
0012c5 91d0 2808                 	lds r29, pulse2_param
0012c7 73d0                      	andi r29, 0b00110000
0012c8 62d0                      	sbr r29, 0b0100000 //set start flag
0012c9 95d2                      	swap r29
0012ca 2b9d                      	or pulse_channel_flags, r29
0012cb 9220 280e                 	sts pulse2_output_volume, zero
0012cd 93c0 280d                 	sts pulse2_fractional_volume, r28 //initialize fractional volume to max value
                                 	
                                 	//CHANNEL 1 LENGTH
0012cf 2eec                      	mov pulse2_length_counter, r28
                                 
                                 	//CHANNEL 1 SEQUENCE
0012d0 e0c1                      	ldi r28, 0b00000001 //12.5% is the default duty cycle sequence
0012d1 2edc                      	mov pulse2_sequence, r28
                                 
                                 	//CHANNEL 1 SWEEP
0012d2 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param
0012d4 94f2                      	swap pulse2_sweep //swap data from high byte and low byte
0012d5 6098                      	sbr pulse_channel_flags, 0b00001000 //set reload flag
                                 
                                 	//CHANNEL 1 FX
0012d6 efcf                      	ldi r28, 0xFF
0012d7 9220 2897                 	sts pulse2_fx_0xy_sequence, zero
0012d9 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
0012db 9220 2899                 	sts pulse2_fx_1xx, zero
0012dd 9220 289a                 	sts pulse2_fx_1xx+1, zero
0012df 9220 289b                 	sts pulse2_fx_1xx_total, zero
0012e1 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
0012e3 9220 289d                 	sts pulse2_fx_2xx, zero
0012e5 9220 289e                 	sts pulse2_fx_2xx+1, zero
0012e7 9220 289f                 	sts pulse2_fx_2xx_total, zero
0012e9 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
0012eb 9220 28a1                 	sts pulse2_fx_3xx_start, zero
0012ed 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero
0012ef 9220 28a3                 	sts pulse2_fx_3xx_target, zero
0012f1 9220 28a4                 	sts pulse2_fx_3xx_target+1, zero
0012f3 9220 28a5                 	sts pulse2_fx_3xx_speed, zero
0012f5 9220 28a6                 	sts pulse2_fx_3xx_speed+1, zero
0012f7 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
0012f9 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
0012fb 9220 28a9                 	sts pulse2_fx_4xy_speed, zero
0012fd 9220 28aa                 	sts pulse2_fx_4xy_depth, zero
0012ff 9220 28ab                 	sts pulse2_fx_4xy_phase, zero
001301 9220 28ac                 	sts pulse2_fx_7xy_speed, zero
001303 9220 28ad                 	sts pulse2_fx_7xy_depth, zero
001305 9220 28ae                 	sts pulse2_fx_7xy_phase, zero
001307 9220 28af                 	sts pulse2_fx_7xy_value, zero
001309 9220 28b0                 	sts pulse2_fx_Axy, zero
00130b 93c0 28b1                 	sts pulse2_fx_Gxx_pre, r28
00130d 93c0 28b2                 	sts pulse2_fx_Gxx_post, r28
00130f 9220 28b3                 	sts pulse2_fx_Pxx_total, zero
001311 9220 28b4                 	sts pulse2_fx_Pxx_total+1, zero
001313 9220 28b5                 	sts pulse2_fx_Qxy_target_note, zero
001315 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
001317 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001319 9220 28b8                 	sts pulse2_fx_Qxy_speed, zero
00131b 9220 28b9                 	sts pulse2_fx_Qxy_speed+1, zero
00131d 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
00131f 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
001321 9220 28bc                 	sts pulse2_fx_Rxy_target_note, zero
001323 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001325 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001327 9220 28bf                 	sts pulse2_fx_Rxy_speed, zero
001329 9220 28c0                 	sts pulse2_fx_Rxy_speed+1, zero
00132b 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
00132d 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
00132f 93c0 28c3                 	sts pulse2_fx_Sxx_pre, r28
001331 93c0 28c4                 	sts pulse2_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 2 instrument macros
001333 efcf                      	ldi r28, 0xFF
001334 9220 28cd                 	sts triangle_volume_macro_offset, zero
001336 93c0 28ce                 	sts triangle_volume_macro_loop, r28
001338 93c0 28cf                 	sts triangle_volume_macro_release, r28
00133a 9220 28d2                 	sts triangle_arpeggio_macro_offset, zero
00133c 93c0 28d3                 	sts triangle_arpeggio_macro_loop, r28
00133e 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
001340 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
001342 9220 28da                 	sts triangle_pitch_macro_offset, zero
001344 93c0 28db                 	sts triangle_pitch_macro_loop, r28
001346 93c0 28dc                 	sts triangle_pitch_macro_release, r28
001348 9220 28e0                 	sts triangle_hi_pitch_macro_offset, zero
00134a 93c0 28e1                 	sts triangle_hi_pitch_macro_loop, r28
00134c 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
00134e 9220 28e5                 	sts triangle_duty_macro_offset, zero
001350 93c0 28e6                 	sts triangle_duty_macro_loop, r28
001352 93c0 28e7                 	sts triangle_duty_macro_release, r28
                                 
001354 9220 28cb                 	sts triangle_volume_macro, zero
001356 9220 28cc                 	sts triangle_volume_macro+1, zero
001358 9220 28d0                 	sts triangle_arpeggio_macro, zero
00135a 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
00135c 9220 28d6                 	sts triangle_total_pitch_offset, zero
00135e 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001360 9220 28d8                 	sts triangle_pitch_macro, zero
001362 9220 28d9                 	sts triangle_pitch_macro+1, zero
001364 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
001366 9220 28de                 	sts triangle_hi_pitch_macro, zero
001368 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
00136a 9220 28e3                 	sts triangle_duty_macro, zero
00136c 9220 28e4                 	sts triangle_duty_macro+1, zero
                                 
                                 	//CHANNEL 2 SEQUENCE
00136e e0c0                      	ldi r28, 0b00000000 //reset sequence to 0
00136f 2f4c                      	mov triangle_sequence, r28
                                 
                                 	//CHANNEL 2 FX
001370 efcf                      	ldi r28, 0xFF
001371 9220 28e8                 	sts triangle_fx_0xy_sequence, zero
001373 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001375 9220 28ea                 	sts triangle_fx_1xx, zero
001377 9220 28eb                 	sts triangle_fx_1xx+1, zero
001379 9220 28ec                 	sts triangle_fx_1xx_total, zero
00137b 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
00137d 9220 28ee                 	sts triangle_fx_2xx, zero
00137f 9220 28ef                 	sts triangle_fx_2xx+1, zero
001381 9220 28f0                 	sts triangle_fx_2xx_total, zero
001383 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
001385 9220 28f2                 	sts triangle_fx_3xx_start, zero
001387 9220 28f3                 	sts triangle_fx_3xx_start+1, zero
001389 9220 28f4                 	sts triangle_fx_3xx_target, zero
00138b 9220 28f5                 	sts triangle_fx_3xx_target+1, zero
00138d 9220 28f6                 	sts triangle_fx_3xx_speed, zero
00138f 9220 28f7                 	sts triangle_fx_3xx_speed+1, zero
001391 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
001393 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001395 9220 28fa                 	sts triangle_fx_4xy_speed, zero
001397 9220 28fb                 	sts triangle_fx_4xy_depth, zero
001399 9220 28fc                 	sts triangle_fx_4xy_phase, zero
00139b 93c0 28fd                 	sts triangle_fx_Gxx_pre, r28
00139d 93c0 28fe                 	sts triangle_fx_Gxx_post, r28
00139f 9220 28ff                 	sts triangle_fx_Pxx_total, zero
0013a1 9220 2900                 	sts triangle_fx_Pxx_total+1, zero
0013a3 9220 2901                 	sts triangle_fx_Qxy_target_note, zero
0013a5 9220 2902                 	sts triangle_fx_Qxy_target, zero
0013a7 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
0013a9 9220 2904                 	sts triangle_fx_Qxy_speed, zero
0013ab 9220 2905                 	sts triangle_fx_Qxy_speed+1, zero
0013ad 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
0013af 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
0013b1 9220 2908                 	sts triangle_fx_Rxy_target_note, zero
0013b3 9220 2909                 	sts triangle_fx_Rxy_target, zero
0013b5 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
0013b7 9220 290b                 	sts triangle_fx_Rxy_speed, zero
0013b9 9220 290c                 	sts triangle_fx_Rxy_speed+1, zero
0013bb 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
0013bd 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
0013bf 93c0 290f                 	sts triangle_fx_Sxx_pre, r28
0013c1 93c0 2910                 	sts triangle_fx_Sxx_post, r28
                                 
                                 	//CHANNEL 3 instrument macros
0013c3 efcf                      	ldi r28, 0xFF
0013c4 9220 2919                 	sts noise_volume_macro_offset, zero
0013c6 93c0 291a                 	sts noise_volume_macro_loop, r28
0013c8 93c0 291b                 	sts noise_volume_macro_release, r28
0013ca 9220 291e                 	sts noise_arpeggio_macro_offset, zero
0013cc 93c0 291f                 	sts noise_arpeggio_macro_loop, r28
0013ce 93c0 2920                 	sts noise_arpeggio_macro_release, r28
0013d0 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
0013d2 9220 2926                 	sts noise_pitch_macro_offset, zero
0013d4 93c0 2927                 	sts noise_pitch_macro_loop, r28
0013d6 93c0 2928                 	sts noise_pitch_macro_release, r28
0013d8 9220 292c                 	sts noise_hi_pitch_macro_offset, zero
0013da 93c0 292d                 	sts noise_hi_pitch_macro_loop, r28
0013dc 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
0013de 9220 2931                 	sts noise_duty_macro_offset, zero
0013e0 93c0 2932                 	sts noise_duty_macro_loop, r28
0013e2 93c0 2933                 	sts noise_duty_macro_release, r28
                                 
0013e4 9220 2917                 	sts noise_volume_macro, zero
0013e6 9220 2918                 	sts noise_volume_macro+1, zero
0013e8 9220 291c                 	sts noise_arpeggio_macro, zero
0013ea 9220 291d                 	sts noise_arpeggio_macro+1, zero
0013ec 9220 2922                 	sts noise_total_pitch_offset, zero
0013ee 9220 2923                 	sts noise_total_pitch_offset+1, zero
0013f0 9220 2924                 	sts noise_pitch_macro, zero
0013f2 9220 2925                 	sts noise_pitch_macro+1, zero
0013f4 9220 2929                 	sts noise_total_hi_pitch_offset, zero
0013f6 9220 292a                 	sts noise_hi_pitch_macro, zero
0013f8 9220 292b                 	sts noise_hi_pitch_macro+1, zero
0013fa 9220 292f                 	sts noise_duty_macro, zero
0013fc 9220 2930                 	sts noise_duty_macro+1, zero
                                 
                                 	//CHANNEL 3 VOLUME
0013fe 9220 2816                 	sts noise_output_volume, zero
001400 93c0 2815                 	sts noise_fractional_volume, r28 //initialize fractional volume to max value
                                 
                                 	//CHANNEL 3 SEQUENCE
001402 e0c1                      	ldi r28, 0b00000001 //noise sequence is reset to 0x0001
001403 2f5c                      	mov noise_sequence_LOW, r28
001404 2d62                      	mov noise_sequence_HIGH, zero
                                 
                                 	//CHANNEL 3 FX
001405 efcf                      	ldi r28, 0xFF
001406 9220 2934                 	sts noise_fx_0xy_sequence, zero
001408 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
00140a 9220 2936                 	sts noise_fx_1xx, zero
00140c 9220 2937                 	sts noise_fx_1xx_total, zero
00140e 9220 2938                 	sts noise_fx_2xx, zero
001410 9220 2939                 	sts noise_fx_2xx_total, zero
001412 9220 293a                 	sts noise_fx_4xy_speed, zero
001414 9220 293b                 	sts noise_fx_4xy_depth, zero
001416 9220 293c                 	sts noise_fx_4xy_phase, zero
001418 9220 293d                 	sts noise_fx_4xy_offset, zero
00141a 9220 293e                 	sts noise_fx_7xy_speed, zero
00141c 9220 293f                 	sts noise_fx_7xy_depth, zero
00141e 9220 2940                 	sts noise_fx_7xy_phase, zero
001420 9220 2941                 	sts noise_fx_7xy_value, zero
001422 9220 2942                 	sts noise_fx_Axy, zero
001424 93c0 2943                 	sts noise_fx_Gxx_pre, r28
001426 93c0 2944                 	sts noise_fx_Gxx_post, r28
001428 9220 2945                 	sts noise_fx_Pxx_total, zero
00142a 93c0 2946                 	sts noise_fx_Sxx_pre, r28
00142c 93c0 2947                 	sts noise_fx_Sxx_post, r28
                                 
                                 	//PINS
00142e efcf                      	ldi r28, 0xFF
00142f b9c0                      	out VPORTA_DIR, r28 //set all pins in VPORTA to output
                                 
                                 	//TIMERS
                                 	//Frame Counter
                                 	//NOTE:The frame counter will be defaulted to NTSC mode (60 Hz, 120 Hz, 240 Hz)
                                 	//Each interrupt will be setup to interrupt every 240 Hz clock
                                 	//CMP0 = sequence 0, CMP1 = sequence 1, CMP2 = sequence 2, OVF = sequence 3/sound driver
                                 	//Sequence 3 will clock the sound driver every 60Hz, in which new audio data is read and written to the registers
                                 	//Timer period Calculation: (0.00416666666 * 20000000/64)-1 = 1301.08333125 = 0x0515
                                 	//The ATmega4809 is cofigured to run at 20000000 Hz
                                 	//0.00416666666 seconds is the period for 240 Hz
                                 	//The /64 comes from the prescaler divider used
001430 e7c0                      	ldi r28, TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_CMP1EN_bm | TCA_SINGLE_CMP2EN_bm | TCA_SINGLE_WGMODE_NORMAL_gc //interrupt mode
001431 93c0 0a01                 	sts TCA0_SINGLE_CTRLB, r28
001433 e7c1                      	ldi r28, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP1_bm | TCA_SINGLE_CMP2_bm | TCA_SINGLE_OVF_bm //enable overflow and compare interrupts
001434 93c0 0a0a                 	sts TCA0_SINGLE_INTCTRL, r28
001436 e1c5                      	ldi r28, 0x15 //set the period for CMP0
001437 93c0 0a28                 	sts TCA0_SINGLE_CMP0, r28
001439 e0c5                      	ldi r28, 0x05
00143a 93c0 0a29                 	sts TCA0_SINGLE_CMP0 + 1, r28
00143c e2cb                      	ldi r28, 0x2B //set the period for CMP1
00143d 93c0 0a2a                 	sts TCA0_SINGLE_CMP1, r28
00143f e0ca                      	ldi r28, 0x0A
001440 93c0 0a2b                 	sts TCA0_SINGLE_CMP1 + 1, r28
001442 e4c1                      	ldi r28, 0x41 //set the period for CMP2
001443 93c0 0a2c                 	sts TCA0_SINGLE_CMP2, r28
001445 e0cf                      	ldi r28, 0x0F
001446 93c0 0a2d                 	sts TCA0_SINGLE_CMP2 + 1, r28
001448 e5c7                      	ldi r28, 0x57 //set the period for OVF
001449 93c0 0a26                 	sts TCA0_SINGLE_PER, r28
00144b e1c4                      	ldi r28, 0x14
00144c 93c0 0a27                 	sts TCA0_SINGLE_PER + 1, r28
00144e e0cb                      	ldi r28, TCA_SINGLE_CLKSEL_DIV64_gc | TCA_SINGLE_ENABLE_bm //use prescale divider of 64 and enable timer
00144f 93c0 0a00                 	sts TCA0_SINGLE_CTRLA, r28
                                 
                                 	//NOTE: Channel Timers are clocked (20/2)/(0.8948865) = 11.1746014718 times faster than the NES APU
                                 	//Because of this, we multiply all the NES timer values by 11.1746014718 beforehand
                                 	//Since we rotate the sequence when the timer goes from t-(t-1) to 0, instead of 0 to t like the NES, we add 1 to the NES timers before multiplying
                                 	//The ATmega4809 is configured to run at 20 MHz
                                 	//The /2 comes from the prescaler divider used
                                 	//0.8948865 MHz is the speed of the NTSC NES APU
                                 	//NOTE: This means that any offset to the pitch for the NES timers would be multiplied by 11.1746014718 aswell.
                                 	//Pulse 1
001451 e0c0                      	ldi r28, TCB_CNTMODE_INT_gc //interrupt mode
001452 93c0 0a81                 	sts TCB0_CTRLB, r28
001454 e0c1                      	ldi r28, TCB_CAPT_bm //enable interrupts
001455 93c0 0a85                 	sts TCB0_INTCTRL, r28
001457 91c0 2802                 	lds r28, pulse1_timerL //load the LOW bits for timer
001459 93c0 0a8c                 	sts TCB0_CCMPL, r28
00145b 91c0 2803                 	lds r28, pulse1_timerH //load the HIGH bits for timer
00145d 93c0 0a8d                 	sts TCB0_CCMPH, r28
00145f e0c3                      	ldi r28, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001460 93c0 0a80                 	sts TCB0_CTRLA, r28
                                 
                                 	//PULSE 2
001462 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001463 93b0 0a91                 	sts TCB1_CTRLB, r27
001465 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001466 93b0 0a95                 	sts TCB1_INTCTRL, r27
001468 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00146a 93b0 0a9c                 	sts TCB1_CCMPL, r27
00146c 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
00146e 93b0 0a9d                 	sts TCB1_CCMPH, r27
001470 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001471 93b0 0a90                 	sts TCB1_CTRLA, r27
                                 
                                 	//NOTE: The triangle timer is clocked at the same speed as the NES CPU, aka twice the NES APU.
                                 	//Therefore, we won't be using a /2 clock divider like we did with the pulse timers.
                                 	//TRIANGLE
001473 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001474 93b0 0aa1                 	sts TCB2_CTRLB, r27
001476 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
                                 	//sts TCB2_INTCTRL, r27 //keep interrupts disabled to mute channel since triangle doesn't have volume bits
001477 91b0 2810                 	lds r27, triangle_timerL //load the LOW bits for timer
001479 93b0 0aac                 	sts TCB2_CCMPL, r27
00147b 91b0 2811                 	lds r27, triangle_timerH //load the HIGH bits for timer
00147d 93b0 0aad                 	sts TCB2_CCMPH, r27
00147f e0b1                      	ldi r27, TCB_CLKSEL_CLKDIV1_gc | TCB_ENABLE_bm //use prescaler divider of 1 and enable timer
001480 93b0 0aa0                 	sts TCB2_CTRLA, r27
001482 9478                      	sei //global interrupt enable
                                 
                                 	//NOISE
001483 e0b0                      	ldi r27, TCB_CNTMODE_INT_gc //interrupt mode
001484 93b0 0ab1                 	sts TCB3_CTRLB, r27
001486 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001487 93b0 0ab5                 	sts TCB3_INTCTRL, r27
001489 91b0 280a                 	lds r27, pulse2_timerL //load the LOW bits for timer
00148b 93b0 0abc                 	sts TCB3_CCMPL, r27
00148d 91b0 280b                 	lds r27, pulse2_timerH //load the HIGH bits for timer
00148f 93b0 0abd                 	sts TCB3_CCMPH, r27
001491 e0b3                      	ldi r27, TCB_CLKSEL_CLKDIV2_gc | TCB_ENABLE_bm //use prescaler divider of 2 and enable timer
001492 93b0 0ab0                 	sts TCB3_CTRLA, r27
                                 
                                 
                                 
                                 //https://wiki.nesdev.com/w/index.php/APU_Mixer
                                 volume_mixer:
001494 91c0 2806                 	lds r28, pulse1_output_volume
001496 91d0 280e                 	lds r29, pulse2_output_volume
                                 
                                 volume_mixer_pulse1:
001498 fea0                      	sbrs pulse1_sequence, 0 //if the sequence output is zero, return
001499 c015                      	rjmp volume_mixer_pulse1_off
                                 
00149a 14b2                      	cp pulse1_length_counter, zero //if length is zero, return
00149b f099                      	breq volume_mixer_pulse1_off
                                 
                                 	//NOTE: We will just mute the pulse when the current period is < $0008
                                 	//This is done in order to account for the sweep unit muting the channel when the period is < $0008,
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $0008 becomes $0059
00149c 91e0 0a8c                 	lds r30, TCB0_CCMPL
00149e e5f9                      	ldi r31, 0x59
00149f 17ef                      	cp r30, r31
0014a0 91e0 0a8d                 	lds r30, TCB0_CCMPH
0014a2 e0f0                      	ldi r31, 0x00
0014a3 07ef                      	cpc r30, r31
0014a4 f050                      	brlo volume_mixer_pulse1_off
                                 
                                 	//NOTE: Since it'd be too taxing to calculate a target period for every APU clock in the sweep unit,
                                 	//we will be muting the channel if it's period ever reaches $07FF, aka the target period was == $07FF
                                 	//Doing this does not account for the real NES "feature" of muting the pulse even if the sweep unit was disabled.
                                 	//Due to the 11.1746014718 timer multiplier being applied to the timer periods, $07FF becomes $595A
0014a5 91e0 0a8c                 	lds r30, TCB0_CCMPL
0014a7 e5fa                      	ldi r31, 0x5A
0014a8 17ef                      	cp r30, r31
0014a9 91e0 0a8d                 	lds r30, TCB0_CCMPH
0014ab e5f9                      	ldi r31, 0x59
0014ac 07ef                      	cpc r30, r31
0014ad f408                      	brsh volume_mixer_pulse1_off
0014ae c001                      	rjmp volume_mixer_pulse2 //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse1_off:
0014af 27cc                      	clr r28
                                 
                                 volume_mixer_pulse2:
0014b0 fed0                      	sbrs pulse2_sequence, 0 //if the sequence output is zero, return
0014b1 c015                      	rjmp volume_mixer_pulse2_off
                                 
0014b2 14e2                      	cp pulse2_length_counter, zero //if length is zero, return
0014b3 f099                      	breq volume_mixer_pulse2_off
                                 
0014b4 91e0 0a9c                 	lds r30, TCB1_CCMPL
0014b6 e5f9                      	ldi r31, 0x59
0014b7 17ef                      	cp r30, r31
0014b8 91e0 0a9d                 	lds r30, TCB1_CCMPH
0014ba e0f0                      	ldi r31, 0x00
0014bb 07ef                      	cpc r30, r31
0014bc f050                      	brlo volume_mixer_pulse2_off
                                 
0014bd 91e0 0a9c                 	lds r30, TCB1_CCMPL
0014bf e5fa                      	ldi r31, 0x5A
0014c0 17ef                      	cp r30, r31
0014c1 91e0 0a9d                 	lds r30, TCB1_CCMPH
0014c3 e5f9                      	ldi r31, 0x59
0014c4 07ef                      	cpc r30, r31
0014c5 f408                      	brsh volume_mixer_pulse2_off
0014c6 c001                      	rjmp volume_mixer_pulse_out //if the HIGH period == $59 && LOW period < $65, pulse is not off
                                 volume_mixer_pulse2_off:
0014c7 27dd                      	clr r29
                                 
                                 volume_mixer_pulse_out:
0014c8 0fcd                      	add r28, r29
0014c9 e6e2                      	ldi ZL, LOW(pulse_volume_table << 1)
0014ca e0f2                      	ldi ZH, HIGH(pulse_volume_table << 1)
0014cb 0fec                      	add ZL, r28
0014cc 1df2                      	adc ZH, zero
0014cd 91c4                      	lpm r28, Z
                                 
                                 volume_mixer_tnd_triangle:
0014ce 2fd4                      	mov r29, triangle_sequence
0014cf fdd4                      	sbrc r29, 4 //check 5th bit
0014d0 95d0                      	com r29
0014d1 70df                      	andi r29, 0x0F
0014d2 2fed                      	mov r30, r29
0014d3 0fde                      	add r29, r30 //multiply the triangle volume by 3
0014d4 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_noise:
0014d5 ff50                      	sbrs noise_sequence_LOW, 0 //check 0th bit, skip if set
0014d6 c006                      	rjmp volume_mixer_tnd_out
0014d7 91e0 2816                 	lds r30, noise_output_volume
0014d9 0fee                      	lsl r30 //multiply noise volume by 2
0014da b9e1                      	out VPORTA_OUT, r30
0014db cfb8                      	rjmp volume_mixer
0014dc 0fde                      	add r29, r30
                                 
                                 volume_mixer_tnd_out:
0014dd b821                      	out VPORTA_OUT, zero
0014de cfb5                      	rjmp volume_mixer
0014df e8e2                      	ldi ZL, LOW(tnd_volume_table << 1)
0014e0 e0f2                      	ldi ZH, HIGH(tnd_volume_table << 1)
0014e1 0fed                      	add ZL, r29
0014e2 1df2                      	adc ZH, zero
0014e3 91d4                      	lpm r29, Z
                                 
                                 volume_mixer_output:
0014e4 0fcd                      	add r28, r29
0014e5 b9c1                      	out VPORTA_OUT, r28
0014e6 cfad                      	rjmp volume_mixer
                                 
                                 
                                 
                                 //FRAME COUNTER/AUDIO SAMPLE ISR
                                 sequence_0_2:
0014e7 b7bf                      	in r27, CPU_SREG
0014e8 93bf                      	push r27
0014e9 94f8                      	cli
                                 
                                 	//ENVELOPE
0014ea d053                      	rcall pulse1_envelope_routine
0014eb d09f                      	rcall pulse2_envelope_routine
                                 
0014ec e5b0                      	ldi r27, TCA_SINGLE_CMP0_bm | TCA_SINGLE_CMP2_bm //clear OVF flag
0014ed 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
0014ef 91bf                      	pop r27
0014f0 bfbf                      	out CPU_SREG, r27
0014f1 9518                      	reti
                                 
                                 sequence_1_3:
0014f2 b7bf                      	in r27, CPU_SREG
0014f3 93bf                      	push r27
0014f4 94f8                      	cli
                                 
                                 	//ENVELOPE
0014f5 d048                      	rcall pulse1_envelope_routine
0014f6 d094                      	rcall pulse2_envelope_routine
                                 
                                 	//SWEEP
0014f7 fcc3                      	sbrc pulse1_sweep, 3 //check if the sweep enable bit is cleared
0014f8 d01b                      	rcall pulse1_sweep_routine
0014f9 fcf3                      	sbrc pulse2_sweep, 3
0014fa d066                      	rcall pulse2_sweep_routine
                                 
                                 	//LENGTH
                                 	//NOTE: The length routine is relatively simple, so we will not be using clocks to rjmp and ret to a seperate lable
                                 sequence_1_3_pulse1_length:
0014fb fd95                      	sbrc pulse_channel_flags, 5 //check if the length counter halt bit is cleared
0014fc c002                      	rjmp sequence_1_3_pulse2_length
0014fd 10b2                      	cpse pulse1_length_counter, zero //if length counter is already 0, don't decrement
0014fe 94ba                      	dec pulse1_length_counter
                                 sequence_1_3_pulse2_length:
0014ff fd91                      	sbrc pulse_channel_flags, 1 //check if the length counter halt bit is cleared
001500 c002                      	rjmp sequence_1_3_exit
001501 10e2                      	cpse pulse2_length_counter, zero //if length counter is already 0, don't decrement
001502 94ea                      	dec pulse2_length_counter
                                 
                                 sequence_1_3_exit:
001503 e2b1                      	ldi r27, TCA_SINGLE_CMP1_bm | TCA_SINGLE_OVF_bm //clear OVF flag
001504 93b0 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r27
001506 91bf                      	pop r27
001507 bfbf                      	out CPU_SREG, r27
001508 9518                      	reti
                                 
                                 //PULSE 1 ROUTINES
                                 pulse1_sequence_routine:
001509 b7bf                      	in r27, CPU_SREG
00150a 93bf                      	push r27
00150b 94f8                      	cli
                                 
00150c 0caa                      	lsl pulse1_sequence //shifts sequence to the left
00150d 1ca2                      	adc pulse1_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00150e e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00150f 93b0 0a86                 	sts TCB0_INTFLAGS, r27
001511 91bf                      	pop r27
001512 bfbf                      	out CPU_SREG, r27
001513 9518                      	reti
                                 
                                 pulse1_sweep_routine:
001514 2dbc                      	mov r27, pulse1_sweep
001515 70b7                      	andi r27, 0x07 //mask for period divider bits
001516 f4f9                      	brne pulse1_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse1_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001517 93df                      	push r29
001518 2ddc                      	mov r29, pulse1_sweep
001519 95d2                      	swap r29
00151a 70d7                      	andi r29, 0x07 //mask for shift bits
00151b f411                      	brne pulse1_sweep_routine_action_main //shift != 0
00151c 91df                      	pop r29
00151d c019                      	rjmp pulse1_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse1_sweep_routine_action_main:
00151e 91a0 0a8c                 	lds r26, TCB0_CCMPL
001520 91b0 0a8d                 	lds r27, TCB0_CCMPH
                                 pulse1_sweep_routine_action_main_loop:
001522 95b6                      	lsr r27
001523 95a7                      	ror r26
001524 95da                      	dec r29
001525 f7e1                      	brne pulse1_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001526 fec7                      	sbrs pulse1_sweep, 7 //check the negate flag
001527 c002                      	rjmp pulse1_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001528 95a0                      	com r26 //pulse1 uses one's complement if the negate flag is set
001529 95b0                      	com r27
                                 
                                 pulse1_sweep_routine_action_main_add:
00152a 91d0 0a8c                 	lds r29, TCB0_CCMPL //perform addition to get new timer period
00152c 0fad                      	add r26, r29
00152d 91d0 0a8d                 	lds r29, TCB0_CCMPH
00152f 1fbd                      	adc r27, r29
                                 
001530 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new LOW bits for timer
001532 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001534 91df                      	pop r29
001535 c001                      	rjmp pulse1_sweep_routine_check_reload
                                 
                                 pulse1_sweep_routine_decrement_divider:
001536 94ca                      	dec pulse1_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse1_sweep_routine_check_reload:
001537 ff97                      	sbrs pulse_channel_flags, 7 //if the reload flag is set, reload the sweep divider
001538 9508                      	ret
                                 
                                 pulse1_sweep_reload:
001539 90c0 2801                 	lds pulse1_sweep, pulse1_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
00153b 94c2                      	swap pulse1_sweep //bring data from high byte to low byte
00153c 779f                      	cbr pulse_channel_flags, 0b10000000 //clear reload flag
00153d 9508                      	ret
                                 
                                 
                                 
                                 pulse1_envelope_routine:
00153e fd96                      	sbrc pulse_channel_flags, 6 //check if start flag is cleared
00153f c010                      	rjmp pulse1_envelope_routine_clear_start
                                 
001540 3000                      	cpi pulse1_volume_divider, 0x00 //check if the divider is 0
001541 f011                      	breq PC+3 //if the divider == 0, check loop flag
001542 950a                      	dec pulse1_volume_divider //if the divider != 0, decrement and return
001543 9508                      	ret
                                 
001544 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the divider == 0, reset the divider period
001546 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001547 ff95                      	sbrs pulse_channel_flags, 5 //check if the loop flag is set
001548 c002                      	rjmp pulse1_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001549 e01f                      	ldi pulse1_volume_decay, 0x0F //if the loop flag is set, reset decay and return
00154a 9508                      	ret
                                 
                                 pulse1_envelope_routine_decrement_decay:
00154b 3010                      	cpi pulse1_volume_decay, 0x00 //check if the decay is 0
00154c f409                      	brne PC+2 //if decay != 0, go decrement
00154d 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
00154e 951a                      	dec pulse1_volume_decay
00154f 9508                      	ret
                                 
                                 pulse1_envelope_routine_clear_start:
001550 7b9f                      	cbr pulse_channel_flags, 0b01000000 //if the start flag is set, clear it
001551 9100 2800                 	lds pulse1_volume_divider, pulse1_param //if the start flag is set, reset the divider period
001553 700f                      	andi pulse1_volume_divider, 0x0F //mask for VVVV bits
001554 e01f                      	ldi pulse1_volume_decay, 0x0F //if the start flag is set, reset decay
001555 9508                      	ret
                                 
                                 //PULSE 2 ROUTINES
                                 pulse2_sequence_routine:
001556 b7bf                      	in r27, CPU_SREG
001557 93bf                      	push r27
001558 94f8                      	cli
                                 
001559 0cdd                      	lsl pulse2_sequence //shifts sequence to the left
00155a 1cd2                      	adc pulse2_sequence, zero //if the shifted bit was a 1, it will be added to the LSB
                                 
00155b e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
00155c 93b0 0a96                 	sts TCB1_INTFLAGS, r27
00155e 91bf                      	pop r27
00155f bfbf                      	out CPU_SREG, r27
001560 9518                      	reti
                                 
                                 pulse2_sweep_routine:
001561 2dbf                      	mov r27, pulse2_sweep
001562 70b7                      	andi r27, 0x07 //mask for period divider bits
001563 f4f9                      	brne pulse2_sweep_routine_decrement_divider //check if divider != 0
                                 
                                 pulse2_sweep_routine_action: //if the divider is == 0, update the pulse timer period
001564 93df                      	push r29
001565 2ddf                      	mov r29, pulse2_sweep
001566 95d2                      	swap r29
001567 70d7                      	andi r29, 0x07 //mask for shift bits
001568 f411                      	brne pulse2_sweep_routine_action_main //shift != 0
001569 91df                      	pop r29
00156a c019                      	rjmp pulse2_sweep_routine_check_reload //if the shift == 0, do nothing and return
                                 
                                 pulse2_sweep_routine_action_main:
00156b 91a0 0a9c                 	lds r26, TCB1_CCMPL
00156d 91b0 0a9d                 	lds r27, TCB1_CCMPH
                                 pulse2_sweep_routine_action_main_loop:
00156f 95b6                      	lsr r27
001570 95a7                      	ror r26
001571 95da                      	dec r29
001572 f7e1                      	brne pulse2_sweep_routine_action_main_loop //keep looping/shifting until shift count is 0
                                 
001573 fef7                      	sbrs pulse2_sweep, 7 //check the negate flag
001574 c002                      	rjmp pulse2_sweep_routine_action_main_add //if negate flag was clear, go straight to addition
                                 
001575 95a0                      	com r26 //pulse2 uses one's complement if the negate flag is set
001576 95b0                      	com r27
                                 
                                 pulse2_sweep_routine_action_main_add:
001577 91d0 0a9c                 	lds r29, TCB1_CCMPL //perform addition to get new timer period
001579 0fad                      	add r26, r29
00157a 91d0 0a9d                 	lds r29, TCB1_CCMPH
00157c 1fbd                      	adc r27, r29
                                 
00157d 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new LOW bits for timer
00157f 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new HIGH bits for timer
                                 	
001581 91df                      	pop r29
001582 c001                      	rjmp pulse2_sweep_routine_check_reload
                                 
                                 pulse2_sweep_routine_decrement_divider:
001583 94fa                      	dec pulse2_sweep //if the divider != 0, decrement the divider
                                 
                                 pulse2_sweep_routine_check_reload:
001584 ff93                      	sbrs pulse_channel_flags, 3 //if the reload flag is set, reload the sweep divider
001585 9508                      	ret
                                 
                                 pulse2_sweep_reload:
001586 90f0 2809                 	lds pulse2_sweep, pulse2_sweep_param //NOTE: since the reload flag is kept in bit 6, we clear the reload flag indirectly
001588 94f2                      	swap pulse2_sweep //bring data from high byte to low byte
001589 7f97                      	cbr pulse_channel_flags, 0b00001000 //clear reload flag
00158a 9508                      	ret
                                 
                                 
                                 
                                 pulse2_envelope_routine:
00158b fd92                      	sbrc pulse_channel_flags, 2 //check if start flag is cleared
00158c c010                      	rjmp pulse2_envelope_routine_clear_start
                                 
00158d 3020                      	cpi pulse2_volume_divider, 0x00 //check if the divider is 0
00158e f011                      	breq PC+3 //if the divider == 0, check loop flag
00158f 952a                      	dec pulse2_volume_divider //if the divider != 0, decrement and return
001590 9508                      	ret
                                 
001591 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the divider == 0, reset the divider period
001593 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
001594 ff91                      	sbrs pulse_channel_flags, 1 //check if the loop flag is set
001595 c002                      	rjmp pulse2_envelope_routine_decrement_decay //if the loop flag is not set, check the decay
001596 e03f                      	ldi pulse2_volume_decay, 0x0F //if the loop flag is set, reset decay and return
001597 9508                      	ret
                                 
                                 pulse2_envelope_routine_decrement_decay:
001598 3030                      	cpi pulse2_volume_decay, 0x00 //check if the decay is 0
001599 f409                      	brne PC+2 //if decay != 0, go decrement
00159a 9508                      	ret //if decay == 0 && loop flag == 0, do nothing and return
00159b 953a                      	dec pulse2_volume_decay
00159c 9508                      	ret
                                 
                                 pulse2_envelope_routine_clear_start:
00159d 7f9b                      	cbr pulse_channel_flags, 0b00000100 //if the start flag is set, clear it
00159e 9120 2808                 	lds pulse2_volume_divider, pulse2_param //if the start flag is set, reset the divider period
0015a0 702f                      	andi pulse2_volume_divider, 0x0F //mask for VVVV bits
0015a1 e03f                      	ldi pulse2_volume_decay, 0x0F //if the start flag is set, reset decay
0015a2 9508                      	ret
                                 
                                 //TRIANGLE ROUTINES
                                 triangle_sequence_routine:
0015a3 b7bf                      	in r27, CPU_SREG
0015a4 93bf                      	push r27
0015a5 94f8                      	cli
                                 
0015a6 5f4f                      	subi triangle_sequence, -1 //increment sequence by 1
0015a7 714f                      	andi triangle_sequence, 0b00011111 //mask out bits 5, 6 and 7 NOTE: the sequence only needs bits 0-4.
                                 
0015a8 e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0015a9 93b0 0aa6                 	sts TCB2_INTFLAGS, r27
0015ab 91bf                      	pop r27
0015ac bfbf                      	out CPU_SREG, r27
0015ad 9518                      	reti
                                 
                                 //NOISE ROUTINES
                                 noise_sequence_routine:
0015ae b7bf                      	in r27, CPU_SREG
0015af 93bf                      	push r27
0015b0 94f8                      	cli
                                 
0015b1 2fa5                      	mov r26, noise_sequence_LOW
0015b2 fd67                      	sbrc noise_sequence_HIGH, 7 //skip if MODE bit is clear
0015b3 c00b                      	rjmp noise_sequence_routine_mode_set
                                 
                                 noise_sequence_routine_mode_clear:
0015b4 95a6                      	lsr r26 //move the 1th bit to the 0th bit place
0015b5 27a5                      	eor r26, noise_sequence_LOW
0015b6 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0015b7 c003                      	rjmp noise_sequence_routine_mode_clear_EOR_set
                                 
                                 noise_sequence_routine_mode_clear_EOR_clear:
0015b8 9566                      	lsr noise_sequence_HIGH
0015b9 9557                      	ror noise_sequence_LOW
0015ba c013                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_clear_EOR_set:
0015bb 9566                      	lsr noise_sequence_HIGH
0015bc 9557                      	ror noise_sequence_LOW
0015bd 6460                      	ori noise_sequence_HIGH, 0b01000000 //set the 14th bit
0015be c00f                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set:
0015bf 0faa                      	lsl r26
0015c0 1faa                      	rol r26
0015c1 1faa                      	rol r26 //move the 6th bit to the 0th bit place
0015c2 27a5                      	eor r26, noise_sequence_LOW
0015c3 fda0                      	sbrc r26, 0 //skip if the EOR of bit 0 and 1 is clear
0015c4 c005                      	rjmp noise_sequence_routine_mode_set_EOR_set
                                 
                                 noise_sequence_routine_mode_set_EOR_clear:
0015c5 776f                      	cbr noise_sequence_HIGH, 0b10000000 //clear the MODE flag
0015c6 9566                      	lsr noise_sequence_HIGH
0015c7 9557                      	ror noise_sequence_LOW
0015c8 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0015c9 c004                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_routine_mode_set_EOR_set:
0015ca 9566                      	lsr noise_sequence_HIGH
0015cb 9557                      	ror noise_sequence_LOW
0015cc 6860                      	sbr noise_sequence_HIGH, 0b10000000 //set the MODE flag
0015cd c000                      	rjmp noise_sequence_exit
                                 
                                 noise_sequence_exit:
0015ce e0b1                      	ldi r27, TCB_CAPT_bm //clear OVF flag
0015cf 93b0 0ab6                 	sts TCB3_INTFLAGS, r27
0015d1 91bf                      	pop r27
0015d2 bfbf                      	out CPU_SREG, r27
0015d3 9518                      	reti
                                 
                                 //CONVERTERS
                                 //converts and loads 5 bit length to corresponding 8 bit length value into r29
                                 length_converter:
0015d4 e3e0                      	ldi ZL, LOW(length << 1)
0015d5 e5fc                      	ldi ZH, HIGH(length << 1)
0015d6 0fed                      	add ZL, r29
0015d7 1df2                      	adc ZH, zero
0015d8 91d4                      	lpm r29, Z
0015d9 9508                      	ret
                                 
                                 //loads pulse sequence into r29
                                 duty_cycle_sequences:
0015da e5e0                      	ldi ZL, LOW(sequences << 1)
0015db e5fc                      	ldi ZH, HIGH(sequences << 1)
0015dc 0fed                      	add ZL, r29
0015dd 1df2                      	adc ZH, zero
0015de 91d4                      	lpm r29, Z
0015df 9508                      	ret
                                 
                                 
                                 
                                 //SOUND DRIVER
                                 sound_driver:
0015e0 b7bf                      	in r27, CPU_SREG
0015e1 93bf                      	push r27
0015e2 94f8                      	cli
0015e3 93cf                      	push r28
0015e4 93df                      	push r29
0015e5 93ef                      	push r30
0015e6 93ff                      	push r31
                                 
                                 	//SOUND DRIVER
0015e7 91a0 2820                 	lds r26, song_fx_Bxx
0015e9 3faf                      	cpi r26, 0xFF //0xFF means that the flag is disabled
0015ea f4a9                      	brne sound_driver_fx_Bxx_routine
0015eb 91a0 2821                 	lds r26, song_fx_Cxx
0015ed 11a2                      	cpse r26, zero
0015ee c08b                      	rjmp sound_driver_fx_Cxx_routine
0015ef 91a0 2822                 	lds r26, song_fx_Dxx
0015f1 11a2                      	cpse r26, zero
0015f2 c096                      	rjmp sound_driver_fx_Dxx_routine
                                 
0015f3 91a0 281b                 	lds r26, song_frame_offset
0015f5 91b0 281c                 	lds r27, song_frame_offset+1
0015f7 91c0 281d                 	lds r28, song_size
0015f9 91d0 281e                 	lds r29, song_size+1
0015fb 17ac                      	cp r26, r28
0015fc 07bd                      	cpc r27, r29
0015fd f408                      	brsh sound_driver_fx_song_loop
0015fe c101                      	rjmp sound_driver_channel0
                                 
                                 
                                 sound_driver_fx_song_loop:
0015ff e0a0                      	ldi r26, 0x00
                                 sound_driver_fx_Bxx_routine:
001600 91e0 2819                 	lds ZL, song_frames
001602 91f0 281a                 	lds ZH, song_frames+1
001604 27cc                      	clr r28 //initialize r29:r28 to 0
001605 27dd                      	clr r29
001606 95a3                      	inc r26 //increment xx parameter by 1
                                 sound_driver_fx_Bxx_routine_loop:
001607 95aa                      	dec r26
001608 f011                      	breq sound_driver_fx_Bxx_routine_loop_exit //once r26 == 0, r29:r28 will hold Bxx*(5*2).
001609 962a                      	adiw r29:r28, 10 //increment the offset by 10 because 5 channels, and each address takes 2 bytes (5*2 = 10)
00160a cffc                      	rjmp sound_driver_fx_Bxx_routine_loop
                                 
                                 sound_driver_fx_Bxx_routine_loop_exit:
00160b 9622                      	adiw r29:r28, 2 //add 2 to skip the first 2 bytes (first 2 bytes is the song size)
00160c 93c0 281b                 	sts song_frame_offset, r28
00160e 93d0 281c                 	sts song_frame_offset+1, r29
001610 0fec                      	add ZL, r28
001611 1ffd                      	adc ZH, r29
                                 
001612 91a5                      	lpm r26, Z+ //load the address of the frame(pattern)
001613 91b5                      	lpm r27, Z+
001614 0faa                      	lsl r26
001615 1fbb                      	rol r27
001616 93a0 2823                 	sts pulse1_pattern, r26
001618 93b0 2824                 	sts pulse1_pattern+1, r27
00161a 91a5                      	lpm r26, Z+
00161b 91b5                      	lpm r27, Z+
00161c 0faa                      	lsl r26
00161d 1fbb                      	rol r27
00161e 93a0 2874                 	sts pulse2_pattern, r26
001620 93b0 2875                 	sts pulse2_pattern+1, r27
001622 91a5                      	lpm r26, Z+
001623 91b5                      	lpm r27, Z+
001624 0faa                      	lsl r26
001625 1fbb                      	rol r27
001626 93a0 28c5                 	sts triangle_pattern, r26
001628 93b0 28c6                 	sts triangle_pattern+1, r27
00162a 91a5                      	lpm r26, Z+
00162b 91b5                      	lpm r27, Z+
00162c 0faa                      	lsl r26
00162d 1fbb                      	rol r27
00162e 93a0 2911                 	sts noise_pattern, r26
001630 93b0 2912                 	sts noise_pattern+1, r27
                                 
001632 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001634 9220 2828                 	sts pulse1_pattern_offset+1, zero
001636 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
001638 9220 2826                 	sts pulse1_pattern_delay_frames, zero
00163a 9220 2878                 	sts pulse2_pattern_offset, zero
00163c 9220 2879                 	sts pulse2_pattern_offset+1, zero
00163e 9220 2876                 	sts pulse2_pattern_delay_rows, zero
001640 9220 2877                 	sts pulse2_pattern_delay_frames, zero
001642 9220 28c9                 	sts triangle_pattern_offset, zero
001644 9220 28ca                 	sts triangle_pattern_offset+1, zero
001646 9220 28c7                 	sts triangle_pattern_delay_rows, zero
001648 9220 28c8                 	sts triangle_pattern_delay_frames, zero
00164a 9220 2915                 	sts noise_pattern_offset, zero
00164c 9220 2916                 	sts noise_pattern_offset+1, zero
00164e 9220 2913                 	sts noise_pattern_delay_rows, zero
001650 9220 2914                 	sts noise_pattern_delay_frames, zero
                                 
001652 efaf                      	ldi r26, 0xFF
001653 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
001655 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
001657 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
001659 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
00165b 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
00165d 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
00165f 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
001661 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
001663 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
001665 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
001667 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
001669 93a0 2910                 	sts triangle_fx_Sxx_post, r26
00166b 93a0 2943                 	sts noise_fx_Gxx_pre, r26
00166d 93a0 2944                 	sts noise_fx_Gxx_post, r26
00166f 93a0 2946                 	sts noise_fx_Sxx_pre, r26
001671 93a0 2947                 	sts noise_fx_Sxx_post, r26
                                 
001673 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
001675 9220 2821                 	sts song_fx_Cxx, zero
001677 9220 2822                 	sts song_fx_Dxx, zero
001679 c086                      	rjmp sound_driver_channel0
                                 
                                 sound_driver_fx_Cxx_routine:
00167a 91ff                      	pop r31
00167b 91ef                      	pop r30
00167c 91df                      	pop r29
00167d 91cf                      	pop r28
00167e 91bf                      	pop r27
00167f bfbf                      	out CPU_SREG, r27
001680 94f8                      	cli //disable global interrupts
                                 		
001681 efaf                      	ldi r26, 0xFF
001682 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
001684 9220 2821                 	sts song_fx_Cxx, zero
001686 9220 2822                 	sts song_fx_Dxx, zero
001688 9518                      	reti
                                 
                                 sound_driver_fx_Dxx_routine:
001689 91e0 2819                 	lds ZL, song_frames
00168b 91f0 281a                 	lds ZH, song_frames+1
00168d 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00168f 91b0 281c                 	lds r27, song_frame_offset+1
001691 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
001692 93a0 281b                 	sts song_frame_offset, r26
001694 93b0 281c                 	sts song_frame_offset+1, r27
001696 0fea                      	add ZL, r26
001697 1ffb                      	adc ZH, r27
                                 
001698 91a5                      	lpm r26, Z+ //load the address of the next pattern
001699 91b5                      	lpm r27, Z+
00169a 0faa                      	lsl r26
00169b 1fbb                      	rol r27
00169c 93a0 2823                 	sts pulse1_pattern, r26
00169e 93b0 2824                 	sts pulse1_pattern+1, r27
0016a0 91a5                      	lpm r26, Z+
0016a1 91b5                      	lpm r27, Z+
0016a2 0faa                      	lsl r26
0016a3 1fbb                      	rol r27
0016a4 93a0 2874                 	sts pulse2_pattern, r26
0016a6 93b0 2875                 	sts pulse2_pattern+1, r27
0016a8 91a5                      	lpm r26, Z+
0016a9 91b5                      	lpm r27, Z+
0016aa 0faa                      	lsl r26
0016ab 1fbb                      	rol r27
0016ac 93a0 28c5                 	sts triangle_pattern, r26
0016ae 93b0 28c6                 	sts triangle_pattern+1, r27
0016b0 91a5                      	lpm r26, Z+
0016b1 91b5                      	lpm r27, Z+
0016b2 0faa                      	lsl r26
0016b3 1fbb                      	rol r27
0016b4 93a0 2911                 	sts noise_pattern, r26
0016b6 93b0 2912                 	sts noise_pattern+1, r27
                                 
0016b8 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0016ba 9220 2828                 	sts pulse1_pattern_offset+1, zero
0016bc 9220 2825                 	sts pulse1_pattern_delay_rows, zero //reset the delay to 0 as well
0016be 9220 2826                 	sts pulse1_pattern_delay_frames, zero
0016c0 9220 2878                 	sts pulse2_pattern_offset, zero
0016c2 9220 2879                 	sts pulse2_pattern_offset+1, zero
0016c4 9220 2876                 	sts pulse2_pattern_delay_rows, zero
0016c6 9220 2877                 	sts pulse2_pattern_delay_frames, zero
0016c8 9220 28c9                 	sts triangle_pattern_offset, zero
0016ca 9220 28ca                 	sts triangle_pattern_offset+1, zero
0016cc 9220 28c7                 	sts triangle_pattern_delay_rows, zero
0016ce 9220 28c8                 	sts triangle_pattern_delay_frames, zero
0016d0 9220 2915                 	sts noise_pattern_offset, zero
0016d2 9220 2916                 	sts noise_pattern_offset+1, zero
0016d4 9220 2913                 	sts noise_pattern_delay_rows, zero
0016d6 9220 2914                 	sts noise_pattern_delay_frames, zero
                                 
0016d8 efaf                      	ldi r26, 0xFF
0016d9 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //reset all Gxx and Sxx effects. if we don't channels can get desynced
0016db 93a0 2861                 	sts pulse1_fx_Gxx_post, r26
0016dd 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26
0016df 93a0 2873                 	sts pulse1_fx_Sxx_post, r26
0016e1 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26
0016e3 93a0 28b2                 	sts pulse2_fx_Gxx_post, r26
0016e5 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26
0016e7 93a0 28c4                 	sts pulse2_fx_Sxx_post, r26
0016e9 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26
0016eb 93a0 28fe                 	sts triangle_fx_Gxx_post, r26
0016ed 93a0 290f                 	sts triangle_fx_Sxx_pre, r26
0016ef 93a0 2910                 	sts triangle_fx_Sxx_post, r26
0016f1 93a0 2943                 	sts noise_fx_Gxx_pre, r26
0016f3 93a0 2944                 	sts noise_fx_Gxx_post, r26
0016f5 93a0 2946                 	sts noise_fx_Sxx_pre, r26
0016f7 93a0 2947                 	sts noise_fx_Sxx_post, r26
                                 
0016f9 93a0 2820                 	sts song_fx_Bxx, r26 //reset all song effects
0016fb 9220 2821                 	sts song_fx_Cxx, zero
0016fd 9220 2822                 	sts song_fx_Dxx, zero
0016ff c000                      	rjmp sound_driver_channel0
                                 
                                 
                                 
                                 sound_driver_channel0:
001700 91a0 2825                 	lds r26, pulse1_pattern_delay_rows
001702 91b0 2826                 	lds r27, pulse1_pattern_delay_frames
001704 9610                      	adiw r27:r26, 0
001705 f009                      	breq sound_driver_channel0_main //if the pattern delay is 0, proceed with sound driver procedures
001706 c2e4                      	rjmp sound_driver_channel0_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel0_main:
001707 91e0 2823                 	lds ZL, pulse1_pattern //current pattern for pulse 1
001709 91f0 2824                 	lds ZH, pulse1_pattern+1
00170b 91a0 2827                 	lds r26, pulse1_pattern_offset //current offset in the pattern for pulse 1
00170d 91b0 2828                 	lds r27, pulse1_pattern_offset+1
00170f 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001710 1ffb                      	adc ZH, r27
001711 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel0_check_if_note: //check if data is a note (0x00 - 0x56)
001712 35b7                      	cpi r27, 0x57
001713 f408                      	brsh sound_driver_channel0_check_if_volume
001714 c17c                      	rjmp sound_driver_channel0_note
                                 sound_driver_channel0_check_if_volume: //check if data is volume (0x57-0x66)
001715 36b7                      	cpi r27, 0x67
001716 f408                      	brsh sound_driver_channel0_check_if_delay
001717 c1ba                      	rjmp sound_driver_channel0_volume
                                 sound_driver_channel0_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001718 3eb3                      	cpi r27, 0xE3
001719 f408                      	brsh sound_driver_channel0_check_if_instrument
00171a c1c1                      	rjmp sound_driver_channel0_delay
                                 sound_driver_channel0_check_if_instrument: //check for instrument flag (0xE3)
00171b f409                      	brne sound_driver_channel0_check_if_release
00171c c1c4                      	rjmp sound_driver_channel0_instrument_change 
                                 sound_driver_channel0_check_if_release: //check for note release flag (0xE4)
00171d 3eb4                      	cpi r27, 0xE4
00171e f409                      	brne sound_driver_channel0_check_if_end
00171f c26d                      	rjmp sound_driver_channel0_release
                                 sound_driver_channel0_check_if_end:
001720 3fbf                      	cpi r27, 0xFF
001721 f409                      	brne sound_driver_channel0_check_if_fx
001722 c28f                      	rjmp sound_driver_channel0_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel0_check_if_fx: //fx flags (0xE5 - 0xFE)
001723 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001724 91a4                      	lpm r26, Z //load the fx data into r26
001725 d2bb                      	rcall sound_driver_channel0_increment_offset_twice
                                 
001726 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001727 e5e4                      	ldi ZL, LOW(channel0_fx << 1) //load in note table
001728 e5fc                      	ldi ZH, HIGH(channel0_fx << 1)
001729 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
00172a 0feb                      	add ZL, r27 //add offset
00172b 1df2                      	adc ZH, zero
00172c 91c5                      	lpm r28, Z+ //load address bytes
00172d 91d4                      	lpm r29, Z
00172e 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
00172f 2ffd                      	mov ZH, r29
001730 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel0_fx_0xy:
001731 93a0 2846                 	sts pulse1_fx_0xy_sequence, r26
001733 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
001735 cfd1                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel0_fx_1xx:
001736 9220 284c                 	sts pulse1_fx_2xx, zero //turn off any 2xx pitch slide down
001738 9220 284d                 	sts pulse1_fx_2xx+1, zero
00173a 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
00173c 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
00173e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00173f 937f                      	push r23
001740 2f6a                      	mov r22, r26 //store the rate into r22
001741 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001742 9f67                      	mul r22, r23
001743 917f                      	pop r23
001744 916f                      	pop r22
                                 
001745 9416                      	lsr r1 //shift out the fractional bits
001746 9407                      	ror r0
001747 9416                      	lsr r1
001748 9407                      	ror r0
001749 9416                      	lsr r1
00174a 9407                      	ror r0
00174b 9416                      	lsr r1
00174c 9407                      	ror r0
00174d 9200 2848                 	sts pulse1_fx_1xx, r0
00174f 9210 2849                 	sts pulse1_fx_1xx+1, r1
001751 cfb5                      	rjmp sound_driver_channel0_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel0_fx_2xx:
001752 9220 2848                 	sts pulse1_fx_1xx, zero //turn off any 1xx pitch slide down
001754 9220 2849                 	sts pulse1_fx_1xx+1, zero
001756 9220 2846                 	sts pulse1_fx_0xy_sequence, zero //disable any 0xy effect
001758 9220 2847                 	sts pulse1_fx_0xy_sequence+1, zero
00175a 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00175b 937f                      	push r23
00175c 2f6a                      	mov r22, r26 //store the rate into r22
00175d eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00175e 9f67                      	mul r22, r23
00175f 917f                      	pop r23
001760 916f                      	pop r22
                                 
001761 9416                      	lsr r1 //shift out the fractional bits
001762 9407                      	ror r0
001763 9416                      	lsr r1
001764 9407                      	ror r0
001765 9416                      	lsr r1
001766 9407                      	ror r0
001767 9416                      	lsr r1
001768 9407                      	ror r0
001769 9200 284c                 	sts pulse1_fx_2xx, r0
00176b 9210 284d                 	sts pulse1_fx_2xx+1, r1
00176d cf99                      	rjmp sound_driver_channel0_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel0_fx_3xx:
00176e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
00176f 937f                      	push r23
001770 2f6a                      	mov r22, r26 //store the rate into r22
001771 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001772 9f67                      	mul r22, r23
001773 917f                      	pop r23
001774 916f                      	pop r22
                                 
001775 9416                      	lsr r1 //shift out the fractional bits
001776 9407                      	ror r0
001777 9416                      	lsr r1
001778 9407                      	ror r0
001779 9416                      	lsr r1
00177a 9407                      	ror r0
00177b 9416                      	lsr r1
00177c 9407                      	ror r0
00177d 9200 2854                 	sts pulse1_fx_3xx_speed, r0
00177f 9210 2855                 	sts pulse1_fx_3xx_speed+1, r1
                                 
001781 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001782 c001                      	rjmp sound_driver_channel0_fx_3xx_enabled
001783 cf83                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_3xx_enabled:
001784 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001786 91b0 0a8d                 	lds r27, TCB0_CCMPH
001788 93a0 2850                 	sts pulse1_fx_3xx_start, r26
00178a 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
                                 
00178c 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero
00178e 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
001790 cf76                      	rjmp sound_driver_channel0_main
                                 
                                 //VIBRATO
                                 sound_driver_channel0_fx_4xy:
001791 2fba                      	mov r27, r26
001792 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001793 95a2                      	swap r26
001794 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001795 93a0 2858                 	sts pulse1_fx_4xy_speed, r26
001797 93b0 2859                 	sts pulse1_fx_4xy_depth, r27
001799 9220 285a                 	sts pulse1_fx_4xy_phase, zero //reset the phase to 0
00179b cf6b                      	rjmp sound_driver_channel0_main
                                 
                                 //TREMELO
                                 sound_driver_channel0_fx_7xy:
00179c 2fba                      	mov r27, r26
00179d 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
00179e 95a2                      	swap r26
00179f 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
0017a0 93a0 285b                 	sts pulse1_fx_7xy_speed, r26
0017a2 93b0 285c                 	sts pulse1_fx_7xy_depth, r27
0017a4 9220 285d                 	sts pulse1_fx_7xy_phase, zero //reset the phase to 0
0017a6 9220 285e                 	sts pulse1_fx_7xy_value, zero //reset the tremelo value
0017a8 cf5e                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel0_fx_Axy:
0017a9 93a0 285f                 	sts pulse1_fx_Axy, r26
0017ab cf5b                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel0_fx_Bxx:
0017ac 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
0017ae cf58                      	rjmp sound_driver_channel0_main
                                 
                                 //HALT
                                 sound_driver_channel0_fx_Cxx:
0017af 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0017b1 cf55                      	rjmp sound_driver_channel0_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel0_fx_Dxx:
0017b2 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
0017b4 cf52                      	rjmp sound_driver_channel0_main
                                 
                                 //VOLUME
                                 sound_driver_channel0_fx_Exx:
0017b5 91b0 2800                 	lds r27, pulse1_param
0017b7 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
0017b8 2bba                      	or r27, r26 //move new VVVV bits into pulse1_param
0017b9 93b0 2800                 	sts pulse1_param, r27
0017bb 6096                      	sbr pulse_channel_flags, 6
0017bc cf4a                      	rjmp sound_driver_channel0_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel0_fx_Fxx:
0017bd 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
0017bf cf47                      	rjmp sound_driver_channel0_main
                                 
                                 //DELAY
                                 sound_driver_channel0_fx_Gxx:
0017c0 15a2                      	cp r26, zero
0017c1 f051                      	breq sound_driver_channel0_fx_Gxx_invalid
0017c2 91b0 281f                 	lds r27, song_speed
0017c4 17ab                      	cp r26, r27
0017c5 f430                      	brsh sound_driver_channel0_fx_Gxx_invalid
0017c6 93a0 2860                 	sts pulse1_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
0017c8 e0b1                      	ldi r27, 0x01
0017c9 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
0017cb c222                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Gxx_invalid:
0017cc cf3a                      	rjmp sound_driver_channel0_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel0_fx_Hxy: //hardware sweep up
0017cd cf39                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixy: //hardware sweep down
0017ce cf38                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Hxx: //FDS modulation depth
0017cf cf37                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Ixx: //FDS modulation speed
0017d0 cf36                      	rjmp sound_driver_channel0_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel0_fx_Pxx:
0017d1 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0017d2 937f                      	push r23
0017d3 2f6a                      	mov r22, r26
0017d4 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0017d5 0367                      	mulsu r22, r23
0017d6 917f                      	pop r23
0017d7 916f                      	pop r22
0017d8 9416                      	lsr r1 //shift out the fractional bits
0017d9 9407                      	ror r0
0017da 9416                      	lsr r1
0017db 9407                      	ror r0
0017dc 9416                      	lsr r1
0017dd 9407                      	ror r0
0017de 9416                      	lsr r1
0017df 9407                      	ror r0
0017e0 fe13                      	sbrs r1, 3 //check if result was a negative number
0017e1 c002                      	rjmp sound_driver_channel0_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel0_fx_Pxx_negative:
0017e2 efb0                      	ldi r27, 0xF0
0017e3 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel0_fx_Pxx_store:
0017e4 9200 2862                 	sts pulse1_fx_Pxx_total, r0
0017e6 9210 2863                 	sts pulse1_fx_Pxx_total+1, r1
0017e8 cf1e                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel0_fx_Qxy:
                                 sound_driver_channel0_fx_Qxy_check_arpeggio_macro:
0017e9 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
0017eb 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
0017ed 9630                      	adiw Z, 0
0017ee f009                      	breq sound_driver_channel0_fx_Qxy_check_pitch_macro
0017ef cf17                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_pitch_macro:
0017f0 91e0 2836                 	lds ZL, pulse1_pitch_macro
0017f2 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
0017f4 9630                      	adiw Z, 0
0017f5 f009                      	breq sound_driver_channel0_fx_Qxy_check_hi_pitch_macro
0017f6 cf10                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_check_hi_pitch_macro:
0017f7 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
0017f9 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
0017fb 9630                      	adiw Z, 0
0017fc f009                      	breq sound_driver_channel0_fx_Qxy_process
0017fd cf09                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Qxy_process:
0017fe 2fba                      	mov r27, r26 //copy fx parameters into r27
0017ff 70bf                      	andi r27, 0x0F //mask note index offset
001800 91c0 2864                 	lds r28, pulse1_fx_Qxy_target_note //load current note index
001802 0fbc                      	add r27, r28
001803 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001804 f008                      	brlo sound_driver_channel0_fx_Qxy_process_continue
001805 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel0_fx_Qxy_process_continue:
001806 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
001808 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001809 e0f0                      	ldi ZH, HIGH(note_table << 1)
00180a 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
00180b 0feb                      	add ZL, r27 //add offset
00180c 1df2                      	adc ZH, zero
00180d 91c5                      	lpm r28, Z+ //load bytes
00180e 91d4                      	lpm r29, Z
00180f 93c0 2865                 	sts pulse1_fx_Qxy_target, r28 //load the LOW bits for the target period
001811 93d0 2866                 	sts pulse1_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Qxy_process_speed:
001813 95a2                      	swap r26
001814 70af                      	andi r26, 0x0F //mask effect speed
001815 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001816 95a3                      	inc r26 //increment the speed by 1
                                 
001817 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001818 937f                      	push r23
001819 2f6a                      	mov r22, r26 //store the speed data into r27
00181a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00181b 9f67                      	mul r22, r23
00181c 917f                      	pop r23
00181d 916f                      	pop r22
                                 
00181e 9416                      	lsr r1 //shift out the fractional bits
00181f 9407                      	ror r0
001820 9416                      	lsr r1
001821 9407                      	ror r0
001822 9416                      	lsr r1
001823 9407                      	ror r0
001824 9416                      	lsr r1
001825 9407                      	ror r0
                                 
001826 9200 2867                 	sts pulse1_fx_Qxy_speed, r0 //store the effect speed
001828 9210 2868                 	sts pulse1_fx_Qxy_speed+1, r1
00182a cedc                      	rjmp sound_driver_channel0_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel0_fx_Rxy:
                                 sound_driver_channel0_fx_Rxy_check_arpeggio_macro:
00182b 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
00182d 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
00182f 9630                      	adiw Z, 0
001830 f009                      	breq sound_driver_channel0_fx_Rxy_check_pitch_macro
001831 ced5                      	rjmp sound_driver_channel0_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_pitch_macro:
001832 91e0 2836                 	lds ZL, pulse1_pitch_macro
001834 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
001836 9630                      	adiw Z, 0
001837 f009                      	breq sound_driver_channel0_fx_Rxy_check_hi_pitch_macro
001838 cece                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_check_hi_pitch_macro:
001839 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
00183b 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
00183d 9630                      	adiw Z, 0
00183e f009                      	breq sound_driver_channel0_fx_Rxy_process
00183f cec7                      	rjmp sound_driver_channel0_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel0_fx_Rxy_process:
001840 2fba                      	mov r27, r26 //copy fx parameters into r27
001841 70bf                      	andi r27, 0x0F //mask note index offset
001842 91c0 286b                 	lds r28, pulse1_fx_Rxy_target_note //load current note index
001844 1bcb                      	sub r28, r27
001845 f408                      	brcc sound_driver_channel0_fx_Rxy_process_continue
001846 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel0_fx_Rxy_process_continue:
001847 93c0 286b                 	sts pulse1_fx_Rxy_target_note, r28
001849 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00184a e0f0                      	ldi ZH, HIGH(note_table << 1)
00184b 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
00184c 0fec                      	add ZL, r28 //add offset
00184d 1df2                      	adc ZH, zero
00184e 91c5                      	lpm r28, Z+ //load bytes
00184f 91d4                      	lpm r29, Z
001850 93c0 286c                 	sts pulse1_fx_Rxy_target, r28 //load the LOW bits for the target period
001852 93d0 286d                 	sts pulse1_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel0_fx_Rxy_process_speed:
001854 95a2                      	swap r26
001855 70af                      	andi r26, 0x0F //mask effect speed
001856 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001857 95a3                      	inc r26 //increment the speed by 1
                                 
001858 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001859 937f                      	push r23
00185a 2f6a                      	mov r22, r26 //store the speed data into r27
00185b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00185c 9f67                      	mul r22, r23
00185d 917f                      	pop r23
00185e 916f                      	pop r22
                                 
00185f 9416                      	lsr r1 //shift out the fractional bits
001860 9407                      	ror r0
001861 9416                      	lsr r1
001862 9407                      	ror r0
001863 9416                      	lsr r1
001864 9407                      	ror r0
001865 9416                      	lsr r1
001866 9407                      	ror r0
                                 
001867 9200 286e                 	sts pulse1_fx_Rxy_speed, r0 //store the effect speed
001869 9210 286f                 	sts pulse1_fx_Rxy_speed+1, r1
00186b ce9b                      	rjmp sound_driver_channel0_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel0_fx_Sxx:
00186c 15a2                      	cp r26, zero
00186d f051                      	breq sound_driver_channel0_fx_Sxx_invalid
00186e 91b0 281f                 	lds r27, song_speed
001870 17ab                      	cp r26, r27
001871 f430                      	brsh sound_driver_channel0_fx_Sxx_invalid
001872 93a0 2872                 	sts pulse1_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001874 e0b1                      	ldi r27, 0x01
001875 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
001877 c176                      	rjmp sound_driver_channel1
                                 sound_driver_channel0_fx_Sxx_invalid:
001878 ce8e                      	rjmp sound_driver_channel0_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel0_fx_Vxx:
001879 e5e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00187a e5fc                      	ldi ZH, HIGH(sequences << 1)
00187b 0fea                      	add ZL, r26 //offset the pointer
00187c 1df2                      	adc ZH, zero
                                 
00187d 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
00187e 95a7                      	ror r26
00187f 95a7                      	ror r26
001880 91b0 2800                 	lds r27, pulse1_param //load r27 with pulse1_param (register $4000)
001882 2fcb                      	mov r28, r27 //store a copy of pulse1_param into r28
001883 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001884 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001885 c001                      	rjmp sound_driver_channel0_fx_Vxx_store
001886 ce80                      	rjmp sound_driver_channel0_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel0_fx_Vxx_store:
001887 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
001888 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001889 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00188a 93c0 2800                 	sts pulse1_param, r28
00188c ce7a                      	rjmp sound_driver_channel0_main
                                 
                                 sound_driver_channel0_fx_Wxx: //DPCM sample speed
00188d ce79                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Xxx: //DPCM sample retrigger
00188e ce78                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Yxx: //DPCM sample offset
00188f ce77                      	rjmp sound_driver_channel0_main
                                 sound_driver_channel0_fx_Zxx: //DPCM sample delta counter
001890 ce76                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 sound_driver_channel0_note:
001891 93b0 2807                 	sts pulse1_note, r27 //store the note index
001893 93b0 2864                 	sts pulse1_fx_Qxy_target_note, r27
001895 93b0 286b                 	sts pulse1_fx_Rxy_target_note, r27
001897 e0a3                      	ldi r26, 0x03
001898 e0b2                      	ldi r27, 0x02
001899 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
00189b 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
00189d 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
00189f 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
0018a1 93b0 2843                 	sts pulse1_duty_macro_offset, r27
0018a3 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch and hi pitch offset
0018a5 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
0018a7 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
0018a9 9220 284a                 	sts pulse1_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
0018ab 9220 284b                 	sts pulse1_fx_1xx_total+1, zero
0018ad 9220 284e                 	sts pulse1_fx_2xx_total, zero
0018af 9220 284f                 	sts pulse1_fx_2xx_total+1, zero
0018b1 9220 2856                 	sts pulse1_fx_3xx_total_offset, zero //reset 3xx offset
0018b3 9220 2857                 	sts pulse1_fx_3xx_total_offset+1, zero
0018b5 91a0 0a8c                 	lds r26, TCB0_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
0018b7 91b0 0a8d                 	lds r27, TCB0_CCMPH
0018b9 93a0 2850                 	sts pulse1_fx_3xx_start, r26
0018bb 93b0 2851                 	sts pulse1_fx_3xx_start+1, r27
0018bd 9220 2801                 	sts pulse1_sweep_param, zero //reset any sweep effect
0018bf 6097                      	sbr pulse_channel_flags, 7 //set reload flag
0018c0 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
0018c2 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
0018c4 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero
0018c6 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
0018c8 9220 286c                 	sts pulse1_fx_Rxy_target, zero
0018ca 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
0018cc 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero
0018ce 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
0018d0 d106                      	rcall sound_driver_channel0_increment_offset
0018d1 ce35                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_volume:
0018d2 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
0018d3 91a0 2800                 	lds r26, pulse1_param
0018d5 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
0018d6 2bab                      	or r26, r27 //move new VVVV bits into pulse1_param
0018d7 93a0 2800                 	sts pulse1_param, r26
0018d9 6096                      	sbr pulse_channel_flags, 6
0018da d0fc                      	rcall sound_driver_channel0_increment_offset
0018db ce2b                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_delay:
0018dc 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
0018dd 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
0018df d0f7                      	rcall sound_driver_channel0_increment_offset
0018e0 c10d                      	rjmp sound_driver_channel1
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change:
0018e1 9220 2829                 	sts pulse1_volume_macro, zero //reset all macro addresses
0018e3 9220 282a                 	sts pulse1_volume_macro+1, zero
0018e5 9220 282e                 	sts pulse1_arpeggio_macro, zero
0018e7 9220 282f                 	sts pulse1_arpeggio_macro+1, zero
0018e9 9220 2836                 	sts pulse1_pitch_macro, zero
0018eb 9220 2837                 	sts pulse1_pitch_macro+1, zero
0018ed 9220 283c                 	sts pulse1_hi_pitch_macro, zero
0018ef 9220 283d                 	sts pulse1_hi_pitch_macro+1, zero
0018f1 9220 2841                 	sts pulse1_duty_macro, zero
0018f3 9220 2842                 	sts pulse1_duty_macro+1, zero
0018f5 9220 2834                 	sts pulse1_total_pitch_offset, zero //reset the pitch offset
0018f7 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
0018f9 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
0018fb 9631                      	adiw Z, 1 //point to the byte next to the flag
0018fc 91b4                      	lpm r27, Z //store the instrument offset into r27
0018fd e7e1                      	ldi ZL, LOW(instruments) //point Z to instruments table
0018fe e1f0                      	ldi ZH, HIGH(instruments)
0018ff 0feb                      	add ZL, r27 //point Z to offsetted instrument
001900 1df2                      	adc ZH, zero
001901 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001902 1fff                      	rol ZH
001903 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001904 91b4                      	lpm r27, Z
                                 
001905 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001906 1fbb                      	rol r27
001907 2fea                      	mov ZL, r26
001908 2ffb                      	mov ZH, r27
001909 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
00190a 9632                      	adiw Z, 2 //point Z to the address of the macro
00190b e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel0_instrument_change_macro_loop:
00190c 95aa                      	dec r26
00190d f019                      	breq sound_driver_channel0_instrument_change_exit
00190e 95b6                      	lsr r27
00190f f078                      	brcs sound_driver_channel0_instrument_change_load_macro
001910 cffb                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_exit:
001911 e0a3                      	ldi r26, 0x03
001912 e0b2                      	ldi r27, 0x02
001913 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //reset all macro offsets
001915 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
001917 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
001919 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
00191b 93b0 2843                 	sts pulse1_duty_macro_offset, r27
00191d d0c3                      	rcall sound_driver_channel0_increment_offset_twice
00191e cde8                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_load_macro:
00191f 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001920 91d5                      	lpm r29, Z+
                                 
001921 30a5                      	cpi r26, 5
001922 f039                      	breq sound_driver_channel0_instrument_change_load_macro_volume
001923 30a4                      	cpi r26, 4
001924 f079                      	breq sound_driver_channel0_instrument_change_load_macro_arpeggio
001925 30a3                      	cpi r26, 3
001926 f0d9                      	breq sound_driver_channel0_instrument_change_load_macro_pitch
001927 30a2                      	cpi r26, 2
001928 f159                      	breq sound_driver_channel0_instrument_change_load_macro_hi_pitch
001929 c03c                      	rjmp sound_driver_channel0_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel0_instrument_change_load_macro_volume:
00192a 93c0 2829                 	sts pulse1_volume_macro, r28
00192c 93d0 282a                 	sts pulse1_volume_macro+1, r29
00192e d041                      	rcall sound_driver_channel0_instrument_change_read_header
00192f 93c0 282d                 	sts pulse1_volume_macro_release, r28
001931 93d0 282c                 	sts pulse1_volume_macro_loop, r29
001933 cfd8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 	
                                 sound_driver_channel0_instrument_change_load_macro_arpeggio:
001934 93c0 282e                 	sts pulse1_arpeggio_macro, r28
001936 93d0 282f                 	sts pulse1_arpeggio_macro+1, r29
001938 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00193a 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
00193c 9220 286c                 	sts pulse1_fx_Rxy_target, zero
00193e 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001940 d03a                      	rcall sound_driver_channel0_instrument_change_read_header_arpeggio
001941 cfca                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_pitch:
001942 93c0 2836                 	sts pulse1_pitch_macro, r28
001944 93d0 2837                 	sts pulse1_pitch_macro+1, r29
001946 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001948 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
00194a 9220 286c                 	sts pulse1_fx_Rxy_target, zero
00194c 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
00194e d021                      	rcall sound_driver_channel0_instrument_change_read_header
00194f 93c0 283a                 	sts pulse1_pitch_macro_release, r28
001951 93d0 2839                 	sts pulse1_pitch_macro_loop, r29
001953 cfb8                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_hi_pitch:
001954 93c0 283c                 	sts pulse1_hi_pitch_macro, r28
001956 93d0 283d                 	sts pulse1_hi_pitch_macro+1, r29
001958 9220 2865                 	sts pulse1_fx_Qxy_target, zero //reset the Qxy, Rxy effects
00195a 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
00195c 9220 286c                 	sts pulse1_fx_Rxy_target, zero
00195e 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
001960 d00f                      	rcall sound_driver_channel0_instrument_change_read_header
001961 93c0 2840                 	sts pulse1_hi_pitch_macro_release, r28
001963 93d0 283f                 	sts pulse1_hi_pitch_macro_loop, r29
001965 cfa6                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 sound_driver_channel0_instrument_change_load_macro_duty:
001966 93c0 2841                 	sts pulse1_duty_macro, r28
001968 93d0 2842                 	sts pulse1_duty_macro+1, r29
00196a d005                      	rcall sound_driver_channel0_instrument_change_read_header
00196b 93c0 2845                 	sts pulse1_duty_macro_release, r28
00196d 93d0 2844                 	sts pulse1_duty_macro_loop, r29
00196f cf9c                      	rjmp sound_driver_channel0_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel0_instrument_change_read_header:
001970 93ef                      	push ZL
001971 93ff                      	push ZH
001972 2fec                      	mov ZL, r28
001973 2ffd                      	mov ZH, r29
001974 0fee                      	lsl ZL
001975 1fff                      	rol ZH
001976 91c5                      	lpm r28, Z+
001977 91d4                      	lpm r29, Z
001978 91ff                      	pop ZH
001979 91ef                      	pop ZL
00197a 9508                      	ret
                                 
                                 sound_driver_channel0_instrument_change_read_header_arpeggio:
00197b 93ef                      	push ZL
00197c 93ff                      	push ZH
00197d 2fec                      	mov ZL, r28
00197e 2ffd                      	mov ZH, r29
00197f 0fee                      	lsl ZL
001980 1fff                      	rol ZH
001981 91c5                      	lpm r28, Z+
001982 91d5                      	lpm r29, Z+
001983 93c0 2832                 	sts pulse1_arpeggio_macro_release, r28
001985 93d0 2831                 	sts pulse1_arpeggio_macro_loop, r29
001987 91c4                      	lpm r28, Z
001988 93c0 2833                 	sts pulse1_arpeggio_macro_mode, r28
00198a 91ff                      	pop ZH
00198b 91ef                      	pop ZL
00198c 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel0_release:
                                 sound_driver_channel0_release_volume:
00198d 91b0 282d                 	lds r27, pulse1_volume_macro_release
00198f 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001990 f019                      	breq sound_driver_channel0_release_arpeggio //if the macro has no release flag, check the next macro
001991 95b3                      	inc r27
001992 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel0_release_arpeggio:
001994 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
001996 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001997 f019                      	breq sound_driver_channel0_release_pitch
001998 95b3                      	inc r27
001999 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27
                                 sound_driver_channel0_release_pitch:
00199b 91b0 283a                 	lds r27, pulse1_pitch_macro_release
00199d 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
00199e f019                      	breq sound_driver_channel0_release_hi_pitch
00199f 95b3                      	inc r27
0019a0 93b0 2838                 	sts pulse1_pitch_macro_offset, r27
                                 sound_driver_channel0_release_hi_pitch:
0019a2 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
0019a4 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
0019a5 f019                      	breq sound_driver_channel0_release_duty
0019a6 95b3                      	inc r27
0019a7 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27
                                 sound_driver_channel0_release_duty:
0019a9 91b0 2845                 	lds r27, pulse1_duty_macro_release
0019ab 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
0019ac f019                      	breq sound_driver_channel0_release_exit
0019ad 95b3                      	inc r27
0019ae 93b0 2843                 	sts pulse1_duty_macro_offset, r27
                                 sound_driver_channel0_release_exit:
0019b0 d026                      	rcall sound_driver_channel0_increment_offset
0019b1 cd55                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_next_pattern:
0019b2 91e0 2819                 	lds ZL, song_frames
0019b4 91f0 281a                 	lds ZH, song_frames+1
0019b6 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
0019b8 91b0 281c                 	lds r27, song_frame_offset+1
0019ba 961a                      	adiw r27:r26, 10 //increment the frame offset by (5*2 = 10) since there are 5 channel patterns per frame. We *2 because we are getting byte values from the table
0019bb 93a0 281b                 	sts song_frame_offset, r26
0019bd 93b0 281c                 	sts song_frame_offset+1, r27
                                 
0019bf 91c0 281d                 	lds r28, song_size
0019c1 91d0 281e                 	lds r29, song_size+1
0019c3 17ac                      	cp r26, r28
0019c4 07bd                      	cpc r27, r29
0019c5 f010                      	brlo sound_driver_channel0_next_pattern_exists
0019c6 940c 2e12                 	jmp sound_driver_exit
                                 
                                 sound_driver_channel0_next_pattern_exists:
0019c8 0fea                      	add ZL, r26
0019c9 1ffb                      	adc ZH, r27
                                 
0019ca 91a5                      	lpm r26, Z+ //load the address of the next pattern
0019cb 91b4                      	lpm r27, Z
0019cc 0faa                      	lsl r26
0019cd 1fbb                      	rol r27
0019ce 93a0 2823                 	sts pulse1_pattern, r26
0019d0 93b0 2824                 	sts pulse1_pattern+1, r27
                                 
0019d2 9220 2827                 	sts pulse1_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
0019d4 9220 2828                 	sts pulse1_pattern_offset+1, zero
0019d6 cd30                      	rjmp sound_driver_channel0_main
                                 
                                 
                                 
                                 sound_driver_channel0_increment_offset:
0019d7 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0019d9 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
0019db 9631                      	adiw Z, 1
0019dc 93e0 2827                 	sts pulse1_pattern_offset, ZL
0019de 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
0019e0 9508                      	ret
                                 
                                 sound_driver_channel0_increment_offset_twice: //used for data that takes up 2 bytes worth of space
0019e1 91e0 2827                 	lds ZL, pulse1_pattern_offset //current offset in the pattern for pulse 1
0019e3 91f0 2828                 	lds ZH, pulse1_pattern_offset+1
0019e5 9632                      	adiw Z, 2 //increment the pointer twice
0019e6 93e0 2827                 	sts pulse1_pattern_offset, ZL
0019e8 93f0 2828                 	sts pulse1_pattern_offset+1, ZH
0019ea 9508                      	ret
                                 
                                 sound_driver_channel0_decrement_frame_delay:
0019eb 95ba                      	dec r27
0019ec 93b0 2826                 	sts pulse1_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel1:
0019ee 91a0 2876                 	lds r26, pulse2_pattern_delay_rows
0019f0 91b0 2877                 	lds r27, pulse2_pattern_delay_frames
0019f2 9610                      	adiw r27:r26, 0
0019f3 f009                      	breq sound_driver_channel1_main //if the pattern delay is 0, proceed with sound driver procedures
0019f4 c2d7                      	rjmp sound_driver_channel1_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel1_main:
0019f5 91e0 2874                 	lds ZL, pulse2_pattern //current pattern for pulse 2
0019f7 91f0 2875                 	lds ZH, pulse2_pattern+1
0019f9 91a0 2878                 	lds r26, pulse2_pattern_offset //current offset in the pattern for pulse 2
0019fb 91b0 2879                 	lds r27, pulse2_pattern_offset+1
0019fd 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
0019fe 1ffb                      	adc ZH, r27
0019ff 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel1_check_if_note: //check if data is a note (0x00 - 0x56)
001a00 35b7                      	cpi r27, 0x57
001a01 f408                      	brsh sound_driver_channel1_check_if_volume
001a02 c17c                      	rjmp sound_driver_channel1_note
                                 sound_driver_channel1_check_if_volume: //check if data is volume (0x57-0x66)
001a03 36b7                      	cpi r27, 0x67
001a04 f408                      	brsh sound_driver_channel1_check_if_delay
001a05 c1ba                      	rjmp sound_driver_channel1_volume
                                 sound_driver_channel1_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001a06 3eb3                      	cpi r27, 0xE3
001a07 f408                      	brsh sound_driver_channel1_check_if_instrument
001a08 c1c1                      	rjmp sound_driver_channel1_delay
                                 sound_driver_channel1_check_if_instrument: //check for instrument flag (0xE3)
001a09 f409                      	brne sound_driver_channel1_check_if_release
001a0a c1c4                      	rjmp sound_driver_channel1_instrument_change 
                                 sound_driver_channel1_check_if_release: //check for note release flag (0xE4)
001a0b 3eb4                      	cpi r27, 0xE4
001a0c f409                      	brne sound_driver_channel1_check_if_end
001a0d c26d                      	rjmp sound_driver_channel1_release
                                 sound_driver_channel1_check_if_end:
001a0e 3fbf                      	cpi r27, 0xFF
001a0f f409                      	brne sound_driver_channel1_check_if_fx
001a10 c28f                      	rjmp sound_driver_channel1_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel1_check_if_fx: //fx flags (0xE5 - 0xFE)
001a11 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001a12 91a4                      	lpm r26, Z //load the fx data into r26
001a13 d2ae                      	rcall sound_driver_channel1_increment_offset_twice
                                 
001a14 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001a15 e8e8                      	ldi ZL, LOW(channel1_fx << 1) //load in note table
001a16 e5fc                      	ldi ZH, HIGH(channel1_fx << 1)
001a17 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001a18 0feb                      	add ZL, r27 //add offset
001a19 1df2                      	adc ZH, zero
001a1a 91c5                      	lpm r28, Z+ //load address bytes
001a1b 91d4                      	lpm r29, Z
001a1c 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001a1d 2ffd                      	mov ZH, r29
001a1e 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel1_fx_0xy:
001a1f 93a0 2897                 	sts pulse2_fx_0xy_sequence, r26
001a21 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001a23 cfd1                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel1_fx_1xx:
001a24 9220 289d                 	sts pulse2_fx_2xx, zero //turn off any 2xx pitch slide down
001a26 9220 289e                 	sts pulse2_fx_2xx+1, zero
001a28 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001a2a 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001a2c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a2d 937f                      	push r23
001a2e 2f6a                      	mov r22, r26 //store the rate into r22
001a2f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a30 9f67                      	mul r22, r23
001a31 917f                      	pop r23
001a32 916f                      	pop r22
                                 
001a33 9416                      	lsr r1 //shift out the fractional bits
001a34 9407                      	ror r0
001a35 9416                      	lsr r1
001a36 9407                      	ror r0
001a37 9416                      	lsr r1
001a38 9407                      	ror r0
001a39 9416                      	lsr r1
001a3a 9407                      	ror r0
001a3b 9200 2899                 	sts pulse2_fx_1xx, r0
001a3d 9210 289a                 	sts pulse2_fx_1xx+1, r1
001a3f cfb5                      	rjmp sound_driver_channel1_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel1_fx_2xx:
001a40 9220 2899                 	sts pulse2_fx_1xx, zero //turn off any 1xx pitch slide down
001a42 9220 289a                 	sts pulse2_fx_1xx+1, zero
001a44 9220 2897                 	sts pulse2_fx_0xy_sequence, zero //disable any 0xy effect
001a46 9220 2898                 	sts pulse2_fx_0xy_sequence+1, zero
001a48 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a49 937f                      	push r23
001a4a 2f6a                      	mov r22, r26 //store the rate into r22
001a4b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a4c 9f67                      	mul r22, r23
001a4d 917f                      	pop r23
001a4e 916f                      	pop r22
                                 
001a4f 9416                      	lsr r1 //shift out the fractional bits
001a50 9407                      	ror r0
001a51 9416                      	lsr r1
001a52 9407                      	ror r0
001a53 9416                      	lsr r1
001a54 9407                      	ror r0
001a55 9416                      	lsr r1
001a56 9407                      	ror r0
001a57 9200 289d                 	sts pulse2_fx_2xx, r0
001a59 9210 289e                 	sts pulse2_fx_2xx+1, r1
001a5b cf99                      	rjmp sound_driver_channel1_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel1_fx_3xx:
001a5c 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001a5d 937f                      	push r23
001a5e 2f6a                      	mov r22, r26 //store the rate into r22
001a5f eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001a60 9f67                      	mul r22, r23
001a61 917f                      	pop r23
001a62 916f                      	pop r22
                                 
001a63 9416                      	lsr r1 //shift out the fractional bits
001a64 9407                      	ror r0
001a65 9416                      	lsr r1
001a66 9407                      	ror r0
001a67 9416                      	lsr r1
001a68 9407                      	ror r0
001a69 9416                      	lsr r1
001a6a 9407                      	ror r0
001a6b 9200 28a5                 	sts pulse2_fx_3xx_speed, r0
001a6d 9210 28a6                 	sts pulse2_fx_3xx_speed+1, r1
                                 
001a6f 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001a70 c001                      	rjmp sound_driver_channel1_fx_3xx_enabled
001a71 cf83                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_3xx_enabled:
001a72 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001a74 91b0 0a9d                 	lds r27, TCB1_CCMPH
001a76 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001a78 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
                                 
001a7a 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero
001a7c 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001a7e cf76                      	rjmp sound_driver_channel1_main
                                 
                                 //VIBRATO
                                 sound_driver_channel1_fx_4xy:
001a7f 2fba                      	mov r27, r26
001a80 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001a81 95a2                      	swap r26
001a82 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001a83 93a0 28a9                 	sts pulse2_fx_4xy_speed, r26
001a85 93b0 28aa                 	sts pulse2_fx_4xy_depth, r27
001a87 9220 28ab                 	sts pulse2_fx_4xy_phase, zero //reset the phase to 0
001a89 cf6b                      	rjmp sound_driver_channel1_main
                                 
                                 //TREMELO
                                 sound_driver_channel1_fx_7xy:
001a8a 2fba                      	mov r27, r26
001a8b 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001a8c 95a2                      	swap r26
001a8d 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001a8e 93a0 28ac                 	sts pulse2_fx_7xy_speed, r26
001a90 93b0 28ad                 	sts pulse2_fx_7xy_depth, r27
001a92 9220 28ae                 	sts pulse2_fx_7xy_phase, zero //reset the phase to 0
001a94 9220 28af                 	sts pulse2_fx_7xy_value, zero //reset the tremelo value
001a96 cf5e                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel1_fx_Axy:
001a97 93a0 28b0                 	sts pulse2_fx_Axy, r26
001a99 cf5b                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel1_fx_Bxx:
001a9a 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001a9c cf58                      	rjmp sound_driver_channel1_main
                                 
                                 //HALT
                                 sound_driver_channel1_fx_Cxx:
001a9d 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001a9f cf55                      	rjmp sound_driver_channel1_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel1_fx_Dxx:
001aa0 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001aa2 cf52                      	rjmp sound_driver_channel1_main
                                 
                                 //VOLUME
                                 sound_driver_channel1_fx_Exx:
001aa3 91b0 2808                 	lds r27, pulse2_param
001aa5 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
001aa6 2bba                      	or r27, r26 //move new VVVV bits into pulse2_param
001aa7 93b0 2808                 	sts pulse2_param, r27
001aa9 6092                      	sbr pulse_channel_flags, 2
001aaa cf4a                      	rjmp sound_driver_channel1_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel1_fx_Fxx:
001aab 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001aad cf47                      	rjmp sound_driver_channel1_main
                                 
                                 //DELAY
                                 sound_driver_channel1_fx_Gxx:
001aae 15a2                      	cp r26, zero
001aaf f051                      	breq sound_driver_channel1_fx_Gxx_invalid
001ab0 91b0 281f                 	lds r27, song_speed
001ab2 17ab                      	cp r26, r27
001ab3 f430                      	brsh sound_driver_channel1_fx_Gxx_invalid
001ab4 93a0 28b1                 	sts pulse2_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001ab6 e0b1                      	ldi r27, 0x01
001ab7 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001ab9 c215                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Gxx_invalid:
001aba cf3a                      	rjmp sound_driver_channel1_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel1_fx_Hxy: //hardware sweep up
001abb cf39                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixy: //hardware sweep down
001abc cf38                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Hxx: //FDS modulation depth
001abd cf37                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Ixx: //FDS modulation speed
001abe cf36                      	rjmp sound_driver_channel1_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel1_fx_Pxx:
001abf 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001ac0 937f                      	push r23
001ac1 2f6a                      	mov r22, r26
001ac2 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001ac3 0367                      	mulsu r22, r23
001ac4 917f                      	pop r23
001ac5 916f                      	pop r22
001ac6 9416                      	lsr r1 //shift out the fractional bits
001ac7 9407                      	ror r0
001ac8 9416                      	lsr r1
001ac9 9407                      	ror r0
001aca 9416                      	lsr r1
001acb 9407                      	ror r0
001acc 9416                      	lsr r1
001acd 9407                      	ror r0
001ace fe13                      	sbrs r1, 3 //check if result was a negative number
001acf c002                      	rjmp sound_driver_channel1_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel1_fx_Pxx_negative:
001ad0 efb0                      	ldi r27, 0xF0
001ad1 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel1_fx_Pxx_store:
001ad2 9200 28b3                 	sts pulse2_fx_Pxx_total, r0
001ad4 9210 28b4                 	sts pulse2_fx_Pxx_total+1, r1
001ad6 cf1e                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel1_fx_Qxy:
                                 sound_driver_channel1_fx_Qxy_check_arpeggio_macro:
001ad7 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001ad9 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001adb 9630                      	adiw Z, 0
001adc f009                      	breq sound_driver_channel1_fx_Qxy_check_pitch_macro
001add cf17                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_pitch_macro:
001ade 91e0 2887                 	lds ZL, pulse2_pitch_macro
001ae0 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
001ae2 9630                      	adiw Z, 0
001ae3 f009                      	breq sound_driver_channel1_fx_Qxy_check_hi_pitch_macro
001ae4 cf10                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_check_hi_pitch_macro:
001ae5 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001ae7 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001ae9 9630                      	adiw Z, 0
001aea f009                      	breq sound_driver_channel1_fx_Qxy_process
001aeb cf09                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Qxy_process:
001aec 2fba                      	mov r27, r26 //copy fx parameters into r27
001aed 70bf                      	andi r27, 0x0F //mask note index offset
001aee 91c0 28b5                 	lds r28, pulse2_fx_Qxy_target_note //load current note index
001af0 0fbc                      	add r27, r28
001af1 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001af2 f008                      	brlo sound_driver_channel1_fx_Qxy_process_continue
001af3 e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel1_fx_Qxy_process_continue:
001af4 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001af6 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001af7 e0f0                      	ldi ZH, HIGH(note_table << 1)
001af8 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001af9 0feb                      	add ZL, r27 //add offset
001afa 1df2                      	adc ZH, zero
001afb 91c5                      	lpm r28, Z+ //load bytes
001afc 91d4                      	lpm r29, Z
001afd 93c0 28b6                 	sts pulse2_fx_Qxy_target, r28 //load the LOW bits for the target period
001aff 93d0 28b7                 	sts pulse2_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Qxy_process_speed:
001b01 95a2                      	swap r26
001b02 70af                      	andi r26, 0x0F //mask effect speed
001b03 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b04 95a3                      	inc r26 //increment the speed by 1
                                 
001b05 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b06 937f                      	push r23
001b07 2f6a                      	mov r22, r26 //store the speed data into r27
001b08 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b09 9f67                      	mul r22, r23
001b0a 917f                      	pop r23
001b0b 916f                      	pop r22
                                 
001b0c 9416                      	lsr r1 //shift out the fractional bits
001b0d 9407                      	ror r0
001b0e 9416                      	lsr r1
001b0f 9407                      	ror r0
001b10 9416                      	lsr r1
001b11 9407                      	ror r0
001b12 9416                      	lsr r1
001b13 9407                      	ror r0
                                 
001b14 9200 28b8                 	sts pulse2_fx_Qxy_speed, r0 //store the effect speed
001b16 9210 28b9                 	sts pulse2_fx_Qxy_speed+1, r1
001b18 cedc                      	rjmp sound_driver_channel1_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel1_fx_Rxy:
                                 sound_driver_channel1_fx_Rxy_check_arpeggio_macro:
001b19 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
001b1b 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
001b1d 9630                      	adiw Z, 0
001b1e f009                      	breq sound_driver_channel1_fx_Rxy_check_pitch_macro
001b1f ced5                      	rjmp sound_driver_channel1_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_pitch_macro:
001b20 91e0 2887                 	lds ZL, pulse2_pitch_macro
001b22 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
001b24 9630                      	adiw Z, 0
001b25 f009                      	breq sound_driver_channel1_fx_Rxy_check_hi_pitch_macro
001b26 cece                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_check_hi_pitch_macro:
001b27 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
001b29 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
001b2b 9630                      	adiw Z, 0
001b2c f009                      	breq sound_driver_channel1_fx_Rxy_process
001b2d cec7                      	rjmp sound_driver_channel1_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel1_fx_Rxy_process:
001b2e 2fba                      	mov r27, r26 //copy fx parameters into r27
001b2f 70bf                      	andi r27, 0x0F //mask note index offset
001b30 91c0 28bc                 	lds r28, pulse2_fx_Rxy_target_note //load current note index
001b32 1bcb                      	sub r28, r27
001b33 f408                      	brcc sound_driver_channel1_fx_Rxy_process_continue
001b34 e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel1_fx_Rxy_process_continue:
001b35 93c0 28bc                 	sts pulse2_fx_Rxy_target_note, r28
001b37 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001b38 e0f0                      	ldi ZH, HIGH(note_table << 1)
001b39 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001b3a 0fec                      	add ZL, r28 //add offset
001b3b 1df2                      	adc ZH, zero
001b3c 91c5                      	lpm r28, Z+ //load bytes
001b3d 91d4                      	lpm r29, Z
001b3e 93c0 28bd                 	sts pulse2_fx_Rxy_target, r28 //load the LOW bits for the target period
001b40 93d0 28be                 	sts pulse2_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel1_fx_Rxy_process_speed:
001b42 95a2                      	swap r26
001b43 70af                      	andi r26, 0x0F //mask effect speed
001b44 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001b45 95a3                      	inc r26 //increment the speed by 1
                                 
001b46 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001b47 937f                      	push r23
001b48 2f6a                      	mov r22, r26 //store the speed data into r27
001b49 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001b4a 9f67                      	mul r22, r23
001b4b 917f                      	pop r23
001b4c 916f                      	pop r22
                                 
001b4d 9416                      	lsr r1 //shift out the fractional bits
001b4e 9407                      	ror r0
001b4f 9416                      	lsr r1
001b50 9407                      	ror r0
001b51 9416                      	lsr r1
001b52 9407                      	ror r0
001b53 9416                      	lsr r1
001b54 9407                      	ror r0
                                 
001b55 9200 28bf                 	sts pulse2_fx_Rxy_speed, r0 //store the effect speed
001b57 9210 28c0                 	sts pulse2_fx_Rxy_speed+1, r1
001b59 ce9b                      	rjmp sound_driver_channel1_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel1_fx_Sxx:
001b5a 15a2                      	cp r26, zero
001b5b f051                      	breq sound_driver_channel1_fx_Sxx_invalid
001b5c 91b0 281f                 	lds r27, song_speed
001b5e 17ab                      	cp r26, r27
001b5f f430                      	brsh sound_driver_channel1_fx_Sxx_invalid
001b60 93a0 28c3                 	sts pulse2_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001b62 e0b1                      	ldi r27, 0x01
001b63 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001b65 c169                      	rjmp sound_driver_channel2
                                 sound_driver_channel1_fx_Sxx_invalid:
001b66 ce8e                      	rjmp sound_driver_channel1_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel1_fx_Vxx:
001b67 e5e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
001b68 e5fc                      	ldi ZH, HIGH(sequences << 1)
001b69 0fea                      	add ZL, r26 //offset the pointer
001b6a 1df2                      	adc ZH, zero
                                 
001b6b 95a6                      	lsr r26 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
001b6c 95a7                      	ror r26
001b6d 95a7                      	ror r26
001b6e 91b0 2808                 	lds r27, pulse2_param //load r27 with pulse2_param (register $4000)
001b70 2fcb                      	mov r28, r27 //store a copy of pulse2_param into r28
001b71 7cb0                      	andi r27, 0b11000000 //mask the duty cycle bits
001b72 13ab                      	cpse r26, r27 //check if the previous duty cycle and the new duty cycle are equal
001b73 c001                      	rjmp sound_driver_channel1_fx_Vxx_store
001b74 ce80                      	rjmp sound_driver_channel1_main //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_channel1_fx_Vxx_store:
001b75 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
001b76 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
001b77 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
001b78 93c0 2808                 	sts pulse2_param, r28
001b7a ce7a                      	rjmp sound_driver_channel1_main
                                 
                                 sound_driver_channel1_fx_Wxx: //DPCM sample speed
001b7b ce79                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Xxx: //DPCM sample retrigger
001b7c ce78                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Yxx: //DPCM sample offset
001b7d ce77                      	rjmp sound_driver_channel1_main
                                 sound_driver_channel1_fx_Zxx: //DPCM sample delta counter
001b7e ce76                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 sound_driver_channel1_note:
001b7f 93b0 280f                 	sts pulse2_note, r27 //store the note index
001b81 93b0 28b5                 	sts pulse2_fx_Qxy_target_note, r27
001b83 93b0 28bc                 	sts pulse2_fx_Rxy_target_note, r27
001b85 e0a3                      	ldi r26, 0x03
001b86 e0b2                      	ldi r27, 0x02
001b87 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001b89 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
001b8b 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001b8d 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001b8f 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001b91 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch and hi pitch offset
001b93 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001b95 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
001b97 9220 289b                 	sts pulse2_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001b99 9220 289c                 	sts pulse2_fx_1xx_total+1, zero
001b9b 9220 289f                 	sts pulse2_fx_2xx_total, zero
001b9d 9220 28a0                 	sts pulse2_fx_2xx_total+1, zero
001b9f 9220 28a7                 	sts pulse2_fx_3xx_total_offset, zero //reset 3xx offset
001ba1 9220 28a8                 	sts pulse2_fx_3xx_total_offset+1, zero
001ba3 91a0 0a9c                 	lds r26, TCB1_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001ba5 91b0 0a9d                 	lds r27, TCB1_CCMPH
001ba7 93a0 28a1                 	sts pulse2_fx_3xx_start, r26
001ba9 93b0 28a2                 	sts pulse2_fx_3xx_start+1, r27
001bab 9220 2809                 	sts pulse2_sweep_param, zero //reset any sweep effect
001bad 6093                      	sbr pulse_channel_flags, 3 //set reload flag
001bae 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001bb0 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001bb2 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero
001bb4 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
001bb6 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001bb8 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001bba 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero
001bbc 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
001bbe d0f9                      	rcall sound_driver_channel1_increment_offset
001bbf ce35                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_volume:
001bc0 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001bc1 91a0 2808                 	lds r26, pulse2_param
001bc3 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
001bc4 2bab                      	or r26, r27 //move new VVVV bits into pulse2_param
001bc5 93a0 2808                 	sts pulse2_param, r26
001bc7 6092                      	sbr pulse_channel_flags, 2
001bc8 d0ef                      	rcall sound_driver_channel1_increment_offset
001bc9 ce2b                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_delay:
001bca 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001bcb 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
001bcd d0ea                      	rcall sound_driver_channel1_increment_offset
001bce c100                      	rjmp sound_driver_channel2
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change:
001bcf 9220 287a                 	sts pulse2_volume_macro, zero //reset all macro addresses
001bd1 9220 287b                 	sts pulse2_volume_macro+1, zero
001bd3 9220 287f                 	sts pulse2_arpeggio_macro, zero
001bd5 9220 2880                 	sts pulse2_arpeggio_macro+1, zero
001bd7 9220 2887                 	sts pulse2_pitch_macro, zero
001bd9 9220 2888                 	sts pulse2_pitch_macro+1, zero
001bdb 9220 288d                 	sts pulse2_hi_pitch_macro, zero
001bdd 9220 288e                 	sts pulse2_hi_pitch_macro+1, zero
001bdf 9220 2892                 	sts pulse2_duty_macro, zero
001be1 9220 2893                 	sts pulse2_duty_macro+1, zero
001be3 9220 2885                 	sts pulse2_total_pitch_offset, zero //reset the pitch offset
001be5 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
001be7 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001be9 9631                      	adiw Z, 1 //point to the byte next to the flag
001bea 91b4                      	lpm r27, Z //store the instrument offset into r27
001beb e7e1                      	ldi ZL, LOW(instruments) //point Z to instruments table
001bec e1f0                      	ldi ZH, HIGH(instruments)
001bed 0feb                      	add ZL, r27 //point Z to offsetted instrument
001bee 1df2                      	adc ZH, zero
001bef 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001bf0 1fff                      	rol ZH
001bf1 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001bf2 91b4                      	lpm r27, Z
                                 
001bf3 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001bf4 1fbb                      	rol r27
001bf5 2fea                      	mov ZL, r26
001bf6 2ffb                      	mov ZH, r27
001bf7 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001bf8 9632                      	adiw Z, 2 //point Z to the address of the macro
001bf9 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel1_instrument_change_macro_loop:
001bfa 95aa                      	dec r26
001bfb f019                      	breq sound_driver_channel1_instrument_change_exit
001bfc 95b6                      	lsr r27
001bfd f078                      	brcs sound_driver_channel1_instrument_change_load_macro
001bfe cffb                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_exit:
001bff e0a3                      	ldi r26, 0x03
001c00 e0b2                      	ldi r27, 0x02
001c01 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //reset all macro offsets
001c03 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
001c05 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
001c07 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
001c09 93b0 2894                 	sts pulse2_duty_macro_offset, r27
001c0b d0b6                      	rcall sound_driver_channel1_increment_offset_twice
001c0c cde8                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_load_macro:
001c0d 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001c0e 91d5                      	lpm r29, Z+
                                 
001c0f 30a5                      	cpi r26, 5
001c10 f039                      	breq sound_driver_channel1_instrument_change_load_macro_volume
001c11 30a4                      	cpi r26, 4
001c12 f079                      	breq sound_driver_channel1_instrument_change_load_macro_arpeggio
001c13 30a3                      	cpi r26, 3
001c14 f0d9                      	breq sound_driver_channel1_instrument_change_load_macro_pitch
001c15 30a2                      	cpi r26, 2
001c16 f159                      	breq sound_driver_channel1_instrument_change_load_macro_hi_pitch
001c17 c03c                      	rjmp sound_driver_channel1_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel1_instrument_change_load_macro_volume:
001c18 93c0 287a                 	sts pulse2_volume_macro, r28
001c1a 93d0 287b                 	sts pulse2_volume_macro+1, r29
001c1c d041                      	rcall sound_driver_channel1_instrument_change_read_header
001c1d 93c0 287e                 	sts pulse2_volume_macro_release, r28
001c1f 93d0 287d                 	sts pulse2_volume_macro_loop, r29
001c21 cfd8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 	
                                 sound_driver_channel1_instrument_change_load_macro_arpeggio:
001c22 93c0 287f                 	sts pulse2_arpeggio_macro, r28
001c24 93d0 2880                 	sts pulse2_arpeggio_macro+1, r29
001c26 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c28 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001c2a 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001c2c 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001c2e d03a                      	rcall sound_driver_channel1_instrument_change_read_header_arpeggio
001c2f cfca                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_pitch:
001c30 93c0 2887                 	sts pulse2_pitch_macro, r28
001c32 93d0 2888                 	sts pulse2_pitch_macro+1, r29
001c34 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c36 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001c38 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001c3a 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001c3c d021                      	rcall sound_driver_channel1_instrument_change_read_header
001c3d 93c0 288b                 	sts pulse2_pitch_macro_release, r28
001c3f 93d0 288a                 	sts pulse2_pitch_macro_loop, r29
001c41 cfb8                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_hi_pitch:
001c42 93c0 288d                 	sts pulse2_hi_pitch_macro, r28
001c44 93d0 288e                 	sts pulse2_hi_pitch_macro+1, r29
001c46 9220 28b6                 	sts pulse2_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001c48 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
001c4a 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
001c4c 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
001c4e d00f                      	rcall sound_driver_channel1_instrument_change_read_header
001c4f 93c0 2891                 	sts pulse2_hi_pitch_macro_release, r28
001c51 93d0 2890                 	sts pulse2_hi_pitch_macro_loop, r29
001c53 cfa6                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 sound_driver_channel1_instrument_change_load_macro_duty:
001c54 93c0 2892                 	sts pulse2_duty_macro, r28
001c56 93d0 2893                 	sts pulse2_duty_macro+1, r29
001c58 d005                      	rcall sound_driver_channel1_instrument_change_read_header
001c59 93c0 2896                 	sts pulse2_duty_macro_release, r28
001c5b 93d0 2895                 	sts pulse2_duty_macro_loop, r29
001c5d cf9c                      	rjmp sound_driver_channel1_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel1_instrument_change_read_header:
001c5e 93ef                      	push ZL
001c5f 93ff                      	push ZH
001c60 2fec                      	mov ZL, r28
001c61 2ffd                      	mov ZH, r29
001c62 0fee                      	lsl ZL
001c63 1fff                      	rol ZH
001c64 91c5                      	lpm r28, Z+
001c65 91d4                      	lpm r29, Z
001c66 91ff                      	pop ZH
001c67 91ef                      	pop ZL
001c68 9508                      	ret
                                 
                                 sound_driver_channel1_instrument_change_read_header_arpeggio:
001c69 93ef                      	push ZL
001c6a 93ff                      	push ZH
001c6b 2fec                      	mov ZL, r28
001c6c 2ffd                      	mov ZH, r29
001c6d 0fee                      	lsl ZL
001c6e 1fff                      	rol ZH
001c6f 91c5                      	lpm r28, Z+
001c70 91d5                      	lpm r29, Z+
001c71 93c0 2883                 	sts pulse2_arpeggio_macro_release, r28
001c73 93d0 2882                 	sts pulse2_arpeggio_macro_loop, r29
001c75 91c4                      	lpm r28, Z
001c76 93c0 2884                 	sts pulse2_arpeggio_macro_mode, r28
001c78 91ff                      	pop ZH
001c79 91ef                      	pop ZL
001c7a 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel1_release:
                                 sound_driver_channel1_release_volume:
001c7b 91b0 287e                 	lds r27, pulse2_volume_macro_release
001c7d 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001c7e f019                      	breq sound_driver_channel1_release_arpeggio //if the macro has no release flag, check the next macro
001c7f 95b3                      	inc r27
001c80 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel1_release_arpeggio:
001c82 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
001c84 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001c85 f019                      	breq sound_driver_channel1_release_pitch
001c86 95b3                      	inc r27
001c87 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27
                                 sound_driver_channel1_release_pitch:
001c89 91b0 288b                 	lds r27, pulse2_pitch_macro_release
001c8b 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001c8c f019                      	breq sound_driver_channel1_release_hi_pitch
001c8d 95b3                      	inc r27
001c8e 93b0 2889                 	sts pulse2_pitch_macro_offset, r27
                                 sound_driver_channel1_release_hi_pitch:
001c90 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
001c92 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001c93 f019                      	breq sound_driver_channel1_release_duty
001c94 95b3                      	inc r27
001c95 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27
                                 sound_driver_channel1_release_duty:
001c97 91b0 2896                 	lds r27, pulse2_duty_macro_release
001c99 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001c9a f019                      	breq sound_driver_channel1_release_exit
001c9b 95b3                      	inc r27
001c9c 93b0 2894                 	sts pulse2_duty_macro_offset, r27
                                 sound_driver_channel1_release_exit:
001c9e d019                      	rcall sound_driver_channel1_increment_offset
001c9f cd55                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_next_pattern:
001ca0 91e0 2819                 	lds ZL, song_frames
001ca2 91f0 281a                 	lds ZH, song_frames+1
001ca4 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001ca6 91b0 281c                 	lds r27, song_frame_offset+1
001ca8 9612                      	adiw r27:r26, 2 //offset for channel 1
001ca9 0fea                      	add ZL, r26
001caa 1ffb                      	adc ZH, r27
                                 
001cab 91a5                      	lpm r26, Z+ //load the address of the next pattern
001cac 91b4                      	lpm r27, Z
001cad 0faa                      	lsl r26
001cae 1fbb                      	rol r27
001caf 93a0 2874                 	sts pulse2_pattern, r26
001cb1 93b0 2875                 	sts pulse2_pattern+1, r27
                                 
001cb3 9220 2878                 	sts pulse2_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001cb5 9220 2879                 	sts pulse2_pattern_offset+1, zero
001cb7 cd3d                      	rjmp sound_driver_channel1_main
                                 
                                 
                                 
                                 sound_driver_channel1_increment_offset:
001cb8 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001cba 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001cbc 9631                      	adiw Z, 1
001cbd 93e0 2878                 	sts pulse2_pattern_offset, ZL
001cbf 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001cc1 9508                      	ret
                                 
                                 sound_driver_channel1_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001cc2 91e0 2878                 	lds ZL, pulse2_pattern_offset //current offset in the pattern for pulse 2
001cc4 91f0 2879                 	lds ZH, pulse2_pattern_offset+1
001cc6 9632                      	adiw Z, 2 //increment the pointer twice
001cc7 93e0 2878                 	sts pulse2_pattern_offset, ZL
001cc9 93f0 2879                 	sts pulse2_pattern_offset+1, ZH
001ccb 9508                      	ret
                                 
                                 sound_driver_channel1_decrement_frame_delay:
001ccc 95ba                      	dec r27
001ccd 93b0 2877                 	sts pulse2_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel2:
001ccf 91a0 28c7                 	lds r26, triangle_pattern_delay_rows
001cd1 91b0 28c8                 	lds r27, triangle_pattern_delay_frames
001cd3 9610                      	adiw r27:r26, 0
001cd4 f009                      	breq sound_driver_channel2_main //if the pattern delay is 0, proceed with sound driver procedures
001cd5 c2bf                      	rjmp sound_driver_channel2_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel2_main:
001cd6 91e0 28c5                 	lds ZL, triangle_pattern //current pattern for triangle
001cd8 91f0 28c6                 	lds ZH, triangle_pattern+1
001cda 91a0 28c9                 	lds r26, triangle_pattern_offset //current offset in the pattern for triangle
001cdc 91b0 28ca                 	lds r27, triangle_pattern_offset+1
001cde 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001cdf 1ffb                      	adc ZH, r27
001ce0 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel2_check_if_note: //check if data is a note (0x00 - 0x56)
001ce1 35b7                      	cpi r27, 0x57
001ce2 f408                      	brsh sound_driver_channel2_check_if_volume
001ce3 c160                      	rjmp sound_driver_channel2_note
                                 sound_driver_channel2_check_if_volume: //check if data is volume (0x57-0x66)
001ce4 36b7                      	cpi r27, 0x67
001ce5 f408                      	brsh sound_driver_channel2_check_if_delay
001ce6 c19e                      	rjmp sound_driver_channel2_volume
                                 sound_driver_channel2_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001ce7 3eb3                      	cpi r27, 0xE3
001ce8 f408                      	brsh sound_driver_channel2_check_if_instrument
001ce9 c1a9                      	rjmp sound_driver_channel2_delay
                                 sound_driver_channel2_check_if_instrument: //check for instrument flag (0xE3)
001cea f409                      	brne sound_driver_channel2_check_if_release
001ceb c1ac                      	rjmp sound_driver_channel2_instrument_change 
                                 sound_driver_channel2_check_if_release: //check for note release flag (0xE4)
001cec 3eb4                      	cpi r27, 0xE4
001ced f409                      	brne sound_driver_channel2_check_if_end
001cee c255                      	rjmp sound_driver_channel2_release
                                 sound_driver_channel2_check_if_end:
001cef 3fbf                      	cpi r27, 0xFF
001cf0 f409                      	brne sound_driver_channel2_check_if_fx
001cf1 c277                      	rjmp sound_driver_channel2_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel2_check_if_fx: //fx flags (0xE5 - 0xFE)
001cf2 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001cf3 91a4                      	lpm r26, Z //load the fx data into r26
001cf4 d296                      	rcall sound_driver_channel2_increment_offset_twice
                                 
001cf5 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001cf6 ebec                      	ldi ZL, LOW(channel2_fx << 1) //load in note table
001cf7 e5fc                      	ldi ZH, HIGH(channel2_fx << 1)
001cf8 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001cf9 0feb                      	add ZL, r27 //add offset
001cfa 1df2                      	adc ZH, zero
001cfb 91c5                      	lpm r28, Z+ //load address bytes
001cfc 91d4                      	lpm r29, Z
001cfd 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001cfe 2ffd                      	mov ZH, r29
001cff 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel2_fx_0xy:
001d00 93a0 28e8                 	sts triangle_fx_0xy_sequence, r26
001d02 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001d04 cfd1                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel2_fx_1xx:
001d05 9220 28ee                 	sts triangle_fx_2xx, zero //turn off any 2xx pitch slide down
001d07 9220 28ef                 	sts triangle_fx_2xx+1, zero
001d09 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001d0b 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001d0d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d0e 937f                      	push r23
001d0f 2f6a                      	mov r22, r26 //store the rate into r22
001d10 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d11 9f67                      	mul r22, r23
001d12 917f                      	pop r23
001d13 916f                      	pop r22
                                 
001d14 9416                      	lsr r1 //shift out the fractional bits
001d15 9407                      	ror r0
001d16 9416                      	lsr r1
001d17 9407                      	ror r0
001d18 9416                      	lsr r1
001d19 9407                      	ror r0
001d1a 9416                      	lsr r1
001d1b 9407                      	ror r0
001d1c 9200 28ea                 	sts triangle_fx_1xx, r0
001d1e 9210 28eb                 	sts triangle_fx_1xx+1, r1
001d20 cfb5                      	rjmp sound_driver_channel2_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel2_fx_2xx:
001d21 9220 28ea                 	sts triangle_fx_1xx, zero //turn off any 1xx pitch slide down
001d23 9220 28eb                 	sts triangle_fx_1xx+1, zero
001d25 9220 28e8                 	sts triangle_fx_0xy_sequence, zero //disable any 0xy effect
001d27 9220 28e9                 	sts triangle_fx_0xy_sequence+1, zero
001d29 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d2a 937f                      	push r23
001d2b 2f6a                      	mov r22, r26 //store the rate into r22
001d2c eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d2d 9f67                      	mul r22, r23
001d2e 917f                      	pop r23
001d2f 916f                      	pop r22
                                 
001d30 9416                      	lsr r1 //shift out the fractional bits
001d31 9407                      	ror r0
001d32 9416                      	lsr r1
001d33 9407                      	ror r0
001d34 9416                      	lsr r1
001d35 9407                      	ror r0
001d36 9416                      	lsr r1
001d37 9407                      	ror r0
001d38 9200 28ee                 	sts triangle_fx_2xx, r0
001d3a 9210 28ef                 	sts triangle_fx_2xx+1, r1
001d3c cf99                      	rjmp sound_driver_channel2_main
                                 
                                 //AUTOMATIC PORTAMENTO
                                 sound_driver_channel2_fx_3xx:
001d3d 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d3e 937f                      	push r23
001d3f 2f6a                      	mov r22, r26 //store the rate into r22
001d40 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d41 9f67                      	mul r22, r23
001d42 917f                      	pop r23
001d43 916f                      	pop r22
                                 
001d44 9416                      	lsr r1 //shift out the fractional bits
001d45 9407                      	ror r0
001d46 9416                      	lsr r1
001d47 9407                      	ror r0
001d48 9416                      	lsr r1
001d49 9407                      	ror r0
001d4a 9416                      	lsr r1
001d4b 9407                      	ror r0
001d4c 9200 28f6                 	sts triangle_fx_3xx_speed, r0
001d4e 9210 28f7                 	sts triangle_fx_3xx_speed+1, r1
                                 
001d50 11a2                      	cpse r26, zero //check if the effect was enabled or disabled
001d51 c001                      	rjmp sound_driver_channel2_fx_3xx_enabled
001d52 cf83                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_3xx_enabled:
001d53 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001d55 91b0 0aad                 	lds r27, TCB2_CCMPH
001d57 93a0 28f2                 	sts triangle_fx_3xx_start, r26
001d59 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
                                 
001d5b 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero
001d5d 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001d5f cf76                      	rjmp sound_driver_channel2_main
                                 
                                 //VIBRATO
                                 sound_driver_channel2_fx_4xy:
001d60 2fba                      	mov r27, r26
001d61 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001d62 95a2                      	swap r26
001d63 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001d64 93a0 28fa                 	sts triangle_fx_4xy_speed, r26
001d66 93b0 28fb                 	sts triangle_fx_4xy_depth, r27
001d68 9220 28fc                 	sts triangle_fx_4xy_phase, zero //reset the phase to 0
001d6a cf6b                      	rjmp sound_driver_channel2_main
                                 
                                 sound_driver_channel2_fx_7xy: //tremelo
001d6b cf6a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Axy: //volume slide
001d6c cf69                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel2_fx_Bxx:
001d6d 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
001d6f cf66                      	rjmp sound_driver_channel2_main
                                 
                                 //HALT
                                 sound_driver_channel2_fx_Cxx:
001d70 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001d72 cf63                      	rjmp sound_driver_channel2_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel2_fx_Dxx:
001d73 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
001d75 cf60                      	rjmp sound_driver_channel2_main
                                 
                                 //VOLUME
                                 sound_driver_channel2_fx_Exx:
001d76 15a2                      	cp r26, zero
001d77 f021                      	breq sound_driver_channel2_fx_Exx_disable
                                 sound_driver_channel2_fx_Exx_enable:
001d78 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001d79 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001d7b cf5a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Exx_disable:
001d7c 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001d7e 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001d80 9220 0aad                 	sts TCB2_CCMPH, zero
001d82 cf53                      	rjmp sound_driver_channel2_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel2_fx_Fxx:
001d83 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
001d85 cf50                      	rjmp sound_driver_channel2_main
                                 
                                 //DELAY
                                 sound_driver_channel2_fx_Gxx:
001d86 15a2                      	cp r26, zero
001d87 f051                      	breq sound_driver_channel2_fx_Gxx_invalid
001d88 91b0 281f                 	lds r27, song_speed
001d8a 17ab                      	cp r26, r27
001d8b f430                      	brsh sound_driver_channel2_fx_Gxx_invalid
001d8c 93a0 28fd                 	sts triangle_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001d8e e0b1                      	ldi r27, 0x01
001d8f 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001d91 c206                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Gxx_invalid:
001d92 cf43                      	rjmp sound_driver_channel2_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Hxy: //hardware sweep up
001d93 cf42                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixy: //hardware sweep down
001d94 cf41                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Hxx: //FDS modulation depth
001d95 cf40                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Ixx: //FDS modulation speed
001d96 cf3f                      	rjmp sound_driver_channel2_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel2_fx_Pxx:
001d97 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001d98 937f                      	push r23
001d99 2f6a                      	mov r22, r26
001d9a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001d9b 0367                      	mulsu r22, r23
001d9c 917f                      	pop r23
001d9d 916f                      	pop r22
001d9e 9416                      	lsr r1 //shift out the fractional bits
001d9f 9407                      	ror r0
001da0 9416                      	lsr r1
001da1 9407                      	ror r0
001da2 9416                      	lsr r1
001da3 9407                      	ror r0
001da4 9416                      	lsr r1
001da5 9407                      	ror r0
001da6 fe13                      	sbrs r1, 3 //check if result was a negative number
001da7 c002                      	rjmp sound_driver_channel2_fx_Pxx_store //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_channel2_fx_Pxx_negative:
001da8 efb0                      	ldi r27, 0xF0
001da9 2a1b                      	or r1, r27 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_channel2_fx_Pxx_store:
001daa 9200 28ff                 	sts triangle_fx_Pxx_total, r0
001dac 9210 2900                 	sts triangle_fx_Pxx_total+1, r1
001dae cf27                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE UP
                                 sound_driver_channel2_fx_Qxy:
                                 sound_driver_channel2_fx_Qxy_check_arpeggio_macro:
001daf 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
001db1 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
001db3 9630                      	adiw Z, 0
001db4 f009                      	breq sound_driver_channel2_fx_Qxy_check_pitch_macro
001db5 cf20                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_pitch_macro:
001db6 91e0 28d8                 	lds ZL, triangle_pitch_macro
001db8 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
001dba 9630                      	adiw Z, 0
001dbb f009                      	breq sound_driver_channel2_fx_Qxy_check_hi_pitch_macro
001dbc cf19                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_check_hi_pitch_macro:
001dbd 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
001dbf 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
001dc1 9630                      	adiw Z, 0
001dc2 f009                      	breq sound_driver_channel2_fx_Qxy_process
001dc3 cf12                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Qxy_process:
001dc4 2fba                      	mov r27, r26 //copy fx parameters into r27
001dc5 70bf                      	andi r27, 0x0F //mask note index offset
001dc6 91c0 2901                 	lds r28, triangle_fx_Qxy_target_note //load current note index
001dc8 0fbc                      	add r27, r28
001dc9 35b7                      	cpi r27, 0x57 //largest possible note index is 0x56
001dca f008                      	brlo sound_driver_channel2_fx_Qxy_process_continue
001dcb e5b6                      	ldi r27, 0x56 //if the target note was larger than the highest possible note index, keep the target at 0x56
                                 
                                 sound_driver_channel2_fx_Qxy_process_continue:
001dcc 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
001dce e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001dcf e0f0                      	ldi ZH, HIGH(note_table << 1)
001dd0 0fbb                      	lsl r27 //double the offset for the note table because we are getting byte data
001dd1 0feb                      	add ZL, r27 //add offset
001dd2 1df2                      	adc ZH, zero
001dd3 91c5                      	lpm r28, Z+ //load bytes
001dd4 91d4                      	lpm r29, Z
001dd5 93c0 2902                 	sts triangle_fx_Qxy_target, r28 //load the LOW bits for the target period
001dd7 93d0 2903                 	sts triangle_fx_Qxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Qxy_process_speed:
001dd9 95a2                      	swap r26
001dda 70af                      	andi r26, 0x0F //mask effect speed
001ddb 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001ddc 95a3                      	inc r26 //increment the speed by 1
                                 
001ddd 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001dde 937f                      	push r23
001ddf 2f6a                      	mov r22, r26 //store the speed data into r27
001de0 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001de1 9f67                      	mul r22, r23
001de2 917f                      	pop r23
001de3 916f                      	pop r22
                                 
001de4 9416                      	lsr r1 //shift out the fractional bits
001de5 9407                      	ror r0
001de6 9416                      	lsr r1
001de7 9407                      	ror r0
001de8 9416                      	lsr r1
001de9 9407                      	ror r0
001dea 9416                      	lsr r1
001deb 9407                      	ror r0
                                 
001dec 9200 2904                 	sts triangle_fx_Qxy_speed, r0 //store the effect speed
001dee 9210 2905                 	sts triangle_fx_Qxy_speed+1, r1
001df0 cee5                      	rjmp sound_driver_channel2_main
                                 
                                 //NOTE SLIDE DOWN
                                 sound_driver_channel2_fx_Rxy:
                                 sound_driver_channel2_fx_Rxy_check_arpeggio_macro:
001df1 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
001df3 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
001df5 9630                      	adiw Z, 0
001df6 f009                      	breq sound_driver_channel2_fx_Rxy_check_pitch_macro
001df7 cede                      	rjmp sound_driver_channel2_main //if there is an arpeggio macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_pitch_macro:
001df8 91e0 28d8                 	lds ZL, triangle_pitch_macro
001dfa 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
001dfc 9630                      	adiw Z, 0
001dfd f009                      	breq sound_driver_channel2_fx_Rxy_check_hi_pitch_macro
001dfe ced7                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_check_hi_pitch_macro:
001dff 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
001e01 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
001e03 9630                      	adiw Z, 0
001e04 f009                      	breq sound_driver_channel2_fx_Rxy_process
001e05 ced0                      	rjmp sound_driver_channel2_main //if there is a pitch macro, don't enable the effect
                                 
                                 sound_driver_channel2_fx_Rxy_process:
001e06 2fba                      	mov r27, r26 //copy fx parameters into r27
001e07 70bf                      	andi r27, 0x0F //mask note index offset
001e08 91c0 2908                 	lds r28, triangle_fx_Rxy_target_note //load current note index
001e0a 1bcb                      	sub r28, r27
001e0b f408                      	brcc sound_driver_channel2_fx_Rxy_process_continue
001e0c e0c0                      	ldi r28, 0x00
                                 
                                 sound_driver_channel2_fx_Rxy_process_continue:
001e0d 93c0 2908                 	sts triangle_fx_Rxy_target_note, r28
001e0f e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
001e10 e0f0                      	ldi ZH, HIGH(note_table << 1)
001e11 0fcc                      	lsl r28 //double the offset for the note table because we are getting byte data
001e12 0fec                      	add ZL, r28 //add offset
001e13 1df2                      	adc ZH, zero
001e14 91c5                      	lpm r28, Z+ //load bytes
001e15 91d4                      	lpm r29, Z
001e16 93c0 2909                 	sts triangle_fx_Rxy_target, r28 //load the LOW bits for the target period
001e18 93d0 290a                 	sts triangle_fx_Rxy_target+1, r29 //load the HIGH bits for the target period
                                 
                                 sound_driver_channel2_fx_Rxy_process_speed:
001e1a 95a2                      	swap r26
001e1b 70af                      	andi r26, 0x0F //mask effect speed
001e1c 0faa                      	lsl r26 //multiply the speed by 2 NOTE: formula for the speed is 2x+1
001e1d 95a3                      	inc r26 //increment the speed by 1
                                 
001e1e 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
001e1f 937f                      	push r23
001e20 2f6a                      	mov r22, r26 //store the speed data into r27
001e21 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
001e22 9f67                      	mul r22, r23
001e23 917f                      	pop r23
001e24 916f                      	pop r22
                                 
001e25 9416                      	lsr r1 //shift out the fractional bits
001e26 9407                      	ror r0
001e27 9416                      	lsr r1
001e28 9407                      	ror r0
001e29 9416                      	lsr r1
001e2a 9407                      	ror r0
001e2b 9416                      	lsr r1
001e2c 9407                      	ror r0
                                 
001e2d 9200 290b                 	sts triangle_fx_Rxy_speed, r0 //store the effect speed
001e2f 9210 290c                 	sts triangle_fx_Rxy_speed+1, r1
001e31 cea4                      	rjmp sound_driver_channel2_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel2_fx_Sxx:
001e32 15a2                      	cp r26, zero
001e33 f051                      	breq sound_driver_channel2_fx_Sxx_invalid
001e34 91b0 281f                 	lds r27, song_speed
001e36 17ab                      	cp r26, r27
001e37 f430                      	brsh sound_driver_channel2_fx_Sxx_invalid
001e38 93a0 290f                 	sts triangle_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
001e3a e0b1                      	ldi r27, 0x01
001e3b 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001e3d c15a                      	rjmp sound_driver_channel3
                                 sound_driver_channel2_fx_Sxx_invalid:
001e3e ce97                      	rjmp sound_driver_channel2_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel2_fx_Vxx: //duty
001e3f ce96                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Wxx: //DPCM sample speed
001e40 ce95                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Xxx: //DPCM sample retrigger
001e41 ce94                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Yxx: //DPCM sample offset
001e42 ce93                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_fx_Zxx: //DPCM sample delta counter
001e43 ce92                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 sound_driver_channel2_note:
001e44 93b0 2812                 	sts triangle_note, r27 //store the note index
001e46 93b0 2901                 	sts triangle_fx_Qxy_target_note, r27
001e48 93b0 2908                 	sts triangle_fx_Rxy_target_note, r27
001e4a e0a3                      	ldi r26, 0x03
001e4b e0b2                      	ldi r27, 0x02
001e4c 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001e4e 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
001e50 93b0 28da                 	sts triangle_pitch_macro_offset, r27
001e52 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
001e54 93b0 28e5                 	sts triangle_duty_macro_offset, r27
001e56 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch and hi pitch offset
001e58 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001e5a 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
001e5c 9220 28ec                 	sts triangle_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
001e5e 9220 28ed                 	sts triangle_fx_1xx_total+1, zero
001e60 9220 28f0                 	sts triangle_fx_2xx_total, zero
001e62 9220 28f1                 	sts triangle_fx_2xx_total+1, zero
001e64 9220 28f8                 	sts triangle_fx_3xx_total_offset, zero //reset 3xx offset
001e66 9220 28f9                 	sts triangle_fx_3xx_total_offset+1, zero
001e68 91a0 0aac                 	lds r26, TCB2_CCMPL //if the 3xx effect is enabled, we need to store the current timer period
001e6a 91b0 0aad                 	lds r27, TCB2_CCMPH
001e6c 93a0 28f2                 	sts triangle_fx_3xx_start, r26
001e6e 93b0 28f3                 	sts triangle_fx_3xx_start+1, r27
001e70 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001e72 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
001e74 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero
001e76 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
001e78 9220 2909                 	sts triangle_fx_Rxy_target, zero
001e7a 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
001e7c 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero
001e7e 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
001e80 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001e81 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001e83 d0fd                      	rcall sound_driver_channel2_increment_offset
001e84 ce51                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_volume:
001e85 d0fb                      	rcall sound_driver_channel2_increment_offset
001e86 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
001e87 f021                      	breq sound_driver_channel2_volume_disable
                                 sound_driver_channel2_volume_enable:
001e88 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
001e89 93b0 0aa5                 	sts TCB2_INTCTRL, r27
001e8b ce4a                      	rjmp sound_driver_channel2_main
                                 sound_driver_channel2_volume_disable:
001e8c 9220 0aa5                 	sts TCB2_INTCTRL, zero //disable interrupts
001e8e 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
001e90 9220 0aad                 	sts TCB2_CCMPH, zero
001e92 ce43                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_delay:
001e93 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
001e94 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
001e96 d0ea                      	rcall sound_driver_channel2_increment_offset
001e97 c100                      	rjmp sound_driver_channel3
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change:
001e98 9220 28cb                 	sts triangle_volume_macro, zero //reset all macro addresses
001e9a 9220 28cc                 	sts triangle_volume_macro+1, zero
001e9c 9220 28d0                 	sts triangle_arpeggio_macro, zero
001e9e 9220 28d1                 	sts triangle_arpeggio_macro+1, zero
001ea0 9220 28d8                 	sts triangle_pitch_macro, zero
001ea2 9220 28d9                 	sts triangle_pitch_macro+1, zero
001ea4 9220 28de                 	sts triangle_hi_pitch_macro, zero
001ea6 9220 28df                 	sts triangle_hi_pitch_macro+1, zero
001ea8 9220 28e3                 	sts triangle_duty_macro, zero
001eaa 9220 28e4                 	sts triangle_duty_macro+1, zero
001eac 9220 28d6                 	sts triangle_total_pitch_offset, zero //reset the pitch offset
001eae 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
001eb0 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
001eb2 9631                      	adiw Z, 1 //point to the byte next to the flag
001eb3 91b4                      	lpm r27, Z //store the instrument offset into r27
001eb4 e7e1                      	ldi ZL, LOW(instruments) //point Z to instruments table
001eb5 e1f0                      	ldi ZH, HIGH(instruments)
001eb6 0feb                      	add ZL, r27 //point Z to offsetted instrument
001eb7 1df2                      	adc ZH, zero
001eb8 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
001eb9 1fff                      	rol ZH
001eba 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
001ebb 91b4                      	lpm r27, Z
                                 
001ebc 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
001ebd 1fbb                      	rol r27
001ebe 2fea                      	mov ZL, r26
001ebf 2ffb                      	mov ZH, r27
001ec0 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
001ec1 9632                      	adiw Z, 2 //point Z to the address of the macro
001ec2 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel2_instrument_change_macro_loop:
001ec3 95aa                      	dec r26
001ec4 f019                      	breq sound_driver_channel2_instrument_change_exit
001ec5 95b6                      	lsr r27
001ec6 f078                      	brcs sound_driver_channel2_instrument_change_load_macro
001ec7 cffb                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_exit:
001ec8 e0a3                      	ldi r26, 0x03
001ec9 e0b2                      	ldi r27, 0x02
001eca 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //reset all macro offsets
001ecc 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
001ece 93b0 28da                 	sts triangle_pitch_macro_offset, r27
001ed0 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
001ed2 93b0 28e5                 	sts triangle_duty_macro_offset, r27
001ed4 d0b6                      	rcall sound_driver_channel2_increment_offset_twice
001ed5 ce00                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_load_macro:
001ed6 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
001ed7 91d5                      	lpm r29, Z+
                                 
001ed8 30a5                      	cpi r26, 5
001ed9 f039                      	breq sound_driver_channel2_instrument_change_load_macro_volume
001eda 30a4                      	cpi r26, 4
001edb f079                      	breq sound_driver_channel2_instrument_change_load_macro_arpeggio
001edc 30a3                      	cpi r26, 3
001edd f0d9                      	breq sound_driver_channel2_instrument_change_load_macro_pitch
001ede 30a2                      	cpi r26, 2
001edf f159                      	breq sound_driver_channel2_instrument_change_load_macro_hi_pitch
001ee0 c03c                      	rjmp sound_driver_channel2_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel2_instrument_change_load_macro_volume:
001ee1 93c0 28cb                 	sts triangle_volume_macro, r28
001ee3 93d0 28cc                 	sts triangle_volume_macro+1, r29
001ee5 d041                      	rcall sound_driver_channel2_instrument_change_read_header
001ee6 93c0 28cf                 	sts triangle_volume_macro_release, r28
001ee8 93d0 28ce                 	sts triangle_volume_macro_loop, r29
001eea cfd8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 	
                                 sound_driver_channel2_instrument_change_load_macro_arpeggio:
001eeb 93c0 28d0                 	sts triangle_arpeggio_macro, r28
001eed 93d0 28d1                 	sts triangle_arpeggio_macro+1, r29
001eef 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001ef1 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
001ef3 9220 2909                 	sts triangle_fx_Rxy_target, zero
001ef5 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
001ef7 d03a                      	rcall sound_driver_channel2_instrument_change_read_header_arpeggio
001ef8 cfca                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_pitch:
001ef9 93c0 28d8                 	sts triangle_pitch_macro, r28
001efb 93d0 28d9                 	sts triangle_pitch_macro+1, r29
001efd 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001eff 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
001f01 9220 2909                 	sts triangle_fx_Rxy_target, zero
001f03 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
001f05 d021                      	rcall sound_driver_channel2_instrument_change_read_header
001f06 93c0 28dc                 	sts triangle_pitch_macro_release, r28
001f08 93d0 28db                 	sts triangle_pitch_macro_loop, r29
001f0a cfb8                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_hi_pitch:
001f0b 93c0 28de                 	sts triangle_hi_pitch_macro, r28
001f0d 93d0 28df                 	sts triangle_hi_pitch_macro+1, r29
001f0f 9220 2902                 	sts triangle_fx_Qxy_target, zero //reset the Qxy, Rxy effects
001f11 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
001f13 9220 2909                 	sts triangle_fx_Rxy_target, zero
001f15 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
001f17 d00f                      	rcall sound_driver_channel2_instrument_change_read_header
001f18 93c0 28e2                 	sts triangle_hi_pitch_macro_release, r28
001f1a 93d0 28e1                 	sts triangle_hi_pitch_macro_loop, r29
001f1c cfa6                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 sound_driver_channel2_instrument_change_load_macro_duty:
001f1d 93c0 28e3                 	sts triangle_duty_macro, r28
001f1f 93d0 28e4                 	sts triangle_duty_macro+1, r29
001f21 d005                      	rcall sound_driver_channel2_instrument_change_read_header
001f22 93c0 28e7                 	sts triangle_duty_macro_release, r28
001f24 93d0 28e6                 	sts triangle_duty_macro_loop, r29
001f26 cf9c                      	rjmp sound_driver_channel2_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel2_instrument_change_read_header:
001f27 93ef                      	push ZL
001f28 93ff                      	push ZH
001f29 2fec                      	mov ZL, r28
001f2a 2ffd                      	mov ZH, r29
001f2b 0fee                      	lsl ZL
001f2c 1fff                      	rol ZH
001f2d 91c5                      	lpm r28, Z+
001f2e 91d4                      	lpm r29, Z
001f2f 91ff                      	pop ZH
001f30 91ef                      	pop ZL
001f31 9508                      	ret
                                 
                                 sound_driver_channel2_instrument_change_read_header_arpeggio:
001f32 93ef                      	push ZL
001f33 93ff                      	push ZH
001f34 2fec                      	mov ZL, r28
001f35 2ffd                      	mov ZH, r29
001f36 0fee                      	lsl ZL
001f37 1fff                      	rol ZH
001f38 91c5                      	lpm r28, Z+
001f39 91d5                      	lpm r29, Z+
001f3a 93c0 28d4                 	sts triangle_arpeggio_macro_release, r28
001f3c 93d0 28d3                 	sts triangle_arpeggio_macro_loop, r29
001f3e 91c4                      	lpm r28, Z
001f3f 93c0 28d5                 	sts triangle_arpeggio_macro_mode, r28
001f41 91ff                      	pop ZH
001f42 91ef                      	pop ZL
001f43 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel2_release:
                                 sound_driver_channel2_release_volume:
001f44 91b0 28cf                 	lds r27, triangle_volume_macro_release
001f46 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
001f47 f019                      	breq sound_driver_channel2_release_arpeggio //if the macro has no release flag, check the next macro
001f48 95b3                      	inc r27
001f49 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel2_release_arpeggio:
001f4b 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
001f4d 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
001f4e f019                      	breq sound_driver_channel2_release_pitch
001f4f 95b3                      	inc r27
001f50 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27
                                 sound_driver_channel2_release_pitch:
001f52 91b0 28dc                 	lds r27, triangle_pitch_macro_release
001f54 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
001f55 f019                      	breq sound_driver_channel2_release_hi_pitch
001f56 95b3                      	inc r27
001f57 93b0 28da                 	sts triangle_pitch_macro_offset, r27
                                 sound_driver_channel2_release_hi_pitch:
001f59 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
001f5b 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
001f5c f019                      	breq sound_driver_channel2_release_duty
001f5d 95b3                      	inc r27
001f5e 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27
                                 sound_driver_channel2_release_duty:
001f60 91b0 28e7                 	lds r27, triangle_duty_macro_release
001f62 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
001f63 f019                      	breq sound_driver_channel2_release_exit
001f64 95b3                      	inc r27
001f65 93b0 28e5                 	sts triangle_duty_macro_offset, r27
                                 sound_driver_channel2_release_exit:
001f67 d019                      	rcall sound_driver_channel2_increment_offset
001f68 cd6d                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_next_pattern:
001f69 91e0 2819                 	lds ZL, song_frames
001f6b 91f0 281a                 	lds ZH, song_frames+1
001f6d 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
001f6f 91b0 281c                 	lds r27, song_frame_offset+1
001f71 9614                      	adiw r27:r26, 4 //offset for channel 2
001f72 0fea                      	add ZL, r26
001f73 1ffb                      	adc ZH, r27
                                 
001f74 91a5                      	lpm r26, Z+ //load the address of the next pattern
001f75 91b4                      	lpm r27, Z
001f76 0faa                      	lsl r26
001f77 1fbb                      	rol r27
001f78 93a0 28c5                 	sts triangle_pattern, r26
001f7a 93b0 28c6                 	sts triangle_pattern+1, r27
                                 
001f7c 9220 28c9                 	sts triangle_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
001f7e 9220 28ca                 	sts triangle_pattern_offset+1, zero
001f80 cd55                      	rjmp sound_driver_channel2_main
                                 
                                 
                                 
                                 sound_driver_channel2_increment_offset:
001f81 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001f83 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
001f85 9631                      	adiw Z, 1
001f86 93e0 28c9                 	sts triangle_pattern_offset, ZL
001f88 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
001f8a 9508                      	ret
                                 
                                 sound_driver_channel2_increment_offset_twice: //used for data that takes up 2 bytes worth of space
001f8b 91e0 28c9                 	lds ZL, triangle_pattern_offset //current offset in the pattern for triangle
001f8d 91f0 28ca                 	lds ZH, triangle_pattern_offset+1
001f8f 9632                      	adiw Z, 2 //increment the pointer twice
001f90 93e0 28c9                 	sts triangle_pattern_offset, ZL
001f92 93f0 28ca                 	sts triangle_pattern_offset+1, ZH
001f94 9508                      	ret
                                 
                                 sound_driver_channel2_decrement_frame_delay:
001f95 95ba                      	dec r27
001f96 93b0 28c8                 	sts triangle_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel3:
001f98 91a0 2913                 	lds r26, noise_pattern_delay_rows
001f9a 91b0 2914                 	lds r27, noise_pattern_delay_frames
001f9c 9610                      	adiw r27:r26, 0
001f9d f009                      	breq sound_driver_channel3_main //if the pattern delay is 0, proceed with sound driver procedures
001f9e c1b9                      	rjmp sound_driver_channel3_decrement_frame_delay //if the pattern delay is not 0, decrement the delay
                                 
                                 sound_driver_channel3_main:
001f9f 91e0 2911                 	lds ZL, noise_pattern //current pattern for noise
001fa1 91f0 2912                 	lds ZH, noise_pattern+1
001fa3 91a0 2915                 	lds r26, noise_pattern_offset //current offset in the pattern for noise
001fa5 91b0 2916                 	lds r27, noise_pattern_offset+1
001fa7 0fea                      	add ZL, r26 //offset the current pattern pointer to point to new byte data
001fa8 1ffb                      	adc ZH, r27
001fa9 91b4                      	lpm r27, Z //load the byte data from the current pattern
                                 
                                 sound_driver_channel3_check_if_note: //check if data is a note (0x00 - 0x56)
001faa 35b7                      	cpi r27, 0x57
001fab f408                      	brsh sound_driver_channel3_check_if_volume
001fac c096                      	rjmp sound_driver_channel3_note
                                 sound_driver_channel3_check_if_volume: //check if data is volume (0x57-0x66)
001fad 36b7                      	cpi r27, 0x67
001fae f408                      	brsh sound_driver_channel3_check_if_delay
001faf c0b1                      	rjmp sound_driver_channel3_volume
                                 sound_driver_channel3_check_if_delay: //check if data is a delay (0x67 - 0xE2)
001fb0 3eb3                      	cpi r27, 0xE3
001fb1 f408                      	brsh sound_driver_channel3_check_if_instrument
001fb2 c0b7                      	rjmp sound_driver_channel3_delay
                                 sound_driver_channel3_check_if_instrument: //check for instrument flag (0xE3)
001fb3 f409                      	brne sound_driver_channel3_check_if_release
001fb4 c0ba                      	rjmp sound_driver_channel3_instrument_change 
                                 sound_driver_channel3_check_if_release: //check for note release flag (0xE4)
001fb5 3eb4                      	cpi r27, 0xE4
001fb6 f409                      	brne sound_driver_channel3_check_if_end
001fb7 c14b                      	rjmp sound_driver_channel3_release
                                 sound_driver_channel3_check_if_end:
001fb8 3fbf                      	cpi r27, 0xFF
001fb9 f409                      	brne sound_driver_channel3_check_if_fx
001fba c16d                      	rjmp sound_driver_channel3_next_pattern
                                 
                                 
                                 
                                 sound_driver_channel3_check_if_fx: //fx flags (0xE5 - 0xFE)
001fbb 9631                      	adiw Z, 1 //point Z to the byte next to the flag
001fbc 91a4                      	lpm r26, Z //load the fx data into r26
001fbd d190                      	rcall sound_driver_channel3_increment_offset_twice
                                 
001fbe 5eb5                      	subi r27, 0xE5 //prepare offset to perform table lookup
001fbf efe0                      	ldi ZL, LOW(channel3_fx << 1) //load in note table
001fc0 e5fc                      	ldi ZH, HIGH(channel3_fx << 1)
001fc1 0fbb                      	lsl r27 //double the offset for the table because we are getting byte data
001fc2 0feb                      	add ZL, r27 //add offset
001fc3 1df2                      	adc ZH, zero
001fc4 91c5                      	lpm r28, Z+ //load address bytes
001fc5 91d4                      	lpm r29, Z
001fc6 2fec                      	mov ZL, r28 //move address bytes back into Z for an indirect jump
001fc7 2ffd                      	mov ZH, r29
001fc8 9409                      	ijmp
                                 
                                 
                                 //ARPEGGIO
                                 sound_driver_channel3_fx_0xy:
001fc9 93a0 2934                 	sts noise_fx_0xy_sequence, r26
001fcb 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
001fcd cfd1                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE UP
                                 sound_driver_channel3_fx_1xx:
001fce 9220 2938                 	sts noise_fx_2xx, zero //turn off any 2xx pitch slide down
001fd0 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001fd2 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
001fd4 93a0 2936                 	sts noise_fx_1xx, r26
001fd6 cfc8                      	rjmp sound_driver_channel3_main
                                 
                                 //PITCH SLIDE DOWN
                                 sound_driver_channel3_fx_2xx:
001fd7 9220 2936                 	sts noise_fx_1xx, zero //turn off any 1xx pitch slide down
001fd9 9220 2934                 	sts noise_fx_0xy_sequence, zero //disable any 0xy effect
001fdb 9220 2935                 	sts noise_fx_0xy_sequence+1, zero
001fdd 93a0 2938                 	sts noise_fx_2xx, r26
001fdf cfbf                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_3xx: //automatic portamento
001fe0 cfbe                      	rjmp sound_driver_channel3_main
                                 
                                 //VIBRATO
                                 sound_driver_channel3_fx_4xy:
001fe1 2fba                      	mov r27, r26
001fe2 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001fe3 95a2                      	swap r26
001fe4 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001fe5 93a0 293a                 	sts noise_fx_4xy_speed, r26
001fe7 93b0 293b                 	sts noise_fx_4xy_depth, r27
001fe9 9220 293c                 	sts noise_fx_4xy_phase, zero //reset the phase to 0
001feb 9220 293d                 	sts noise_fx_4xy_offset, zero
001fed cfb1                      	rjmp sound_driver_channel3_main
                                 
                                 //TREMELO
                                 sound_driver_channel3_fx_7xy:
001fee 2fba                      	mov r27, r26
001fef 7fa0                      	andi r26, 0xF0 //mask r26 for x, the speed param
001ff0 95a2                      	swap r26
001ff1 70bf                      	andi r27, 0x0F //mask r27 for y, the depth param
001ff2 93a0 293e                 	sts noise_fx_7xy_speed, r26
001ff4 93b0 293f                 	sts noise_fx_7xy_depth, r27
001ff6 9220 2940                 	sts noise_fx_7xy_phase, zero //reset the phase to 0
001ff8 9220 2941                 	sts noise_fx_7xy_value, zero //reset the tremelo value
001ffa cfa4                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME SLIDE
                                 sound_driver_channel3_fx_Axy:
001ffb 93a0 2942                 	sts noise_fx_Axy, r26
001ffd cfa1                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME JUMP
                                 sound_driver_channel3_fx_Bxx:
001ffe 93a0 2820                 	sts song_fx_Bxx, r26 //NOTE: a Bxx value of FF won't be detected since FF is used to indicate that the flag is disabled
002000 cf9e                      	rjmp sound_driver_channel3_main
                                 
                                 //HALT
                                 sound_driver_channel3_fx_Cxx:
002001 93b0 2821                 	sts song_fx_Cxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002003 cf9b                      	rjmp sound_driver_channel3_main
                                 
                                 //FRAME SKIP
                                 sound_driver_channel3_fx_Dxx:
002004 93b0 2822                 	sts song_fx_Dxx, r27 //NOTE: the value stored doesn't mean anything. we only need to check that it is non-zero
002006 cf98                      	rjmp sound_driver_channel3_main
                                 
                                 //VOLUME
                                 sound_driver_channel3_fx_Exx:
002007 91b0 2813                 	lds r27, noise_param
002009 7fb0                      	andi r27, 0xF0 //clear previous VVVV volume bits
00200a 2bba                      	or r27, r26 //move new VVVV bits into noise_param
00200b 93b0 2813                 	sts noise_param, r27
00200d cf91                      	rjmp sound_driver_channel3_main
                                 
                                 //SPEED AND TEMPO
                                 sound_driver_channel3_fx_Fxx:
00200e 93a0 281f                 	sts song_speed, r26 //NOTE: only changes to speed are supported
002010 cf8e                      	rjmp sound_driver_channel3_main
                                 
                                 //DELAY
                                 sound_driver_channel3_fx_Gxx:
002011 15a2                      	cp r26, zero
002012 f051                      	breq sound_driver_channel3_fx_Gxx_invalid
002013 91b0 281f                 	lds r27, song_speed
002015 17ab                      	cp r26, r27
002016 f430                      	brsh sound_driver_channel3_fx_Gxx_invalid
002017 93a0 2943                 	sts noise_fx_Gxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
002019 e0b1                      	ldi r27, 0x01
00201a 93b0 2913                 	sts noise_pattern_delay_rows, r27
00201c c13e                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Gxx_invalid:
00201d cf81                      	rjmp sound_driver_channel3_main //if Gxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 sound_driver_channel3_fx_Hxy: //hardware sweep up
00201e cf80                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixy: //hardware sweep down
00201f cf7f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Hxx: //FDS modulation depth
002020 cf7e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Ixx: //FDS modulation speed
002021 cf7d                      	rjmp sound_driver_channel3_main
                                 
                                 //FINE PITCH
                                 sound_driver_channel3_fx_Pxx:
002022 93a0 2945                 	sts noise_fx_Pxx_total, r26
002024 cf7a                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Qxy: //note slide up
002025 cf79                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Rxy: //note slide down
002026 cf78                      	rjmp sound_driver_channel3_main
                                 
                                 //MUTE DELAY
                                 sound_driver_channel3_fx_Sxx:
002027 15a2                      	cp r26, zero
002028 f051                      	breq sound_driver_channel3_fx_Sxx_invalid
002029 91b0 281f                 	lds r27, song_speed
00202b 17ab                      	cp r26, r27
00202c f430                      	brsh sound_driver_channel3_fx_Sxx_invalid
00202d 93a0 2946                 	sts noise_fx_Sxx_pre, r26 //NOTE: to be processed in the sound driver delay routine
00202f e0b1                      	ldi r27, 0x01
002030 93b0 2913                 	sts noise_pattern_delay_rows, r27
002032 c128                      	rjmp sound_driver_channel4
                                 sound_driver_channel3_fx_Sxx_invalid:
002033 cf6b                      	rjmp sound_driver_channel3_main //if Sxx was 0 or >= the song speed, ignore it and continue reading note data
                                 
                                 //DUTY
                                 sound_driver_channel3_fx_Vxx:
002034 95a6                      	lsr r26
002035 95a7                      	ror r26 //move mode bit to bit 7
002036 91b0 2814                 	lds r27, noise_period
002038 77bf                      	andi r27, 0b01111111
002039 2bba                      	or r27, r26 //store the new noise mode
00203a 93b0 2813                 	sts noise_param, r27
                                 
00203c 776f                      	andi noise_sequence_HIGH, 0b01111111
00203d 2b6a                      	or noise_sequence_HIGH, r26
00203e cf60                      	rjmp sound_driver_channel3_main
                                 
                                 sound_driver_channel3_fx_Wxx: //DPCM sample speed
00203f cf5f                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Xxx: //DPCM sample retrigger
002040 cf5e                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Yxx: //DPCM sample offset
002041 cf5d                      	rjmp sound_driver_channel3_main
                                 sound_driver_channel3_fx_Zxx: //DPCM sample delta counter
002042 cf5c                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 sound_driver_channel3_note:
002043 93b0 2817                 	sts noise_note, r27
002045 93b0 2818                 	sts noise_adjusted_note, r27
002047 e0a3                      	ldi r26, 0x03
002048 e0b2                      	ldi r27, 0x02
002049 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
00204b 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
00204d 93b0 2926                 	sts noise_pitch_macro_offset, r27
00204f 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
002051 93b0 2931                 	sts noise_duty_macro_offset, r27
002053 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch and hi pitch offset
002055 9220 2923                 	sts noise_total_pitch_offset+1, zero
002057 9220 2929                 	sts noise_total_hi_pitch_offset, zero
002059 9220 2937                 	sts noise_fx_1xx_total, zero //reset the total for 1xx and 2xx effects
00205b 9220 2939                 	sts noise_fx_2xx_total, zero
00205d 9220 293d                 	sts noise_fx_4xy_offset, zero
00205f d0e4                      	rcall sound_driver_channel3_increment_offset
002060 cf3e                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_volume:
002061 55b7                      	subi r27, 0x57 //NOTE: the delay values are offset by the highest volume value, which is 0x56
002062 91a0 2813                 	lds r26, noise_param
002064 7fa0                      	andi r26, 0xF0 //clear previous VVVV volume bits
002065 2bab                      	or r26, r27 //move new VVVV bits into noise_param
002066 93a0 2813                 	sts noise_param, r26
002068 d0db                      	rcall sound_driver_channel3_increment_offset
002069 cf35                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_delay:
00206a 56b6                      	subi r27, 0x66 //NOTE: the delay values are offset by the highest volume value, which is 0x66
00206b 93b0 2913                 	sts noise_pattern_delay_rows, r27
00206d d0d6                      	rcall sound_driver_channel3_increment_offset
00206e c0ec                      	rjmp sound_driver_channel4
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change:
00206f 9220 2917                 	sts noise_volume_macro, zero //reset all macro addresses
002071 9220 2918                 	sts noise_volume_macro+1, zero
002073 9220 291c                 	sts noise_arpeggio_macro, zero
002075 9220 291d                 	sts noise_arpeggio_macro+1, zero
002077 9220 2924                 	sts noise_pitch_macro, zero
002079 9220 2925                 	sts noise_pitch_macro+1, zero
00207b 9220 292a                 	sts noise_hi_pitch_macro, zero
00207d 9220 292b                 	sts noise_hi_pitch_macro+1, zero
00207f 9220 292f                 	sts noise_duty_macro, zero
002081 9220 2930                 	sts noise_duty_macro+1, zero
002083 9220 2922                 	sts noise_total_pitch_offset, zero //reset the pitch offset
002085 9220 2923                 	sts noise_total_pitch_offset+1, zero
002087 9220 2929                 	sts noise_total_hi_pitch_offset, zero //reset the hi pitch offset
                                 
002089 9631                      	adiw Z, 1 //point to the byte next to the flag
00208a 91b4                      	lpm r27, Z //store the instrument offset into r27
00208b e7e1                      	ldi ZL, LOW(instruments) //point Z to instruments table
00208c e1f0                      	ldi ZH, HIGH(instruments)
00208d 0feb                      	add ZL, r27 //point Z to offsetted instrument
00208e 1df2                      	adc ZH, zero
00208f 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the instrument's address
002090 1fff                      	rol ZH
002091 91a5                      	lpm r26, Z+ //r26:r27 now points to the instrument
002092 91b4                      	lpm r27, Z
                                 
002093 0faa                      	lsl r26 //multiply by 2 to make r26:r27 into a byte pointer for the instrument's data
002094 1fbb                      	rol r27
002095 2fea                      	mov ZL, r26
002096 2ffb                      	mov ZH, r27
002097 91b4                      	lpm r27, Z //get macro header byte. NOTE: Each macro type for each intrument is represented by a bit in this byte. 1 indicates that the instrument uses a macro of it's corresponding type.
002098 9632                      	adiw Z, 2 //point Z to the address of the macro
002099 e0a6                      	ldi r26, 6 //(6-1) = 5 for the 5 different macro types. NOTE: bit 0 = volume, bit 1 = arpeggio, bit 2 = pitch, bit 3 = hi pitch, bit 4 = duty
                                 sound_driver_channel3_instrument_change_macro_loop:
00209a 95aa                      	dec r26
00209b f019                      	breq sound_driver_channel3_instrument_change_exit
00209c 95b6                      	lsr r27
00209d f078                      	brcs sound_driver_channel3_instrument_change_load_macro
00209e cffb                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_exit:
00209f e0a3                      	ldi r26, 0x03
0020a0 e0b2                      	ldi r27, 0x02
0020a1 93b0 2919                 	sts noise_volume_macro_offset, r27 //reset all macro offsets
0020a3 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
0020a5 93b0 2926                 	sts noise_pitch_macro_offset, r27
0020a7 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
0020a9 93b0 2931                 	sts noise_duty_macro_offset, r27
0020ab d0a2                      	rcall sound_driver_channel3_increment_offset_twice
0020ac cef2                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_load_macro:
0020ad 91c5                      	lpm r28, Z+ //r28:r29 now point to the macro
0020ae 91d5                      	lpm r29, Z+
                                 
0020af 30a5                      	cpi r26, 5
0020b0 f039                      	breq sound_driver_channel3_instrument_change_load_macro_volume
0020b1 30a4                      	cpi r26, 4
0020b2 f079                      	breq sound_driver_channel3_instrument_change_load_macro_arpeggio
0020b3 30a3                      	cpi r26, 3
0020b4 f099                      	breq sound_driver_channel3_instrument_change_load_macro_pitch
0020b5 30a2                      	cpi r26, 2
0020b6 f0d9                      	breq sound_driver_channel3_instrument_change_load_macro_hi_pitch
0020b7 c024                      	rjmp sound_driver_channel3_instrument_change_load_macro_duty
                                 
                                 sound_driver_channel3_instrument_change_load_macro_volume:
0020b8 93c0 2917                 	sts noise_volume_macro, r28
0020ba 93d0 2918                 	sts noise_volume_macro+1, r29
0020bc d029                      	rcall sound_driver_channel3_instrument_change_read_header
0020bd 93c0 291b                 	sts noise_volume_macro_release, r28
0020bf 93d0 291a                 	sts noise_volume_macro_loop, r29
0020c1 cfd8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 	
                                 sound_driver_channel3_instrument_change_load_macro_arpeggio:
0020c2 93c0 291c                 	sts noise_arpeggio_macro, r28
0020c4 93d0 291d                 	sts noise_arpeggio_macro+1, r29
0020c6 d02a                      	rcall sound_driver_channel3_instrument_change_read_header_arpeggio
0020c7 cfd2                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_pitch:
0020c8 93c0 2924                 	sts noise_pitch_macro, r28
0020ca 93d0 2925                 	sts noise_pitch_macro+1, r29
0020cc d019                      	rcall sound_driver_channel3_instrument_change_read_header
0020cd 93c0 2928                 	sts noise_pitch_macro_release, r28
0020cf 93d0 2927                 	sts noise_pitch_macro_loop, r29
0020d1 cfc8                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_hi_pitch:
0020d2 93c0 292a                 	sts noise_hi_pitch_macro, r28
0020d4 93d0 292b                 	sts noise_hi_pitch_macro+1, r29
0020d6 d00f                      	rcall sound_driver_channel3_instrument_change_read_header
0020d7 93c0 292e                 	sts noise_hi_pitch_macro_release, r28
0020d9 93d0 292d                 	sts noise_hi_pitch_macro_loop, r29
0020db cfbe                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 sound_driver_channel3_instrument_change_load_macro_duty:
0020dc 93c0 292f                 	sts noise_duty_macro, r28
0020de 93d0 2930                 	sts noise_duty_macro+1, r29
0020e0 d005                      	rcall sound_driver_channel3_instrument_change_read_header
0020e1 93c0 2933                 	sts noise_duty_macro_release, r28
0020e3 93d0 2932                 	sts noise_duty_macro_loop, r29
0020e5 cfb4                      	rjmp sound_driver_channel3_instrument_change_macro_loop
                                 
                                 
                                 
                                 sound_driver_channel3_instrument_change_read_header:
0020e6 93ef                      	push ZL
0020e7 93ff                      	push ZH
0020e8 2fec                      	mov ZL, r28
0020e9 2ffd                      	mov ZH, r29
0020ea 0fee                      	lsl ZL
0020eb 1fff                      	rol ZH
0020ec 91c5                      	lpm r28, Z+
0020ed 91d4                      	lpm r29, Z
0020ee 91ff                      	pop ZH
0020ef 91ef                      	pop ZL
0020f0 9508                      	ret
                                 
                                 sound_driver_channel3_instrument_change_read_header_arpeggio:
0020f1 93ef                      	push ZL
0020f2 93ff                      	push ZH
0020f3 2fec                      	mov ZL, r28
0020f4 2ffd                      	mov ZH, r29
0020f5 0fee                      	lsl ZL
0020f6 1fff                      	rol ZH
0020f7 91c5                      	lpm r28, Z+
0020f8 91d5                      	lpm r29, Z+
0020f9 93c0 2920                 	sts noise_arpeggio_macro_release, r28
0020fb 93d0 291f                 	sts noise_arpeggio_macro_loop, r29
0020fd 91c4                      	lpm r28, Z
0020fe 93c0 2921                 	sts noise_arpeggio_macro_mode, r28
002100 91ff                      	pop ZH
002101 91ef                      	pop ZL
002102 9508                      	ret
                                 
                                 
                                 
                                 sound_driver_channel3_release:
                                 sound_driver_channel3_release_volume:
002103 91b0 291b                 	lds r27, noise_volume_macro_release
002105 3fbf                      	cpi r27, 0xFF //check if volume macro has a release flag
002106 f019                      	breq sound_driver_channel3_release_arpeggio //if the macro has no release flag, check the next macro
002107 95b3                      	inc r27
002108 93b0 2919                 	sts noise_volume_macro_offset, r27 //adjust offset so that it starts after the release flag index
                                 sound_driver_channel3_release_arpeggio:
00210a 91b0 2920                 	lds r27, noise_arpeggio_macro_release
00210c 3fbf                      	cpi r27, 0xFF //check if arpeggio macro has a release flag
00210d f019                      	breq sound_driver_channel3_release_pitch
00210e 95b3                      	inc r27
00210f 93b0 291e                 	sts noise_arpeggio_macro_offset, r27
                                 sound_driver_channel3_release_pitch:
002111 91b0 2928                 	lds r27, noise_pitch_macro_release
002113 3fbf                      	cpi r27, 0xFF //check if pitch macro has a release flag
002114 f019                      	breq sound_driver_channel3_release_hi_pitch
002115 95b3                      	inc r27
002116 93b0 2926                 	sts noise_pitch_macro_offset, r27
                                 sound_driver_channel3_release_hi_pitch:
002118 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
00211a 3fbf                      	cpi r27, 0xFF //check if hi_pitch macro has a release flag
00211b f019                      	breq sound_driver_channel3_release_duty
00211c 95b3                      	inc r27
00211d 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27
                                 sound_driver_channel3_release_duty:
00211f 91b0 2933                 	lds r27, noise_duty_macro_release
002121 3fbf                      	cpi r27, 0xFF //check if duty macro has a release flag
002122 f019                      	breq sound_driver_channel3_release_exit
002123 95b3                      	inc r27
002124 93b0 2931                 	sts noise_duty_macro_offset, r27
                                 sound_driver_channel3_release_exit:
002126 d01d                      	rcall sound_driver_channel3_increment_offset
002127 ce77                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_next_pattern:
002128 91e0 2819                 	lds ZL, song_frames
00212a 91f0 281a                 	lds ZH, song_frames+1
00212c 91a0 281b                 	lds r26, song_frame_offset //we must offset to the appropriate channel
00212e 91b0 281c                 	lds r27, song_frame_offset+1
002130 93a0 281b                 	sts song_frame_offset, r26
002132 93b0 281c                 	sts song_frame_offset+1, r27
002134 9616                      	adiw r27:r26, 6 //offset for channel 3
002135 0fea                      	add ZL, r26
002136 1ffb                      	adc ZH, r27
                                 
002137 91a5                      	lpm r26, Z+ //load the address of the next pattern
002138 91b4                      	lpm r27, Z
002139 0faa                      	lsl r26
00213a 1fbb                      	rol r27
00213b 93a0 2911                 	sts noise_pattern, r26
00213d 93b0 2912                 	sts noise_pattern+1, r27
                                 
00213f 9220 2915                 	sts noise_pattern_offset, zero //restart the pattern offset back to 0 because we are reading from a new pattern now
002141 9220 2916                 	sts noise_pattern_offset+1, zero
002143 ce5b                      	rjmp sound_driver_channel3_main
                                 
                                 
                                 
                                 sound_driver_channel3_increment_offset:
002144 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002146 91f0 2916                 	lds ZH, noise_pattern_offset+1
002148 9631                      	adiw Z, 1
002149 93e0 2915                 	sts noise_pattern_offset, ZL
00214b 93f0 2916                 	sts noise_pattern_offset+1, ZH
00214d 9508                      	ret
                                 
                                 sound_driver_channel3_increment_offset_twice: //used for data that takes up 2 bytes worth of space
00214e 91e0 2915                 	lds ZL, noise_pattern_offset //current offset in the pattern for noise
002150 91f0 2916                 	lds ZH, noise_pattern_offset+1
002152 9632                      	adiw Z, 2 //increment the pointer twice
002153 93e0 2915                 	sts noise_pattern_offset, ZL
002155 93f0 2916                 	sts noise_pattern_offset+1, ZH
002157 9508                      	ret
                                 
                                 sound_driver_channel3_decrement_frame_delay:
002158 95ba                      	dec r27
002159 93b0 2914                 	sts noise_pattern_delay_frames, r27
                                 
                                 
                                 
                                 sound_driver_channel4:
                                 
                                 sound_driver_calculate_delays:
00215b 91f0 281f                 	lds r31, song_speed
00215d 2fef                      	mov r30, r31
00215e 50e1                      	subi r30, 1
                                 sound_driver_calculate_delays_pulse1:
00215f 91a0 2826                 	lds r26, pulse1_pattern_delay_frames
002161 11a2                      	cpse r26, zero
002162 c042                      	rjmp sound_driver_calculate_delays_pulse2
002163 c000                      	rjmp sound_driver_calculate_delays_pulse1_main
                                 
                                 sound_driver_calculate_delays_pulse1_main:
002164 2faf                      	mov r26, r31 //move the speed to r26
002165 91b0 2825                 	lds r27, pulse1_pattern_delay_rows //decrement the delay rows
002167 15b2                      	cp r27, zero
002168 f409                      	brne PC+2
002169 c03b                      	rjmp sound_driver_calculate_delays_pulse2
00216a 95ba                      	dec r27
00216b 93b0 2825                 	sts pulse1_pattern_delay_rows, r27
00216d 11b2                      	cpse r27, zero
00216e c034                      	rjmp sound_driver_calculate_delays_pulse1_store
00216f 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx:
002170 efbf                      	ldi r27, 0xFF
002171 91c0 2872                 	lds r28, pulse1_fx_Sxx_pre
002173 91d0 2873                 	lds r29, pulse1_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse1_Sxx_check_pre:
002175 17cb                      	cp r28, r27
002176 f009                      	breq sound_driver_calculate_delays_pulse1_Sxx_check_post
002177 c00d                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_pre
                                 sound_driver_calculate_delays_pulse1_Sxx_check_post:
002178 17db                      	cp r29, r27
002179 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx
00217a c015                      	rjmp sound_driver_calculate_delays_pulse1_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx:
00217b 91c0 2860                 	lds r28, pulse1_fx_Gxx_pre
00217d 91d0 2861                 	lds r29, pulse1_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse1_Gxx_check_pre:
00217f 17cb                      	cp r28, r27
002180 f009                      	breq sound_driver_calculate_delays_pulse1_Gxx_check_post
002181 c012                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_pre
                                 sound_driver_calculate_delays_pulse1_Gxx_check_post:
002182 17db                      	cp r29, r27
002183 f0f9                      	breq sound_driver_calculate_delays_pulse1_store
002184 c01a                      	rjmp sound_driver_calculate_delays_pulse1_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_pre:
002185 93b0 2872                 	sts pulse1_fx_Sxx_pre, r27
002187 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002188 93e0 2873                 	sts pulse1_fx_Sxx_post, r30
00218a 95ca                      	dec r28
00218b 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
00218d 2fef                      	mov r30, r31
00218e 50e1                      	subi r30, 1
00218f c015                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse1_Sxx_post:
002190 93b0 2873                 	sts pulse1_fx_Sxx_post, r27
002192 2fad                      	mov r26, r29
002193 c00f                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_Gxx_pre:
002194 93b0 2860                 	sts pulse1_fx_Gxx_pre, r27
002196 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002197 93e0 2861                 	sts pulse1_fx_Gxx_post, r30
002199 95ca                      	dec r28
00219a 93c0 2826                 	sts pulse1_pattern_delay_frames, r28
00219c 2fef                      	mov r30, r31
00219d 50e1                      	subi r30, 1
00219e c006                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse1_Gxx_post:
00219f 93b0 2861                 	sts pulse1_fx_Gxx_post, r27
0021a1 2fad                      	mov r26, r29
0021a2 c000                      	rjmp sound_driver_calculate_delays_pulse1_store
                                 
                                 sound_driver_calculate_delays_pulse1_store:
0021a3 93a0 2826                 	sts pulse1_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_pulse2:
0021a5 91a0 2877                 	lds r26, pulse2_pattern_delay_frames
0021a7 11a2                      	cpse r26, zero
0021a8 c042                      	rjmp sound_driver_calculate_delays_triangle
0021a9 c000                      	rjmp sound_driver_calculate_delays_pulse2_main
                                 
                                 sound_driver_calculate_delays_pulse2_main:
0021aa 2faf                      	mov r26, r31 //move the speed to r26
0021ab 91b0 2876                 	lds r27, pulse2_pattern_delay_rows //decrement the delay rows
0021ad 15b2                      	cp r27, zero
0021ae f409                      	brne PC+2
0021af c03b                      	rjmp sound_driver_calculate_delays_triangle
0021b0 95ba                      	dec r27
0021b1 93b0 2876                 	sts pulse2_pattern_delay_rows, r27
0021b3 11b2                      	cpse r27, zero
0021b4 c034                      	rjmp sound_driver_calculate_delays_pulse2_store
0021b5 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx:
0021b6 efbf                      	ldi r27, 0xFF
0021b7 91c0 28c3                 	lds r28, pulse2_fx_Sxx_pre
0021b9 91d0 28c4                 	lds r29, pulse2_fx_Sxx_post
                                 sound_driver_calculate_delays_pulse2_Sxx_check_pre:
0021bb 17cb                      	cp r28, r27
0021bc f009                      	breq sound_driver_calculate_delays_pulse2_Sxx_check_post
0021bd c00d                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_pre
                                 sound_driver_calculate_delays_pulse2_Sxx_check_post:
0021be 17db                      	cp r29, r27
0021bf f009                      	breq sound_driver_calculate_delays_pulse2_Gxx
0021c0 c015                      	rjmp sound_driver_calculate_delays_pulse2_Sxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx:
0021c1 91c0 28b1                 	lds r28, pulse2_fx_Gxx_pre
0021c3 91d0 28b2                 	lds r29, pulse2_fx_Gxx_post
                                 sound_driver_calculate_delays_pulse2_Gxx_check_pre:
0021c5 17cb                      	cp r28, r27
0021c6 f009                      	breq sound_driver_calculate_delays_pulse2_Gxx_check_post
0021c7 c012                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_pre
                                 sound_driver_calculate_delays_pulse2_Gxx_check_post:
0021c8 17db                      	cp r29, r27
0021c9 f0f9                      	breq sound_driver_calculate_delays_pulse2_store
0021ca c01a                      	rjmp sound_driver_calculate_delays_pulse2_Gxx_post
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_pre:
0021cb 93b0 28c3                 	sts pulse2_fx_Sxx_pre, r27
0021cd 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0021ce 93e0 28c4                 	sts pulse2_fx_Sxx_post, r30
0021d0 95ca                      	dec r28
0021d1 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
0021d3 2fef                      	mov r30, r31
0021d4 50e1                      	subi r30, 1
0021d5 cfcf                      	rjmp sound_driver_calculate_delays_pulse2
                                 
                                 sound_driver_calculate_delays_pulse2_Sxx_post:
0021d6 93b0 28c4                 	sts pulse2_fx_Sxx_post, r27
0021d8 2fad                      	mov r26, r29
0021d9 c00f                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_Gxx_pre:
0021da 93b0 28b1                 	sts pulse2_fx_Gxx_pre, r27
0021dc 1bec                      	sub r30, r28 //(song speed)-1-Sxx
0021dd 93e0 28b2                 	sts pulse2_fx_Gxx_post, r30
0021df 95ca                      	dec r28
0021e0 93c0 2877                 	sts pulse2_pattern_delay_frames, r28
0021e2 2fef                      	mov r30, r31
0021e3 50e1                      	subi r30, 1
0021e4 cfc0                      	rjmp sound_driver_calculate_delays_pulse2
                                 	
                                 sound_driver_calculate_delays_pulse2_Gxx_post:
0021e5 93b0 28b2                 	sts pulse2_fx_Gxx_post, r27
0021e7 2fad                      	mov r26, r29
0021e8 c000                      	rjmp sound_driver_calculate_delays_pulse2_store
                                 
                                 sound_driver_calculate_delays_pulse2_store:
0021e9 93a0 2877                 	sts pulse2_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_triangle:
0021eb 91a0 28c8                 	lds r26, triangle_pattern_delay_frames
0021ed 11a2                      	cpse r26, zero
0021ee c042                      	rjmp sound_driver_calculate_delays_noise
0021ef c000                      	rjmp sound_driver_calculate_delays_triangle_main
                                 
                                 sound_driver_calculate_delays_triangle_main:
0021f0 2faf                      	mov r26, r31 //move the speed to r26
0021f1 91b0 28c7                 	lds r27, triangle_pattern_delay_rows //decrement the delay rows
0021f3 15b2                      	cp r27, zero
0021f4 f409                      	brne PC+2
0021f5 c03b                      	rjmp sound_driver_calculate_delays_noise
0021f6 95ba                      	dec r27
0021f7 93b0 28c7                 	sts triangle_pattern_delay_rows, r27
0021f9 11b2                      	cpse r27, zero
0021fa c034                      	rjmp sound_driver_calculate_delays_triangle_store
0021fb 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_triangle_Sxx:
0021fc efbf                      	ldi r27, 0xFF
0021fd 91c0 290f                 	lds r28, triangle_fx_Sxx_pre
0021ff 91d0 2910                 	lds r29, triangle_fx_Sxx_post
                                 sound_driver_calculate_delays_triangle_Sxx_check_pre:
002201 17cb                      	cp r28, r27
002202 f009                      	breq sound_driver_calculate_delays_triangle_Sxx_check_post
002203 c00d                      	rjmp sound_driver_calculate_delays_triangle_Sxx_pre
                                 sound_driver_calculate_delays_triangle_Sxx_check_post:
002204 17db                      	cp r29, r27
002205 f009                      	breq sound_driver_calculate_delays_triangle_Gxx
002206 c015                      	rjmp sound_driver_calculate_delays_triangle_Sxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Gxx:
002207 91c0 28fd                 	lds r28, triangle_fx_Gxx_pre
002209 91d0 28fe                 	lds r29, triangle_fx_Gxx_post
                                 sound_driver_calculate_delays_triangle_Gxx_check_pre:
00220b 17cb                      	cp r28, r27
00220c f009                      	breq sound_driver_calculate_delays_triangle_Gxx_check_post
00220d c012                      	rjmp sound_driver_calculate_delays_triangle_Gxx_pre
                                 sound_driver_calculate_delays_triangle_Gxx_check_post:
00220e 17db                      	cp r29, r27
00220f f0f9                      	breq sound_driver_calculate_delays_triangle_store
002210 c01a                      	rjmp sound_driver_calculate_delays_triangle_Gxx_post
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_pre:
002211 93b0 290f                 	sts triangle_fx_Sxx_pre, r27
002213 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002214 93e0 2910                 	sts triangle_fx_Sxx_post, r30
002216 95ca                      	dec r28
002217 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
002219 2fef                      	mov r30, r31
00221a 50e1                      	subi r30, 1
00221b c015                      	rjmp sound_driver_calculate_delays_noise
                                 
                                 sound_driver_calculate_delays_triangle_Sxx_post:
00221c 93b0 2910                 	sts triangle_fx_Sxx_post, r27
00221e 2fad                      	mov r26, r29
00221f c00f                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_Gxx_pre:
002220 93b0 28fd                 	sts triangle_fx_Gxx_pre, r27
002222 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002223 93e0 28fe                 	sts triangle_fx_Gxx_post, r30
002225 95ca                      	dec r28
002226 93c0 28c8                 	sts triangle_pattern_delay_frames, r28
002228 2fef                      	mov r30, r31
002229 50e1                      	subi r30, 1
00222a c006                      	rjmp sound_driver_calculate_delays_noise
                                 	
                                 sound_driver_calculate_delays_triangle_Gxx_post:
00222b 93b0 28fe                 	sts triangle_fx_Gxx_post, r27
00222d 2fad                      	mov r26, r29
00222e c000                      	rjmp sound_driver_calculate_delays_triangle_store
                                 
                                 sound_driver_calculate_delays_triangle_store:
00222f 93a0 28c8                 	sts triangle_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_noise:
002231 91a0 2914                 	lds r26, noise_pattern_delay_frames
002233 11a2                      	cpse r26, zero
002234 c042                      	rjmp sound_driver_calculate_delays_dpcm
002235 c000                      	rjmp sound_driver_calculate_delays_noise_main
                                 
                                 sound_driver_calculate_delays_noise_main:
002236 2faf                      	mov r26, r31 //move the speed to r26
002237 91b0 2913                 	lds r27, noise_pattern_delay_rows //decrement the delay rows
002239 15b2                      	cp r27, zero
00223a f409                      	brne PC+2
00223b c03b                      	rjmp sound_driver_calculate_delays_dpcm
00223c 95ba                      	dec r27
00223d 93b0 2913                 	sts noise_pattern_delay_rows, r27
00223f 11b2                      	cpse r27, zero
002240 c034                      	rjmp sound_driver_calculate_delays_noise_store
002241 95aa                      	dec r26
                                 
                                 sound_driver_calculate_delays_noise_Sxx:
002242 efbf                      	ldi r27, 0xFF
002243 91c0 2946                 	lds r28, noise_fx_Sxx_pre
002245 91d0 2947                 	lds r29, noise_fx_Sxx_post
                                 sound_driver_calculate_delays_noise_Sxx_check_pre:
002247 17cb                      	cp r28, r27
002248 f009                      	breq sound_driver_calculate_delays_noise_Sxx_check_post
002249 c00d                      	rjmp sound_driver_calculate_delays_noise_Sxx_pre
                                 sound_driver_calculate_delays_noise_Sxx_check_post:
00224a 17db                      	cp r29, r27
00224b f009                      	breq sound_driver_calculate_delays_noise_Gxx
00224c c015                      	rjmp sound_driver_calculate_delays_noise_Sxx_post
                                 
                                 sound_driver_calculate_delays_noise_Gxx:
00224d 91c0 2943                 	lds r28, noise_fx_Gxx_pre
00224f 91d0 2944                 	lds r29, noise_fx_Gxx_post
                                 sound_driver_calculate_delays_noise_Gxx_check_pre:
002251 17cb                      	cp r28, r27
002252 f009                      	breq sound_driver_calculate_delays_noise_Gxx_check_post
002253 c012                      	rjmp sound_driver_calculate_delays_noise_Gxx_pre
                                 sound_driver_calculate_delays_noise_Gxx_check_post:
002254 17db                      	cp r29, r27
002255 f0f9                      	breq sound_driver_calculate_delays_noise_store
002256 c01a                      	rjmp sound_driver_calculate_delays_noise_Gxx_post
                                 
                                 sound_driver_calculate_delays_noise_Sxx_pre:
002257 93b0 2946                 	sts noise_fx_Sxx_pre, r27
002259 1bec                      	sub r30, r28 //(song speed)-1-Sxx
00225a 93e0 2947                 	sts noise_fx_Sxx_post, r30
00225c 95ca                      	dec r28
00225d 93c0 2914                 	sts noise_pattern_delay_frames, r28
00225f 2fef                      	mov r30, r31
002260 50e1                      	subi r30, 1
002261 c015                      	rjmp sound_driver_calculate_delays_dpcm
                                 
                                 sound_driver_calculate_delays_noise_Sxx_post:
002262 93b0 2947                 	sts noise_fx_Sxx_post, r27
002264 2fad                      	mov r26, r29
002265 c00f                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_Gxx_pre:
002266 93b0 2943                 	sts noise_fx_Gxx_pre, r27
002268 1bec                      	sub r30, r28 //(song speed)-1-Sxx
002269 93e0 2944                 	sts noise_fx_Gxx_post, r30
00226b 95ca                      	dec r28
00226c 93c0 2914                 	sts noise_pattern_delay_frames, r28
00226e 2fef                      	mov r30, r31
00226f 50e1                      	subi r30, 1
002270 c006                      	rjmp sound_driver_calculate_delays_dpcm
                                 	
                                 sound_driver_calculate_delays_noise_Gxx_post:
002271 93b0 2944                 	sts noise_fx_Gxx_post, r27
002273 2fad                      	mov r26, r29
002274 c000                      	rjmp sound_driver_calculate_delays_noise_store
                                 
                                 sound_driver_calculate_delays_noise_store:
002275 93a0 2914                 	sts noise_pattern_delay_frames, r26
                                 
                                 
                                 
                                 sound_driver_calculate_delays_dpcm:
                                 
                                 sound_driver_instrument_fx_routine:
                                 sound_driver_instrument_routine_channel0_volume:
002277 91e0 2829                 	lds ZL, pulse1_volume_macro
002279 91f0 282a                 	lds ZH, pulse1_volume_macro+1
00227b 9630                      	adiw Z, 0
00227c f1a1                      	breq sound_driver_instrument_routine_channel0_volume_default //if no volume macro is in use, use default multiplier of F
00227d 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00227e 1fff                      	rol ZH
00227f 91a0 282b                 	lds r26, pulse1_volume_macro_offset
002281 0fea                      	add ZL, r26
002282 1df2                      	adc ZH, zero
                                 
002283 91b0 282d                 	lds r27, pulse1_volume_macro_release
002285 17ba                      	cp r27, r26
002286 f429                      	brne sound_driver_instrument_routine_channel0_volume_increment //if the current offset is not equal to the release index, increment the offset
002287 91a0 282c                 	lds r26, pulse1_volume_macro_loop
002289 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00228a f010                      	brlo sound_driver_instrument_routine_channel0_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
00228b c003                      	rjmp sound_driver_instrument_routine_channel0_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_volume_increment:
00228c 95a3                      	inc r26 //increment the macro offset
00228d 93a0 282b                 	sts pulse1_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_volume_read:
00228f 91b4                      	lpm r27, Z //load volume data into r27
002290 3fbf                      	cpi r27, 0xFF //check for macro end flag
002291 f469                      	brne sound_driver_instrument_routine_channel0_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_release:
002292 91b0 282d                 	lds r27, pulse1_volume_macro_release
002294 3fbf                      	cpi r27, 0xFF
002295 f429                      	brne sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_check_loop:
002296 91b0 282c                 	lds r27, pulse1_volume_macro_loop //load the loop index
002298 93b0 282b                 	sts pulse1_volume_macro_offset, r27 //store the loop index into the offset
00229a cfdc                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel0_volume_macro_end_flag_last_index:
00229b 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
00229c 93a0 282b                 	sts pulse1_volume_macro_offset, r26
00229e cfd8                      	rjmp sound_driver_instrument_routine_channel0_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_volume_calculate:
00229f e2e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0022a0 e5fd                      	ldi ZH, HIGH(volumes << 1)
0022a1 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
0022a2 0feb                      	add ZL, r27 //add offset to the table
0022a3 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel0_volume_load:
0022a4 91b0 2800                 	lds r27, pulse1_param //load main volume
0022a6 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0022a7 91a0 285e                 	lds r26, pulse1_fx_7xy_value
0022a9 30a0                      	cpi r26, 0x00
0022aa f481                      	brne sound_driver_instrument_routine_channel0_volume_load_7xy
                                 
0022ab 0feb                      	add ZL, r27 //offset the volume table by the main volume
0022ac 1df2                      	adc ZH, zero
0022ad 91b4                      	lpm r27, Z
0022ae 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0022b0 c023                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default:
0022b1 91b0 2800                 	lds r27, pulse1_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
0022b3 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
0022b4 91a0 285e                 	lds r26, pulse1_fx_7xy_value
0022b6 30a0                      	cpi r26, 0x00
0022b7 f499                      	brne sound_driver_instrument_routine_channel0_volume_default_7xy
0022b8 93b0 2806                 	sts pulse1_output_volume, r27
0022ba c019                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy:
0022bb 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0022bc f038                      	brcs sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
0022bd f031                      	breq sound_driver_instrument_routine_channel0_volume_load_7xy_overflow
                                 
0022be 0feb                      	add ZL, r27 //offset the volume table by the main volume
0022bf 1df2                      	adc ZH, zero
0022c0 91b4                      	lpm r27, Z
0022c1 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0022c3 c010                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_load_7xy_overflow:
0022c4 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0022c5 0feb                      	add ZL, r27 //offset the volume table by the main volume
0022c6 1df2                      	adc ZH, zero
0022c7 91b4                      	lpm r27, Z
0022c8 93b0 2806                 	sts pulse1_output_volume, r27 //store the new output volume
0022ca c009                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_volume_default_7xy:
0022cb 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
0022cc f020                      	brcs sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0022cd f019                      	breq sound_driver_instrument_routine_channel0_volume_default_7xy_overflow
0022ce 93b0 2806                 	sts pulse1_output_volume, r27
0022d0 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel0_volume_default_7xy_overflow:
0022d1 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
0022d2 93b0 2806                 	sts pulse1_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
0022d4 91e0 282e                 	lds ZL, pulse1_arpeggio_macro
0022d6 91f0 282f                 	lds ZH, pulse1_arpeggio_macro+1
0022d8 9630                      	adiw Z, 0
0022d9 f1d9                      	breq sound_driver_instrument_routine_channel0_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
0022da 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0022db 1fff                      	rol ZH
0022dc 91a0 2830                 	lds r26, pulse1_arpeggio_macro_offset
0022de 0fea                      	add ZL, r26
0022df 1df2                      	adc ZH, zero
                                 
0022e0 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
0022e2 17ba                      	cp r27, r26
0022e3 f429                      	brne sound_driver_instrument_routine_channel0_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
0022e4 91a0 2831                 	lds r26, pulse1_arpeggio_macro_loop
0022e6 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0022e7 f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
0022e8 c003                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_increment:
0022e9 95a3                      	inc r26 //increment the macro offset
0022ea 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_read:
0022ec 91b4                      	lpm r27, Z //load arpeggio data into r27
0022ed 38b0                      	cpi r27, 0x80 //check for macro end flag
0022ee f009                      	breq sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag
0022ef c041                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_check_mode:
0022f0 50a1                      	subi r26, 1 //keep the offset at the end flag
0022f1 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26
0022f3 91b0 2833                 	lds r27, pulse1_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
0022f5 30b1                      	cpi r27, 0x01
0022f6 f048                      	brlo sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_release:
0022f7 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
0022f9 3fbf                      	cpi r27, 0xFF
0022fa f4d1                      	brne sound_driver_instrument_routine_channel0_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_fixed_relative_check_loop:
0022fb 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop
0022fd 3fbf                      	cpi r27, 0xFF
0022fe f499                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
0022ff c015                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute:
002300 91b0 2832                 	lds r27, pulse1_arpeggio_macro_release
002302 3fbf                      	cpi r27, 0xFF
002303 f421                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_check_loop:
002304 91b0 2831                 	lds r27, pulse1_arpeggio_macro_loop //load the loop index
002306 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002307 f451                      	brne sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_absolute_no_loop:
002308 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //check for 0xy effect
00230a 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
00230c 9620                      	adiw r29:r28, 0
00230d f469                      	brne sound_driver_instrument_routine_channel0_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00230e 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00230f 93a0 2830                 	sts pulse1_arpeggio_macro_offset, r26 //store the last valid index into the offset
002311 cfc2                      	rjmp sound_driver_instrument_routine_channel0_arpeggio
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_macro_end_flag_reload:
002312 93b0 2830                 	sts pulse1_arpeggio_macro_offset, r27 //store the loop index into the offset
002314 cfbf                      	rjmp sound_driver_instrument_routine_channel0_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_default:
002315 91c0 2846                 	lds r28, pulse1_fx_0xy_sequence //load 0xy effect
002317 91d0 2847                 	lds r29, pulse1_fx_0xy_sequence+1
002319 9620                      	adiw r29:r28, 0 //check for 0xy effect
00231a f099                      	breq sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel0_arpeggio_default_0xy:
00231b 95d6                      	lsr r29
00231c 95c7                      	ror r28
00231d 95d7                      	ror r29
00231e 95c7                      	ror r28
00231f 95d7                      	ror r29
002320 95c7                      	ror r28
002321 95d7                      	ror r29
002322 95c7                      	ror r28
002323 95d7                      	ror r29
002324 95d2                      	swap r29
                                 
002325 93c0 2846                 	sts pulse1_fx_0xy_sequence, r28 //store the rolled sequence
002327 93d0 2847                 	sts pulse1_fx_0xy_sequence+1, r29
002329 70cf                      	andi r28, 0x0F //mask out the 4 LSB
00232a 91a0 2807                 	lds r26, pulse1_note //load the current note index
00232c 0fac                      	add r26, r28 //add the note offset
00232d c02e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel0_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00232e 91a0 2807                 	lds r26, pulse1_note //load the current note index
002330 c02b                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process:
002331 9220 2834                 	sts pulse1_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002333 9220 2835                 	sts pulse1_total_pitch_offset+1, zero
002335 9220 283b                 	sts pulse1_total_hi_pitch_offset, zero
002337 91a0 2833                 	lds r26, pulse1_arpeggio_macro_mode
002339 30a1                      	cpi r26, 0x01 //absolute mode
00233a f010                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_absolute
00233b f069                      	breq sound_driver_instrument_routine_channel0_arpeggio_process_fixed
00233c c00e                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute:
00233d 91a0 2807                 	lds r26, pulse1_note //load the current note index
00233f 0fab                      	add r26, r27 //offset the note with the arpeggio data
002340 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
002341 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_add:
002342 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002343 f0c0                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002344 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002345 c016                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_absolute_subtract:
002346 fda7                      	sbrc r26, 7 //check if result is negative
002347 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
002348 c013                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_fixed:
002349 2fab                      	mov r26, r27 //move the arpeggio data into r26
00234a c011                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative:
00234b 91a0 2807                 	lds r26, pulse1_note //load the current note index
00234d 0fab                      	add r26, r27 //offset the note with the arpeggio data
00234e fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00234f c008                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_add:
002350 93a0 2807                 	sts pulse1_note, r26 //NOTE: relative mode modifies the original note index
002352 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
002353 f040                      	brlo sound_driver_instrument_routine_channel0_arpeggio_process_load //if the result is valid, go load the new note
002354 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
002355 93a0 2807                 	sts pulse1_note, r26
002357 c004                      	rjmp sound_driver_instrument_routine_channel0_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_relative_subtract:
002358 fda7                      	sbrc r26, 7 //check if result is negative
002359 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
00235a 93a0 2807                 	sts pulse1_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_arpeggio_process_load:
00235c e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
00235d e0f0                      	ldi ZH, HIGH(note_table << 1)
00235e 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
00235f 0fea                      	add ZL, r26 //add offset
002360 1df2                      	adc ZH, zero
002361 91a5                      	lpm r26, Z+ //load bytes
002362 91b4                      	lpm r27, Z
002363 93a0 0a8c                 	sts TCB0_CCMPL, r26 //load the LOW bits for timer
002365 93b0 0a8d                 	sts TCB0_CCMPH, r27 //load the HIGH bits for timer
002367 93a0 2852                 	sts pulse1_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002369 93b0 2853                 	sts pulse1_fx_3xx_target+1, r27
00236b c000                      	rjmp sound_driver_instrument_routine_channel0_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch:
00236c 91e0 2836                 	lds ZL, pulse1_pitch_macro
00236e 91f0 2837                 	lds ZH, pulse1_pitch_macro+1
002370 9630                      	adiw Z, 0
002371 f409                      	brne sound_driver_instrument_routine_channel0_pitch_continue
002372 c023                      	rjmp sound_driver_instrument_routine_channel0_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel0_pitch_continue:
002373 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002374 1fff                      	rol ZH
002375 91a0 2838                 	lds r26, pulse1_pitch_macro_offset
002377 0fea                      	add ZL, r26
002378 1df2                      	adc ZH, zero
                                 
002379 91b0 283a                 	lds r27, pulse1_pitch_macro_release
00237b 17ba                      	cp r27, r26
00237c f429                      	brne sound_driver_instrument_routine_channel0_pitch_increment //if the current offset is not equal to the release index, increment the offset
00237d 91a0 2839                 	lds r26, pulse1_pitch_macro_loop
00237f 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002380 f010                      	brlo sound_driver_instrument_routine_channel0_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002381 c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_pitch_increment:
002382 95a3                      	inc r26 //increment the macro offset
002383 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_pitch_read:
002385 91b4                      	lpm r27, Z //load pitch data into r27
002386 38b0                      	cpi r27, 0x80 //check for macro end flag
002387 f479                      	brne sound_driver_instrument_routine_channel0_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_release:
002388 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002389 93a0 2838                 	sts pulse1_pitch_macro_offset, r26
00238b 91b0 283a                 	lds r27, pulse1_pitch_macro_release
00238d 3fbf                      	cpi r27, 0xFF
00238e f439                      	brne sound_driver_instrument_routine_channel0_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel0_pitch_macro_end_flag_check_loop:
00238f 91b0 2839                 	lds r27, pulse1_pitch_macro_loop //load the loop index
002391 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002392 f019                      	breq sound_driver_instrument_routine_channel0_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002393 93b0 2838                 	sts pulse1_pitch_macro_offset, r27 //store the loop index into the offset
002395 cfd6                      	rjmp sound_driver_instrument_routine_channel0_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_pitch_default:
002396 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel0_pitch_calculate:
002397 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002398 937f                      	push r23
002399 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
00239a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00239b 0367                      	mulsu r22, r23
00239c 917f                      	pop r23
00239d 916f                      	pop r22
                                 
00239e 9416                      	lsr r1 //shift out the fractional bits
00239f 9407                      	ror r0
0023a0 9416                      	lsr r1
0023a1 9407                      	ror r0
0023a2 9416                      	lsr r1
0023a3 9407                      	ror r0
0023a4 9416                      	lsr r1
0023a5 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_negative:
0023a6 fe13                      	sbrs r1, 3 //check if result was a negative number
0023a7 c007                      	rjmp sound_driver_instrument_routine_channel0_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_negative:
0023a8 efc0                      	ldi r28, 0xF0
0023a9 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_check_divisible_8:
0023aa 70b7                      	andi r27, 0b00000111
0023ab f019                      	breq sound_driver_instrument_routine_channel0_pitch_calculate_offset
                                 
0023ac e0b1                      	ldi r27, 0x01
0023ad 0e0b                      	add r0, r27
0023ae 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel0_pitch_calculate_offset:
0023af 91a0 2834                 	lds r26, pulse1_total_pitch_offset
0023b1 91b0 2835                 	lds r27, pulse1_total_pitch_offset+1
0023b3 0e0a                      	add r0, r26
0023b4 1e1b                      	adc r1, r27
0023b5 9200 2834                 	sts pulse1_total_pitch_offset, r0
0023b7 9210 2835                 	sts pulse1_total_pitch_offset+1, r1
0023b9 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
0023bb 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
0023bd 0da0                      	add r26, r0 //offset the timer values
0023be 1db1                      	adc r27, r1
                                 	
0023bf 91c0 284a                 	lds r28, pulse1_fx_1xx_total
0023c1 91d0 284b                 	lds r29, pulse1_fx_1xx_total+1
0023c3 1bac                      	sub r26, r28
0023c4 0bbd                      	sbc r27, r29
0023c5 91c0 284e                 	lds r28, pulse1_fx_2xx_total
0023c7 91d0 284f                 	lds r29, pulse1_fx_2xx_total+1
0023c9 0fac                      	add r26, r28
0023ca 1fbd                      	adc r27, r29
0023cb 91c0 2862                 	lds r28, pulse1_fx_Pxx_total
0023cd 91d0 2863                 	lds r29, pulse1_fx_Pxx_total+1
0023cf 0fac                      	add r26, r28
0023d0 1fbd                      	adc r27, r29
0023d1 91c0 2869                 	lds r28, pulse1_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
0023d3 91d0 286a                 	lds r29, pulse1_fx_Qxy_total_offset+1
0023d5 1bac                      	sub r26, r28
0023d6 0bbd                      	sbc r27, r29
0023d7 91c0 2870                 	lds r28, pulse1_fx_Rxy_total_offset
0023d9 91d0 2871                 	lds r29, pulse1_fx_Rxy_total_offset+1
0023db 0fac                      	add r26, r28
0023dc 1fbd                      	adc r27, r29
                                 
0023dd e5c9                      	ldi r28, 0x59
0023de e0d0                      	ldi r29, 0x00
0023df 17ac                      	cp r26, r28
0023e0 07bd                      	cpc r27, r29
0023e1 f030                      	brlo sound_driver_instrument_routine_channel0_pitch_min
                                 
0023e2 e5ca                      	ldi r28, 0x5A
0023e3 e5d9                      	ldi r29, 0x59
0023e4 17ac                      	cp r26, r28
0023e5 07bd                      	cpc r27, r29
0023e6 f420                      	brsh sound_driver_instrument_routine_channel0_pitch_max
0023e7 c006                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_min:
0023e8 e5c9                      	ldi r28, 0x59
0023e9 e0d0                      	ldi r29, 0x00
0023ea c003                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_max:
0023eb e5c9                      	ldi r28, 0x59
0023ec e5d9                      	ldi r29, 0x59
0023ed c000                      	rjmp sound_driver_instrument_routine_channel0_pitch_store
                                 
                                 sound_driver_instrument_routine_channel0_pitch_store:
0023ee 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
0023f0 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel0_hi_pitch:
0023f2 91e0 283c                 	lds ZL, pulse1_hi_pitch_macro
0023f4 91f0 283d                 	lds ZH, pulse1_hi_pitch_macro+1
0023f6 9630                      	adiw Z, 0
0023f7 f409                      	brne sound_driver_instrument_routine_channel0_hi_pitch_continue
0023f8 c03c                      	rjmp sound_driver_instrument_routine_channel0_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel0_hi_pitch_continue:
0023f9 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0023fa 1fff                      	rol ZH
0023fb 91a0 283e                 	lds r26, pulse1_hi_pitch_macro_offset
0023fd 0fea                      	add ZL, r26
0023fe 1df2                      	adc ZH, zero
                                 
0023ff 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
002401 17ba                      	cp r27, r26
002402 f429                      	brne sound_driver_instrument_routine_channel0_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002403 91a0 283f                 	lds r26, pulse1_hi_pitch_macro_loop
002405 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002406 f010                      	brlo sound_driver_instrument_routine_channel0_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002407 c003                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_increment:
002408 95a3                      	inc r26 //increment the macro offset
002409 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_hi_pitch_read:
00240b 91b4                      	lpm r27, Z //load hi pitch data into r27
00240c 38b0                      	cpi r27, 0x80 //check for macro end flag
00240d f489                      	brne sound_driver_instrument_routine_channel0_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_release:
00240e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00240f 93a0 283e                 	sts pulse1_hi_pitch_macro_offset, r26
002411 91b0 2840                 	lds r27, pulse1_hi_pitch_macro_release
002413 3fbf                      	cpi r27, 0xFF
002414 f439                      	brne sound_driver_instrument_routine_channel0_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_macro_end_flag_check_loop:
002415 91b0 283f                 	lds r27, pulse1_hi_pitch_macro_loop //load the loop index
002417 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002418 f019                      	breq sound_driver_instrument_routine_channel0_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002419 93b0 283e                 	sts pulse1_hi_pitch_macro_offset, r27 //store the loop index into the offset
00241b cfd6                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_default:
00241c 91b0 283b                 	lds r27, pulse1_total_hi_pitch_offset
00241e c005                      	rjmp sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate:
00241f 91a0 283b                 	lds r26, pulse1_total_hi_pitch_offset //load the total hi pitch offset to change
002421 0fba                      	add r27, r26
002422 93b0 283b                 	sts pulse1_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_multiply:
002424 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002425 937f                      	push r23
002426 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002427 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002428 0367                      	mulsu r22, r23
002429 917f                      	pop r23
00242a 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel0_hi_pitch_calculate_offset:
00242b 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the low bits for timer
00242d 91b0 0a8d                 	lds r27, TCB0_CCMPH //load the high bits for timer
00242f 0da0                      	add r26, r0 //offset the timer values
002430 1db1                      	adc r27, r1
002431 93a0 0a8c                 	sts TCB0_CCMPL, r26 //store the new low bits for timer
002433 93b0 0a8d                 	sts TCB0_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel0_duty:
002435 91e0 2841                 	lds ZL, pulse1_duty_macro
002437 91f0 2842                 	lds ZH, pulse1_duty_macro+1
002439 9630                      	adiw Z, 0
00243a f1b1                      	breq sound_driver_channel0_fx_routines //if no duty macro is in use, go to the next routine
00243b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00243c 1fff                      	rol ZH
00243d 91a0 2843                 	lds r26, pulse1_duty_macro_offset
00243f 0fea                      	add ZL, r26
002440 1df2                      	adc ZH, zero
                                 
002441 91b0 2845                 	lds r27, pulse1_duty_macro_release
002443 17ba                      	cp r27, r26
002444 f429                      	brne sound_driver_instrument_routine_channel0_duty_increment //if the current offset is not equal to the release index, increment the offset
002445 91a0 2844                 	lds r26, pulse1_duty_macro_loop
002447 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002448 f010                      	brlo sound_driver_instrument_routine_channel0_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002449 c027                      	rjmp sound_driver_channel0_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel0_duty_increment:
00244a 95a3                      	inc r26 //increment the macro offset
00244b 93a0 2843                 	sts pulse1_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel0_duty_read:
00244d 91b4                      	lpm r27, Z //load pitch data into r27
00244e 3fbf                      	cpi r27, 0xFF //check for macro end flag
00244f f471                      	brne sound_driver_instrument_routine_channel0_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_release:
002450 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002451 93a0 2843                 	sts pulse1_duty_macro_offset, r26
002453 91b0 2845                 	lds r27, pulse1_duty_macro_release
002455 3fbf                      	cpi r27, 0xFF
002456 f4d1                      	brne sound_driver_channel0_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel0_duty_macro_end_flag_check_loop:
002457 91b0 2844                 	lds r27, pulse1_duty_macro_loop //load the loop index
002459 3fbf                      	cpi r27, 0xFF //check if there is a loop index
00245a f0b1                      	breq sound_driver_channel0_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
00245b 93b0 2843                 	sts pulse1_duty_macro_offset, r27 //store the loop index into the offset
00245d cfd7                      	rjmp sound_driver_instrument_routine_channel0_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel0_duty_load:
00245e e5e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
00245f e5fc                      	ldi ZH, HIGH(sequences << 1)
002460 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
002461 1df2                      	adc ZH, zero
                                 
002462 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse1_param (register $4000)
002463 95b7                      	ror r27
002464 95b7                      	ror r27
002465 91a0 2800                 	lds r26, pulse1_param //load r26 with pulse1_param (register $4000)
002467 2fca                      	mov r28, r26 //store a copy of pulse1_param into r28
002468 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
002469 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
00246a c001                      	rjmp sound_driver_instrument_routine_channel0_duty_load_store
00246b c005                      	rjmp sound_driver_channel0_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel0_duty_load_store:
00246c 90a4                      	lpm pulse1_sequence, Z //store the sequence
                                 
00246d 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
00246e 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
00246f 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_routines:
                                 sound_driver_channel0_fx_1xx_routine:
002471 91e0 2848                 	lds ZL, pulse1_fx_1xx
002473 91f0 2849                 	lds ZH, pulse1_fx_1xx+1
002475 9630                      	adiw Z, 0
002476 f051                      	breq sound_driver_channel0_fx_2xx_routine
                                 
002477 91a0 284a                 	lds r26, pulse1_fx_1xx_total //load the rate to change the pitch by
002479 91b0 284b                 	lds r27, pulse1_fx_1xx_total+1
00247b 0fae                      	add r26, ZL //increase the total offset by the rate
00247c 1fbf                      	adc r27, ZH
00247d 93a0 284a                 	sts pulse1_fx_1xx_total, r26
00247f 93b0 284b                 	sts pulse1_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_2xx_routine:
002481 91e0 284c                 	lds ZL, pulse1_fx_2xx
002483 91f0 284d                 	lds ZH, pulse1_fx_2xx+1
002485 9630                      	adiw Z, 0
002486 f051                      	breq sound_driver_channel0_fx_3xx_routine
                                 
002487 91a0 284e                 	lds r26, pulse1_fx_2xx_total //load the rate to change the pitch by
002489 91b0 284f                 	lds r27, pulse1_fx_2xx_total+1
00248b 0fae                      	add r26, ZL //increase the total offset by the rate
00248c 1fbf                      	adc r27, ZH
00248d 93a0 284e                 	sts pulse1_fx_2xx_total, r26
00248f 93b0 284f                 	sts pulse1_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_3xx_routine:
002491 91e0 2854                 	lds ZL, pulse1_fx_3xx_speed
002493 91f0 2855                 	lds ZH, pulse1_fx_3xx_speed+1
002495 9630                      	adiw Z, 0
002496 f409                      	brne sound_driver_channel0_fx_3xx_routine_check_start
002497 c048                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_check_start:
002498 91a0 2850                 	lds r26, pulse1_fx_3xx_start
00249a 91b0 2851                 	lds r27, pulse1_fx_3xx_start+1
00249c 9610                      	adiw r26:r27, 0
00249d f409                      	brne sound_driver_channel0_fx_3xx_routine_main
00249e c041                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_main:
00249f 91c0 2852                 	lds r28, pulse1_fx_3xx_target
0024a1 91d0 2853                 	lds r29, pulse1_fx_3xx_target+1
                                 
0024a3 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
0024a4 07bd                      	cpc r27, r29
0024a5 f011                      	breq sound_driver_channel0_fx_3xx_routine_disable
0024a6 f030                      	brlo sound_driver_channel0_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
0024a7 c01f                      	rjmp sound_driver_channel0_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel0_fx_3xx_routine_disable:
0024a8 9220 2850                 	sts pulse1_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
0024aa 9220 2851                 	sts pulse1_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
0024ac c033                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_subtract:
0024ad 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
0024ae 0bdb                      	sbc r29, r27
0024af 91a0 2856                 	lds r26, pulse1_fx_3xx_total_offset
0024b1 91b0 2857                 	lds r27, pulse1_fx_3xx_total_offset+1
                                 
0024b3 0fae                      	add r26, ZL //add the speed to the total offset
0024b4 1fbf                      	adc r27, ZH
0024b5 1bca                      	sub r28, r26 //invert the total difference with the total offset
0024b6 0bdb                      	sbc r29, r27
0024b7 f380                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0024b8 93a0 2856                 	sts pulse1_fx_3xx_total_offset, r26 //store the new total offset
0024ba 93b0 2857                 	sts pulse1_fx_3xx_total_offset+1, r27
                                 
0024bc 91a0 0a8c                 	lds r26, TCB0_CCMPL //load the current timer period
0024be 91b0 0a8d                 	lds r27, TCB0_CCMPH
0024c0 1bac                      	sub r26, r28 //offset the current timer period with the total offset
0024c1 0bbd                      	sbc r27, r29
0024c2 93a0 0a8c                 	sts TCB0_CCMPL, r26
0024c4 93b0 0a8d                 	sts TCB0_CCMPH, r27
0024c6 c019                      	rjmp sound_driver_channel0_fx_4xy_routine
                                 
                                 sound_driver_channel0_fx_3xx_routine_add:
0024c7 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
0024c8 0bbd                      	sbc r27, r29
0024c9 91c0 2856                 	lds r28, pulse1_fx_3xx_total_offset
0024cb 91d0 2857                 	lds r29, pulse1_fx_3xx_total_offset+1
                                 
0024cd 0fce                      	add r28, ZL //add the speed to the total offset
0024ce 1fdf                      	adc r29, ZH
0024cf 1bac                      	sub r26, r28 //invert the total difference with the total offset
0024d0 0bbd                      	sbc r27, r29
0024d1 f2b0                      	brlo sound_driver_channel0_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
0024d2 93c0 2856                 	sts pulse1_fx_3xx_total_offset, r28 //store the new total offset
0024d4 93d0 2857                 	sts pulse1_fx_3xx_total_offset+1, r29
                                 
0024d6 91c0 0a8c                 	lds r28, TCB0_CCMPL //load the current timer period
0024d8 91d0 0a8d                 	lds r29, TCB0_CCMPH
0024da 0fca                      	add r28, r26 //offset the current timer period with the total offset
0024db 1fdb                      	adc r29, r27
0024dc 93c0 0a8c                 	sts TCB0_CCMPL, r28
0024de 93d0 0a8d                 	sts TCB0_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel0_fx_4xy_routine:
0024e0 91a0 2858                 	lds r26, pulse1_fx_4xy_speed
0024e2 15a2                      	cp r26, zero
0024e3 f409                      	brne sound_driver_channel0_fx_4xy_routine_continue
0024e4 c05c                      	rjmp sound_driver_channel0_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel0_fx_4xy_routine_continue:
0024e5 91b0 2859                 	lds r27, pulse1_fx_4xy_depth
0024e7 91c0 285a                 	lds r28, pulse1_fx_4xy_phase
0024e9 0fca                      	add r28, r26 //increase the phase by the speed
0024ea 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0024eb f008                      	brlo sound_driver_channel0_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
0024ec e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase:
0024ed 93c0 285a                 	sts pulse1_fx_4xy_phase, r28 //store the new phase
0024ef 31c0                      	cpi r28, 16
0024f0 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_0
0024f1 32c0                      	cpi r28, 32
0024f2 f028                      	brlo sound_driver_channel0_fx_4xy_routine_phase_1
0024f3 33c0                      	cpi r28, 48
0024f4 f030                      	brlo sound_driver_channel0_fx_4xy_routine_phase_2
0024f5 c007                      	rjmp sound_driver_channel0_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_0:
0024f6 70cf                      	andi r28, 0x0F //mask for values 0-15
0024f7 c029                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_1:
0024f8 6fc0                      	ori r28, 0xF0
0024f9 95c0                      	com r28 //invert values 0-15
0024fa c026                      	rjmp sound_driver_channel0_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_2:
0024fb 70cf                      	andi r28, 0x0F //mask for values 0-15
0024fc c003                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_phase_3:
0024fd 6fc0                      	ori r28, 0xF0
0024fe 95c0                      	com r28 //invert values 0-15
0024ff c000                      	rjmp sound_driver_channel0_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_add:
002500 95b2                      	swap r27 //multiply depth by 16
002501 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002502 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002503 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002504 0fec                      	add ZL, r28 //offset the table by the depth+phase
002505 1df2                      	adc ZH, zero
002506 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002507 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002508 937f                      	push r23
002509 2f6c                      	mov r22, r28 //store the vibrato value into r22
00250a eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00250b 9f67                      	mul r22, r23
00250c 917f                      	pop r23
00250d 916f                      	pop r22
                                 
00250e 9416                      	lsr r1 //shift out the fractional bits
00250f 9407                      	ror r0
002510 9416                      	lsr r1
002511 9407                      	ror r0
002512 9416                      	lsr r1
002513 9407                      	ror r0
002514 9416                      	lsr r1
002515 9407                      	ror r0
                                 	
002516 91a0 0a8c                 	lds r26, TCB0_CCMPL
002518 91b0 0a8d                 	lds r27, TCB0_CCMPH
00251a 0da0                      	add r26, r0
00251b 1db1                      	adc r27, r1
00251c 93a0 0a8c                 	sts TCB0_CCMPL, r26
00251e 93b0 0a8d                 	sts TCB0_CCMPH, r27
002520 c020                      	rjmp sound_driver_channel0_fx_7xy_routine
                                 
                                 sound_driver_channel0_fx_4xy_routine_load_subtract:
002521 95b2                      	swap r27 //multiply depth by 16
002522 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002523 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002524 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002525 0fec                      	add ZL, r28 //offset the table by the depth+phase
002526 1df2                      	adc ZH, zero
002527 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002528 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002529 937f                      	push r23
00252a 2f6c                      	mov r22, r28 //store the vibrato value into r22
00252b eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00252c 9f67                      	mul r22, r23
00252d 917f                      	pop r23
00252e 916f                      	pop r22
                                 
00252f 9416                      	lsr r1 //shift out the fractional bits
002530 9407                      	ror r0
002531 9416                      	lsr r1
002532 9407                      	ror r0
002533 9416                      	lsr r1
002534 9407                      	ror r0
002535 9416                      	lsr r1
002536 9407                      	ror r0
                                 
002537 91a0 0a8c                 	lds r26, TCB0_CCMPL
002539 91b0 0a8d                 	lds r27, TCB0_CCMPH
00253b 19a0                      	sub r26, r0
00253c 09b1                      	sbc r27, r1
00253d 93a0 0a8c                 	sts TCB0_CCMPL, r26
00253f 93b0 0a8d                 	sts TCB0_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_7xy_routine:
002541 91a0 285b                 	lds r26, pulse1_fx_7xy_speed
002543 15a2                      	cp r26, zero
002544 f0e9                      	breq sound_driver_channel0_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002545 91b0 285c                 	lds r27, pulse1_fx_7xy_depth
002547 91c0 285d                 	lds r28, pulse1_fx_7xy_phase
002549 0fca                      	add r28, r26 //increase the phase by the speed
00254a 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
00254b f008                      	brlo sound_driver_channel0_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
00254c e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase:
00254d 93c0 285d                 	sts pulse1_fx_7xy_phase, r28 //store the new phase
00254f 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002550 ffc4                      	sbrs r28, 4
002551 c001                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_0
002552 c002                      	rjmp sound_driver_channel0_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel0_fx_7xy_routine_phase_0:
002553 70cf                      	andi r28, 0x0F //mask for values 0-15
002554 c003                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_phase_1:
002555 6fc0                      	ori r28, 0xF0
002556 95c0                      	com r28 //invert values 0-15
002557 c000                      	rjmp sound_driver_channel0_fx_7xy_routine_load
                                 
                                 sound_driver_channel0_fx_7xy_routine_load:
002558 95b2                      	swap r27 //multiply depth by 16
002559 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
00255a e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
00255b e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
00255c 0fec                      	add ZL, r28 //offset the table by the depth+phase
00255d 1df2                      	adc ZH, zero
00255e 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
00255f 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002560 93c0 285e                 	sts pulse1_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Axy_routine:
002562 91b0 285f                 	lds r27, pulse1_fx_Axy
002564 15b2                      	cp r27, zero
002565 f0e9                      	breq sound_driver_channel0_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002566 91a0 2805                 	lds r26, pulse1_fractional_volume //load fractional volume representation of the channel
002568 91c0 2800                 	lds r28, pulse1_param //load the integer volume representation of the channel
00256a 2fda                      	mov r29, r26 //copy fractional volume into r29
00256b 2fec                      	mov r30, r28 //copy the pulse1_param into r30
00256c 95e2                      	swap r30
00256d 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
00256e 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
00256f 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002570 f009                      	breq sound_driver_channel0_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel0_fx_Axy_routine_reload:
002571 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate:
002572 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002573 c004                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_addition:
002574 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002575 f428                      	brcc sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002576 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002577 c003                      	rjmp sound_driver_channel0_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_subtraction:
002578 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002579 f008                      	brcs sound_driver_channel0_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
00257a e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel0_fx_Axy_routine_calculate_store:
00257b 93a0 2805                 	sts pulse1_fractional_volume, r26 //store the new fractional volume
00257d 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
00257e 95a2                      	swap r26
00257f 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002580 2bca                      	or r28, r26 //store the new volume back into pulse1_param
002581 93c0 2800                 	sts pulse1_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel0_fx_Qxy_routine:
002583 91e0 2865                 	lds ZL, pulse1_fx_Qxy_target
002585 91f0 2866                 	lds ZH, pulse1_fx_Qxy_target+1
002587 9630                      	adiw Z, 0
002588 f119                      	breq sound_driver_channel0_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002589 91a0 2869                 	lds r26, pulse1_fx_Qxy_total_offset
00258b 91b0 286a                 	lds r27, pulse1_fx_Qxy_total_offset+1
00258d 91c0 0a8c                 	lds r28, TCB0_CCMPL
00258f 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
002591 1bec                      	sub ZL, r28 //calculate the difference to the target
002592 0bfd                      	sbc ZH, r29
002593 f408                      	brsh sound_driver_channel0_fx_Qxy_routine_end //if the target has been reached (or passed)
002594 f068                      	brlo sound_driver_channel0_fx_Qxy_routine_add
                                 
                                 sound_driver_channel0_fx_Qxy_routine_end:
002595 9220 2869                 	sts pulse1_fx_Qxy_total_offset, zero //turn off the effect
002597 9220 286a                 	sts pulse1_fx_Qxy_total_offset+1, zero
002599 9220 2865                 	sts pulse1_fx_Qxy_target, zero
00259b 9220 2866                 	sts pulse1_fx_Qxy_target+1, zero
00259d 91b0 2864                 	lds r27, pulse1_fx_Qxy_target_note
00259f 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
0025a1 c00a                      	rjmp sound_driver_channel0_fx_Rxy_routine
                                 
                                 sound_driver_channel0_fx_Qxy_routine_add:
0025a2 91c0 2867                 	lds r28, pulse1_fx_Qxy_speed
0025a4 91d0 2868                 	lds r29, pulse1_fx_Qxy_speed+1
0025a6 0fac                      	add r26, r28 //increase the total offset by the speed
0025a7 1fbd                      	adc r27, r29
0025a8 93a0 2869                 	sts pulse1_fx_Qxy_total_offset, r26 //store the total offset
0025aa 93b0 286a                 	sts pulse1_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel0_fx_Rxy_routine:
0025ac 91e0 286c                 	lds ZL, pulse1_fx_Rxy_target
0025ae 91f0 286d                 	lds ZH, pulse1_fx_Rxy_target+1
0025b0 9630                      	adiw Z, 0
0025b1 f119                      	breq sound_driver_instrument_routine_channel1_volume //if the effect is not enabled, skip the routine
                                 
0025b2 91a0 2870                 	lds r26, pulse1_fx_Rxy_total_offset
0025b4 91b0 2871                 	lds r27, pulse1_fx_Rxy_total_offset+1
0025b6 91c0 0a8c                 	lds r28, TCB0_CCMPL
0025b8 91d0 0a8d                 	lds r29, TCB0_CCMPH
                                 
0025ba 1bce                      	sub r28, ZL //calculate the difference to the target
0025bb 0bdf                      	sbc r29, ZH
0025bc f408                      	brsh sound_driver_channel0_fx_Rxy_routine_end //if the target has been reached (or passed)
0025bd f068                      	brlo sound_driver_channel0_fx_Rxy_routine_add
                                 
                                 sound_driver_channel0_fx_Rxy_routine_end:
0025be 9220 2870                 	sts pulse1_fx_Rxy_total_offset, zero //disable the effect
0025c0 9220 2871                 	sts pulse1_fx_Rxy_total_offset+1, zero
0025c2 9220 286c                 	sts pulse1_fx_Rxy_target, zero
0025c4 9220 286d                 	sts pulse1_fx_Rxy_target+1, zero
0025c6 91b0 286b                 	lds r27, pulse1_fx_Rxy_target_note
0025c8 93b0 2807                 	sts pulse1_note, r27 //replace the note with the final target note
0025ca c00a                      	rjmp sound_driver_instrument_routine_channel1_volume
                                 
                                 sound_driver_channel0_fx_Rxy_routine_add:
0025cb 91c0 286e                 	lds r28, pulse1_fx_Rxy_speed
0025cd 91d0 286f                 	lds r29, pulse1_fx_Rxy_speed+1
0025cf 0fac                      	add r26, r28 //increase the total offset by the speed
0025d0 1fbd                      	adc r27, r29
0025d1 93a0 2870                 	sts pulse1_fx_Rxy_total_offset, r26 //store the total offset
0025d3 93b0 2871                 	sts pulse1_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume:
0025d5 91e0 287a                 	lds ZL, pulse2_volume_macro
0025d7 91f0 287b                 	lds ZH, pulse2_volume_macro+1
0025d9 9630                      	adiw Z, 0
0025da f1a1                      	breq sound_driver_instrument_routine_channel1_volume_default //if no volume macro is in use, use default multiplier of F
0025db 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
0025dc 1fff                      	rol ZH
0025dd 91a0 287c                 	lds r26, pulse2_volume_macro_offset
0025df 0fea                      	add ZL, r26
0025e0 1df2                      	adc ZH, zero
                                 
0025e1 91b0 287e                 	lds r27, pulse2_volume_macro_release
0025e3 17ba                      	cp r27, r26
0025e4 f429                      	brne sound_driver_instrument_routine_channel1_volume_increment //if the current offset is not equal to the release index, increment the offset
0025e5 91a0 287d                 	lds r26, pulse2_volume_macro_loop
0025e7 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0025e8 f010                      	brlo sound_driver_instrument_routine_channel1_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0025e9 c003                      	rjmp sound_driver_instrument_routine_channel1_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_volume_increment:
0025ea 95a3                      	inc r26 //increment the macro offset
0025eb 93a0 287c                 	sts pulse2_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_volume_read:
0025ed 91b4                      	lpm r27, Z //load volume data into r27
0025ee 3fbf                      	cpi r27, 0xFF //check for macro end flag
0025ef f469                      	brne sound_driver_instrument_routine_channel1_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_release:
0025f0 91b0 287e                 	lds r27, pulse2_volume_macro_release
0025f2 3fbf                      	cpi r27, 0xFF
0025f3 f429                      	brne sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_check_loop:
0025f4 91b0 287d                 	lds r27, pulse2_volume_macro_loop //load the loop index
0025f6 93b0 287c                 	sts pulse2_volume_macro_offset, r27 //store the loop index into the offset
0025f8 cfdc                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel1_volume_macro_end_flag_last_index:
0025f9 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
0025fa 93a0 287c                 	sts pulse2_volume_macro_offset, r26
0025fc cfd8                      	rjmp sound_driver_instrument_routine_channel1_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_volume_calculate:
0025fd e2e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
0025fe e5fd                      	ldi ZH, HIGH(volumes << 1)
0025ff 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002600 0feb                      	add ZL, r27 //add offset to the table
002601 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel1_volume_load:
002602 91b0 2808                 	lds r27, pulse2_param //load main volume
002604 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002605 91a0 28af                 	lds r26, pulse2_fx_7xy_value
002607 30a0                      	cpi r26, 0x00
002608 f481                      	brne sound_driver_instrument_routine_channel1_volume_load_7xy
                                 
002609 0feb                      	add ZL, r27 //offset the volume table by the main volume
00260a 1df2                      	adc ZH, zero
00260b 91b4                      	lpm r27, Z
00260c 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
00260e c023                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default:
00260f 91b0 2808                 	lds r27, pulse2_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002611 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002612 91a0 28af                 	lds r26, pulse2_fx_7xy_value
002614 30a0                      	cpi r26, 0x00
002615 f499                      	brne sound_driver_instrument_routine_channel1_volume_default_7xy
002616 93b0 280e                 	sts pulse2_output_volume, r27
002618 c019                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy:
002619 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00261a f038                      	brcs sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
00261b f031                      	breq sound_driver_instrument_routine_channel1_volume_load_7xy_overflow
                                 
00261c 0feb                      	add ZL, r27 //offset the volume table by the main volume
00261d 1df2                      	adc ZH, zero
00261e 91b4                      	lpm r27, Z
00261f 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002621 c010                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_load_7xy_overflow:
002622 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002623 0feb                      	add ZL, r27 //offset the volume table by the main volume
002624 1df2                      	adc ZH, zero
002625 91b4                      	lpm r27, Z
002626 93b0 280e                 	sts pulse2_output_volume, r27 //store the new output volume
002628 c009                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_volume_default_7xy:
002629 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
00262a f020                      	brcs sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00262b f019                      	breq sound_driver_instrument_routine_channel1_volume_default_7xy_overflow
00262c 93b0 280e                 	sts pulse2_output_volume, r27
00262e c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel1_volume_default_7xy_overflow:
00262f e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002630 93b0 280e                 	sts pulse2_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002632 91e0 287f                 	lds ZL, pulse2_arpeggio_macro
002634 91f0 2880                 	lds ZH, pulse2_arpeggio_macro+1
002636 9630                      	adiw Z, 0
002637 f1d9                      	breq sound_driver_instrument_routine_channel1_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002638 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002639 1fff                      	rol ZH
00263a 91a0 2881                 	lds r26, pulse2_arpeggio_macro_offset
00263c 0fea                      	add ZL, r26
00263d 1df2                      	adc ZH, zero
                                 
00263e 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
002640 17ba                      	cp r27, r26
002641 f429                      	brne sound_driver_instrument_routine_channel1_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002642 91a0 2882                 	lds r26, pulse2_arpeggio_macro_loop
002644 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002645 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002646 c003                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_increment:
002647 95a3                      	inc r26 //increment the macro offset
002648 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_read:
00264a 91b4                      	lpm r27, Z //load arpeggio data into r27
00264b 38b0                      	cpi r27, 0x80 //check for macro end flag
00264c f009                      	breq sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag
00264d c041                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_check_mode:
00264e 50a1                      	subi r26, 1 //keep the offset at the end flag
00264f 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26
002651 91b0 2884                 	lds r27, pulse2_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002653 30b1                      	cpi r27, 0x01
002654 f048                      	brlo sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_release:
002655 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
002657 3fbf                      	cpi r27, 0xFF
002658 f4d1                      	brne sound_driver_instrument_routine_channel1_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_fixed_relative_check_loop:
002659 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop
00265b 3fbf                      	cpi r27, 0xFF
00265c f499                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
00265d c015                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute:
00265e 91b0 2883                 	lds r27, pulse2_arpeggio_macro_release
002660 3fbf                      	cpi r27, 0xFF
002661 f421                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_check_loop:
002662 91b0 2882                 	lds r27, pulse2_arpeggio_macro_loop //load the loop index
002664 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002665 f451                      	brne sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_absolute_no_loop:
002666 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //check for 0xy effect
002668 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
00266a 9620                      	adiw r29:r28, 0
00266b f469                      	brne sound_driver_instrument_routine_channel1_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
00266c 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
00266d 93a0 2881                 	sts pulse2_arpeggio_macro_offset, r26 //store the last valid index into the offset
00266f cfc2                      	rjmp sound_driver_instrument_routine_channel1_arpeggio
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_macro_end_flag_reload:
002670 93b0 2881                 	sts pulse2_arpeggio_macro_offset, r27 //store the loop index into the offset
002672 cfbf                      	rjmp sound_driver_instrument_routine_channel1_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_default:
002673 91c0 2897                 	lds r28, pulse2_fx_0xy_sequence //load 0xy effect
002675 91d0 2898                 	lds r29, pulse2_fx_0xy_sequence+1
002677 9620                      	adiw r29:r28, 0 //check for 0xy effect
002678 f099                      	breq sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel1_arpeggio_default_0xy:
002679 95d6                      	lsr r29
00267a 95c7                      	ror r28
00267b 95d7                      	ror r29
00267c 95c7                      	ror r28
00267d 95d7                      	ror r29
00267e 95c7                      	ror r28
00267f 95d7                      	ror r29
002680 95c7                      	ror r28
002681 95d7                      	ror r29
002682 95d2                      	swap r29
                                 
002683 93c0 2897                 	sts pulse2_fx_0xy_sequence, r28 //store the rolled sequence
002685 93d0 2898                 	sts pulse2_fx_0xy_sequence+1, r29
002687 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002688 91a0 280f                 	lds r26, pulse2_note //load the current note index
00268a 0fac                      	add r26, r28 //add the note offset
00268b c02e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel1_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
00268c 91a0 280f                 	lds r26, pulse2_note //load the current note index
00268e c02b                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process:
00268f 9220 2885                 	sts pulse2_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002691 9220 2886                 	sts pulse2_total_pitch_offset+1, zero
002693 9220 288c                 	sts pulse2_total_hi_pitch_offset, zero
002695 91a0 2884                 	lds r26, pulse2_arpeggio_macro_mode
002697 30a1                      	cpi r26, 0x01 //absolute mode
002698 f010                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_absolute
002699 f069                      	breq sound_driver_instrument_routine_channel1_arpeggio_process_fixed
00269a c00e                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute:
00269b 91a0 280f                 	lds r26, pulse2_note //load the current note index
00269d 0fab                      	add r26, r27 //offset the note with the arpeggio data
00269e fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
00269f c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_add:
0026a0 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0026a1 f0c0                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0026a2 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0026a3 c016                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_absolute_subtract:
0026a4 fda7                      	sbrc r26, 7 //check if result is negative
0026a5 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0026a6 c013                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_fixed:
0026a7 2fab                      	mov r26, r27 //move the arpeggio data into r26
0026a8 c011                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative:
0026a9 91a0 280f                 	lds r26, pulse2_note //load the current note index
0026ab 0fab                      	add r26, r27 //offset the note with the arpeggio data
0026ac fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0026ad c008                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_add:
0026ae 93a0 280f                 	sts pulse2_note, r26 //NOTE: relative mode modifies the original note index
0026b0 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0026b1 f040                      	brlo sound_driver_instrument_routine_channel1_arpeggio_process_load //if the result is valid, go load the new note
0026b2 e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0026b3 93a0 280f                 	sts pulse2_note, r26
0026b5 c004                      	rjmp sound_driver_instrument_routine_channel1_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_relative_subtract:
0026b6 fda7                      	sbrc r26, 7 //check if result is negative
0026b7 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0026b8 93a0 280f                 	sts pulse2_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_arpeggio_process_load:
0026ba e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0026bb e0f0                      	ldi ZH, HIGH(note_table << 1)
0026bc 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0026bd 0fea                      	add ZL, r26 //add offset
0026be 1df2                      	adc ZH, zero
0026bf 91a5                      	lpm r26, Z+ //load bytes
0026c0 91b4                      	lpm r27, Z
0026c1 93a0 0a9c                 	sts TCB1_CCMPL, r26 //load the LOW bits for timer
0026c3 93b0 0a9d                 	sts TCB1_CCMPH, r27 //load the HIGH bits for timer
0026c5 93a0 28a3                 	sts pulse2_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
0026c7 93b0 28a4                 	sts pulse2_fx_3xx_target+1, r27
0026c9 c000                      	rjmp sound_driver_instrument_routine_channel1_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch:
0026ca 91e0 2887                 	lds ZL, pulse2_pitch_macro
0026cc 91f0 2888                 	lds ZH, pulse2_pitch_macro+1
0026ce 9630                      	adiw Z, 0
0026cf f409                      	brne sound_driver_instrument_routine_channel1_pitch_continue
0026d0 c023                      	rjmp sound_driver_instrument_routine_channel1_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel1_pitch_continue:
0026d1 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
0026d2 1fff                      	rol ZH
0026d3 91a0 2889                 	lds r26, pulse2_pitch_macro_offset
0026d5 0fea                      	add ZL, r26
0026d6 1df2                      	adc ZH, zero
                                 
0026d7 91b0 288b                 	lds r27, pulse2_pitch_macro_release
0026d9 17ba                      	cp r27, r26
0026da f429                      	brne sound_driver_instrument_routine_channel1_pitch_increment //if the current offset is not equal to the release index, increment the offset
0026db 91a0 288a                 	lds r26, pulse2_pitch_macro_loop
0026dd 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0026de f010                      	brlo sound_driver_instrument_routine_channel1_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0026df c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_pitch_increment:
0026e0 95a3                      	inc r26 //increment the macro offset
0026e1 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_pitch_read:
0026e3 91b4                      	lpm r27, Z //load pitch data into r27
0026e4 38b0                      	cpi r27, 0x80 //check for macro end flag
0026e5 f479                      	brne sound_driver_instrument_routine_channel1_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_release:
0026e6 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0026e7 93a0 2889                 	sts pulse2_pitch_macro_offset, r26
0026e9 91b0 288b                 	lds r27, pulse2_pitch_macro_release
0026eb 3fbf                      	cpi r27, 0xFF
0026ec f439                      	brne sound_driver_instrument_routine_channel1_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel1_pitch_macro_end_flag_check_loop:
0026ed 91b0 288a                 	lds r27, pulse2_pitch_macro_loop //load the loop index
0026ef 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0026f0 f019                      	breq sound_driver_instrument_routine_channel1_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
0026f1 93b0 2889                 	sts pulse2_pitch_macro_offset, r27 //store the loop index into the offset
0026f3 cfd6                      	rjmp sound_driver_instrument_routine_channel1_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_pitch_default:
0026f4 e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel1_pitch_calculate:
0026f5 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
0026f6 937f                      	push r23
0026f7 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
0026f8 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
0026f9 0367                      	mulsu r22, r23
0026fa 917f                      	pop r23
0026fb 916f                      	pop r22
                                 
0026fc 9416                      	lsr r1 //shift out the fractional bits
0026fd 9407                      	ror r0
0026fe 9416                      	lsr r1
0026ff 9407                      	ror r0
002700 9416                      	lsr r1
002701 9407                      	ror r0
002702 9416                      	lsr r1
002703 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_negative:
002704 fe13                      	sbrs r1, 3 //check if result was a negative number
002705 c007                      	rjmp sound_driver_instrument_routine_channel1_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_negative:
002706 efc0                      	ldi r28, 0xF0
002707 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_check_divisible_8:
002708 70b7                      	andi r27, 0b00000111
002709 f019                      	breq sound_driver_instrument_routine_channel1_pitch_calculate_offset
                                 
00270a e0b1                      	ldi r27, 0x01
00270b 0e0b                      	add r0, r27
00270c 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel1_pitch_calculate_offset:
00270d 91a0 2885                 	lds r26, pulse2_total_pitch_offset
00270f 91b0 2886                 	lds r27, pulse2_total_pitch_offset+1
002711 0e0a                      	add r0, r26
002712 1e1b                      	adc r1, r27
002713 9200 2885                 	sts pulse2_total_pitch_offset, r0
002715 9210 2886                 	sts pulse2_total_pitch_offset+1, r1
002717 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
002719 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
00271b 0da0                      	add r26, r0 //offset the timer values
00271c 1db1                      	adc r27, r1
                                 	
00271d 91c0 289b                 	lds r28, pulse2_fx_1xx_total
00271f 91d0 289c                 	lds r29, pulse2_fx_1xx_total+1
002721 1bac                      	sub r26, r28
002722 0bbd                      	sbc r27, r29
002723 91c0 289f                 	lds r28, pulse2_fx_2xx_total
002725 91d0 28a0                 	lds r29, pulse2_fx_2xx_total+1
002727 0fac                      	add r26, r28
002728 1fbd                      	adc r27, r29
002729 91c0 28b3                 	lds r28, pulse2_fx_Pxx_total
00272b 91d0 28b4                 	lds r29, pulse2_fx_Pxx_total+1
00272d 0fac                      	add r26, r28
00272e 1fbd                      	adc r27, r29
00272f 91c0 28ba                 	lds r28, pulse2_fx_Qxy_total_offset //NOTE: Qxy and Rxy offsets are applied here
002731 91d0 28bb                 	lds r29, pulse2_fx_Qxy_total_offset+1
002733 1bac                      	sub r26, r28
002734 0bbd                      	sbc r27, r29
002735 91c0 28c1                 	lds r28, pulse2_fx_Rxy_total_offset
002737 91d0 28c2                 	lds r29, pulse2_fx_Rxy_total_offset+1
002739 0fac                      	add r26, r28
00273a 1fbd                      	adc r27, r29
                                 
00273b e5c9                      	ldi r28, 0x59
00273c e0d0                      	ldi r29, 0x00
00273d 17ac                      	cp r26, r28
00273e 07bd                      	cpc r27, r29
00273f f030                      	brlo sound_driver_instrument_routine_channel1_pitch_min
                                 
002740 e5ca                      	ldi r28, 0x5A
002741 e5d9                      	ldi r29, 0x59
002742 17ac                      	cp r26, r28
002743 07bd                      	cpc r27, r29
002744 f420                      	brsh sound_driver_instrument_routine_channel1_pitch_max
002745 c006                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_min:
002746 e5c9                      	ldi r28, 0x59
002747 e0d0                      	ldi r29, 0x00
002748 c003                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_max:
002749 e5c9                      	ldi r28, 0x59
00274a e5d9                      	ldi r29, 0x59
00274b c000                      	rjmp sound_driver_instrument_routine_channel1_pitch_store
                                 
                                 sound_driver_instrument_routine_channel1_pitch_store:
00274c 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
00274e 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel1_hi_pitch:
002750 91e0 288d                 	lds ZL, pulse2_hi_pitch_macro
002752 91f0 288e                 	lds ZH, pulse2_hi_pitch_macro+1
002754 9630                      	adiw Z, 0
002755 f409                      	brne sound_driver_instrument_routine_channel1_hi_pitch_continue
002756 c03c                      	rjmp sound_driver_instrument_routine_channel1_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel1_hi_pitch_continue:
002757 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002758 1fff                      	rol ZH
002759 91a0 288f                 	lds r26, pulse2_hi_pitch_macro_offset
00275b 0fea                      	add ZL, r26
00275c 1df2                      	adc ZH, zero
                                 
00275d 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
00275f 17ba                      	cp r27, r26
002760 f429                      	brne sound_driver_instrument_routine_channel1_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002761 91a0 2890                 	lds r26, pulse2_hi_pitch_macro_loop
002763 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002764 f010                      	brlo sound_driver_instrument_routine_channel1_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002765 c003                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_increment:
002766 95a3                      	inc r26 //increment the macro offset
002767 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_hi_pitch_read:
002769 91b4                      	lpm r27, Z //load hi pitch data into r27
00276a 38b0                      	cpi r27, 0x80 //check for macro end flag
00276b f489                      	brne sound_driver_instrument_routine_channel1_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_release:
00276c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
00276d 93a0 288f                 	sts pulse2_hi_pitch_macro_offset, r26
00276f 91b0 2891                 	lds r27, pulse2_hi_pitch_macro_release
002771 3fbf                      	cpi r27, 0xFF
002772 f439                      	brne sound_driver_instrument_routine_channel1_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_macro_end_flag_check_loop:
002773 91b0 2890                 	lds r27, pulse2_hi_pitch_macro_loop //load the loop index
002775 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002776 f019                      	breq sound_driver_instrument_routine_channel1_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002777 93b0 288f                 	sts pulse2_hi_pitch_macro_offset, r27 //store the loop index into the offset
002779 cfd6                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_default:
00277a 91b0 288c                 	lds r27, pulse2_total_hi_pitch_offset
00277c c005                      	rjmp sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate:
00277d 91a0 288c                 	lds r26, pulse2_total_hi_pitch_offset //load the total hi pitch offset to change
00277f 0fba                      	add r27, r26
002780 93b0 288c                 	sts pulse2_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_multiply:
002782 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002783 937f                      	push r23
002784 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002785 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002786 0367                      	mulsu r22, r23
002787 917f                      	pop r23
002788 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel1_hi_pitch_calculate_offset:
002789 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the low bits for timer
00278b 91b0 0a9d                 	lds r27, TCB1_CCMPH //load the high bits for timer
00278d 0da0                      	add r26, r0 //offset the timer values
00278e 1db1                      	adc r27, r1
00278f 93a0 0a9c                 	sts TCB1_CCMPL, r26 //store the new low bits for timer
002791 93b0 0a9d                 	sts TCB1_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: Unlike the original NES, changing the duty cycle will reset the sequencer position entirely.
                                 sound_driver_instrument_routine_channel1_duty:
002793 91e0 2892                 	lds ZL, pulse2_duty_macro
002795 91f0 2893                 	lds ZH, pulse2_duty_macro+1
002797 9630                      	adiw Z, 0
002798 f1b1                      	breq sound_driver_channel1_fx_routines //if no duty macro is in use, go to the next routine
002799 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
00279a 1fff                      	rol ZH
00279b 91a0 2894                 	lds r26, pulse2_duty_macro_offset
00279d 0fea                      	add ZL, r26
00279e 1df2                      	adc ZH, zero
                                 
00279f 91b0 2896                 	lds r27, pulse2_duty_macro_release
0027a1 17ba                      	cp r27, r26
0027a2 f429                      	brne sound_driver_instrument_routine_channel1_duty_increment //if the current offset is not equal to the release index, increment the offset
0027a3 91a0 2895                 	lds r26, pulse2_duty_macro_loop
0027a5 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
0027a6 f010                      	brlo sound_driver_instrument_routine_channel1_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
0027a7 c027                      	rjmp sound_driver_channel1_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel1_duty_increment:
0027a8 95a3                      	inc r26 //increment the macro offset
0027a9 93a0 2894                 	sts pulse2_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel1_duty_read:
0027ab 91b4                      	lpm r27, Z //load pitch data into r27
0027ac 3fbf                      	cpi r27, 0xFF //check for macro end flag
0027ad f471                      	brne sound_driver_instrument_routine_channel1_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_release:
0027ae 50a1                      	subi r26, 1 //keep the macro offset at the end flag
0027af 93a0 2894                 	sts pulse2_duty_macro_offset, r26
0027b1 91b0 2896                 	lds r27, pulse2_duty_macro_release
0027b3 3fbf                      	cpi r27, 0xFF
0027b4 f4d1                      	brne sound_driver_channel1_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel1_duty_macro_end_flag_check_loop:
0027b5 91b0 2895                 	lds r27, pulse2_duty_macro_loop //load the loop index
0027b7 3fbf                      	cpi r27, 0xFF //check if there is a loop index
0027b8 f0b1                      	breq sound_driver_channel1_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
0027b9 93b0 2894                 	sts pulse2_duty_macro_offset, r27 //store the loop index into the offset
0027bb cfd7                      	rjmp sound_driver_instrument_routine_channel1_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel1_duty_load:
0027bc e5e0                      	ldi ZL, LOW(sequences << 1) //point Z to sequence table
0027bd e5fc                      	ldi ZH, HIGH(sequences << 1)
0027be 0feb                      	add ZL, r27 //offset the pointer by the duty macro data
0027bf 1df2                      	adc ZH, zero
                                 
0027c0 95b6                      	lsr r27 //move the duty cycle bits to the 2 MSB for pulse2_param (register $4000)
0027c1 95b7                      	ror r27
0027c2 95b7                      	ror r27
0027c3 91a0 2808                 	lds r26, pulse2_param //load r26 with pulse2_param (register $4000)
0027c5 2fca                      	mov r28, r26 //store a copy of pulse2_param into r28
0027c6 7ca0                      	andi r26, 0b11000000 //mask the duty cycle bits
0027c7 13ba                      	cpse r27, r26 //check if the previous duty cycle and the new duty cycle are equal
0027c8 c001                      	rjmp sound_driver_instrument_routine_channel1_duty_load_store
0027c9 c005                      	rjmp sound_driver_channel1_fx_routines //if the previous and new duty cycle are the same, don't reload the sequence
                                 
                                 sound_driver_instrument_routine_channel1_duty_load_store:
0027ca 90d4                      	lpm pulse2_sequence, Z //store the sequence
                                 
0027cb 73cf                      	andi r28, 0b00111111 //mask out the duty cycle bits
0027cc 2bcb                      	or r28, r27 //store the new duty cycle bits into r27
0027cd 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_routines:
                                 sound_driver_channel1_fx_1xx_routine:
0027cf 91e0 2899                 	lds ZL, pulse2_fx_1xx
0027d1 91f0 289a                 	lds ZH, pulse2_fx_1xx+1
0027d3 9630                      	adiw Z, 0
0027d4 f051                      	breq sound_driver_channel1_fx_2xx_routine
                                 
0027d5 91a0 289b                 	lds r26, pulse2_fx_1xx_total //load the rate to change the pitch by
0027d7 91b0 289c                 	lds r27, pulse2_fx_1xx_total+1
0027d9 0fae                      	add r26, ZL //increase the total offset by the rate
0027da 1fbf                      	adc r27, ZH
0027db 93a0 289b                 	sts pulse2_fx_1xx_total, r26
0027dd 93b0 289c                 	sts pulse2_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_2xx_routine:
0027df 91e0 289d                 	lds ZL, pulse2_fx_2xx
0027e1 91f0 289e                 	lds ZH, pulse2_fx_2xx+1
0027e3 9630                      	adiw Z, 0
0027e4 f051                      	breq sound_driver_channel1_fx_3xx_routine
                                 
0027e5 91a0 289f                 	lds r26, pulse2_fx_2xx_total //load the rate to change the pitch by
0027e7 91b0 28a0                 	lds r27, pulse2_fx_2xx_total+1
0027e9 0fae                      	add r26, ZL //increase the total offset by the rate
0027ea 1fbf                      	adc r27, ZH
0027eb 93a0 289f                 	sts pulse2_fx_2xx_total, r26
0027ed 93b0 28a0                 	sts pulse2_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_3xx_routine:
0027ef 91e0 28a5                 	lds ZL, pulse2_fx_3xx_speed
0027f1 91f0 28a6                 	lds ZH, pulse2_fx_3xx_speed+1
0027f3 9630                      	adiw Z, 0
0027f4 f409                      	brne sound_driver_channel1_fx_3xx_routine_check_start
0027f5 c048                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_check_start:
0027f6 91a0 28a1                 	lds r26, pulse2_fx_3xx_start
0027f8 91b0 28a2                 	lds r27, pulse2_fx_3xx_start+1
0027fa 9610                      	adiw r26:r27, 0
0027fb f409                      	brne sound_driver_channel1_fx_3xx_routine_main
0027fc c041                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_main:
0027fd 91c0 28a3                 	lds r28, pulse2_fx_3xx_target
0027ff 91d0 28a4                 	lds r29, pulse2_fx_3xx_target+1
                                 
002801 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002802 07bd                      	cpc r27, r29
002803 f011                      	breq sound_driver_channel1_fx_3xx_routine_disable
002804 f030                      	brlo sound_driver_channel1_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002805 c01f                      	rjmp sound_driver_channel1_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel1_fx_3xx_routine_disable:
002806 9220 28a1                 	sts pulse2_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002808 9220 28a2                 	sts pulse2_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
00280a c033                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_subtract:
00280b 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
00280c 0bdb                      	sbc r29, r27
00280d 91a0 28a7                 	lds r26, pulse2_fx_3xx_total_offset
00280f 91b0 28a8                 	lds r27, pulse2_fx_3xx_total_offset+1
                                 
002811 0fae                      	add r26, ZL //add the speed to the total offset
002812 1fbf                      	adc r27, ZH
002813 1bca                      	sub r28, r26 //invert the total difference with the total offset
002814 0bdb                      	sbc r29, r27
002815 f380                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002816 93a0 28a7                 	sts pulse2_fx_3xx_total_offset, r26 //store the new total offset
002818 93b0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r27
                                 
00281a 91a0 0a9c                 	lds r26, TCB1_CCMPL //load the current timer period
00281c 91b0 0a9d                 	lds r27, TCB1_CCMPH
00281e 1bac                      	sub r26, r28 //offset the current timer period with the total offset
00281f 0bbd                      	sbc r27, r29
002820 93a0 0a9c                 	sts TCB1_CCMPL, r26
002822 93b0 0a9d                 	sts TCB1_CCMPH, r27
002824 c019                      	rjmp sound_driver_channel1_fx_4xy_routine
                                 
                                 sound_driver_channel1_fx_3xx_routine_add:
002825 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002826 0bbd                      	sbc r27, r29
002827 91c0 28a7                 	lds r28, pulse2_fx_3xx_total_offset
002829 91d0 28a8                 	lds r29, pulse2_fx_3xx_total_offset+1
                                 
00282b 0fce                      	add r28, ZL //add the speed to the total offset
00282c 1fdf                      	adc r29, ZH
00282d 1bac                      	sub r26, r28 //invert the total difference with the total offset
00282e 0bbd                      	sbc r27, r29
00282f f2b0                      	brlo sound_driver_channel1_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002830 93c0 28a7                 	sts pulse2_fx_3xx_total_offset, r28 //store the new total offset
002832 93d0 28a8                 	sts pulse2_fx_3xx_total_offset+1, r29
                                 
002834 91c0 0a9c                 	lds r28, TCB1_CCMPL //load the current timer period
002836 91d0 0a9d                 	lds r29, TCB1_CCMPH
002838 0fca                      	add r28, r26 //offset the current timer period with the total offset
002839 1fdb                      	adc r29, r27
00283a 93c0 0a9c                 	sts TCB1_CCMPL, r28
00283c 93d0 0a9d                 	sts TCB1_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel1_fx_4xy_routine:
00283e 91a0 28a9                 	lds r26, pulse2_fx_4xy_speed
002840 15a2                      	cp r26, zero
002841 f409                      	brne sound_driver_channel1_fx_4xy_routine_continue
002842 c05c                      	rjmp sound_driver_channel1_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel1_fx_4xy_routine_continue:
002843 91b0 28aa                 	lds r27, pulse2_fx_4xy_depth
002845 91c0 28ab                 	lds r28, pulse2_fx_4xy_phase
002847 0fca                      	add r28, r26 //increase the phase by the speed
002848 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002849 f008                      	brlo sound_driver_channel1_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
00284a e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase:
00284b 93c0 28ab                 	sts pulse2_fx_4xy_phase, r28 //store the new phase
00284d 31c0                      	cpi r28, 16
00284e f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_0
00284f 32c0                      	cpi r28, 32
002850 f028                      	brlo sound_driver_channel1_fx_4xy_routine_phase_1
002851 33c0                      	cpi r28, 48
002852 f030                      	brlo sound_driver_channel1_fx_4xy_routine_phase_2
002853 c007                      	rjmp sound_driver_channel1_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_0:
002854 70cf                      	andi r28, 0x0F //mask for values 0-15
002855 c029                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_1:
002856 6fc0                      	ori r28, 0xF0
002857 95c0                      	com r28 //invert values 0-15
002858 c026                      	rjmp sound_driver_channel1_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_2:
002859 70cf                      	andi r28, 0x0F //mask for values 0-15
00285a c003                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_phase_3:
00285b 6fc0                      	ori r28, 0xF0
00285c 95c0                      	com r28 //invert values 0-15
00285d c000                      	rjmp sound_driver_channel1_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_add:
00285e 95b2                      	swap r27 //multiply depth by 16
00285f 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002860 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002861 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002862 0fec                      	add ZL, r28 //offset the table by the depth+phase
002863 1df2                      	adc ZH, zero
002864 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002865 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002866 937f                      	push r23
002867 2f6c                      	mov r22, r28 //store the vibrato value into r22
002868 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002869 9f67                      	mul r22, r23
00286a 917f                      	pop r23
00286b 916f                      	pop r22
                                 
00286c 9416                      	lsr r1 //shift out the fractional bits
00286d 9407                      	ror r0
00286e 9416                      	lsr r1
00286f 9407                      	ror r0
002870 9416                      	lsr r1
002871 9407                      	ror r0
002872 9416                      	lsr r1
002873 9407                      	ror r0
                                 	
002874 91a0 0a9c                 	lds r26, TCB1_CCMPL
002876 91b0 0a9d                 	lds r27, TCB1_CCMPH
002878 0da0                      	add r26, r0
002879 1db1                      	adc r27, r1
00287a 93a0 0a9c                 	sts TCB1_CCMPL, r26
00287c 93b0 0a9d                 	sts TCB1_CCMPH, r27
00287e c020                      	rjmp sound_driver_channel1_fx_7xy_routine
                                 
                                 sound_driver_channel1_fx_4xy_routine_load_subtract:
00287f 95b2                      	swap r27 //multiply depth by 16
002880 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002881 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002882 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002883 0fec                      	add ZL, r28 //offset the table by the depth+phase
002884 1df2                      	adc ZH, zero
002885 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002886 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002887 937f                      	push r23
002888 2f6c                      	mov r22, r28 //store the vibrato value into r22
002889 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
00288a 9f67                      	mul r22, r23
00288b 917f                      	pop r23
00288c 916f                      	pop r22
                                 
00288d 9416                      	lsr r1 //shift out the fractional bits
00288e 9407                      	ror r0
00288f 9416                      	lsr r1
002890 9407                      	ror r0
002891 9416                      	lsr r1
002892 9407                      	ror r0
002893 9416                      	lsr r1
002894 9407                      	ror r0
                                 
002895 91a0 0a9c                 	lds r26, TCB1_CCMPL
002897 91b0 0a9d                 	lds r27, TCB1_CCMPH
002899 19a0                      	sub r26, r0
00289a 09b1                      	sbc r27, r1
00289b 93a0 0a9c                 	sts TCB1_CCMPL, r26
00289d 93b0 0a9d                 	sts TCB1_CCMPH, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_7xy_routine:
00289f 91a0 28ac                 	lds r26, pulse2_fx_7xy_speed
0028a1 15a2                      	cp r26, zero
0028a2 f0e9                      	breq sound_driver_channel1_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
0028a3 91b0 28ad                 	lds r27, pulse2_fx_7xy_depth
0028a5 91c0 28ae                 	lds r28, pulse2_fx_7xy_phase
0028a7 0fca                      	add r28, r26 //increase the phase by the speed
0028a8 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
0028a9 f008                      	brlo sound_driver_channel1_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
0028aa e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase:
0028ab 93c0 28ae                 	sts pulse2_fx_7xy_phase, r28 //store the new phase
0028ad 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
0028ae ffc4                      	sbrs r28, 4
0028af c001                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_0
0028b0 c002                      	rjmp sound_driver_channel1_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel1_fx_7xy_routine_phase_0:
0028b1 70cf                      	andi r28, 0x0F //mask for values 0-15
0028b2 c003                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_phase_1:
0028b3 6fc0                      	ori r28, 0xF0
0028b4 95c0                      	com r28 //invert values 0-15
0028b5 c000                      	rjmp sound_driver_channel1_fx_7xy_routine_load
                                 
                                 sound_driver_channel1_fx_7xy_routine_load:
0028b6 95b2                      	swap r27 //multiply depth by 16
0028b7 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
0028b8 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
0028b9 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
0028ba 0fec                      	add ZL, r28 //offset the table by the depth+phase
0028bb 1df2                      	adc ZH, zero
0028bc 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
0028bd 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
0028be 93c0 28af                 	sts pulse2_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Axy_routine:
0028c0 91b0 28b0                 	lds r27, pulse2_fx_Axy
0028c2 15b2                      	cp r27, zero
0028c3 f0e9                      	breq sound_driver_channel1_fx_Qxy_routine //0 means that the effect is not in use
                                 	
0028c4 91a0 280d                 	lds r26, pulse2_fractional_volume //load fractional volume representation of the channel
0028c6 91c0 2808                 	lds r28, pulse2_param //load the integer volume representation of the channel
0028c8 2fda                      	mov r29, r26 //copy fractional volume into r29
0028c9 2fec                      	mov r30, r28 //copy the pulse2_param into r30
0028ca 95e2                      	swap r30
0028cb 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
0028cc 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
0028cd 17ed                      	cp r30, r29 //compare the fractional and integer volumes
0028ce f009                      	breq sound_driver_channel1_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel1_fx_Axy_routine_reload:
0028cf 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate:
0028d0 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
0028d1 c004                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_addition:
0028d2 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0028d3 f428                      	brcc sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0028d4 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
0028d5 c003                      	rjmp sound_driver_channel1_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_subtraction:
0028d6 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
0028d7 f008                      	brcs sound_driver_channel1_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
0028d8 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel1_fx_Axy_routine_calculate_store:
0028d9 93a0 280d                 	sts pulse2_fractional_volume, r26 //store the new fractional volume
0028db 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
0028dc 95a2                      	swap r26
0028dd 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
0028de 2bca                      	or r28, r26 //store the new volume back into pulse2_param
0028df 93c0 2808                 	sts pulse2_param, r28
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel1_fx_Qxy_routine:
0028e1 91e0 28b6                 	lds ZL, pulse2_fx_Qxy_target
0028e3 91f0 28b7                 	lds ZH, pulse2_fx_Qxy_target+1
0028e5 9630                      	adiw Z, 0
0028e6 f119                      	breq sound_driver_channel1_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
0028e7 91a0 28ba                 	lds r26, pulse2_fx_Qxy_total_offset
0028e9 91b0 28bb                 	lds r27, pulse2_fx_Qxy_total_offset+1
0028eb 91c0 0a9c                 	lds r28, TCB1_CCMPL
0028ed 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
0028ef 1bec                      	sub ZL, r28 //calculate the difference to the target
0028f0 0bfd                      	sbc ZH, r29
0028f1 f408                      	brsh sound_driver_channel1_fx_Qxy_routine_end //if the target has been reached (or passed)
0028f2 f068                      	brlo sound_driver_channel1_fx_Qxy_routine_add
                                 
                                 sound_driver_channel1_fx_Qxy_routine_end:
0028f3 9220 28ba                 	sts pulse2_fx_Qxy_total_offset, zero //turn off the effect
0028f5 9220 28bb                 	sts pulse2_fx_Qxy_total_offset+1, zero
0028f7 9220 28b6                 	sts pulse2_fx_Qxy_target, zero
0028f9 9220 28b7                 	sts pulse2_fx_Qxy_target+1, zero
0028fb 91b0 28b5                 	lds r27, pulse2_fx_Qxy_target_note
0028fd 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
0028ff c00a                      	rjmp sound_driver_channel1_fx_Rxy_routine
                                 
                                 sound_driver_channel1_fx_Qxy_routine_add:
002900 91c0 28b8                 	lds r28, pulse2_fx_Qxy_speed
002902 91d0 28b9                 	lds r29, pulse2_fx_Qxy_speed+1
002904 0fac                      	add r26, r28 //increase the total offset by the speed
002905 1fbd                      	adc r27, r29
002906 93a0 28ba                 	sts pulse2_fx_Qxy_total_offset, r26 //store the total offset
002908 93b0 28bb                 	sts pulse2_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel1_fx_Rxy_routine:
00290a 91e0 28bd                 	lds ZL, pulse2_fx_Rxy_target
00290c 91f0 28be                 	lds ZH, pulse2_fx_Rxy_target+1
00290e 9630                      	adiw Z, 0
00290f f119                      	breq sound_driver_instrument_routine_channel2_volume //if the effect is not enabled, skip the routine
                                 
002910 91a0 28c1                 	lds r26, pulse2_fx_Rxy_total_offset
002912 91b0 28c2                 	lds r27, pulse2_fx_Rxy_total_offset+1
002914 91c0 0a9c                 	lds r28, TCB1_CCMPL
002916 91d0 0a9d                 	lds r29, TCB1_CCMPH
                                 
002918 1bce                      	sub r28, ZL //calculate the difference to the target
002919 0bdf                      	sbc r29, ZH
00291a f408                      	brsh sound_driver_channel1_fx_Rxy_routine_end //if the target has been reached (or passed)
00291b f068                      	brlo sound_driver_channel1_fx_Rxy_routine_add
                                 
                                 sound_driver_channel1_fx_Rxy_routine_end:
00291c 9220 28c1                 	sts pulse2_fx_Rxy_total_offset, zero //disable the effect
00291e 9220 28c2                 	sts pulse2_fx_Rxy_total_offset+1, zero
002920 9220 28bd                 	sts pulse2_fx_Rxy_target, zero
002922 9220 28be                 	sts pulse2_fx_Rxy_target+1, zero
002924 91b0 28bc                 	lds r27, pulse2_fx_Rxy_target_note
002926 93b0 280f                 	sts pulse2_note, r27 //replace the note with the final target note
002928 c00a                      	rjmp sound_driver_instrument_routine_channel2_volume
                                 
                                 sound_driver_channel1_fx_Rxy_routine_add:
002929 91c0 28bf                 	lds r28, pulse2_fx_Rxy_speed
00292b 91d0 28c0                 	lds r29, pulse2_fx_Rxy_speed+1
00292d 0fac                      	add r26, r28 //increase the total offset by the speed
00292e 1fbd                      	adc r27, r29
00292f 93a0 28c1                 	sts pulse2_fx_Rxy_total_offset, r26 //store the total offset
002931 93b0 28c2                 	sts pulse2_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume:
002933 91e0 28cb                 	lds ZL, triangle_volume_macro
002935 91f0 28cc                 	lds ZH, triangle_volume_macro+1
002937 9630                      	adiw Z, 0
002938 f199                      	breq sound_driver_instrument_routine_channel2_volume_default //if no volume macro is in use, do nothing
002939 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
00293a 1fff                      	rol ZH
00293b 91a0 28cd                 	lds r26, triangle_volume_macro_offset
00293d 0fea                      	add ZL, r26
00293e 1df2                      	adc ZH, zero
                                 
00293f 91b0 28cf                 	lds r27, triangle_volume_macro_release
002941 17ba                      	cp r27, r26
002942 f429                      	brne sound_driver_instrument_routine_channel2_volume_increment //if the current offset is not equal to the release index, increment the offset
002943 91a0 28ce                 	lds r26, triangle_volume_macro_loop
002945 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002946 f010                      	brlo sound_driver_instrument_routine_channel2_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002947 c003                      	rjmp sound_driver_instrument_routine_channel2_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_volume_increment:
002948 95a3                      	inc r26 //increment the macro offset
002949 93a0 28cd                 	sts triangle_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_volume_read:
00294b 91b4                      	lpm r27, Z //load volume data into r27
00294c 3fbf                      	cpi r27, 0xFF //check for macro end flag
00294d f469                      	brne sound_driver_instrument_routine_channel2_volume_process //if the data was not the macro end flag
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_release:
00294e 91b0 28cf                 	lds r27, triangle_volume_macro_release
002950 3fbf                      	cpi r27, 0xFF
002951 f429                      	brne sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_check_loop:
002952 91b0 28ce                 	lds r27, triangle_volume_macro_loop //load the loop index
002954 93b0 28cd                 	sts triangle_volume_macro_offset, r27 //store the loop index into the offset
002956 cfdc                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel2_volume_macro_end_flag_last_index:
002957 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002958 93a0 28cd                 	sts triangle_volume_macro_offset, r26
00295a cfd8                      	rjmp sound_driver_instrument_routine_channel2_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_volume_process:
00295b 15b2                      	cp r27, zero
00295c f041                      	breq sound_driver_instrument_routine_channel2_volume_process_disable
                                 sound_driver_instrument_routine_channel2_volume_process_enable:
00295d 91b0 0aa5                 	lds r27, TCB2_INTCTRL
00295f 30b1                      	cpi r27, TCB_CAPT_bm
002960 f459                      	brne sound_driver_instrument_routine_channel2_volume_default //if the channel has already been muted, don't enable it again
002961 e0b1                      	ldi r27, TCB_CAPT_bm //enable interrupts
002962 93b0 0aa5                 	sts TCB2_INTCTRL, r27
002964 c007                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 sound_driver_instrument_routine_channel2_volume_process_disable:
002965 9220 0aa5                 	sts TCB2_INTCTRL, zero
002967 9220 0aac                 	sts TCB2_CCMPL, zero //reset timer
002969 9220 0aad                 	sts TCB2_CCMPH, zero
00296b c000                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_volume_default:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
00296c 91e0 28d0                 	lds ZL, triangle_arpeggio_macro
00296e 91f0 28d1                 	lds ZH, triangle_arpeggio_macro+1
002970 9630                      	adiw Z, 0
002971 f1d9                      	breq sound_driver_instrument_routine_channel2_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002972 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002973 1fff                      	rol ZH
002974 91a0 28d2                 	lds r26, triangle_arpeggio_macro_offset
002976 0fea                      	add ZL, r26
002977 1df2                      	adc ZH, zero
                                 
002978 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
00297a 17ba                      	cp r27, r26
00297b f429                      	brne sound_driver_instrument_routine_channel2_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
00297c 91a0 28d3                 	lds r26, triangle_arpeggio_macro_loop
00297e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
00297f f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002980 c003                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_increment:
002981 95a3                      	inc r26 //increment the macro offset
002982 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_read:
002984 91b4                      	lpm r27, Z //load arpeggio data into r27
002985 38b0                      	cpi r27, 0x80 //check for macro end flag
002986 f009                      	breq sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag
002987 c041                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_check_mode:
002988 50a1                      	subi r26, 1 //keep the offset at the end flag
002989 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26
00298b 91b0 28d5                 	lds r27, triangle_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
00298d 30b1                      	cpi r27, 0x01
00298e f048                      	brlo sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_release:
00298f 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
002991 3fbf                      	cpi r27, 0xFF
002992 f4d1                      	brne sound_driver_instrument_routine_channel2_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_fixed_relative_check_loop:
002993 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop
002995 3fbf                      	cpi r27, 0xFF
002996 f499                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002997 c015                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute:
002998 91b0 28d4                 	lds r27, triangle_arpeggio_macro_release
00299a 3fbf                      	cpi r27, 0xFF
00299b f421                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_check_loop:
00299c 91b0 28d3                 	lds r27, triangle_arpeggio_macro_loop //load the loop index
00299e 3fbf                      	cpi r27, 0xFF //check if loop flag exists
00299f f451                      	brne sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_absolute_no_loop:
0029a0 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //check for 0xy effect
0029a2 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
0029a4 9620                      	adiw r29:r28, 0
0029a5 f469                      	brne sound_driver_instrument_routine_channel2_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
0029a6 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
0029a7 93a0 28d2                 	sts triangle_arpeggio_macro_offset, r26 //store the last valid index into the offset
0029a9 cfc2                      	rjmp sound_driver_instrument_routine_channel2_arpeggio
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_macro_end_flag_reload:
0029aa 93b0 28d2                 	sts triangle_arpeggio_macro_offset, r27 //store the loop index into the offset
0029ac cfbf                      	rjmp sound_driver_instrument_routine_channel2_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_default:
0029ad 91c0 28e8                 	lds r28, triangle_fx_0xy_sequence //load 0xy effect
0029af 91d0 28e9                 	lds r29, triangle_fx_0xy_sequence+1
0029b1 9620                      	adiw r29:r28, 0 //check for 0xy effect
0029b2 f099                      	breq sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel2_arpeggio_default_0xy:
0029b3 95d6                      	lsr r29
0029b4 95c7                      	ror r28
0029b5 95d7                      	ror r29
0029b6 95c7                      	ror r28
0029b7 95d7                      	ror r29
0029b8 95c7                      	ror r28
0029b9 95d7                      	ror r29
0029ba 95c7                      	ror r28
0029bb 95d7                      	ror r29
0029bc 95d2                      	swap r29
                                 
0029bd 93c0 28e8                 	sts triangle_fx_0xy_sequence, r28 //store the rolled sequence
0029bf 93d0 28e9                 	sts triangle_fx_0xy_sequence+1, r29
0029c1 70cf                      	andi r28, 0x0F //mask out the 4 LSB
0029c2 91a0 2812                 	lds r26, triangle_note //load the current note index
0029c4 0fac                      	add r26, r28 //add the note offset
0029c5 c02e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel2_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
0029c6 91a0 2812                 	lds r26, triangle_note //load the current note index
0029c8 c02b                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process:
0029c9 9220 28d6                 	sts triangle_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
0029cb 9220 28d7                 	sts triangle_total_pitch_offset+1, zero
0029cd 9220 28dd                 	sts triangle_total_hi_pitch_offset, zero
0029cf 91a0 28d5                 	lds r26, triangle_arpeggio_macro_mode
0029d1 30a1                      	cpi r26, 0x01 //absolute mode
0029d2 f010                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_absolute
0029d3 f069                      	breq sound_driver_instrument_routine_channel2_arpeggio_process_fixed
0029d4 c00e                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute:
0029d5 91a0 2812                 	lds r26, triangle_note //load the current note index
0029d7 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029d8 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029d9 c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_add:
0029da 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029db f0c0                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
0029dc e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029dd c016                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_absolute_subtract:
0029de fda7                      	sbrc r26, 7 //check if result is negative
0029df e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029e0 c013                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_fixed:
0029e1 2fab                      	mov r26, r27 //move the arpeggio data into r26
0029e2 c011                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative:
0029e3 91a0 2812                 	lds r26, triangle_note //load the current note index
0029e5 0fab                      	add r26, r27 //offset the note with the arpeggio data
0029e6 fdb7                      	sbrc r27, 7 //check sign bit to check if we are subtracting from the note index
0029e7 c008                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_add:
0029e8 93a0 2812                 	sts triangle_note, r26 //NOTE: relative mode modifies the original note index
0029ea 35a7                      	cpi r26, 0x57 //check if the result is larger than the size of the note table (0x56 is the highest possible index)
0029eb f040                      	brlo sound_driver_instrument_routine_channel2_arpeggio_process_load //if the result is valid, go load the new note
0029ec e5a6                      	ldi r26, 0x56 //if the result was too large, just set the result to the highest possible note index
0029ed 93a0 2812                 	sts triangle_note, r26
0029ef c004                      	rjmp sound_driver_instrument_routine_channel2_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_relative_subtract:
0029f0 fda7                      	sbrc r26, 7 //check if result is negative
0029f1 e0a0                      	ldi r26, 0x00 //if the result was negative, reset it to the 0th index
0029f2 93a0 2812                 	sts triangle_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_arpeggio_process_load:
0029f4 e9e4                      	ldi ZL, LOW(note_table << 1) //load in note table
0029f5 e0f0                      	ldi ZH, HIGH(note_table << 1)
0029f6 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
0029f7 0fea                      	add ZL, r26 //add offset
0029f8 1df2                      	adc ZH, zero
0029f9 91a5                      	lpm r26, Z+ //load bytes
0029fa 91b4                      	lpm r27, Z
0029fb 93a0 0aac                 	sts TCB2_CCMPL, r26 //load the LOW bits for timer
0029fd 93b0 0aad                 	sts TCB2_CCMPH, r27 //load the HIGH bits for timer
0029ff 93a0 28f4                 	sts triangle_fx_3xx_target, r26 //NOTE: 3xx target note is stored here because the true note is always read in this arpeggio macro routine
002a01 93b0 28f5                 	sts triangle_fx_3xx_target+1, r27
002a03 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch:
002a04 91e0 28d8                 	lds ZL, triangle_pitch_macro
002a06 91f0 28d9                 	lds ZH, triangle_pitch_macro+1
002a08 9630                      	adiw Z, 0
002a09 f409                      	brne sound_driver_instrument_routine_channel2_pitch_continue
002a0a c023                      	rjmp sound_driver_instrument_routine_channel2_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel2_pitch_continue:
002a0b 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a0c 1fff                      	rol ZH
002a0d 91a0 28da                 	lds r26, triangle_pitch_macro_offset
002a0f 0fea                      	add ZL, r26
002a10 1df2                      	adc ZH, zero
                                 
002a11 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002a13 17ba                      	cp r27, r26
002a14 f429                      	brne sound_driver_instrument_routine_channel2_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a15 91a0 28db                 	lds r26, triangle_pitch_macro_loop
002a17 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a18 f010                      	brlo sound_driver_instrument_routine_channel2_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a19 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_pitch_increment:
002a1a 95a3                      	inc r26 //increment the macro offset
002a1b 93a0 28da                 	sts triangle_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_pitch_read:
002a1d 91b4                      	lpm r27, Z //load pitch data into r27
002a1e 38b0                      	cpi r27, 0x80 //check for macro end flag
002a1f f479                      	brne sound_driver_instrument_routine_channel2_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_release:
002a20 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002a21 93a0 28da                 	sts triangle_pitch_macro_offset, r26
002a23 91b0 28dc                 	lds r27, triangle_pitch_macro_release
002a25 3fbf                      	cpi r27, 0xFF
002a26 f439                      	brne sound_driver_instrument_routine_channel2_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel2_pitch_macro_end_flag_check_loop:
002a27 91b0 28db                 	lds r27, triangle_pitch_macro_loop //load the loop index
002a29 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002a2a f019                      	breq sound_driver_instrument_routine_channel2_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002a2b 93b0 28da                 	sts triangle_pitch_macro_offset, r27 //store the loop index into the offset
002a2d cfd6                      	rjmp sound_driver_instrument_routine_channel2_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_pitch_default:
002a2e e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel2_pitch_calculate:
002a2f 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002a30 937f                      	push r23
002a31 2f6b                      	mov r22, r27 //store the signed pitch offset data into r22
002a32 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002a33 0367                      	mulsu r22, r23
002a34 917f                      	pop r23
002a35 916f                      	pop r22
                                 
002a36 9416                      	lsr r1 //shift out the fractional bits
002a37 9407                      	ror r0
002a38 9416                      	lsr r1
002a39 9407                      	ror r0
002a3a 9416                      	lsr r1
002a3b 9407                      	ror r0
002a3c 9416                      	lsr r1
002a3d 9407                      	ror r0
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_negative:
002a3e fe13                      	sbrs r1, 3 //check if result was a negative number
002a3f c007                      	rjmp sound_driver_instrument_routine_channel2_pitch_calculate_offset //if the result was positive, don't fill with 1s
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_negative:
002a40 efc0                      	ldi r28, 0xF0
002a41 2a1c                      	or r1, r28 //when right shifting a two's complement number, must use 1s instead of 0s to fill
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_check_divisible_8:
002a42 70b7                      	andi r27, 0b00000111
002a43 f019                      	breq sound_driver_instrument_routine_channel2_pitch_calculate_offset
                                 
002a44 e0b1                      	ldi r27, 0x01
002a45 0e0b                      	add r0, r27
002a46 1c12                      	adc r1, zero
                                 
                                 sound_driver_instrument_routine_channel2_pitch_calculate_offset:
002a47 91a0 28d6                 	lds r26, triangle_total_pitch_offset
002a49 91b0 28d7                 	lds r27, triangle_total_pitch_offset+1
002a4b 0e0a                      	add r0, r26
002a4c 1e1b                      	adc r1, r27
002a4d 9200 28d6                 	sts triangle_total_pitch_offset, r0
002a4f 9210 28d7                 	sts triangle_total_pitch_offset+1, r1
002a51 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002a53 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002a55 0da0                      	add r26, r0 //offset the timer values
002a56 1db1                      	adc r27, r1
                                 	
002a57 91c0 28ec                 	lds r28, triangle_fx_1xx_total
002a59 91d0 28ed                 	lds r29, triangle_fx_1xx_total+1
002a5b 1bac                      	sub r26, r28
002a5c 0bbd                      	sbc r27, r29
002a5d 91c0 28f0                 	lds r28, triangle_fx_2xx_total
002a5f 91d0 28f1                 	lds r29, triangle_fx_2xx_total+1
002a61 0fac                      	add r26, r28
002a62 1fbd                      	adc r27, r29
002a63 91c0 28ff                 	lds r28, triangle_fx_Pxx_total
002a65 91d0 2900                 	lds r29, triangle_fx_Pxx_total+1
002a67 0fac                      	add r26, r28
002a68 1fbd                      	adc r27, r29
002a69 91c0 2906                 	lds r28, triangle_fx_Qxy_total_offset
002a6b 91d0 2907                 	lds r29, triangle_fx_Qxy_total_offset+1
002a6d 1bac                      	sub r26, r28
002a6e 0bbd                      	sbc r27, r29
002a6f 91c0 290d                 	lds r28, triangle_fx_Rxy_total_offset
002a71 91d0 290e                 	lds r29, triangle_fx_Rxy_total_offset+1
002a73 0fac                      	add r26, r28
002a74 1fbd                      	adc r27, r29
                                 
002a75 e5c9                      	ldi r28, 0x59
002a76 e0d0                      	ldi r29, 0x00
002a77 17ac                      	cp r26, r28
002a78 07bd                      	cpc r27, r29
002a79 f030                      	brlo sound_driver_instrument_routine_channel2_pitch_min
                                 
002a7a e5ca                      	ldi r28, 0x5A
002a7b e5d9                      	ldi r29, 0x59
002a7c 17ac                      	cp r26, r28
002a7d 07bd                      	cpc r27, r29
002a7e f420                      	brsh sound_driver_instrument_routine_channel2_pitch_max
002a7f c006                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_min:
002a80 e5c9                      	ldi r28, 0x59
002a81 e0d0                      	ldi r29, 0x00
002a82 c003                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_max:
002a83 e5c9                      	ldi r28, 0x59
002a84 e5d9                      	ldi r29, 0x59
002a85 c000                      	rjmp sound_driver_instrument_routine_channel2_pitch_store
                                 
                                 sound_driver_instrument_routine_channel2_pitch_store:
002a86 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002a88 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel2_hi_pitch:
002a8a 91e0 28de                 	lds ZL, triangle_hi_pitch_macro
002a8c 91f0 28df                 	lds ZH, triangle_hi_pitch_macro+1
002a8e 9630                      	adiw Z, 0
002a8f f409                      	brne sound_driver_instrument_routine_channel2_hi_pitch_continue
002a90 c03c                      	rjmp sound_driver_instrument_routine_channel2_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel2_hi_pitch_continue:
002a91 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002a92 1fff                      	rol ZH
002a93 91a0 28e0                 	lds r26, triangle_hi_pitch_macro_offset
002a95 0fea                      	add ZL, r26
002a96 1df2                      	adc ZH, zero
                                 
002a97 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002a99 17ba                      	cp r27, r26
002a9a f429                      	brne sound_driver_instrument_routine_channel2_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002a9b 91a0 28e1                 	lds r26, triangle_hi_pitch_macro_loop
002a9d 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002a9e f010                      	brlo sound_driver_instrument_routine_channel2_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002a9f c003                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_increment:
002aa0 95a3                      	inc r26 //increment the macro offset
002aa1 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel2_hi_pitch_read:
002aa3 91b4                      	lpm r27, Z //load hi pitch data into r27
002aa4 38b0                      	cpi r27, 0x80 //check for macro end flag
002aa5 f489                      	brne sound_driver_instrument_routine_channel2_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_release:
002aa6 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002aa7 93a0 28e0                 	sts triangle_hi_pitch_macro_offset, r26
002aa9 91b0 28e2                 	lds r27, triangle_hi_pitch_macro_release
002aab 3fbf                      	cpi r27, 0xFF
002aac f439                      	brne sound_driver_instrument_routine_channel2_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_macro_end_flag_check_loop:
002aad 91b0 28e1                 	lds r27, triangle_hi_pitch_macro_loop //load the loop index
002aaf 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002ab0 f019                      	breq sound_driver_instrument_routine_channel2_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002ab1 93b0 28e0                 	sts triangle_hi_pitch_macro_offset, r27 //store the loop index into the offset
002ab3 cfd6                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_default:
002ab4 91b0 28dd                 	lds r27, triangle_total_hi_pitch_offset
002ab6 c005                      	rjmp sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate:
002ab7 91a0 28dd                 	lds r26, triangle_total_hi_pitch_offset //load the total hi pitch offset to change
002ab9 0fba                      	add r27, r26
002aba 93b0 28dd                 	sts triangle_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_multiply:
002abc 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002abd 937f                      	push r23
002abe 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002abf eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002ac0 0367                      	mulsu r22, r23
002ac1 917f                      	pop r23
002ac2 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel2_hi_pitch_calculate_offset:
002ac3 91a0 0aac                 	lds r26, TCB2_CCMPL //load the low bits for timer
002ac5 91b0 0aad                 	lds r27, TCB2_CCMPH //load the high bits for timer
002ac7 0da0                      	add r26, r0 //offset the timer values
002ac8 1db1                      	adc r27, r1
002ac9 93a0 0aac                 	sts TCB2_CCMPL, r26 //store the new low bits for timer
002acb 93b0 0aad                 	sts TCB2_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 //NOTE: The triangle channel does not have a duty cycle
                                 sound_driver_instrument_routine_channel2_duty:
                                 
                                 
                                 
                                 sound_driver_channel2_fx_routines:
                                 sound_driver_channel2_fx_1xx_routine:
002acd 91e0 28ea                 	lds ZL, triangle_fx_1xx
002acf 91f0 28eb                 	lds ZH, triangle_fx_1xx+1
002ad1 9630                      	adiw Z, 0
002ad2 f051                      	breq sound_driver_channel2_fx_2xx_routine
                                 
002ad3 91a0 28ec                 	lds r26, triangle_fx_1xx_total //load the rate to change the pitch by
002ad5 91b0 28ed                 	lds r27, triangle_fx_1xx_total+1
002ad7 0fae                      	add r26, ZL //increase the total offset by the rate
002ad8 1fbf                      	adc r27, ZH
002ad9 93a0 28ec                 	sts triangle_fx_1xx_total, r26
002adb 93b0 28ed                 	sts triangle_fx_1xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_2xx_routine:
002add 91e0 28ee                 	lds ZL, triangle_fx_2xx
002adf 91f0 28ef                 	lds ZH, triangle_fx_2xx+1
002ae1 9630                      	adiw Z, 0
002ae2 f051                      	breq sound_driver_channel2_fx_3xx_routine
                                 
002ae3 91a0 28f0                 	lds r26, triangle_fx_2xx_total //load the rate to change the pitch by
002ae5 91b0 28f1                 	lds r27, triangle_fx_2xx_total+1
002ae7 0fae                      	add r26, ZL //increase the total offset by the rate
002ae8 1fbf                      	adc r27, ZH
002ae9 93a0 28f0                 	sts triangle_fx_2xx_total, r26
002aeb 93b0 28f1                 	sts triangle_fx_2xx_total+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_3xx_routine:
002aed 91e0 28f6                 	lds ZL, triangle_fx_3xx_speed
002aef 91f0 28f7                 	lds ZH, triangle_fx_3xx_speed+1
002af1 9630                      	adiw Z, 0
002af2 f409                      	brne sound_driver_channel2_fx_3xx_routine_check_start
002af3 c048                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_check_start:
002af4 91a0 28f2                 	lds r26, triangle_fx_3xx_start
002af6 91b0 28f3                 	lds r27, triangle_fx_3xx_start+1
002af8 9610                      	adiw r26:r27, 0
002af9 f409                      	brne sound_driver_channel2_fx_3xx_routine_main
002afa c041                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_main:
002afb 91c0 28f4                 	lds r28, triangle_fx_3xx_target
002afd 91d0 28f5                 	lds r29, triangle_fx_3xx_target+1
                                 
002aff 17ac                      	cp r26, r28 //check if the target is lower, higher or equal to the starting period
002b00 07bd                      	cpc r27, r29
002b01 f011                      	breq sound_driver_channel2_fx_3xx_routine_disable
002b02 f030                      	brlo sound_driver_channel2_fx_3xx_routine_subtract //if target is larger, we need to add to the start (subtract from the current timer)
002b03 c01f                      	rjmp sound_driver_channel2_fx_3xx_routine_add //if target is smaller, we need to subtract from the start (add to the current timer)
                                 
                                 sound_driver_channel2_fx_3xx_routine_disable:
002b04 9220 28f2                 	sts triangle_fx_3xx_start, zero //setting the starting period to 0 effectively disables this routine until a note has been changed
002b06 9220 28f3                 	sts triangle_fx_3xx_start+1, zero //NOTE: to truly disable the effect, 300 must be written.
002b08 c033                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_subtract:
002b09 1bca                      	sub r28, r26 //store the total difference between the start and the target into r28:r29
002b0a 0bdb                      	sbc r29, r27
002b0b 91a0 28f8                 	lds r26, triangle_fx_3xx_total_offset
002b0d 91b0 28f9                 	lds r27, triangle_fx_3xx_total_offset+1
                                 
002b0f 0fae                      	add r26, ZL //add the speed to the total offset
002b10 1fbf                      	adc r27, ZH
002b11 1bca                      	sub r28, r26 //invert the total difference with the total offset
002b12 0bdb                      	sbc r29, r27
002b13 f380                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b14 93a0 28f8                 	sts triangle_fx_3xx_total_offset, r26 //store the new total offset
002b16 93b0 28f9                 	sts triangle_fx_3xx_total_offset+1, r27
                                 
002b18 91a0 0aac                 	lds r26, TCB2_CCMPL //load the current timer period
002b1a 91b0 0aad                 	lds r27, TCB2_CCMPH
002b1c 1bac                      	sub r26, r28 //offset the current timer period with the total offset
002b1d 0bbd                      	sbc r27, r29
002b1e 93a0 0aac                 	sts TCB2_CCMPL, r26
002b20 93b0 0aad                 	sts TCB2_CCMPH, r27
002b22 c019                      	rjmp sound_driver_channel2_fx_4xy_routine
                                 
                                 sound_driver_channel2_fx_3xx_routine_add:
002b23 1bac                      	sub r26, r28 //store the total difference between the start and the target into r28:r29
002b24 0bbd                      	sbc r27, r29
002b25 91c0 28f8                 	lds r28, triangle_fx_3xx_total_offset
002b27 91d0 28f9                 	lds r29, triangle_fx_3xx_total_offset+1
                                 
002b29 0fce                      	add r28, ZL //add the speed to the total offset
002b2a 1fdf                      	adc r29, ZH
002b2b 1bac                      	sub r26, r28 //invert the total difference with the total offset
002b2c 0bbd                      	sbc r27, r29
002b2d f2b0                      	brlo sound_driver_channel2_fx_3xx_routine_disable //if the total offset has surpassed the target difference (target note has been reached)
                                 
002b2e 93c0 28f8                 	sts triangle_fx_3xx_total_offset, r28 //store the new total offset
002b30 93d0 28f9                 	sts triangle_fx_3xx_total_offset+1, r29
                                 
002b32 91c0 0aac                 	lds r28, TCB2_CCMPL //load the current timer period
002b34 91d0 0aad                 	lds r29, TCB2_CCMPH
002b36 0fca                      	add r28, r26 //offset the current timer period with the total offset
002b37 1fdb                      	adc r29, r27
002b38 93c0 0aac                 	sts TCB2_CCMPL, r28
002b3a 93d0 0aad                 	sts TCB2_CCMPH, r29
                                 
                                 
                                 
                                 sound_driver_channel2_fx_4xy_routine:
002b3c 91a0 28fa                 	lds r26, triangle_fx_4xy_speed
002b3e 15a2                      	cp r26, zero
002b3f f409                      	brne sound_driver_channel2_fx_4xy_routine_continue
002b40 c05c                      	rjmp sound_driver_channel2_fx_Qxy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel2_fx_4xy_routine_continue:
002b41 91b0 28fb                 	lds r27, triangle_fx_4xy_depth
002b43 91c0 28fc                 	lds r28, triangle_fx_4xy_phase
002b45 0fca                      	add r28, r26 //increase the phase by the speed
002b46 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002b47 f008                      	brlo sound_driver_channel2_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002b48 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase:
002b49 93c0 28fc                 	sts triangle_fx_4xy_phase, r28 //store the new phase
002b4b 31c0                      	cpi r28, 16
002b4c f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_0
002b4d 32c0                      	cpi r28, 32
002b4e f028                      	brlo sound_driver_channel2_fx_4xy_routine_phase_1
002b4f 33c0                      	cpi r28, 48
002b50 f030                      	brlo sound_driver_channel2_fx_4xy_routine_phase_2
002b51 c007                      	rjmp sound_driver_channel2_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_0:
002b52 70cf                      	andi r28, 0x0F //mask for values 0-15
002b53 c029                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_1:
002b54 6fc0                      	ori r28, 0xF0
002b55 95c0                      	com r28 //invert values 0-15
002b56 c026                      	rjmp sound_driver_channel2_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_2:
002b57 70cf                      	andi r28, 0x0F //mask for values 0-15
002b58 c003                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_phase_3:
002b59 6fc0                      	ori r28, 0xF0
002b5a 95c0                      	com r28 //invert values 0-15
002b5b c000                      	rjmp sound_driver_channel2_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_add:
002b5c 95b2                      	swap r27 //multiply depth by 16
002b5d 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002b5e e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b5f e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b60 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b61 1df2                      	adc ZH, zero
002b62 91c4                      	lpm r28, Z //load the tremelo value into r28
                                 
002b63 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b64 937f                      	push r23
002b65 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b66 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b67 9f67                      	mul r22, r23
002b68 917f                      	pop r23
002b69 916f                      	pop r22
                                 
002b6a 9416                      	lsr r1 //shift out the fractional bits
002b6b 9407                      	ror r0
002b6c 9416                      	lsr r1
002b6d 9407                      	ror r0
002b6e 9416                      	lsr r1
002b6f 9407                      	ror r0
002b70 9416                      	lsr r1
002b71 9407                      	ror r0
                                 	
002b72 91a0 0aac                 	lds r26, TCB2_CCMPL
002b74 91b0 0aad                 	lds r27, TCB2_CCMPH
002b76 0da0                      	add r26, r0
002b77 1db1                      	adc r27, r1
002b78 93a0 0aac                 	sts TCB2_CCMPL, r26
002b7a 93b0 0aad                 	sts TCB2_CCMPH, r27
002b7c c020                      	rjmp sound_driver_channel2_fx_Qxy_routine
                                 
                                 sound_driver_channel2_fx_4xy_routine_load_subtract:
002b7d 95b2                      	swap r27 //multiply depth by 16
002b7e 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002b7f e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002b80 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002b81 0fec                      	add ZL, r28 //offset the table by the depth+phase
002b82 1df2                      	adc ZH, zero
002b83 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002b84 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002b85 937f                      	push r23
002b86 2f6c                      	mov r22, r28 //store the vibrato value into r22
002b87 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002b88 9f67                      	mul r22, r23
002b89 917f                      	pop r23
002b8a 916f                      	pop r22
                                 
002b8b 9416                      	lsr r1 //shift out the fractional bits
002b8c 9407                      	ror r0
002b8d 9416                      	lsr r1
002b8e 9407                      	ror r0
002b8f 9416                      	lsr r1
002b90 9407                      	ror r0
002b91 9416                      	lsr r1
002b92 9407                      	ror r0
                                 
002b93 91a0 0aac                 	lds r26, TCB2_CCMPL
002b95 91b0 0aad                 	lds r27, TCB2_CCMPH
002b97 19a0                      	sub r26, r0
002b98 09b1                      	sbc r27, r1
002b99 93a0 0aac                 	sts TCB2_CCMPL, r26
002b9b 93b0 0aad                 	sts TCB2_CCMPH, r27
                                 
                                 
                                 
                                 //NOTE: The Qxy and Rxy routines ONLY calculate the total offset. The offset is applied in the pitch macro routine
                                 sound_driver_channel2_fx_Qxy_routine:
002b9d 91e0 2902                 	lds ZL, triangle_fx_Qxy_target
002b9f 91f0 2903                 	lds ZH, triangle_fx_Qxy_target+1
002ba1 9630                      	adiw Z, 0
002ba2 f119                      	breq sound_driver_channel2_fx_Rxy_routine //if the effect is not enabled, skip the routine
                                 
002ba3 91a0 2906                 	lds r26, triangle_fx_Qxy_total_offset
002ba5 91b0 2907                 	lds r27, triangle_fx_Qxy_total_offset+1
002ba7 91c0 0aac                 	lds r28, TCB2_CCMPL
002ba9 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002bab 1bec                      	sub ZL, r28 //calculate the difference to the target
002bac 0bfd                      	sbc ZH, r29
002bad f408                      	brsh sound_driver_channel2_fx_Qxy_routine_end //if the target has been reached (or passed)
002bae f068                      	brlo sound_driver_channel2_fx_Qxy_routine_add
                                 
                                 sound_driver_channel2_fx_Qxy_routine_end:
002baf 9220 2906                 	sts triangle_fx_Qxy_total_offset, zero //turn off the effect
002bb1 9220 2907                 	sts triangle_fx_Qxy_total_offset+1, zero
002bb3 9220 2902                 	sts triangle_fx_Qxy_target, zero
002bb5 9220 2903                 	sts triangle_fx_Qxy_target+1, zero
002bb7 91b0 2901                 	lds r27, triangle_fx_Qxy_target_note
002bb9 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002bbb c00a                      	rjmp sound_driver_channel2_fx_Rxy_routine
                                 
                                 sound_driver_channel2_fx_Qxy_routine_add:
002bbc 91c0 2904                 	lds r28, triangle_fx_Qxy_speed
002bbe 91d0 2905                 	lds r29, triangle_fx_Qxy_speed+1
002bc0 0fac                      	add r26, r28 //increase the total offset by the speed
002bc1 1fbd                      	adc r27, r29
002bc2 93a0 2906                 	sts triangle_fx_Qxy_total_offset, r26 //store the total offset
002bc4 93b0 2907                 	sts triangle_fx_Qxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_channel2_fx_Rxy_routine:
002bc6 91e0 2909                 	lds ZL, triangle_fx_Rxy_target
002bc8 91f0 290a                 	lds ZH, triangle_fx_Rxy_target+1
002bca 9630                      	adiw Z, 0
002bcb f119                      	breq sound_driver_instrument_routine_channel3_volume //if the effect is not enabled, skip the routine
                                 
002bcc 91a0 290d                 	lds r26, triangle_fx_Rxy_total_offset
002bce 91b0 290e                 	lds r27, triangle_fx_Rxy_total_offset+1
002bd0 91c0 0aac                 	lds r28, TCB2_CCMPL
002bd2 91d0 0aad                 	lds r29, TCB2_CCMPH
                                 
002bd4 1bce                      	sub r28, ZL //calculate the difference to the target
002bd5 0bdf                      	sbc r29, ZH
002bd6 f408                      	brsh sound_driver_channel2_fx_Rxy_routine_end //if the target has been reached (or passed)
002bd7 f068                      	brlo sound_driver_channel2_fx_Rxy_routine_add
                                 
                                 sound_driver_channel2_fx_Rxy_routine_end:
002bd8 9220 290d                 	sts triangle_fx_Rxy_total_offset, zero //disable the effect
002bda 9220 290e                 	sts triangle_fx_Rxy_total_offset+1, zero
002bdc 9220 2909                 	sts triangle_fx_Rxy_target, zero
002bde 9220 290a                 	sts triangle_fx_Rxy_target+1, zero
002be0 91b0 2908                 	lds r27, triangle_fx_Rxy_target_note
002be2 93b0 2812                 	sts triangle_note, r27 //replace the note with the final target note
002be4 c00a                      	rjmp sound_driver_instrument_routine_channel3_volume
                                 
                                 sound_driver_channel2_fx_Rxy_routine_add:
002be5 91c0 290b                 	lds r28, triangle_fx_Rxy_speed
002be7 91d0 290c                 	lds r29, triangle_fx_Rxy_speed+1
002be9 0fac                      	add r26, r28 //increase the total offset by the speed
002bea 1fbd                      	adc r27, r29
002beb 93a0 290d                 	sts triangle_fx_Rxy_total_offset, r26 //store the total offset
002bed 93b0 290e                 	sts triangle_fx_Rxy_total_offset+1, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume:
002bef 91e0 2917                 	lds ZL, noise_volume_macro
002bf1 91f0 2918                 	lds ZH, noise_volume_macro+1
002bf3 9630                      	adiw Z, 0
002bf4 f1a1                      	breq sound_driver_instrument_routine_channel3_volume_default //if no volume macro is in use, use default multiplier of F
002bf5 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002bf6 1fff                      	rol ZH
002bf7 91a0 2919                 	lds r26, noise_volume_macro_offset
002bf9 0fea                      	add ZL, r26
002bfa 1df2                      	adc ZH, zero
                                 
002bfb 91b0 291b                 	lds r27, noise_volume_macro_release
002bfd 17ba                      	cp r27, r26
002bfe f429                      	brne sound_driver_instrument_routine_channel3_volume_increment //if the current offset is not equal to the release index, increment the offset
002bff 91a0 291a                 	lds r26, noise_volume_macro_loop
002c01 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c02 f010                      	brlo sound_driver_instrument_routine_channel3_volume_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002c03 c003                      	rjmp sound_driver_instrument_routine_channel3_volume_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_volume_increment:
002c04 95a3                      	inc r26 //increment the macro offset
002c05 93a0 2919                 	sts noise_volume_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_volume_read:
002c07 91b4                      	lpm r27, Z //load volume data into r27
002c08 3fbf                      	cpi r27, 0xFF //check for macro end flag
002c09 f469                      	brne sound_driver_instrument_routine_channel3_volume_calculate //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_release:
002c0a 91b0 291b                 	lds r27, noise_volume_macro_release
002c0c 3fbf                      	cpi r27, 0xFF
002c0d f429                      	brne sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index //if there is a release flag, we don't need to loop. stay at the last valid index
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_check_loop:
002c0e 91b0 291a                 	lds r27, noise_volume_macro_loop //load the loop index
002c10 93b0 2919                 	sts noise_volume_macro_offset, r27 //store the loop index into the offset
002c12 cfdc                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 sound_driver_instrument_routine_channel3_volume_macro_end_flag_last_index:
002c13 50a2                      	subi r26, 2 //go back to last valid index NOTE: Since we increment the offset everytime we read data, we have to decrement twice. 1 to account for the increment and 1 for the end flag.
002c14 93a0 2919                 	sts noise_volume_macro_offset, r26
002c16 cfd8                      	rjmp sound_driver_instrument_routine_channel3_volume //go back and re-read the volume data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_volume_calculate:
002c17 e2e4                      	ldi ZL, LOW(volumes << 1) //point Z to volume table
002c18 e5fd                      	ldi ZH, HIGH(volumes << 1)
002c19 95b2                      	swap r27 //multiply the offset by 16 to move to the correct row in the volume table
002c1a 0feb                      	add ZL, r27 //add offset to the table
002c1b 1df2                      	adc ZH, zero
                                 
                                 sound_driver_instrument_routine_channel3_volume_load:
002c1c 91b0 2813                 	lds r27, noise_param //load main volume
002c1e 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002c1f 91a0 2941                 	lds r26, noise_fx_7xy_value
002c21 30a0                      	cpi r26, 0x00
002c22 f481                      	brne sound_driver_instrument_routine_channel3_volume_load_7xy
                                 
002c23 0feb                      	add ZL, r27 //offset the volume table by the main volume
002c24 1df2                      	adc ZH, zero
002c25 91b4                      	lpm r27, Z
002c26 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002c28 c023                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default:
002c29 91b0 2813                 	lds r27, noise_param //a multiplier of F means in no change to the main volume, so we just copy the value into the output
002c2b 70bf                      	andi r27, 0x0F //mask for VVVV volume bits
                                 
002c2c 91a0 2941                 	lds r26, noise_fx_7xy_value
002c2e 30a0                      	cpi r26, 0x00
002c2f f499                      	brne sound_driver_instrument_routine_channel3_volume_default_7xy
002c30 93b0 2816                 	sts noise_output_volume, r27
002c32 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy:
002c33 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002c34 f038                      	brcs sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
002c35 f031                      	breq sound_driver_instrument_routine_channel3_volume_load_7xy_overflow
                                 
002c36 0feb                      	add ZL, r27 //offset the volume table by the main volume
002c37 1df2                      	adc ZH, zero
002c38 91b4                      	lpm r27, Z
002c39 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002c3b c010                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_load_7xy_overflow:
002c3c e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002c3d 0feb                      	add ZL, r27 //offset the volume table by the main volume
002c3e 1df2                      	adc ZH, zero
002c3f 91b4                      	lpm r27, Z
002c40 93b0 2816                 	sts noise_output_volume, r27 //store the new output volume
002c42 c009                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_volume_default_7xy:
002c43 1bba                      	sub r27, r26 //subtract the volume by the tremelo value
002c44 f020                      	brcs sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002c45 f019                      	breq sound_driver_instrument_routine_channel3_volume_default_7xy_overflow
002c46 93b0 2816                 	sts noise_output_volume, r27
002c48 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 	
                                 sound_driver_instrument_routine_channel3_volume_default_7xy_overflow:
002c49 e0b1                      	ldi r27, 0x01 //if the subtraction resulted in a negative volume, cap it to 0x01
002c4a 93b0 2816                 	sts noise_output_volume, r27
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio:
                                 	//NOTE: The arpeggio macro routine is also in charge of actually setting the timers using the note stored in SRAM. The default routine is responsible for that in the case no arpeggio macro is used.
002c4c 91e0 291c                 	lds ZL, noise_arpeggio_macro
002c4e 91f0 291d                 	lds ZH, noise_arpeggio_macro+1
002c50 9630                      	adiw Z, 0
002c51 f1d9                      	breq sound_driver_instrument_routine_channel3_arpeggio_default //if no arpeggio macro is in use, go output the note without any offsets
002c52 0fee                      	lsl ZL //multiply by 2 to make Z into a byte pointer for the macro's address
002c53 1fff                      	rol ZH
002c54 91a0 291e                 	lds r26, noise_arpeggio_macro_offset
002c56 0fea                      	add ZL, r26
002c57 1df2                      	adc ZH, zero
                                 
002c58 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002c5a 17ba                      	cp r27, r26
002c5b f429                      	brne sound_driver_instrument_routine_channel3_arpeggio_increment //if the current offset is not equal to the release index, increment the offset
002c5c 91a0 291f                 	lds r26, noise_arpeggio_macro_loop
002c5e 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002c5f f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_increment+1 //if the current offset is equal to the release index and there is a loop, reload the loop index, but also read the current index data
002c60 c003                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_increment:
002c61 95a3                      	inc r26 //increment the macro offset
002c62 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_read:
002c64 91b4                      	lpm r27, Z //load arpeggio data into r27
002c65 38b0                      	cpi r27, 0x80 //check for macro end flag
002c66 f009                      	breq sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag
002c67 c041                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process //if the data was not the macro end flag, calculate the volume
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_check_mode:
002c68 50a1                      	subi r26, 1 //keep the offset at the end flag
002c69 93a0 291e                 	sts noise_arpeggio_macro_offset, r26
002c6b 91b0 2921                 	lds r27, noise_arpeggio_macro_mode //load the mode to check for fixed/relative mode NOTE: end behavior for fixed/relative mode is different in that once the macro ends, the true note is played
002c6d 30b1                      	cpi r27, 0x01
002c6e f048                      	brlo sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_release:
002c6f 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002c71 3fbf                      	cpi r27, 0xFF
002c72 f4d1                      	brne sound_driver_instrument_routine_channel3_arpeggio_default //if there is a release flag, we don't need to loop. just play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_fixed_relative_check_loop:
002c73 91b0 291f                 	lds r27, noise_arpeggio_macro_loop
002c75 3fbf                      	cpi r27, 0xFF
002c76 f499                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if there is no release flag, but there is a loop, load the offset with the loop index
002c77 c015                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_default //if there is no release flag and no loop, then play the true note
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute:
002c78 91b0 2920                 	lds r27, noise_arpeggio_macro_release
002c7a 3fbf                      	cpi r27, 0xFF
002c7b f421                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop //if there is a release flag, react as if there was no loop.
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_check_loop:
002c7c 91b0 291f                 	lds r27, noise_arpeggio_macro_loop //load the loop index
002c7e 3fbf                      	cpi r27, 0xFF //check if loop flag exists
002c7f f451                      	brne sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload //if a loop flag exists, then load the loop value
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_absolute_no_loop:
002c80 91c0 2934                 	lds r28, noise_fx_0xy_sequence //check for 0xy effect
002c82 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
002c84 9620                      	adiw r29:r28, 0
002c85 f469                      	brne sound_driver_instrument_routine_channel3_arpeggio_default_0xy //if 0xy effect exists, and there is no release/loop, use the default routine and apply the 0xy effect
                                 
002c86 50a1                      	subi r26, 1 //if a loop flag does not exist and fixed mode is not used, use the last valid index
002c87 93a0 291e                 	sts noise_arpeggio_macro_offset, r26 //store the last valid index into the offset
002c89 cfc2                      	rjmp sound_driver_instrument_routine_channel3_arpeggio
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_macro_end_flag_reload:
002c8a 93b0 291e                 	sts noise_arpeggio_macro_offset, r27 //store the loop index into the offset
002c8c cfbf                      	rjmp sound_driver_instrument_routine_channel3_arpeggio //go back and re-read the volume data
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_default:
002c8d 91c0 2934                 	lds r28, noise_fx_0xy_sequence //load 0xy effect
002c8f 91d0 2935                 	lds r29, noise_fx_0xy_sequence+1
002c91 9620                      	adiw r29:r28, 0 //check for 0xy effect
002c92 f099                      	breq sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy //if there is no 0xy effect, we don't need to roll the sequence
                                 	
                                 //NOTE: because of the way the 0xy parameter is stored and processed, using x0 will not create a faster arpeggio
                                 sound_driver_instrument_routine_channel3_arpeggio_default_0xy:
002c93 95d6                      	lsr r29
002c94 95c7                      	ror r28
002c95 95d7                      	ror r29
002c96 95c7                      	ror r28
002c97 95d7                      	ror r29
002c98 95c7                      	ror r28
002c99 95d7                      	ror r29
002c9a 95c7                      	ror r28
002c9b 95d7                      	ror r29
002c9c 95d2                      	swap r29
                                 
002c9d 93c0 2934                 	sts noise_fx_0xy_sequence, r28 //store the rolled sequence
002c9f 93d0 2935                 	sts noise_fx_0xy_sequence+1, r29
002ca1 70cf                      	andi r28, 0x0F //mask out the 4 LSB
002ca2 91a0 2817                 	lds r26, noise_note //load the current note index
002ca4 0fac                      	add r26, r28 //add the note offset
002ca5 c01c                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 	
                                 sound_driver_instrument_routine_channel3_arpeggio_default_no_0xy:
                                 	//NOTE: the pitch offset does not need to be reset here because there is no new note being calculated
002ca6 91a0 2817                 	lds r26, noise_note //load the current note index
002ca8 c019                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process:
002ca9 9220 2922                 	sts noise_total_pitch_offset, zero //the pitch offsets must be reset when a new note is to be calculated from an arpeggio macro
002cab 9220 2923                 	sts noise_total_pitch_offset+1, zero
002cad 9220 2929                 	sts noise_total_hi_pitch_offset, zero
002caf 91a0 2921                 	lds r26, noise_arpeggio_macro_mode
002cb1 30a1                      	cpi r26, 0x01 //absolute mode
002cb2 f010                      	brlo sound_driver_instrument_routine_channel3_arpeggio_process_absolute
002cb3 f031                      	breq sound_driver_instrument_routine_channel3_arpeggio_process_fixed
002cb4 c007                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_relative //relative mode
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_absolute:
002cb5 91a0 2817                 	lds r26, noise_note //load the current note index
002cb7 0fab                      	add r26, r27 //offset the note with the arpeggio data
002cb8 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002cb9 c008                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_fixed:
002cba 2fab                      	mov r26, r27 //move the arpeggio data into r26
002cbb c006                      	rjmp sound_driver_instrument_routine_channel3_arpeggio_process_load
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_relative:
002cbc 91a0 2817                 	lds r26, noise_note //load the current note index
002cbe 0fab                      	add r26, r27 //offset the note with the arpeggio data
002cbf 70af                      	andi r26, 0x0F //keep only bits 0-3 in case there was overflow
002cc0 93a0 2817                 	sts noise_note, r26
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_arpeggio_process_load:
002cc2 93a0 2818                 	sts noise_adjusted_note, r26
002cc4 c000                      	rjmp sound_driver_instrument_routine_channel3_pitch
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch:
002cc5 91e0 2924                 	lds ZL, noise_pitch_macro
002cc7 91f0 2925                 	lds ZH, noise_pitch_macro+1
002cc9 9630                      	adiw Z, 0
002cca f409                      	brne sound_driver_instrument_routine_channel3_pitch_continue
002ccb c023                      	rjmp sound_driver_instrument_routine_channel3_pitch_default //if no pitch macro is in use, process the current total pitch macro offset
                                 sound_driver_instrument_routine_channel3_pitch_continue:
002ccc 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002ccd 1fff                      	rol ZH
002cce 91a0 2926                 	lds r26, noise_pitch_macro_offset
002cd0 0fea                      	add ZL, r26
002cd1 1df2                      	adc ZH, zero
                                 
002cd2 91b0 2928                 	lds r27, noise_pitch_macro_release
002cd4 17ba                      	cp r27, r26
002cd5 f429                      	brne sound_driver_instrument_routine_channel3_pitch_increment //if the current offset is not equal to the release index, increment the offset
002cd6 91a0 2927                 	lds r26, noise_pitch_macro_loop
002cd8 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002cd9 f010                      	brlo sound_driver_instrument_routine_channel3_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002cda c003                      	rjmp sound_driver_instrument_routine_channel3_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_pitch_increment:
002cdb 95a3                      	inc r26 //increment the macro offset
002cdc 93a0 2926                 	sts noise_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_pitch_read:
002cde 91b4                      	lpm r27, Z //load pitch data into r27
002cdf 38b0                      	cpi r27, 0x80 //check for macro end flag
002ce0 f479                      	brne sound_driver_instrument_routine_channel3_pitch_calculate //if the data was not the macro end flag, calculate the pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_release:
002ce1 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002ce2 93a0 2926                 	sts noise_pitch_macro_offset, r26
002ce4 91b0 2928                 	lds r27, noise_pitch_macro_release
002ce6 3fbf                      	cpi r27, 0xFF
002ce7 f439                      	brne sound_driver_instrument_routine_channel3_pitch_default //if there is a release flag, we don't need to loop. offset the pitch by the final total pitch
                                 
                                 sound_driver_instrument_routine_channel3_pitch_macro_end_flag_check_loop:
002ce8 91b0 2927                 	lds r27, noise_pitch_macro_loop //load the loop index
002cea 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002ceb f019                      	breq sound_driver_instrument_routine_channel3_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total pitch
002cec 93b0 2926                 	sts noise_pitch_macro_offset, r27 //store the loop index into the offset
002cee cfd6                      	rjmp sound_driver_instrument_routine_channel3_pitch //go back and re-read the pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_pitch_default:
002cef e0b0                      	ldi r27, 0x00
                                 sound_driver_instrument_routine_channel3_pitch_calculate:
                                 sound_driver_instrument_routine_channel3_pitch_calculate_offset:
002cf0 91a0 2922                 	lds r26, noise_total_pitch_offset
002cf2 0fba                      	add r27, r26
002cf3 93b0 2922                 	sts noise_total_pitch_offset, r27
002cf5 91a0 2818                 	lds r26, noise_adjusted_note
002cf7 1bab                      	sub r26, r27
                                 	
002cf8 91b0 2937                 	lds r27, noise_fx_1xx_total
002cfa 0fab                      	add r26, r27
002cfb 91b0 2939                 	lds r27, noise_fx_2xx_total
002cfd 1bab                      	sub r26, r27
002cfe 91b0 293d                 	lds r27, noise_fx_4xy_offset
002d00 1bab                      	sub r26, r27
002d01 91b0 2945                 	lds r27, noise_fx_Pxx_total
002d03 1bab                      	sub r26, r27
                                 
002d04 70af                      	andi r26, 0x0F
                                 
002d05 e4e2                      	ldi ZL, LOW(noise_period_table << 1) //load in note table
002d06 e0f1                      	ldi ZH, HIGH(noise_period_table << 1)
002d07 0faa                      	lsl r26 //double the offset for the note table because we are getting byte data
002d08 0fea                      	add ZL, r26 //add offset
002d09 1df2                      	adc ZH, zero
002d0a 91a5                      	lpm r26, Z+ //load bytes
002d0b 91b4                      	lpm r27, Z
002d0c 93a0 0abc                 	sts TCB3_CCMPL, r26 //load the LOW bits for timer
002d0e 93b0 0abd                 	sts TCB3_CCMPH, r27 //load the HIGH bits for timer
                                 	
                                 
                                 
                                 //NOTE: The hi pitch macro routine does not account for overflowing from the offset. In famitracker, if the offset
                                 //goes beyond the note range, there will be no more offset calculations. In this routine, it is possible that
                                 //the pitch goes from B-7 and back around to C-0. I don't believe there will ever be a song in which this will be a problem.
                                 sound_driver_instrument_routine_channel3_hi_pitch:
002d10 91e0 292a                 	lds ZL, noise_hi_pitch_macro
002d12 91f0 292b                 	lds ZH, noise_hi_pitch_macro+1
002d14 9630                      	adiw Z, 0
002d15 f409                      	brne sound_driver_instrument_routine_channel3_hi_pitch_continue
002d16 c03c                      	rjmp sound_driver_instrument_routine_channel3_duty //if no hi pitch macro is in use, go to the next macro routine
                                 sound_driver_instrument_routine_channel3_hi_pitch_continue:
002d17 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d18 1fff                      	rol ZH
002d19 91a0 292c                 	lds r26, noise_hi_pitch_macro_offset
002d1b 0fea                      	add ZL, r26
002d1c 1df2                      	adc ZH, zero
                                 
002d1d 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002d1f 17ba                      	cp r27, r26
002d20 f429                      	brne sound_driver_instrument_routine_channel3_hi_pitch_increment //if the current offset is not equal to the release index, increment the offset
002d21 91a0 292d                 	lds r26, noise_hi_pitch_macro_loop
002d23 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d24 f010                      	brlo sound_driver_instrument_routine_channel3_hi_pitch_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d25 c003                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_read //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_increment:
002d26 95a3                      	inc r26 //increment the macro offset
002d27 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_hi_pitch_read:
002d29 91b4                      	lpm r27, Z //load hi pitch data into r27
002d2a 38b0                      	cpi r27, 0x80 //check for macro end flag
002d2b f489                      	brne sound_driver_instrument_routine_channel3_hi_pitch_calculate //if the data was not the macro end flag, calculate the hi pitch offset
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_release:
002d2c 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d2d 93a0 292c                 	sts noise_hi_pitch_macro_offset, r26
002d2f 91b0 292e                 	lds r27, noise_hi_pitch_macro_release
002d31 3fbf                      	cpi r27, 0xFF
002d32 f439                      	brne sound_driver_instrument_routine_channel3_hi_pitch_default //if there is a release flag, we don't need to loop. offset the hi pitch by the final total hi pitch
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_macro_end_flag_check_loop:
002d33 91b0 292d                 	lds r27, noise_hi_pitch_macro_loop //load the loop index
002d35 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d36 f019                      	breq sound_driver_instrument_routine_channel3_hi_pitch_default //if there is no loop flag, we don't need to loop. offset the pitch by the final total hi pitch
002d37 93b0 292c                 	sts noise_hi_pitch_macro_offset, r27 //store the loop index into the offset
002d39 cfd6                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch //go back and re-read the hi pitch data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_default:
002d3a 91b0 2929                 	lds r27, noise_total_hi_pitch_offset
002d3c c005                      	rjmp sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate:
002d3d 91a0 2929                 	lds r26, noise_total_hi_pitch_offset //load the total hi pitch offset to change
002d3f 0fba                      	add r27, r26
002d40 93b0 2929                 	sts noise_total_hi_pitch_offset, r27
                                 
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_multiply:
002d42 936f                      	push r22 //only registers r16 - r23 can be used with mulsu
002d43 937f                      	push r23
002d44 2f6b                      	mov r22, r27 //store the signed hi pitch offset data into r22
002d45 eb72                      	ldi r23, 0b10110010 //store r23 with 11.125 note: this is the closest approximation to the 11.1746014718 multiplier we can get with 8 bits
002d46 0367                      	mulsu r22, r23
002d47 917f                      	pop r23
002d48 916f                      	pop r22
                                 
                                 	//NOTE: fractional bits do not need to be shifted out because hi pitch offsets are multiplied by 16. shifting right 4 times for the fraction and left 4 times for the 16x is the same as no shift.
                                 sound_driver_instrument_routine_channel3_hi_pitch_calculate_offset:
002d49 91a0 0abc                 	lds r26, TCB3_CCMPL //load the low bits for timer
002d4b 91b0 0abd                 	lds r27, TCB3_CCMPH //load the high bits for timer
002d4d 0da0                      	add r26, r0 //offset the timer values
002d4e 1db1                      	adc r27, r1
002d4f 93a0 0abc                 	sts TCB3_CCMPL, r26 //store the new low bits for timer
002d51 93b0 0abd                 	sts TCB3_CCMPH, r27 //store the new high bits for timer
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty:
002d53 91e0 292f                 	lds ZL, noise_duty_macro
002d55 91f0 2930                 	lds ZH, noise_duty_macro+1
002d57 9630                      	adiw Z, 0
002d58 f169                      	breq sound_driver_channel3_fx_routines //if no duty macro is in use, go to the next routine
002d59 0fee                      	lsl ZL //multiply by 2 to make z into a byte pointer for the macro's address
002d5a 1fff                      	rol ZH
002d5b 91a0 2931                 	lds r26, noise_duty_macro_offset
002d5d 0fea                      	add ZL, r26
002d5e 1df2                      	adc ZH, zero
                                 
002d5f 91b0 2933                 	lds r27, noise_duty_macro_release
002d61 17ba                      	cp r27, r26
002d62 f429                      	brne sound_driver_instrument_routine_channel3_duty_increment //if the current offset is not equal to the release index, increment the offset
002d63 91a0 2932                 	lds r26, noise_duty_macro_loop
002d65 17ab                      	cp r26, r27 //check if loop flag exists NOTE: a loop flag and a release flag can only co-exist if the loop is less than the release
002d66 f010                      	brlo sound_driver_instrument_routine_channel3_duty_increment+1 //if the current offset is equal to the release index and there is a loop, load the offset with the loop index, but also read the current index data
002d67 c01e                      	rjmp sound_driver_channel3_fx_routines //if the current offset is equal to the release index and there is no loop, then keep the offset unchanged and skip the rest of the routine
                                 
                                 sound_driver_instrument_routine_channel3_duty_increment:
002d68 95a3                      	inc r26 //increment the macro offset
002d69 93a0 2931                 	sts noise_duty_macro_offset, r26
                                 	
                                 sound_driver_instrument_routine_channel3_duty_read:
002d6b 91b4                      	lpm r27, Z //load pitch data into r27
002d6c 3fbf                      	cpi r27, 0xFF //check for macro end flag
002d6d f471                      	brne sound_driver_instrument_routine_channel3_duty_load //if the data was not the macro end flag, load the new duty cycle
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag:
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_release:
002d6e 50a1                      	subi r26, 1 //keep the macro offset at the end flag
002d6f 93a0 2931                 	sts noise_duty_macro_offset, r26
002d71 91b0 2933                 	lds r27, noise_duty_macro_release
002d73 3fbf                      	cpi r27, 0xFF
002d74 f489                      	brne sound_driver_channel3_fx_routines //if there is a release flag, we don't need to loop. skip the rest of the routine.
                                 
                                 sound_driver_instrument_routine_channel3_duty_macro_end_flag_check_loop:
002d75 91b0 2932                 	lds r27, noise_duty_macro_loop //load the loop index
002d77 3fbf                      	cpi r27, 0xFF //check if there is a loop index
002d78 f069                      	breq sound_driver_channel3_fx_routines //if there is no loop flag, we don't need to loop. skip the rest of the routine.
002d79 93b0 2931                 	sts noise_duty_macro_offset, r27 //store the loop index into the offset
002d7b cfd7                      	rjmp sound_driver_instrument_routine_channel3_duty //go back and re-read the duty data
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel3_duty_load:
002d7c 95b6                      	lsr r27
002d7d 95b7                      	ror r27 //move mode bit to bit 7
002d7e 91c0 2814                 	lds r28, noise_period
002d80 77cf                      	andi r28, 0b01111111
002d81 2bcb                      	or r28, r27 //store the new noise mode
002d82 93c0 2813                 	sts noise_param, r28
                                 
002d84 776f                      	andi noise_sequence_HIGH, 0b01111111
002d85 2b6b                      	or noise_sequence_HIGH, r27
                                 
                                 
                                 
                                 sound_driver_channel3_fx_routines:
                                 sound_driver_channel3_fx_1xx_routine:
002d86 91e0 2936                 	lds ZL, noise_fx_1xx
002d88 30e0                      	cpi ZL, 0
002d89 f029                      	breq sound_driver_channel3_fx_2xx_routine
                                 
002d8a 91a0 2937                 	lds r26, noise_fx_1xx_total //load the rate to change the pitch by
002d8c 0fae                      	add r26, ZL //increase the total offset by the rate
002d8d 93a0 2937                 	sts noise_fx_1xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_2xx_routine:
002d8f 91e0 2938                 	lds ZL, noise_fx_2xx
002d91 30e0                      	cpi ZL, 0
002d92 f029                      	breq sound_driver_channel3_fx_3xx_routine
                                 
002d93 91a0 2939                 	lds r26, noise_fx_2xx_total //load the rate to change the pitch by
002d95 0fae                      	add r26, ZL //increase the total offset by the rate
002d96 93a0 2939                 	sts noise_fx_2xx_total, r26
                                 
                                 
                                 
                                 sound_driver_channel3_fx_3xx_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_4xy_routine:
002d98 91a0 293a                 	lds r26, noise_fx_4xy_speed
002d9a 15a2                      	cp r26, zero
002d9b f409                      	brne sound_driver_channel3_fx_4xy_routine_continue
002d9c c033                      	rjmp sound_driver_channel3_fx_7xy_routine //if speed is 0, then the effect is disabled
                                 
                                 sound_driver_channel3_fx_4xy_routine_continue:
002d9d 91b0 293b                 	lds r27, noise_fx_4xy_depth
002d9f 91c0 293c                 	lds r28, noise_fx_4xy_phase
002da1 0fca                      	add r28, r26 //increase the phase by the speed
002da2 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002da3 f008                      	brlo sound_driver_channel3_fx_4xy_routine_phase //if no overflow, map the phase to 0-15.
002da4 e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase:
002da5 93c0 293c                 	sts noise_fx_4xy_phase, r28 //store the new phase
002da7 31c0                      	cpi r28, 16
002da8 f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_0
002da9 32c0                      	cpi r28, 32
002daa f028                      	brlo sound_driver_channel3_fx_4xy_routine_phase_1
002dab 33c0                      	cpi r28, 48
002dac f030                      	brlo sound_driver_channel3_fx_4xy_routine_phase_2
002dad c007                      	rjmp sound_driver_channel3_fx_4xy_routine_phase_3
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_0:
002dae 70cf                      	andi r28, 0x0F //mask for values 0-15
002daf c014                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_1:
002db0 6fc0                      	ori r28, 0xF0
002db1 95c0                      	com r28 //invert values 0-15
002db2 c011                      	rjmp sound_driver_channel3_fx_4xy_routine_load_subtract
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_2:
002db3 70cf                      	andi r28, 0x0F //mask for values 0-15
002db4 c003                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_phase_3:
002db5 6fc0                      	ori r28, 0xF0
002db6 95c0                      	com r28 //invert values 0-15
002db7 c000                      	rjmp sound_driver_channel3_fx_4xy_routine_load_add
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_add:
002db8 95b2                      	swap r27 //multiply depth by 16
002db9 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002dba e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002dbb e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002dbc 0fec                      	add ZL, r28 //offset the table by the depth+phase
002dbd 1df2                      	adc ZH, zero
002dbe 91c4                      	lpm r28, Z //load the tremelo value into r28
002dbf 95c2                      	swap r28
002dc0 70cf                      	andi r28, 0x0F
                                 
002dc1 93c0 293d                 	sts noise_fx_4xy_offset, r28
002dc3 c00c                      	rjmp sound_driver_channel3_fx_7xy_routine
                                 
                                 sound_driver_channel3_fx_4xy_routine_load_subtract:
002dc4 95b2                      	swap r27 //multiply depth by 16
002dc5 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
002dc6 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002dc7 e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002dc8 0fec                      	add ZL, r28 //offset the table by the depth+phase
002dc9 1df2                      	adc ZH, zero
002dca 91c4                      	lpm r28, Z //load the vibrato value into r28
002dcb 95c2                      	swap r28
002dcc 70cf                      	andi r28, 0x0F
                                 
002dcd 95c1                      	neg r28
002dce 93c0 293d                 	sts noise_fx_4xy_offset, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_7xy_routine:
002dd0 91a0 293e                 	lds r26, noise_fx_7xy_speed
002dd2 15a2                      	cp r26, zero
002dd3 f0e9                      	breq sound_driver_channel3_fx_Axy_routine //if speed is 0, then the effect is disabled
                                 
002dd4 91b0 293f                 	lds r27, noise_fx_7xy_depth
002dd6 91c0 2940                 	lds r28, noise_fx_7xy_phase
002dd8 0fca                      	add r28, r26 //increase the phase by the speed
002dd9 34c0                      	cpi r28, 64 //check if the phase overflowed NOTE: phase values range from 0-63
002dda f008                      	brlo sound_driver_channel3_fx_7xy_routine_phase //if no overflow, map the phase to 0-15.
002ddb e0c0                      	ldi r28, 0x00 //reset the phase if there was overflow
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase:
002ddc 93c0 2940                 	sts noise_fx_7xy_phase, r28 //store the new phase
002dde 95c6                      	lsr r28 //divide the phase by 2 NOTE: 7xy only uses half a sine unlike 4xy
002ddf ffc4                      	sbrs r28, 4
002de0 c001                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_0
002de1 c002                      	rjmp sound_driver_channel3_fx_7xy_routine_phase_1
                                 	
                                 sound_driver_channel3_fx_7xy_routine_phase_0:
002de2 70cf                      	andi r28, 0x0F //mask for values 0-15
002de3 c003                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_phase_1:
002de4 6fc0                      	ori r28, 0xF0
002de5 95c0                      	com r28 //invert values 0-15
002de6 c000                      	rjmp sound_driver_channel3_fx_7xy_routine_load
                                 
                                 sound_driver_channel3_fx_7xy_routine_load:
002de7 95b2                      	swap r27 //multiply depth by 16
002de8 0fcb                      	add r28, r27 //add the depth to the phase NOTE: the table is divided into sixteen different set of 8 values, which correspond to the depth
                                 	
002de9 e6e2                      	ldi ZL, LOW(vibrato_table << 1) //point z to vibrato table
002dea e0f1                      	ldi ZH, HIGH(vibrato_table << 1)
002deb 0fec                      	add ZL, r28 //offset the table by the depth+phase
002dec 1df2                      	adc ZH, zero
002ded 91c4                      	lpm r28, Z //load the vibrato value into r28
                                 
002dee 95c6                      	lsr r28 //convert to tremelo value by shifting to the right
002def 93c0 2941                 	sts noise_fx_7xy_value, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Axy_routine:
002df1 91b0 2942                 	lds r27, noise_fx_Axy
002df3 15b2                      	cp r27, zero
002df4 f0e9                      	breq sound_driver_channel3_fx_Qxy_routine //0 means that the effect is not in use
                                 	
002df5 91a0 2815                 	lds r26, noise_fractional_volume //load fractional volume representation of the channel
002df7 91c0 2813                 	lds r28, noise_param //load the integer volume representation of the channel
002df9 2fda                      	mov r29, r26 //copy fractional volume into r29
002dfa 2fec                      	mov r30, r28 //copy the noise_param into r30
002dfb 95e2                      	swap r30
002dfc 7fd0                      	andi r29, 0xF0 //mask for integer volume bits from the fractional volume
002dfd 7fe0                      	andi r30, 0xF0 //mask for VVVV volume bits
                                 
002dfe 17ed                      	cp r30, r29 //compare the fractional and integer volumes
002dff f009                      	breq sound_driver_channel3_fx_Axy_routine_calculate
                                 
                                 sound_driver_channel3_fx_Axy_routine_reload:
002e00 2fae                      	mov r26, r30 //overwrite the fractional volume with the integer volume
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate:
002e01 fdb7                      	sbrc r27, 7 //check for negative sign bit in Axy offset value
002e02 c004                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_subtraction
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_addition:
002e03 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002e04 f428                      	brcc sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002e05 efa0                      	ldi r26, 0xF0 //if the fractional volume did overflow, reset it back to the highest integer volume possible (0xF)
002e06 c003                      	rjmp sound_driver_channel3_fx_Axy_routine_calculate_store
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_subtraction:
002e07 0fab                      	add r26, r27 //add the fractional volume with the offset specified by the Axy effect
002e08 f008                      	brcs sound_driver_channel3_fx_Axy_routine_calculate_store //if the fractional volume did not overflow, go store the new volume
002e09 e0a0                      	ldi r26, 0x00 //if the fractional volume did overflow, reset it back to the lowest integer volume possible (0x0)
                                 
                                 sound_driver_channel3_fx_Axy_routine_calculate_store:
002e0a 93a0 2815                 	sts noise_fractional_volume, r26 //store the new fractional volume
002e0c 7fa0                      	andi r26, 0xF0 //mask for integer volume bits from the fractional volume
002e0d 95a2                      	swap r26
002e0e 7fc0                      	andi r28, 0xF0 //mask out the old VVVV volume bits
002e0f 2bca                      	or r28, r26 //store the new volume back into noise_param
002e10 93c0 2813                 	sts noise_param, r28
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Qxy_routine:
                                 
                                 
                                 
                                 sound_driver_channel3_fx_Rxy_routine:
                                 
                                 
                                 
                                 sound_driver_instrument_routine_channel4_volume:
                                 
                                 sound_driver_exit:
002e12 91ff                      	pop r31
002e13 91ef                      	pop r30
002e14 91df                      	pop r29
002e15 91cf                      	pop r28
002e16 940c 14f5                 	jmp sequence_1_3 + 3 //+3 is to skip the stack instructions since we already pushed them
                                 
                                 
                                 
                                 //TABLES
002e18 7f05
002e19 010a
002e1a 0214
002e1b 0328
002e1c 0450
002e1d 051e
002e1e 0607
002e1f 070d
002e20 0806
002e21 090c
002e22 0a18
002e23 0b30
002e24 0c60
002e25 0d24
002e26 0e08
002e27 0f10                      length: .db $05, $7F, $0A, $01, $14, $02, $28, $03, $50, $04, $1E, $05, $07, $06, $0D, $07, $06, $08, $0C, $09, $18, $0A, $30, $0B, $60, $0C, $24, $0D, $08, $0E, $10, $0F
                                 
                                 //pulse sequences: 12.5%, 25%, 50%, 75%
002e28 0301
002e29 fc0f                      sequences: .db 0b00000001, 0b00000011, 0b00001111, 0b11111100
                                 
                                 //list of famitracker fx: http://famitracker.com/wiki/index.php?title=Effect_list
                                 channel0_fx:
002e2a 1731
002e2b 1736
002e2c 1752
002e2d 176e
002e2e 1791                      	.dw sound_driver_channel0_fx_0xy, sound_driver_channel0_fx_1xx, sound_driver_channel0_fx_2xx, sound_driver_channel0_fx_3xx, sound_driver_channel0_fx_4xy
002e2f 179c
002e30 17a9
002e31 17ac
002e32 17af
002e33 17b2                      	.dw sound_driver_channel0_fx_7xy, sound_driver_channel0_fx_Axy, sound_driver_channel0_fx_Bxx, sound_driver_channel0_fx_Cxx, sound_driver_channel0_fx_Dxx
002e34 17b5
002e35 17bd
002e36 17c0
002e37 17cd
002e38 17ce                      	.dw sound_driver_channel0_fx_Exx, sound_driver_channel0_fx_Fxx, sound_driver_channel0_fx_Gxx, sound_driver_channel0_fx_Hxy, sound_driver_channel0_fx_Ixy
002e39 17cf
002e3a 17d0
002e3b 17d1
002e3c 17e9
002e3d 182b                      	.dw sound_driver_channel0_fx_Hxx, sound_driver_channel0_fx_Ixx, sound_driver_channel0_fx_Pxx, sound_driver_channel0_fx_Qxy, sound_driver_channel0_fx_Rxy
002e3e 186c
002e3f 1879
002e40 188d
002e41 188e
002e42 188f                      	.dw sound_driver_channel0_fx_Sxx, sound_driver_channel0_fx_Vxx, sound_driver_channel0_fx_Wxx, sound_driver_channel0_fx_Xxx, sound_driver_channel0_fx_Yxx
002e43 1890                      	.dw sound_driver_channel0_fx_Zxx
                                 
                                 channel1_fx:
002e44 1a1f
002e45 1a24
002e46 1a40
002e47 1a5c
002e48 1a7f                      	.dw sound_driver_channel1_fx_0xy, sound_driver_channel1_fx_1xx, sound_driver_channel1_fx_2xx, sound_driver_channel1_fx_3xx, sound_driver_channel1_fx_4xy
002e49 1a8a
002e4a 1a97
002e4b 1a9a
002e4c 1a9d
002e4d 1aa0                      	.dw sound_driver_channel1_fx_7xy, sound_driver_channel1_fx_Axy, sound_driver_channel1_fx_Bxx, sound_driver_channel1_fx_Cxx, sound_driver_channel1_fx_Dxx
002e4e 1aa3
002e4f 1aab
002e50 1aae
002e51 1abb
002e52 1abc                      	.dw sound_driver_channel1_fx_Exx, sound_driver_channel1_fx_Fxx, sound_driver_channel1_fx_Gxx, sound_driver_channel1_fx_Hxy, sound_driver_channel1_fx_Ixy
002e53 1abd
002e54 1abe
002e55 1abf
002e56 1ad7
002e57 1b19                      	.dw sound_driver_channel1_fx_Hxx, sound_driver_channel1_fx_Ixx, sound_driver_channel1_fx_Pxx, sound_driver_channel1_fx_Qxy, sound_driver_channel1_fx_Rxy
002e58 1b5a
002e59 1b67
002e5a 1b7b
002e5b 1b7c
002e5c 1b7d                      	.dw sound_driver_channel1_fx_Sxx, sound_driver_channel1_fx_Vxx, sound_driver_channel1_fx_Wxx, sound_driver_channel1_fx_Xxx, sound_driver_channel1_fx_Yxx
002e5d 1b7e                      	.dw sound_driver_channel1_fx_Zxx
                                 
                                 channel2_fx:
002e5e 1d00
002e5f 1d05
002e60 1d21
002e61 1d3d
002e62 1d60                      	.dw sound_driver_channel2_fx_0xy, sound_driver_channel2_fx_1xx, sound_driver_channel2_fx_2xx, sound_driver_channel2_fx_3xx, sound_driver_channel2_fx_4xy
002e63 1d6b
002e64 1d6c
002e65 1d6d
002e66 1d70
002e67 1d73                      	.dw sound_driver_channel2_fx_7xy, sound_driver_channel2_fx_Axy, sound_driver_channel2_fx_Bxx, sound_driver_channel2_fx_Cxx, sound_driver_channel2_fx_Dxx
002e68 1d76
002e69 1d83
002e6a 1d86
002e6b 1d93
002e6c 1d94                      	.dw sound_driver_channel2_fx_Exx, sound_driver_channel2_fx_Fxx, sound_driver_channel2_fx_Gxx, sound_driver_channel2_fx_Hxy, sound_driver_channel2_fx_Ixy
002e6d 1d95
002e6e 1d96
002e6f 1d97
002e70 1daf
002e71 1df1                      	.dw sound_driver_channel2_fx_Hxx, sound_driver_channel2_fx_Ixx, sound_driver_channel2_fx_Pxx, sound_driver_channel2_fx_Qxy, sound_driver_channel2_fx_Rxy
002e72 1e32
002e73 1e3f
002e74 1e40
002e75 1e41
002e76 1e42                      	.dw sound_driver_channel2_fx_Sxx, sound_driver_channel2_fx_Vxx, sound_driver_channel2_fx_Wxx, sound_driver_channel2_fx_Xxx, sound_driver_channel2_fx_Yxx
002e77 1e43                      	.dw sound_driver_channel2_fx_Zxx
                                 
                                 channel3_fx:
002e78 1fc9
002e79 1fce
002e7a 1fd7
002e7b 1fe0
002e7c 1fe1                      	.dw sound_driver_channel3_fx_0xy, sound_driver_channel3_fx_1xx, sound_driver_channel3_fx_2xx, sound_driver_channel3_fx_3xx, sound_driver_channel3_fx_4xy
002e7d 1fee
002e7e 1ffb
002e7f 1ffe
002e80 2001
002e81 2004                      	.dw sound_driver_channel3_fx_7xy, sound_driver_channel3_fx_Axy, sound_driver_channel3_fx_Bxx, sound_driver_channel3_fx_Cxx, sound_driver_channel3_fx_Dxx
002e82 2007
002e83 200e
002e84 2011
002e85 201e
002e86 201f                      	.dw sound_driver_channel3_fx_Exx, sound_driver_channel3_fx_Fxx, sound_driver_channel3_fx_Gxx, sound_driver_channel3_fx_Hxy, sound_driver_channel3_fx_Ixy
002e87 2020
002e88 2021
002e89 2022
002e8a 2025
002e8b 2026                      	.dw sound_driver_channel3_fx_Hxx, sound_driver_channel3_fx_Ixx, sound_driver_channel3_fx_Pxx, sound_driver_channel3_fx_Qxy, sound_driver_channel3_fx_Rxy
002e8c 2027
002e8d 2034
002e8e 203f
002e8f 2040
002e90 2041                      	.dw sound_driver_channel3_fx_Sxx, sound_driver_channel3_fx_Vxx, sound_driver_channel3_fx_Wxx, sound_driver_channel3_fx_Xxx, sound_driver_channel3_fx_Yxx
002e91 2042                      	.dw sound_driver_channel3_fx_Zxx
                                 
                                 //famitracker volumes table: http://famitracker.com/wiki/index.php?title=Volume
                                 volumes:
002e92 0000
002e93 0000
002e94 0000
002e95 0000
002e96 0000
002e97 0000
002e98 0000
002e99 0000                      	.db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
002e9a 0100
002e9b 0101
002e9c 0101
002e9d 0101
002e9e 0101
002e9f 0101
002ea0 0101
002ea1 0101                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
002ea2 0100
002ea3 0101
002ea4 0101
002ea5 0101
002ea6 0101
002ea7 0101
002ea8 0101
002ea9 0201                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02
002eaa 0100
002eab 0101
002eac 0101
002ead 0101
002eae 0101
002eaf 0202
002eb0 0202
002eb1 0302                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03
002eb2 0100
002eb3 0101
002eb4 0101
002eb5 0101
002eb6 0202
002eb7 0202
002eb8 0303
002eb9 0403                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04
002eba 0100
002ebb 0101
002ebc 0101
002ebd 0202
002ebe 0302
002ebf 0303
002ec0 0404
002ec1 0504                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05
002ec2 0100
002ec3 0101
002ec4 0201
002ec5 0202
002ec6 0303
002ec7 0404
002ec8 0504
002ec9 0605                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x06
002eca 0100
002ecb 0101
002ecc 0201
002ecd 0302
002ece 0403
002ecf 0504
002ed0 0605
002ed1 0706                      	.db 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07
002ed2 0100
002ed3 0101
002ed4 0202
002ed5 0303
002ed6 0404
002ed7 0505
002ed8 0606
002ed9 0807                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x06, 0x06, 0x07, 0x08
002eda 0100
002edb 0101
002edc 0302
002edd 0403
002ede 0504
002edf 0606
002ee0 0707
002ee1 0908                      	.db 0x00, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09
002ee2 0100
002ee3 0201
002ee4 0302
002ee5 0404
002ee6 0605
002ee7 0706
002ee8 0808
002ee9 0a09                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A
002eea 0100
002eeb 0201
002eec 0302
002eed 0504
002eee 0605
002eef 0807
002ef0 0908
002ef1 0b0a                      	.db 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B
002ef2 0100
002ef3 0201
002ef4 0403
002ef5 0504
002ef6 0706
002ef7 0808
002ef8 0a09
002ef9 0c0b                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0A, 0x0B, 0x0C
002efa 0100
002efb 0201
002efc 0403
002efd 0605
002efe 0706
002eff 0908
002f00 0b0a
002f01 0d0c                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D
002f02 0100
002f03 0201
002f04 0403
002f05 0605
002f06 0807
002f07 0a09
002f08 0c0b
002f09 0e0d                      	.db 0x00, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E
002f0a 0100
002f0b 0302
002f0c 0504
002f0d 0706
002f0e 0908
002f0f 0b0a
002f10 0d0c


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :   0 y  :   0 z  : 233 r0 : 148 r1 : 160 r2 : 644 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   6 r11:   4 r12:   9 
r13:   6 r14:   4 r15:   9 r16:   7 r17:   6 r18:   7 r19:   6 r20:   4 
r21:   9 r22: 138 r23: 124 r24:   0 r25:  24 r26: 908 r27:1143 r28: 665 
r29: 339 r30: 360 r31: 312 
Registers used: 25 out of 35 (71.4%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 128 add   : 178 adiw  :  94 and   :   0 
andi  :  99 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   6 brcs  :  13 break :   0 breq  : 163 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :  76 brlt  :   0 brmi  :   0 
brne  : 119 brpl  :   0 brsh  :  32 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   5 
clc   :   0 clh   :   0 cli   :   8 cln   :   0 clr   :   5 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  16 cp    : 106 cpc   :  15 
cpi   : 167 cpse  :  19 dec   :  35 des   :   0 eor   :   2 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   4 in    :   7 inc   :  46 
jmp   :  11 ld    :   0 ldd   :   0 ldi   : 296 lds   : 653 lpm   : 254 
lsl   :  75 lsr   : 135 mov   : 128 movw  :   0 mul   :  21 muls  :   0 
mulsu :  10 neg   :   1 nop   :   0 or    :  24 ori   :  12 out   :  11 
pop   :  97 push  :  91 rcall :  50 ret   :  32 reti  :   7 rjmp  : 508 
rol   :  53 ror   : 156 sbc   :  30 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :  12 sbrc  :  25 sbrs  :  18 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :1307 sub   :  51 subi  :  45 swap  :  46 tst   :   0 wdr   :   0 

Instructions used: 53 out of 114 (46.5%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x005e24  14762   9226  23988   49152  48.8%
[.dseg] 0x002800 0x002949      0    329    329    6144   5.4%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 59 warnings
